;; ../../../../reference-specs/p4-concrete/0-aux.spectec:18:1-18:21:
def $sum(nat*) : nat =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:20:1-20:21:
def $max(nat*) : nat =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:22:1-22:21:
def $min(nat*) : nat =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:28:1-28:29:
def $int_to_text(int) : text =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:30:1-30:31:
def $concat_text(text*) : text =

   ;; ../../../../reference-specs/p4-concrete/0-aux.spectec:31:1-31:27:
   clause 0(text*{text <- text*}) = ""
      -- if text*{text <- text*} matches []

   ;; ../../../../reference-specs/p4-concrete/0-aux.spectec:32:1-32:58:
   clause 1(text*{text <- text*}) = t_h ++ $concat_text(t_t*{t_t <- t_t*})
      -- if text*{text <- text*} matches _ :: _
      -- let t_h :: t_t*{t_t <- t_t*} = text*{text <- text*}

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:34:1-34:37:
def $strip_prefix(text, text) : text =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:35:1-35:37:
def $strip_suffix(text, text) : text =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:41:1-41:23:
def $init_(nat) : nat* =

   ;; ../../../../reference-specs/p4-concrete/0-aux.spectec:42:1-42:20:
   clause 0(nat) = []
      -- if (nat = 0)

   ;; ../../../../reference-specs/p4-concrete/0-aux.spectec:43:1-44:15:
   clause 1(n) = (n - 1) :: $init_((n - 1))
      -- otherwise

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:46:1-46:29:
def $repeat_<X>(X, nat) : X* =

   ;; ../../../../reference-specs/p4-concrete/0-aux.spectec:47:1-47:28:
   clause 0(X, nat) = []
      -- if (nat = 0)

   ;; ../../../../reference-specs/p4-concrete/0-aux.spectec:48:1-49:15:
   clause 1(X, n) = [X] ++ $repeat_<X>(X, (n - 1))
      -- otherwise

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:51:1-51:22:
def $rev_<X>(X*) : X* =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:53:1-53:28:
def $concat_<X>(X**) : X* =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:55:1-55:39:
def $partition_<X>(X*, nat) : (X*, X*) =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:57:1-57:35:
def $assoc_<X, Y>(X, (X, Y)*) : Y? =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:59:1-59:29:
def $distinct_<K>(K*) : bool =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:65:17-65:24:
syntax set<K> = 
   | { K* }

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:67:1-67:27:
def $empty_set<K> : set<K> =

   ;; ../../../../reference-specs/p4-concrete/0-aux.spectec:68:1-68:29:
   clause 0 = { [] }

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:70:1-70:33:
def $in_set<K>(K, set<K>) : bool =

   ;; ../../../../reference-specs/p4-concrete/0-aux.spectec:71:1-71:41:
   clause 0(K, { K_e*{K_e <- K_e*} }) = K <- K_e*{K_e <- K_e*}

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:73:1-73:47:
def $intersect_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:75:1-75:43:
def $union_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:77:1-77:37:
def $unions_set<K>(set<K>*) : set<K> =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:79:1-79:42:
def $diff_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:81:1-81:39:
def $sub_set<K>(set<K>, set<K>) : bool =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:83:1-83:38:
def $eq_set<K>(set<K>, set<K>) : bool =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:89:21-89:27:
syntax pair<K, V> = 
   | K : V

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:91:20-91:35:
syntax map<K, V> = set<pair<K, V>>

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:93:1-93:33:
def $empty_map<K, V> : map<K, V> =

   ;; ../../../../reference-specs/p4-concrete/0-aux.spectec:94:1-94:32:
   clause 0 = { [] }

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:96:1-96:39:
def $dom_map<K, V>(map<K, V>) : set<K> =

   ;; ../../../../reference-specs/p4-concrete/0-aux.spectec:97:1-97:45:
   clause 0({ K : V*{K <- K*, V <- V*} }) = { K*{K <- K*} }

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:99:1-99:39:
def $find_map<K, V>(map<K, V>, K) : V? =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:101:1-101:41:
def $find_maps<K, V>(map<K, V>*, K) : V? =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:103:1-103:48:
def $add_map<K, V>(map<K, V>, K, V) : map<K, V> =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:105:1-105:51:
def $adds_map<K, V>(map<K, V>, K*, V*) : map<K, V> =

;; ../../../../reference-specs/p4-concrete/0-aux.spectec:107:1-107:51:
def $update_map<K, V>(map<K, V>, K, V) : map<K, V> =

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:6:1-7:7:
syntax trailingCommaOpt = 
   | 
   | ,

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:14:1-16:35:
syntax number = 
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:22:24-22:57:
syntax stringLiteral = 
   | " text " hint(print "#%#")

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:35:21-35:29:
syntax identifier = 
   | text

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:36:25-36:34:
syntax typeIdentifier = 
   | text

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:43:1-45:30:
syntax nonTypeName = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:48:1-49:23:
syntax prefixedNonTypeName = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:55:19-55:33:
syntax typeName = typeIdentifier

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:58:1-59:21:
syntax prefixedTypeName = 
   | text
   | . typeName

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:66:1-68:36:
syntax tableCustomName = 
   | text
   | text
   | apply
   | state
   | type
   | priority

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:75:1-77:9:
syntax name = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:80:1-81:21:
syntax nameList = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list
   | nameList , name

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:83:1-83:40:
def $flatten_nameList(nameList) : name* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:84:1-84:35:
   clause 0(nameList) = [name]
      -- if nameList <: name
      -- let name = nameList as name

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:85:1-86:42:
   clause 1(nameList') = $flatten_nameList(nameList) ++ [name]
      -- if nameList' matches `%,%`
      -- let nameList , name = nameList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:88:17-88:21:
syntax member = name

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:94:20-94:45:
syntax direction = 
   | 
   | in
   | out
   | inout

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:107:1-118:32:
syntax baseType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:126:26-126:64:
syntax specializedType = 
   | prefixedTypeName < typeArgumentList >

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:129:1-130:20:
syntax namedType = 
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:136:26-136:51:
syntax headerStackType = 
   | namedType [ expression ]

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:144:19-144:41:
syntax listType = 
   | list< typeArgument >

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:150:20-150:47:
syntax tupleType = 
   | tuple< typeArgumentList >

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:157:1-161:14:
syntax type = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:164:1-166:15:
syntax typeOrVoid = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | text

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:172:24-172:28:
syntax typeParameter = name

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:175:1-176:39:
syntax typeParameterList = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list
   | typeParameterList , typeParameter

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:178:1-178:67:
def $flatten_typeParameterList(typeParameterList) : typeParameter* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:179:1-179:62:
   clause 0(typeParameterList) = [typeParameter]
      -- if typeParameterList <: typeParameter
      -- let typeParameter = typeParameterList as typeParameter

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:180:1-181:69:
   clause 1(typeParameterList') = $flatten_typeParameterList(typeParameterList) ++ [typeParameter]
      -- if typeParameterList' matches `%,%`
      -- let typeParameterList , typeParameter = typeParameterList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:184:1-185:27:
syntax typeParameterListOpt = 
   | 
   | < typeParameterList >

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:187:1-187:73:
def $flatten_typeParameterListOpt(typeParameterListOpt) : typeParameter* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:188:1-188:48:
   clause 0(typeParameterListOpt) = []
      -- if typeParameterListOpt matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:189:1-190:50:
   clause 1(typeParameterListOpt) = $flatten_typeParameterList(typeParameterList)
      -- if typeParameterListOpt matches `<%>`
      -- let < typeParameterList > = typeParameterListOpt

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:199:3-199:52:
syntax parameter = 
   | annotationList direction type name initializerOpt

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:202:1-203:39:
syntax nonEmptyParameterList = 
   | annotationList direction type name initializerOpt
   | nonEmptyParameterList , parameter

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:206:1-207:26:
syntax parameterList = 
   | 
   | annotationList direction type name initializerOpt
   | nonEmptyParameterList , parameter

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:209:1-209:55:
def $flatten_parameterList(parameterList) : parameter* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:210:1-210:41:
   clause 0(parameterList) = []
      -- if parameterList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:211:1-211:50:
   clause 1(parameterList) = [parameter]
      -- if parameterList <: parameter
      -- let parameter = parameterList as parameter

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:212:1-213:67:
   clause 2(parameterList) = $flatten_parameterList(nonEmptyParameterList as parameterList) ++ [parameter]
      -- if parameterList <: nonEmptyParameterList
      -- let nonEmptyParameterList' = parameterList as nonEmptyParameterList
      -- if nonEmptyParameterList' matches `%,%`
      -- let nonEmptyParameterList , parameter = nonEmptyParameterList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:219:31-219:40:
syntax constructorParameter = parameter

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:221:35-221:48:
syntax constructorParameterList = parameterList

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:224:1-225:23:
syntax constructorParameterListOpt = 
   | 
   | ( parameterList )

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:227:1-228:26:
def $flatten_constructorParameterListOpt(constructorParameterListOpt) : constructorParameter* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:230:1-230:55:
   clause 0(constructorParameterListOpt) = []
      -- if constructorParameterListOpt matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:231:1-232:42:
   clause 1(constructorParameterListOpt) = $flatten_parameterList(parameterList)
      -- if constructorParameterListOpt matches `(%)`
      -- let ( parameterList ) = constructorParameterListOpt

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:238:26-238:44:
syntax namedExpression = 
   | name = expression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:241:1-242:43:
syntax namedExpressionList = 
   | name = expression
   | namedExpressionList , namedExpression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:244:1-244:73:
def $flatten_namedExpressionList(namedExpressionList) : namedExpression* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:245:1-245:68:
   clause 0(namedExpressionList) = [namedExpression]
      -- if namedExpressionList <: namedExpression
      -- let namedExpression = namedExpressionList as namedExpression

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:246:1-247:75:
   clause 1(namedExpressionList') = $flatten_namedExpressionList(namedExpressionList) ++ [namedExpression]
      -- if namedExpressionList' matches `%,%`
      -- let namedExpressionList , namedExpression = namedExpressionList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:258:1-260:18:
syntax literalExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:267:1-268:9:
syntax referenceExpression = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:274:28-274:32:
syntax defaultExpression = 
   | ...

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:282:15-282:32:
syntax unop = 
   | !
   | ~
   | -
   | +

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:284:26-284:41:
syntax unaryExpression = 
   | unop expression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:287:1-289:35:
syntax binop = 
   | *
   | /
   | %
   | +
   | -
   | |+|
   | |-|
   | <<
   | >>
   | <=
   | >=
   | <
   | >
   | !=
   | ==
   | &
   | ^
   | |
   | ++
   | &&
   | ||

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:291:27-291:54:
syntax binaryExpression = 
   | expression binop expression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:294:3-294:38:
syntax binaryExpressionNonBrace = 
   | expressionNonBrace binop expression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:297:3-297:41:
syntax ternaryExpression = 
   | expression ? expression : expression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:300:3-300:49:
syntax ternaryExpressionNonBrace = 
   | expressionNonBrace ? expression : expression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:306:25-306:45:
syntax castExpression = 
   | ( type ) expression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:315:1-316:48:
syntax dataExpression = 
   | {#}
   | { dataElementExpression trailingCommaOpt }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:325:3-325:18:
syntax errorAccessExpression = 
   | error. member

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:328:3-328:29:
syntax memberAccessExpression = 
   | memberAccessBase . member

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:331:1-332:45:
syntax indexAccessExpression = 
   | expression [ expression ]
   | expression [ expression : expression ]

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:335:1-337:26:
syntax accessExpression = 
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:340:3-340:37:
syntax memberAccessExpressionNonBrace = 
   | memberAccessBaseNonBrace . member

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:343:1-344:53:
syntax indexAccessExpressionNonBrace = 
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:347:1-349:34:
syntax accessExpressionNonBrace = 
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:363:1-364:62:
syntax callExpression = 
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:367:1-368:70:
syntax callExpressionNonBrace = 
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:374:34-374:49:
syntax parenthesizedExpression = 
   | ( expression )

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:381:1-391:28:
syntax expression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:395:1-397:33:
syntax expressionList = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expressionList , expression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:399:1-399:58:
def $flatten_expressionList(expressionList) : expression* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:400:1-400:42:
   clause 0(expressionList) = []
      -- if expressionList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:401:1-401:53:
   clause 1(expressionList) = [expression]
      -- if expressionList <: expression
      -- let expression = expressionList as expression

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:402:1-403:60:
   clause 2(expressionList') = $flatten_expressionList(expressionList) ++ [expression]
      -- if expressionList' matches `%,%`
      -- let expressionList , expression = expressionList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:406:1-407:15:
syntax memberAccessBase = 
   | text
   | . typeName
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:409:36-409:50:
syntax sequenceElementExpression = expressionList

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:412:1-415:54:
syntax recordElementExpression = 
   | name = expression
   | name = expression ,...
   | name = expression , namedExpressionList
   | name = expression , namedExpressionList ,...

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:418:1-419:28:
syntax dataElementExpression = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expressionList , expression
   | name = expression
   | name = expression ,...
   | name = expression , namedExpressionList
   | name = expression , namedExpressionList ,...

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:421:24-421:34:
syntax routineTarget = expression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:422:28-422:37:
syntax constructorTarget = namedType

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:425:1-426:22:
syntax callTarget = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:433:1-441:28:
syntax expressionNonBrace = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:444:1-445:23:
syntax memberAccessBaseNonBrace = 
   | text
   | . typeName
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:447:32-447:50:
syntax routineTargetNonBrace = expressionNonBrace

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:450:1-451:22:
syntax callTargetNonBrace = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:453:1-453:57:
def $expressionNonBrace(expressionNonBrace) : expression =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:454:1-454:63:
   clause 0(expressionNonBrace) = literalExpression as expression
      -- if expressionNonBrace <: literalExpression
      -- let literalExpression = expressionNonBrace as literalExpression

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:455:1-455:67:
   clause 1(expressionNonBrace) = referenceExpression as expression
      -- if expressionNonBrace <: referenceExpression
      -- let referenceExpression = expressionNonBrace as referenceExpression

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:456:1-456:59:
   clause 2(expressionNonBrace) = unaryExpression as expression
      -- if expressionNonBrace <: unaryExpression
      -- let unaryExpression = expressionNonBrace as unaryExpression

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:457:1-461:65:
   clause 3(expressionNonBrace) = expression_l binop expression_r as expression
      -- if expressionNonBrace <: binaryExpressionNonBrace
      -- let expressionNonBrace_l binop expression_r = expressionNonBrace as binaryExpressionNonBrace
      -- let expression_l = $expressionNonBrace(expressionNonBrace_l)

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:462:1-466:71:
   clause 4(expressionNonBrace) = expression_cond ? expression_true : expression_false as expression
      -- if expressionNonBrace <: ternaryExpressionNonBrace
      -- let expressionNonBrace_cond ? expression_true : expression_false = expressionNonBrace as ternaryExpressionNonBrace
      -- let expression_cond = $expressionNonBrace(expressionNonBrace_cond)

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:467:1-467:57:
   clause 5(expressionNonBrace) = castExpression as expression
      -- if expressionNonBrace <: castExpression
      -- let castExpression = expressionNonBrace as castExpression

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:468:1-468:71:
   clause 6(expressionNonBrace) = errorAccessExpression as expression
      -- if expressionNonBrace <: errorAccessExpression
      -- let errorAccessExpression = expressionNonBrace as errorAccessExpression

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:469:1-470:31:
   clause 7(expressionNonBrace) = prefixedTypeName as memberAccessBase . member as expression
      -- if expressionNonBrace <: memberAccessExpressionNonBrace
      -- let memberAccessBaseNonBrace . member = expressionNonBrace as memberAccessExpressionNonBrace
      -- if memberAccessBaseNonBrace <: prefixedTypeName
      -- let prefixedTypeName = memberAccessBaseNonBrace as prefixedTypeName

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:471:1-473:71:
   clause 8(expressionNonBrace) = expression_base as memberAccessBase . member as expression
      -- if expressionNonBrace <: memberAccessExpressionNonBrace
      -- let memberAccessBaseNonBrace . member = expressionNonBrace as memberAccessExpressionNonBrace
      -- if memberAccessBaseNonBrace <: expressionNonBrace
      -- let expressionNonBrace_base = memberAccessBaseNonBrace as expressionNonBrace
      -- let expression_base = $expressionNonBrace(expressionNonBrace_base)

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:474:1-478:71:
   clause 9(expressionNonBrace) = expression_base [ expression_index ] as expression
      -- if expressionNonBrace <: indexAccessExpressionNonBrace
      -- let indexAccessExpressionNonBrace = expressionNonBrace as indexAccessExpressionNonBrace
      -- if indexAccessExpressionNonBrace matches `%[%]`
      -- let expressionNonBrace_base [ expression_index ] = indexAccessExpressionNonBrace
      -- let expression_base = $expressionNonBrace(expressionNonBrace_base)

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:479:1-483:71:
   clause 10(expressionNonBrace) = expression_base [ expression_hi : expression_lo ] as expression
      -- if expressionNonBrace <: indexAccessExpressionNonBrace
      -- let indexAccessExpressionNonBrace = expressionNonBrace as indexAccessExpressionNonBrace
      -- if indexAccessExpressionNonBrace matches `%[%:%]`
      -- let expressionNonBrace_base [ expression_hi : expression_lo ] = indexAccessExpressionNonBrace
      -- let expression_base = $expressionNonBrace(expressionNonBrace_base)

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:484:1-488:61:
   clause 11(expressionNonBrace') = expression as callTarget ( argumentList ) as expression
      -- if expressionNonBrace' <: callExpressionNonBrace
      -- let callExpressionNonBrace = expressionNonBrace' as callExpressionNonBrace
      -- if callExpressionNonBrace matches `%(%)`
      -- let callTargetNonBrace ( argumentList ) = callExpressionNonBrace
      -- if callTargetNonBrace <: expressionNonBrace
      -- let expressionNonBrace = callTargetNonBrace as expressionNonBrace
      -- let expression = $expressionNonBrace(expressionNonBrace)

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:489:1-492:40:
   clause 12(expressionNonBrace) = constructorTarget as callTarget ( argumentList ) as expression
      -- if expressionNonBrace <: callExpressionNonBrace
      -- let callExpressionNonBrace = expressionNonBrace as callExpressionNonBrace
      -- if callExpressionNonBrace matches `%(%)`
      -- let callTargetNonBrace ( argumentList ) = callExpressionNonBrace
      -- if callTargetNonBrace <: constructorTarget
      -- let constructorTarget = callTargetNonBrace as constructorTarget

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:493:1-497:61:
   clause 13(expressionNonBrace') = expression < realTypeArgumentList >( argumentList ) as expression
      -- if expressionNonBrace' <: callExpressionNonBrace
      -- let callExpressionNonBrace = expressionNonBrace' as callExpressionNonBrace
      -- if callExpressionNonBrace matches `%<%>(%)`
      -- let expressionNonBrace < realTypeArgumentList >( argumentList ) = callExpressionNonBrace
      -- let expression = $expressionNonBrace(expressionNonBrace)

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:498:1-498:75:
   clause 14(expressionNonBrace) = parenthesizedExpression as expression
      -- if expressionNonBrace <: parenthesizedExpression
      -- let parenthesizedExpression = expressionNonBrace as parenthesizedExpression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:505:1-509:7:
syntax simpleKeysetExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:512:1-513:57:
syntax simpleKeysetExpressionList = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _
   | simpleKeysetExpressionList , simpleKeysetExpression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:515:1-516:28:
def $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList) : simpleKeysetExpression* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:517:1-518:27:
   clause 0(simpleKeysetExpressionList) = [simpleKeysetExpression]
      -- if simpleKeysetExpressionList <: simpleKeysetExpression
      -- let simpleKeysetExpression = simpleKeysetExpressionList as simpleKeysetExpression

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:519:1-523:34:
   clause 1(simpleKeysetExpressionList') = $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList) ++ [simpleKeysetExpression]
      -- if simpleKeysetExpressionList' matches `%,%`
      -- let simpleKeysetExpressionList , simpleKeysetExpression = simpleKeysetExpressionList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:526:1-530:62:
syntax tupleKeysetExpression = 
   | ( expression &&& expression )
   | ( expression .. expression )
   | (default)
   | (_)
   | ( simpleKeysetExpression , simpleKeysetExpressionList )

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:533:1-534:26:
syntax keysetExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _
   | ( expression &&& expression )
   | ( expression .. expression )
   | (default)
   | (_)
   | ( simpleKeysetExpression , simpleKeysetExpressionList )

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:541:1-543:7:
syntax realTypeArgument = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:546:1-547:45:
syntax realTypeArgumentList = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | realTypeArgumentList , realTypeArgument

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:549:1-549:76:
def $flatten_realTypeArgumentList(realTypeArgumentList) : realTypeArgument* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:550:1-550:71:
   clause 0(realTypeArgumentList) = [realTypeArgument]
      -- if realTypeArgumentList <: realTypeArgument
      -- let realTypeArgument = realTypeArgumentList as realTypeArgument

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:551:1-552:78:
   clause 1(realTypeArgumentList') = $flatten_realTypeArgumentList(realTypeArgumentList) ++ [realTypeArgument]
      -- if realTypeArgumentList' matches `%,%`
      -- let realTypeArgumentList , realTypeArgument = realTypeArgumentList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:555:1-556:16:
syntax typeArgument = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:560:1-562:37:
syntax typeArgumentList = 
   | 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | typeArgumentList , typeArgument

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:564:1-564:64:
def $flatten_typeArgumentList(typeArgumentList) : typeArgument* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:565:1-565:44:
   clause 0(typeArgumentList) = []
      -- if typeArgumentList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:566:1-566:59:
   clause 1(typeArgumentList) = [typeArgument]
      -- if typeArgumentList <: typeArgument
      -- let typeArgument = typeArgumentList as typeArgument

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:567:1-568:66:
   clause 2(typeArgumentList') = $flatten_typeArgumentList(typeArgumentList) ++ [typeArgument]
      -- if typeArgumentList' matches `%,%`
      -- let typeArgumentList , typeArgument = typeArgumentList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:575:1-578:7:
syntax argument = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:581:1-582:37:
syntax argumentListNonEmpty = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _
   | argumentListNonEmpty , argument

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:585:1-586:25:
syntax argumentList = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _
   | argumentListNonEmpty , argument

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:588:1-588:52:
def $flatten_argumentList(argumentList) : argument* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:589:1-589:40:
   clause 0(argumentList) = []
      -- if argumentList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:590:1-590:47:
   clause 1(argumentList) = [argument]
      -- if argumentList <: argument
      -- let argument = argumentList as argument

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:591:1-592:62:
   clause 2(argumentList) = $flatten_argumentList(argumentListNonEmpty as argumentList) ++ [argument]
      -- if argumentList <: argumentListNonEmpty
      -- let argumentListNonEmpty' = argumentList as argumentListNonEmpty
      -- if argumentListNonEmpty' matches `%,%`
      -- let argumentListNonEmpty , argument = argumentListNonEmpty'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:599:1-603:16:
syntax lvalue = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | lvalue . member
   | lvalue [ expression ]
   | lvalue [ expression : expression ]
   | ( lvalue )

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:613:25-613:27:
syntax emptyStatement = 
   | ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:620:1-622:34:
syntax assignop = 
   | =
   | +=
   | -=
   | |+|=
   | |-|=
   | *=
   | /=
   | %=
   | <<=
   | >>=
   | &=
   | ^=
   | |=

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:624:30-624:59:
syntax assignmentStatement = 
   | lvalue assignop expression ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:631:1-632:54:
syntax callStatement = 
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:638:37-638:76:
syntax directApplicationStatement = 
   | namedType .apply( argumentList );

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:645:1-646:25:
syntax returnStatement = 
   | return;
   | return expression ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:652:24-652:31:
syntax exitStatement = 
   | exit;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:660:25-660:70:
syntax blockStatement = 
   | annotationList { blockElementStatementList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:669:1-670:48:
syntax conditionalStatement = 
   | if( expression ) statement
   | if( expression ) statement else statement

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:679:1-682:31:
syntax forInitStatement = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:685:1-686:53:
syntax forInitStatementListNonEmpty = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forInitStatementListNonEmpty , forInitStatement

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:689:1-690:33:
syntax forInitStatementList = 
   | 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forInitStatementListNonEmpty , forInitStatement

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:692:29-692:45:
syntax forUpdateStatement = forInitStatement

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:695:1-696:57:
syntax forUpdateStatementListNonEmpty = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forUpdateStatementListNonEmpty , forUpdateStatement

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:699:1-700:35:
syntax forUpdateStatementList = 
   | 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forUpdateStatementListNonEmpty , forUpdateStatement

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:703:1-704:30:
syntax forCollectionExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression .. expression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:707:1-712:81:
syntax forStatement = 
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:719:1-720:23:
syntax switchLabel = 
   | default
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:723:1-724:19:
syntax switchCase = 
   | switchLabel : blockStatement
   | switchLabel :

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:727:1-728:30:
syntax switchCaseList = 
   | 
   | switchCaseList switchCase

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:730:1-730:58:
def $flatten_switchCaseList(switchCaseList) : switchCase* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:731:1-731:42:
   clause 0(switchCaseList) = []
      -- if switchCaseList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:732:1-733:62:
   clause 1(switchCaseList') = $flatten_switchCaseList(switchCaseList) ++ [switchCase]
      -- if switchCaseList' matches `%%`
      -- let switchCaseList switchCase = switchCaseList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:735:26-735:68:
syntax switchStatement = 
   | switch( expression ){ switchCaseList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:741:25-741:33:
syntax breakStatement = 
   | break;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:743:28-743:39:
syntax continueStatement = 
   | continue;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:750:1-761:20:
syntax statement = 
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | return;
   | return expression ;
   | exit;
   | annotationList { blockElementStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement
   | break;
   | continue;
   | switch( expression ){ switchCaseList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:771:22-771:35:
syntax initializer = 
   | = expression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:774:3-774:48:
syntax constantDeclaration = 
   | annotationList const type name initializer ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:777:1-778:16:
syntax initializerOpt = 
   | 
   | = expression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:781:3-781:45:
syntax variableDeclaration = 
   | annotationList type name initializerOpt ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:784:1-786:14:
syntax blockElementStatement = 
   | annotationList const type name initializer ;
   | annotationList type name initializerOpt ;
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | return;
   | return expression ;
   | exit;
   | annotationList { blockElementStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement
   | break;
   | continue;
   | switch( expression ){ switchCaseList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:789:1-790:52:
syntax blockElementStatementList = 
   | 
   | blockElementStatementList blockElementStatement

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:792:1-793:27:
def $flatten_blockElementStatementList(blockElementStatementList) : blockElementStatement* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:794:1-794:53:
   clause 0(blockElementStatementList) = []
      -- if blockElementStatementList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:795:1-799:30:
   clause 1(blockElementStatementList') = $flatten_blockElementStatementList(blockElementStatementList) ++ [blockElementStatement]
      -- if blockElementStatementList' matches `%%`
      -- let blockElementStatementList blockElementStatement = blockElementStatementList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:806:3-806:58:
syntax functionPrototype = 
   | typeOrVoid name typeParameterListOpt ( parameterList )

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:809:3-809:50:
syntax functionDeclaration = 
   | annotationList functionPrototype blockStatement

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:816:3-816:63:
syntax actionDeclaration = 
   | annotationList action name ( parameterList ) blockStatement

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:824:28-824:57:
syntax objectInitializer = 
   | ={ objectDeclarationList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:828:1-829:68:
syntax instantiation = 
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:832:1-833:18:
syntax objectDeclaration = 
   | annotationList functionPrototype blockStatement
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:836:1-837:44:
syntax objectDeclarationList = 
   | 
   | objectDeclarationList objectDeclaration

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:839:1-839:79:
def $flatten_objectDeclarationList(objectDeclarationList) : objectDeclaration* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:840:1-840:49:
   clause 0(objectDeclarationList) = []
      -- if objectDeclarationList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:841:1-845:29:
   clause 1(objectDeclarationList') = $flatten_objectDeclarationList(objectDeclarationList) ++ [objectDeclaration]
      -- if objectDeclarationList' matches `%%`
      -- let objectDeclarationList objectDeclaration = objectDeclarationList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:851:27-851:46:
syntax errorDeclaration = 
   | error{ nameList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:857:31-857:72:
syntax matchKindDeclaration = 
   | match_kind{ nameList trailingCommaOpt }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:868:1-869:76:
syntax enumTypeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:875:20-875:47:
syntax typeField = 
   | annotationList type name ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:878:1-879:28:
syntax typeFieldList = 
   | 
   | typeFieldList typeField

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:881:1-881:55:
def $flatten_typeFieldList(typeFieldList) : typeField* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:882:1-882:41:
   clause 0(typeFieldList) = []
      -- if typeFieldList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:883:1-884:59:
   clause 1(typeFieldList') = $flatten_typeFieldList(typeFieldList) ++ [typeField]
      -- if typeFieldList' matches `%%`
      -- let typeFieldList typeField = typeFieldList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:887:3-887:69:
syntax structTypeDeclaration = 
   | annotationList struct name typeParameterListOpt { typeFieldList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:890:3-890:69:
syntax headerTypeDeclaration = 
   | annotationList header name typeParameterListOpt { typeFieldList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:893:3-893:75:
syntax headerUnionTypeDeclaration = 
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:896:1-899:31:
syntax derivedTypeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:906:1-907:27:
syntax typedefType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:910:1-911:37:
syntax typedefDeclaration = 
   | annotationList typedef typedefType name ;
   | annotationList type type name ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:918:3-918:45:
syntax externFunctionDeclaration = 
   | annotationList extern functionPrototype ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:921:1-923:49:
syntax methodPrototype = 
   | annotationList typeIdentifier ( parameterList );
   | annotationList functionPrototype ;
   | annotationList abstract functionPrototype ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:926:1-927:40:
syntax methodPrototypeList = 
   | 
   | methodPrototypeList methodPrototype

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:929:1-929:73:
def $flatten_methodPrototypeList(methodPrototypeList) : methodPrototype* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:930:1-930:47:
   clause 0(methodPrototypeList) = []
      -- if methodPrototypeList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:931:1-934:77:
   clause 1(methodPrototypeList') = $flatten_methodPrototypeList(methodPrototypeList) ++ [methodPrototype]
      -- if methodPrototypeList' matches `%%`
      -- let methodPrototypeList methodPrototype = methodPrototypeList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:937:3-937:82:
syntax externObjectDeclaration = 
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:940:1-941:28:
syntax externDeclaration = 
   | annotationList extern functionPrototype ;
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:951:21-951:48:
syntax selectCase = 
   | keysetExpression : name ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:954:1-955:30:
syntax selectCaseList = 
   | 
   | selectCaseList selectCase

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:957:1-957:58:
def $flatten_selectCaseList(selectCaseList) : selectCase* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:958:1-958:42:
   clause 0(selectCaseList) = []
      -- if selectCaseList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:959:1-960:62:
   clause 1(selectCaseList') = $flatten_selectCaseList(selectCaseList) ++ [selectCase]
      -- if selectCaseList' matches `%%`
      -- let selectCaseList selectCase = selectCaseList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:962:27-962:73:
syntax selectExpression = 
   | select( expressionList ){ selectCaseList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:969:1-970:21:
syntax stateExpression = 
   | name ;
   | select( expressionList ){ selectCaseList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:973:1-974:31:
syntax transitionStatement = 
   | 
   | transition stateExpression

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:981:1-983:21:
syntax valueSetType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | tuple< typeArgumentList >
   | text
   | . typeName

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:986:3-986:69:
syntax valueSetDeclaration = 
   | annotationList value_set< valueSetType >( expression ) name ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:993:3-993:72:
syntax parserTypeDeclaration = 
   | annotationList parser name typeParameterListOpt ( parameterList );

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1001:31-1001:70:
syntax parserBlockStatement = 
   | annotationList { parserStatementList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1004:1-1011:25:
syntax parserStatement = 
   | annotationList const type name initializer ;
   | annotationList type name initializerOpt ;
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | annotationList { parserStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1014:1-1015:40:
syntax parserStatementList = 
   | 
   | parserStatementList parserStatement

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1017:1-1017:73:
def $flatten_parserStatementList(parserStatementList) : parserStatement* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1018:1-1018:47:
   clause 0(parserStatementList) = []
      -- if parserStatementList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1019:1-1020:77:
   clause 1(parserStatementList') = $flatten_parserStatementList(parserStatementList) ++ [parserStatement]
      -- if parserStatementList' matches `%%`
      -- let parserStatementList parserStatement = parserStatementList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1023:3-1023:73:
syntax parserState = 
   | annotationList state name { parserStatementList transitionStatement }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1026:1-1027:32:
syntax parserStateList = 
   | annotationList state name { parserStatementList transitionStatement }
   | parserStateList parserState

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1029:1-1029:61:
def $flatten_parserStateList(parserStateList) : parserState* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1030:1-1030:56:
   clause 0(parserStateList) = [parserState]
      -- if parserStateList <: parserState
      -- let parserState = parserStateList as parserState

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1031:1-1032:65:
   clause 1(parserStateList') = $flatten_parserStateList(parserStateList) ++ [parserState]
      -- if parserStateList' matches `%%`
      -- let parserStateList parserState = parserStateList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1035:1-1038:24:
syntax parserLocalDeclaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList type name initializerOpt ;
   | annotationList value_set< valueSetType >( expression ) name ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1041:1-1042:54:
syntax parserLocalDeclarationList = 
   | 
   | parserLocalDeclarationList parserLocalDeclaration

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1044:1-1045:28:
def $flatten_parserLocalDeclarationList(parserLocalDeclarationList) : parserLocalDeclaration* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1046:1-1046:54:
   clause 0(parserLocalDeclarationList) = []
      -- if parserLocalDeclarationList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1047:1-1051:34:
   clause 1(parserLocalDeclarationList') = $flatten_parserLocalDeclarationList(parserLocalDeclarationList) ++ [parserLocalDeclaration]
      -- if parserLocalDeclarationList' matches `%%`
      -- let parserLocalDeclarationList parserLocalDeclaration = parserLocalDeclarationList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1054:3-1056:52:
syntax parserDeclaration = 
   | annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1066:16-1066:21:
syntax const = 
   | const

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1069:1-1070:10:
syntax constOpt = 
   | 
   | const

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1072:1-1072:41:
def $flatten_constOpt(constOpt) : const? =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1073:1-1073:36:
   clause 0(constOpt) = ?()
      -- if constOpt matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1074:1-1074:37:
   clause 1(constOpt) = ?(const)
      -- if constOpt <: const
      -- let const = constOpt as const

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1080:19-1080:55:
syntax tableKey = 
   | expression : name annotationList ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1083:1-1084:26:
syntax tableKeyList = 
   | 
   | tableKeyList tableKey

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1086:1-1086:52:
def $flatten_tableKeyList(tableKeyList) : tableKey* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1087:1-1087:40:
   clause 0(tableKeyList) = []
      -- if tableKeyList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1088:1-1089:56:
   clause 1(tableKeyList') = $flatten_tableKeyList(tableKeyList) ++ [tableKey]
      -- if tableKeyList' matches `%%`
      -- let tableKeyList tableKey = tableKeyList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1096:1-1097:42:
syntax tableActionReference = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | prefixedNonTypeName ( argumentList )

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1099:22-1099:60:
syntax tableAction = 
   | annotationList tableActionReference ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1102:1-1103:32:
syntax tableActionList = 
   | 
   | tableActionList tableAction

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1105:1-1105:61:
def $flatten_tableActionList(tableActionList) : tableAction* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1106:1-1106:43:
   clause 0(tableActionList) = []
      -- if tableActionList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1107:1-1108:63:
   clause 1(tableActionList') = $flatten_tableActionList(tableActionList) ++ [tableAction]
      -- if tableActionList' matches `%%`
      -- let tableActionList tableAction = tableActionList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1115:1-1116:35:
syntax tableEntryPriority = 
   | priority= number :
   | priority=( expression ):

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1119:1-1120:72:
syntax tableEntry = 
   | constOpt tableEntryPriority keysetExpression : tableActionReference annotationList ;
   | constOpt keysetExpression : tableActionReference annotationList ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1123:1-1124:30:
syntax tableEntryList = 
   | 
   | tableEntryList tableEntry

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1126:1-1126:58:
def $flatten_tableEntryList(tableEntryList) : tableEntry* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1127:1-1127:42:
   clause 0(tableEntryList) = []
      -- if tableEntryList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1128:1-1129:62:
   clause 1(tableEntryList') = $flatten_tableEntryList(tableEntryList) ++ [tableEntry]
      -- if tableEntryList' matches `%%`
      -- let tableEntryList tableEntry = tableEntryList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1136:1-1139:59:
syntax tableProperty = 
   | key={ tableKeyList }
   | actions={ tableActionList }
   | annotationList constOpt entries={ tableEntryList }
   | annotationList constOpt tableCustomName initializer ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1142:1-1143:36:
syntax tablePropertyList = 
   | 
   | tablePropertyList tableProperty

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1145:1-1145:67:
def $flatten_tablePropertyList(tablePropertyList) : tableProperty* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1146:1-1146:45:
   clause 0(tablePropertyList) = []
      -- if tablePropertyList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1147:1-1148:69:
   clause 1(tablePropertyList') = $flatten_tablePropertyList(tablePropertyList) ++ [tableProperty]
      -- if tablePropertyList' matches `%%`
      -- let tablePropertyList tableProperty = tablePropertyList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1151:3-1151:51:
syntax tableDeclaration = 
   | annotationList table name { tablePropertyList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1158:3-1158:73:
syntax controlTypeDeclaration = 
   | annotationList control name typeParameterListOpt ( parameterList );

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1164:22-1164:36:
syntax controlBody = blockStatement

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1167:1-1171:21:
syntax controlLocalDeclaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList type name initializerOpt ;
   | annotationList action name ( parameterList ) blockStatement
   | annotationList table name { tablePropertyList }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1174:1-1175:56:
syntax controlLocalDeclarationList = 
   | 
   | controlLocalDeclarationList controlLocalDeclaration

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1177:1-1178:29:
def $flatten_controlLocalDeclarationList(controlLocalDeclarationList) : controlLocalDeclaration* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1180:1-1180:55:
   clause 0(controlLocalDeclarationList) = []
      -- if controlLocalDeclarationList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1181:1-1185:32:
   clause 1(controlLocalDeclarationList') = $flatten_controlLocalDeclarationList(controlLocalDeclarationList) ++ [controlLocalDeclaration]
      -- if controlLocalDeclarationList' matches `%%`
      -- let controlLocalDeclarationList controlLocalDeclaration = controlLocalDeclarationList'

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1188:3-1190:55:
syntax controlDeclaration = 
   | annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody }

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1197:3-1197:73:
syntax packageTypeDeclaration = 
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1204:1-1208:27:
syntax typeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }
   | annotationList typedef typedefType name ;
   | annotationList type type name ;
   | annotationList parser name typeParameterListOpt ( parameterList );
   | annotationList control name typeParameterListOpt ( parameterList );
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1215:1-1224:20:
syntax declaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList functionPrototype blockStatement
   | annotationList action name ( parameterList ) blockStatement
   | error{ nameList }
   | match_kind{ nameList trailingCommaOpt }
   | annotationList extern functionPrototype ;
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }
   | annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList }
   | annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody }
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }
   | annotationList typedef typedefType name ;
   | annotationList type type name ;
   | annotationList parser name typeParameterListOpt ( parameterList );
   | annotationList control name typeParameterListOpt ( parameterList );
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1231:1-1248:27:
syntax annotationToken = 
   | unexpected_token
   | abstract
   | action
   | actions
   | apply
   | bool
   | bit
   | break
   | const
   | continue
   | control
   | default
   | else
   | entries
   | enum
   | error
   | exit
   | extern
   | false
   | for
   | header
   | header_union
   | if
   | in
   | inout
   | int
   | key
   | match_kind
   | type
   | out
   | parser
   | package
   | pragma
   | return
   | select
   | state
   | string
   | struct
   | switch
   | table
   | this
   | transition
   | true
   | tuple
   | typedef
   | varbit
   | value_set
   | list
   | void
   | _
   | text
   | text
   | " text " hint(print "#%#")
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | &&&
   | ..
   | <<
   | &&
   | ||
   | ==
   | !=
   | >=
   | <=
   | ++
   | +
   | |+|
   | -
   | |-|
   | *
   | /
   | %
   | |
   | &
   | ^
   | ~
   | [
   | ]
   | {
   | }
   | <
   | >
   | !
   | :
   | ,
   | ?
   | .
   | =
   | ;
   | @

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1251:1-1253:35:
syntax annotationBody = 
   | 
   | annotationBody ( annotationBody )
   | annotationBody annotationToken

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1256:3-1256:41:
syntax structuredAnnotationBody = 
   | dataElementExpression trailingCommaOpt

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1259:1-1261:42:
syntax annotation = 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1264:1-1265:38:
syntax annotationListNonEmpty = 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]
   | annotationListNonEmpty annotation

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1268:1-1269:27:
syntax annotationList = 
   | 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]
   | annotationListNonEmpty annotation

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1276:1-1278:17:
syntax p4program = 
   | 
   | p4program declaration
   | p4program ;

;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1280:1-1280:49:
def $flatten_p4program(p4program) : declaration* =

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1281:1-1281:37:
   clause 0(p4program) = []
      -- if p4program matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1282:1-1283:53:
   clause 1(p4program') = $flatten_p4program(p4program) ++ [declaration]
      -- if p4program' matches `%%`
      -- let p4program declaration = p4program'

   ;; ../../../../reference-specs/p4-concrete/1-syntax.spectec:1284:1-1285:34:
   clause 2(p4program') = $flatten_p4program(p4program)
      -- if p4program' matches `%;`
      -- let p4program ; = p4program'

;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:5:17-5:21:
syntax nameIR = text

;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:7:1-7:25:
def $name(name) : nameIR =

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:9:1-9:21:
   clause 0(name) = t
      -- if name <: identifier
      -- let t = name as identifier

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:10:1-10:22:
   clause 1(name) = t
      -- if name <: typeIdentifier
      -- let t = name as typeIdentifier

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:11:1-11:27:
   clause 2(name) = "apply"
      -- if name <: nonTypeName
      -- let nonTypeName = name as nonTypeName
      -- if nonTypeName matches `APPLY`

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:12:1-12:23:
   clause 3(name) = "key"
      -- if name <: nonTypeName
      -- let nonTypeName = name as nonTypeName
      -- if nonTypeName matches `KEY`

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:13:1-13:31:
   clause 4(name) = "actions"
      -- if name <: nonTypeName
      -- let nonTypeName = name as nonTypeName
      -- if nonTypeName matches `ACTIONS`

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:14:1-14:27:
   clause 5(name) = "state"
      -- if name <: nonTypeName
      -- let nonTypeName = name as nonTypeName
      -- if nonTypeName matches `STATE`

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:15:1-15:31:
   clause 6(name) = "entries"
      -- if name <: nonTypeName
      -- let nonTypeName = name as nonTypeName
      -- if nonTypeName matches `ENTRIES`

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:16:1-16:25:
   clause 7(name) = "type"
      -- if name <: nonTypeName
      -- let nonTypeName = name as nonTypeName
      -- if nonTypeName matches `TYPE`

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:17:1-17:33:
   clause 8(name) = "priority"
      -- if name <: nonTypeName
      -- let nonTypeName = name as nonTypeName
      -- if nonTypeName matches `PRIORITY`

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:18:1-18:25:
   clause 9(name) = "list"
      -- if name matches `LIST`

;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:20:1-20:47:
def $tableCustomName(tableCustomName) : nameIR =

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:22:1-22:32:
   clause 0(tableCustomName) = t
      -- if tableCustomName <: identifier
      -- let t = tableCustomName as identifier

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:23:1-23:33:
   clause 1(tableCustomName) = t
      -- if tableCustomName <: typeIdentifier
      -- let t = tableCustomName as typeIdentifier

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:24:1-24:38:
   clause 2(tableCustomName) = "apply"
      -- if tableCustomName matches `APPLY`

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:25:1-25:38:
   clause 3(tableCustomName) = "state"
      -- if tableCustomName matches `STATE`

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:26:1-26:36:
   clause 4(tableCustomName) = "type"
      -- if tableCustomName matches `TYPE`

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:27:1-27:44:
   clause 5(tableCustomName) = "priority"
      -- if tableCustomName matches `PRIORITY`

;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:33:13-33:17:
syntax id = text

;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:39:14-39:16:
syntax tid = id

;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:41:1-41:23:
def $fresh_tid : tid =

;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:42:1-42:28:
def $fresh_tids(nat) : tid* =

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:44:1-44:25:
   clause 0(nat) = []
      -- if (nat = 0)

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:45:1-46:15:
   clause 1(n) = $fresh_tid :: $fresh_tids((n - 1))
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:56:14-56:24:
syntax pid = 
   | id # bool

;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:57:14-57:26:
syntax rid = 
   | id ( pid* )

;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:59:1-59:36:
def $rid(name, parameterList) : rid =

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:63:1-64:42:
   clause 0(name, parameterList) = $name(name) ( $pids(parameterList) )

;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:60:1-60:32:
def $pids(parameterList) : pid* =

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:66:1-66:24:
   clause 0(parameterList) = []
      -- if parameterList matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:67:1-67:39:
   clause 1(parameterList) = [$pid(parameter)]
      -- if parameterList <: parameter
      -- let parameter = parameterList as parameter

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:68:1-69:56:
   clause 2(parameterList) = $pids(nonEmptyParameterList as parameterList) ++ [$pid(parameter)]
      -- if parameterList <: nonEmptyParameterList
      -- let nonEmptyParameterList' = parameterList as nonEmptyParameterList
      -- if nonEmptyParameterList' matches `%,%`
      -- let nonEmptyParameterList , parameter = nonEmptyParameterList'

;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:61:1-61:26:
def $pid(parameter) : pid =

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:71:1-71:51:
   clause 0(_annotationList _direction _type name initializerOpt) = $name(name) # false
      -- if initializerOpt matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:72:1-72:55:
   clause 1(_annotationList _direction _type name initializerOpt) = $name(name) # true
      -- if initializerOpt <: initializer
      -- let initializer = initializerOpt as initializer

;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:78:14-78:17:
syntax cid = rid

;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:80:1-80:50:
def $cid(name, constructorParameterListOpt) : cid =

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:82:1-82:46:
   clause 0(name, constructorParameterListOpt) = $name(name) ( [] )
      -- if constructorParameterListOpt matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:83:1-84:42:
   clause 1(name, constructorParameterListOpt) = $name(name) ( $pids(parameterList) )
      -- if constructorParameterListOpt matches `(%)`
      -- let ( parameterList ) = constructorParameterListOpt

;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:88:1-88:48:
def $expression_as_lvalue(expression) : lvalue? =

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:90:1-90:69:
   clause 0(expression) = ?(referenceExpression as lvalue)
      -- if expression <: referenceExpression
      -- let referenceExpression = expression as referenceExpression

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:91:1-92:51:
   clause 1(expression') = ?(lvalue . member)
      -- if expression' <: memberAccessExpression
      -- let memberAccessBase . member = expression' as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression = memberAccessBase as expression
      -- let lvalue'?{lvalue' <- lvalue'?} = $expression_as_lvalue(expression)
      -- if lvalue'?{lvalue' <- lvalue'?} matches (_)
      -- let ?(lvalue) = lvalue'?{lvalue' <- lvalue'?}

   ;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:93:1-94:51:
   clause 2(expression') = ?(( lvalue ))
      -- if expression' <: parenthesizedExpression
      -- let ( expression ) = expression' as parenthesizedExpression
      -- let lvalue'?{lvalue' <- lvalue'?} = $expression_as_lvalue(expression)
      -- if lvalue'?{lvalue' <- lvalue'?} matches (_)
      -- let ?(lvalue) = lvalue'?{lvalue' <- lvalue'?}

;; ../../../../reference-specs/p4-concrete/2.0-domain.spectec:99:14-99:17:
syntax oid = id*

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:14:1-17:15:
syntax primitiveValue = 
   | b bool
   | error. id
   | match_kind. id
   | " text "

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:24:1-25:21:
syntax numberValue = 
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:27:20-27:50:
syntax baseValue = 
   | b bool
   | error. id
   | match_kind. id
   | " text "
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:35:20-35:31:
syntax listValue = 
   | [ value* ]

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:36:21-36:32:
syntax tupleValue = 
   | ( value* )

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:37:27-37:55:
syntax headerStackValue = 
   | [ value* #( nat ; nat )]

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:39:21-39:32:
syntax fieldValue = 
   | value id ;

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:41:22-41:49:
syntax structValue = 
   | struct tid { fieldValue* }

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:42:22-42:49:
syntax headerValue = 
   | header tid { fieldValue* }

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:43:27-43:60:
syntax headerUnionValue = 
   | header_union tid { fieldValue* }

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:46:1-47:23:
syntax enumValue = 
   | tid . id
   | tid . id # value

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:50:1-56:14:
syntax dataValue = 
   | [ value* ]
   | ( value* )
   | [ value* #( nat ; nat )]
   | struct tid { fieldValue* }
   | header tid { fieldValue* }
   | header_union tid { fieldValue* }
   | tid . id
   | tid . id # value

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:62:23-62:30:
syntax defaultValue = 
   | default

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:64:29-64:33:
syntax invalidHeaderValue = 
   | {#}

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:67:1-68:28:
syntax sequenceValue = 
   | seq( value* )
   | seq( value* ,...)

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:71:1-72:36:
syntax recordValue = 
   | record{ fieldValue* }
   | record{ fieldValue* ,...}

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:75:1-77:29:
syntax setValue = 
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:80:1-81:38:
syntax tableValue = 
   | table_enum tid . id
   | table_struct tid { fieldValue* }

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:84:1-89:15:
syntax synthesizedValue = 
   | default
   | {#}
   | seq( value* )
   | seq( value* ,...)
   | record{ fieldValue* }
   | record{ fieldValue* ,...}
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }
   | table_enum tid . id
   | table_struct tid { fieldValue* }

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:95:31-95:37:
syntax objectReferenceValue = 
   | ! oid

;; ../../../../reference-specs/p4-concrete/2.1.1-value.spectec:102:1-105:25:
syntax value = 
   | b bool
   | error. id
   | match_kind. id
   | " text "
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat
   | [ value* ]
   | ( value* )
   | [ value* #( nat ; nat )]
   | struct tid { fieldValue* }
   | header tid { fieldValue* }
   | header_union tid { fieldValue* }
   | tid . id
   | tid . id # value
   | default
   | {#}
   | seq( value* )
   | seq( value* ,...)
   | record{ fieldValue* }
   | record{ fieldValue* ,...}
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }
   | table_enum tid . id
   | table_struct tid { fieldValue* }
   | ! oid

;; ../../../../reference-specs/p4-concrete/2.1.2-value-aux.spectec:5:1-5:28:
def $to_int(int, int) : int =

;; ../../../../reference-specs/p4-concrete/2.1.2-value-aux.spectec:12:1-12:31:
def $to_bitstr(int, int) : int =

;; ../../../../reference-specs/p4-concrete/2.1.2-value-aux.spectec:18:1-18:28:
def $to_number(value) : int =

   ;; ../../../../reference-specs/p4-concrete/2.1.2-value-aux.spectec:20:1-20:24:
   clause 0(value) = i
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i = number

   ;; ../../../../reference-specs/p4-concrete/2.1.2-value-aux.spectec:21:1-21:38:
   clause 1(value) = $to_int(w as int, i)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w s i = number

   ;; ../../../../reference-specs/p4-concrete/2.1.2-value-aux.spectec:22:1-22:26:
   clause 2(value) = i
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w i = number

   ;; ../../../../reference-specs/p4-concrete/2.1.2-value-aux.spectec:23:1-23:31:
   clause 3(value) = i
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%V%#%`
      -- let w v i # _nat = numberValue

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:14:1-18:11:
syntax primitiveTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:25:1-28:20:
syntax numberTypeIR = 
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:30:21-30:51:
syntax baseTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:40:1-41:31:
syntax namedTypeIR = 
   | tid tid
   | polyTypeDefIR < typeIR* >

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:52:1-53:20:
syntax aliasTypeIR = 
   | typedef tid typeIR
   | type tid typeIR

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:59:21-59:37:
syntax listTypeIR = 
   | list< typeIR >

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:60:22-60:40:
syntax tupleTypeIR = 
   | tuple< typeIR* >

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:61:28-61:43:
syntax headerStackTypeIR = 
   | typeIR [ nat ]

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:63:22-63:34:
syntax fieldTypeIR = 
   | typeIR id ;

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:65:23-65:51:
syntax structTypeIR = 
   | struct tid { fieldTypeIR* }

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:66:23-66:51:
syntax headerTypeIR = 
   | header tid { fieldTypeIR* }

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:67:28-67:62:
syntax headerUnionTypeIR = 
   | header_union tid { fieldTypeIR* }

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:69:23-69:37:
syntax valueFieldIR = 
   | id = value ;

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:72:1-73:42:
syntax enumTypeIR = 
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:76:1-82:15:
syntax dataTypeIR = 
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:92:3-92:40:
syntax externObjectTypeIR = 
   | extern tid map<rid, routineTypeDefIR>

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:93:29-93:57:
syntax parserObjectTypeIR = 
   | parser( parameterTypeIR* )

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:94:30-94:59:
syntax controlObjectTypeIR = 
   | control( parameterTypeIR* )

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:95:30-95:50:
syntax packageObjectTypeIR = 
   | package< typeIR* >

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:96:28-96:47:
syntax tableObjectTypeIR = 
   | table tid # typeIR

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:99:1-103:22:
syntax objectTypeIR = 
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:106:1-108:17:
syntax definedTypeIR = 
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:114:24-114:31:
syntax defaultTypeIR = 
   | default

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:116:30-116:44:
syntax invalidHeaderTypeIR = 
   | header_invalid

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:119:1-120:29:
syntax sequenceTypeIR = 
   | seq< typeIR* >
   | seq< typeIR* ,...>

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:123:1-124:37:
syntax recordTypeIR = 
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:126:20-126:36:
syntax setTypeIR = 
   | set< typeIR* >

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:129:1-130:39:
syntax tableTypeIR = 
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:133:1-138:16:
syntax synthesizedTypeIR = 
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:145:1-148:22:
syntax typeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:154:24-154:30:
syntax monoTypeDefIR = typeIR

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:156:24-156:48:
syntax polyTypeDefIR = 
   | typeIR < tid* , tid* >

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:158:20-158:49:
syntax typeDefIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }
   | typeIR < tid* , tid* >

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:164:26-164:52:
syntax parameterTypeIR = 
   | direction typeIR id value?

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:171:1-174:33:
syntax functionTypeIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:177:1-182:27:
syntax methodTypeIR = 
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:185:1-186:17:
syntax routineTypeIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:192:31-192:44:
syntax monoRoutineTypeDefIR = routineTypeIR

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:194:31-194:62:
syntax polyRoutineTypeDefIR = 
   | routineTypeIR < tid* , tid* >

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:197:1-198:25:
syntax routineTypeDefIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR
   | routineTypeIR < tid* , tid* >

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:204:37-204:52:
syntax constructorParameterTypeIR = parameterTypeIR

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:211:3-211:58:
syntax constructorTypeIR = 
   | constructor( constructorParameterTypeIR* )-> typeIR

;; ../../../../reference-specs/p4-concrete/2.2.1-type.spectec:217:31-217:66:
syntax constructorTypeDefIR = 
   | constructorTypeIR < tid* , tid* >

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:9:1-9:34:
def $is_baseTypeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:10:1-10:38:
   clause 0(typeIR) = true
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:11:1-12:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:16:1-16:39:
def $is_primitiveTypeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:17:1-17:48:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:18:1-19:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:21:1-21:35:
def $is_void_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:22:1-22:33:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `VOID`

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:23:1-24:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:26:1-26:35:
def $is_bool_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:27:1-27:33:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:28:1-29:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:31:1-31:36:
def $is_error_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:32:1-32:35:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ERROR`

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:33:1-34:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:36:1-36:40:
def $is_matchkind_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:37:1-37:44:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `MATCH_KIND`

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:38:1-39:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:41:1-41:37:
def $is_string_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:42:1-42:37:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `STRING`

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:43:1-44:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:48:1-48:36:
def $is_numberTypeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:49:1-49:42:
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:50:1-51:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:53:1-53:44:
def $is_arbitrary_int_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:54:1-54:41:
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:55:1-56:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:58:1-58:40:
def $is_fixed_int_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:59:1-59:44:
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:60:1-61:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:63:1-63:40:
def $is_fixed_bit_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:64:1-64:44:
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:65:1-66:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:76:1-76:34:
def $is_dataTypeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:77:1-77:38:
   clause 0(typeIR) = true
      -- if typeIR <: dataTypeIR
      -- let dataTypeIR = typeIR as dataTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:78:1-79:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:81:1-81:41:
def $is_headerStackTypeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:82:1-82:52:
   clause 0(typeIR) = true
      -- if typeIR <: headerStackTypeIR
      -- let headerStackTypeIR = typeIR as headerStackTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:83:1-84:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:88:1-88:36:
def $is_objectTypeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:89:1-89:42:
   clause 0(typeIR) = true
      -- if typeIR <: objectTypeIR
      -- let objectTypeIR = typeIR as objectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:90:1-91:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:93:1-93:44:
def $is_extern_object_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:94:1-94:56:
   clause 0(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let externObjectTypeIR = typeIR as externObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:95:1-96:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:98:1-98:44:
def $is_parser_object_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:99:1-99:56:
   clause 0(typeIR) = true
      -- if typeIR <: parserObjectTypeIR
      -- let parserObjectTypeIR = typeIR as parserObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:100:1-101:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:103:1-103:45:
def $is_control_object_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:104:1-104:58:
   clause 0(typeIR) = true
      -- if typeIR <: controlObjectTypeIR
      -- let controlObjectTypeIR = typeIR as controlObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:105:1-106:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:108:1-108:45:
def $is_package_object_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:109:1-109:58:
   clause 0(typeIR) = true
      -- if typeIR <: packageObjectTypeIR
      -- let packageObjectTypeIR = typeIR as packageObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:110:1-111:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:113:1-113:43:
def $is_table_object_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:114:1-114:56:
   clause 0(typeIR) = true
      -- if typeIR <: controlObjectTypeIR
      -- let controlObjectTypeIR = typeIR as controlObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:115:1-116:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:120:1-120:41:
def $is_synthesizedTypeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:121:1-121:52:
   clause 0(typeIR) = true
      -- if typeIR <: tableObjectTypeIR
      -- let tableObjectTypeIR = typeIR as tableObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:122:1-123:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:125:1-125:34:
def $is_set_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:126:1-126:38:
   clause 0(typeIR) = true
      -- if typeIR <: setTypeIR
      -- let set< _typeIR*{_typeIR <- _typeIR*} > = typeIR as setTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.2-type-aux.spectec:127:1-128:15:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:5:16-5:24:
syntax bound = set<tid>

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:6:16-6:32:
syntax theta = map<tid, typeIR>

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:8:1-8:31:
def $free_type(typeIR) : bound =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:33:1-33:38:
   clause 0(typeIR) = { [] }
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:37:1-37:35:
   clause 1(typeIR) = { [tid] }
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:39:1-42:59:
   clause 2(typeIR') = $union_set<tid>(bound_base, bound_args)
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR < typeIR*{typeIR <- typeIR*} > = namedTypeIR
      -- let bound_base = $free_typeDef(polyTypeDefIR as typeDefIR)
      -- let bound_args = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:46:1-46:54:
   clause 3(typeIR') = $free_type(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let typedef _tid typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:48:1-48:51:
   clause 4(typeIR') = $free_type(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:52:1-52:54:
   clause 5(typeIR') = $free_type(typeIR)
      -- if typeIR' <: listTypeIR
      -- let list< typeIR > = typeIR' as listTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:54:1-55:42:
   clause 6(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:57:1-57:51:
   clause 7(typeIR') = $free_type(typeIR)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:59:1-60:42:
   clause 8(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerTypeIR
      -- let header _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:62:1-63:42:
   clause 9(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerUnionTypeIR
      -- let header_union _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerUnionTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:65:1-66:42:
   clause 10(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:68:1-68:41:
   clause 11(typeIR) = { [] }
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:70:1-70:61:
   clause 12(typeIR') = $free_type(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:74:1-75:62:
   clause 13(typeIR) = $unions_set<tid>($free_routineTypeDef(routineTypeDefIR)*{routineTypeDefIR <- routineTypeDefIR*})
      -- if typeIR <: externObjectTypeIR
      -- let extern _tid { _rid : routineTypeDefIR*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} } = typeIR as externObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:77:1-80:64:
   clause 14(typeIR) = bound_params
      -- if typeIR <: parserObjectTypeIR
      -- let parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as parserObjectTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:82:1-85:64:
   clause 15(typeIR) = bound_params
      -- if typeIR <: controlObjectTypeIR
      -- let control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as controlObjectTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:87:1-88:42:
   clause 16(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: packageObjectTypeIR
      -- let package< typeIR*{typeIR <- typeIR*} > = typeIR' as packageObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:90:1-90:55:
   clause 17(typeIR') = $free_type(typeIR)
      -- if typeIR' <: tableObjectTypeIR
      -- let table _tid # typeIR = typeIR' as tableObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:94:1-94:35:
   clause 18(typeIR) = { [] }
      -- if typeIR <: defaultTypeIR
      -- let defaultTypeIR = typeIR as defaultTypeIR
      -- if (defaultTypeIR = default)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:96:1-96:42:
   clause 19(typeIR) = { [] }
      -- if typeIR <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR = typeIR as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR = header_invalid)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:98:1-99:42:
   clause 20(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR*{typeIR <- typeIR*} > = sequenceTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:101:1-102:42:
   clause 21(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let seq< typeIR*{typeIR <- typeIR*} ,...> = sequenceTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:104:1-105:42:
   clause 22(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR = typeIR' as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let record{ typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = recordTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:107:1-108:42:
   clause 23(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR = typeIR' as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let record{ typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} ,...} = recordTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:110:1-111:42:
   clause 24(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: setTypeIR
      -- let set< typeIR*{typeIR <- typeIR*} > = typeIR' as setTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:113:1-113:47:
   clause 25(typeIR) = { [] }
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_ENUM%{%}`
      -- let table_enum _tid { _id*{_id <- _id*} } = tableTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:115:1-115:49:
   clause 26(typeIR) = { [] }
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let table_struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = tableTypeIR

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:9:1-9:37:
def $free_typeDef(typeDefIR) : bound =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:121:1-121:47:
   clause 0(typeDefIR) = $free_type(typeIR)
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:123:1-126:49:
   clause 1(typeDefIR) = $diff_set<tid>(bound_base, bound_tparams)
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR_base < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = typeDefIR as polyTypeDefIR
      -- let bound_base = $free_typeDef(typeIR_base as typeDefIR)
      -- let bound_tparams = { tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} }

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:10:1-10:49:
def $free_parameterType(parameterTypeIR) : bound =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:132:1-132:59:
   clause 0(_direction typeIR _id _value?{_value <- _value?}) = $free_type(typeIR)

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:11:1-11:45:
def $free_routineType(routineTypeIR) : bound =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:138:1-144:43:
   clause 0(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let builtin_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:146:1-152:43:
   clause 1(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:154:1-160:43:
   clause 2(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let extern_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:162:1-167:64:
   clause 3(routineTypeIR) = bound_params
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:169:1-175:43:
   clause 4(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let builtin_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:177:1-183:43:
   clause 5(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:185:1-191:43:
   clause 6(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:193:1-198:64:
   clause 7(routineTypeIR) = bound_params
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:200:1-205:64:
   clause 8(routineTypeIR) = bound_params
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:207:1-211:43:
   clause 9(routineTypeIR) = bound_ret
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let table_apply-> typeIR_ret = methodTypeIR
      -- let bound_ret = $free_type(typeIR_ret)

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:12:1-12:51:
def $free_routineTypeDef(routineTypeDefIR) : bound =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:217:1-218:37:
   clause 0(routineTypeDefIR) = $free_routineType(routineTypeIR)
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR = routineTypeDefIR as routineTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:220:1-225:49:
   clause 1(routineTypeDefIR) = $diff_set<tid>(bound_base, bound_tparams)
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = routineTypeDefIR as polyRoutineTypeDefIR
      -- let bound_base = $free_routineTypeDef(routineTypeIR as routineTypeDefIR)
      -- let bound_tparams = { tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} }

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:14:1-14:40:
def $subst_type(theta, typeIR) : typeIR =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:231:1-231:43:
   clause 0(set<pair<tid, typeIR>>, typeIR) = typeIR
      -- if (set<pair<tid, typeIR>> = { [] })

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:232:1-233:15:
   clause 1(theta, typeIR) = $subst_type'(theta, typeIR)
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:15:1-15:41:
def $subst_type'(theta, typeIR) : typeIR =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:237:1-238:52:
   clause 0(theta, typeIR') = typeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid tid = namedTypeIR
      -- let typeIR''?{typeIR'' <- typeIR''?} = $find_map<tid, typeIR>(theta, tid)
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:240:1-244:54:
   clause 1(theta, typeIR') = polyTypeDefIR_subst < typeIR_subst*{typeIR_subst <- typeIR_subst*} > as typeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR < typeIR*{typeIR <- typeIR*} > = namedTypeIR
      -- let typeDefIR = $subst_typeDef'(theta, polyTypeDefIR as typeDefIR)
      -- if typeDefIR <: polyTypeDefIR
      -- let polyTypeDefIR_subst = typeDefIR as polyTypeDefIR
      -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:248:1-250:51:
   clause 2(theta, typeIR') = typedef tid typeIR_subst as typeIR
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let typedef tid typeIR = aliasTypeIR
      -- let typeIR_subst = $subst_type'(theta, typeIR)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:252:1-254:51:
   clause 3(theta, typeIR') = type tid typeIR_subst as typeIR
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type tid typeIR = aliasTypeIR
      -- let typeIR_subst = $subst_type'(theta, typeIR)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:258:1-260:51:
   clause 4(theta, typeIR') = list< typeIR_subst > as typeIR
      -- if typeIR' <: listTypeIR
      -- let list< typeIR > = typeIR' as listTypeIR
      -- let typeIR_subst = $subst_type'(theta, typeIR)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:262:1-264:54:
   clause 5(theta, typeIR') = tuple< typeIR_subst*{typeIR_subst <- typeIR_subst*} > as typeIR
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
      -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:266:1-268:51:
   clause 6(theta, typeIR') = typeIR_subst [ n ] as typeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ n ] = typeIR' as headerStackTypeIR
      -- let typeIR_subst = $subst_type'(theta, typeIR)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:270:1-275:58:
   clause 7(theta, typeIR) = struct tid { typeIR_f_subst id_f ;*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} } as typeIR
      -- if typeIR <: structTypeIR
      -- let struct tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as structTypeIR
      -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:277:1-282:58:
   clause 8(theta, typeIR) = header tid { typeIR_f_subst id_f ;*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} } as typeIR
      -- if typeIR <: headerTypeIR
      -- let header tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as headerTypeIR
      -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:284:1-289:58:
   clause 9(theta, typeIR) = header_union tid { typeIR_f_subst id_f ;*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} } as typeIR
      -- if typeIR <: headerUnionTypeIR
      -- let header_union tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as headerUnionTypeIR
      -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:291:1-296:51:
   clause 10(theta, typeIR') = enum tid # typeIR_subst { valueFieldIR*{valueFieldIR <- valueFieldIR*} } as typeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum tid # typeIR { valueFieldIR*{valueFieldIR <- valueFieldIR*} } = enumTypeIR
      -- let typeIR_subst = $subst_type'(theta, typeIR)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:300:1-306:60:
   clause 11(theta, typeIR) = extern tid { rid : routineTypeDefIR_subst*{rid <- rid*, routineTypeDefIR_subst <- routineTypeDefIR_subst*} } as typeIR
      -- if typeIR <: externObjectTypeIR
      -- let extern tid { rid : routineTypeDefIR*{rid <- rid*, routineTypeDefIR <- routineTypeDefIR*} } = typeIR as externObjectTypeIR
      -- (let routineTypeDefIR_subst = $subst_routineTypeDef'(theta, routineTypeDefIR))*{routineTypeDefIR <- routineTypeDefIR*, routineTypeDefIR_subst <- routineTypeDefIR_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:308:1-311:58:
   clause 12(theta, typeIR) = parser( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} ) as typeIR
      -- if typeIR <: parserObjectTypeIR
      -- let parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as parserObjectTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:313:1-316:58:
   clause 13(theta, typeIR) = control( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} ) as typeIR
      -- if typeIR <: controlObjectTypeIR
      -- let control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as controlObjectTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:318:1-320:54:
   clause 14(theta, typeIR') = package< typeIR_subst*{typeIR_subst <- typeIR_subst*} > as typeIR
      -- if typeIR' <: packageObjectTypeIR
      -- let package< typeIR*{typeIR <- typeIR*} > = typeIR' as packageObjectTypeIR
      -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:322:1-324:51:
   clause 15(theta, typeIR') = table tid # typeIR_subst as typeIR
      -- if typeIR' <: tableObjectTypeIR
      -- let table tid # typeIR = typeIR' as tableObjectTypeIR
      -- let typeIR_subst = $subst_type'(theta, typeIR)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:328:1-330:54:
   clause 16(theta, typeIR') = seq< typeIR_subst*{typeIR_subst <- typeIR_subst*} > as typeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR*{typeIR <- typeIR*} > = sequenceTypeIR
      -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:332:1-334:54:
   clause 17(theta, typeIR') = seq< typeIR_subst*{typeIR_subst <- typeIR_subst*} ,...> as typeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let seq< typeIR*{typeIR <- typeIR*} ,...> = sequenceTypeIR
      -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:336:1-341:58:
   clause 18(theta, typeIR) = record{ typeIR_f_subst id_f ;*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} } as typeIR
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let record{ typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = recordTypeIR
      -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:343:1-348:58:
   clause 19(theta, typeIR) = record{ typeIR_f_subst id_f ;*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} ,...} as typeIR
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let record{ typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} ,...} = recordTypeIR
      -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:350:1-352:54:
   clause 20(theta, typeIR') = set< typeIR_subst*{typeIR_subst <- typeIR_subst*} > as typeIR
      -- if typeIR' <: setTypeIR
      -- let set< typeIR*{typeIR <- typeIR*} > = typeIR' as setTypeIR
      -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:356:1-357:15:
   clause 21(theta, typeIR) = typeIR
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:16:1-16:49:
def $subst_typeDef(theta, typeDefIR) : typeDefIR =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:363:1-363:52:
   clause 0(set<pair<tid, typeIR>>, typeDefIR) = typeDefIR
      -- if (set<pair<tid, typeIR>> = { [] })

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:364:1-366:15:
   clause 1(theta, typeDefIR) = $subst_typeDef'(theta, typeDefIR)
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:17:1-17:50:
def $subst_typeDef'(theta, typeDefIR) : typeDefIR =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:368:1-368:65:
   clause 0(theta, typeDefIR) = $subst_type'(theta, typeIR) as typeDefIR
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:370:1-389:62:
   clause 1(theta, typeDefIR) = typeIR_base_subst < tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} , tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} > as typeDefIR
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR_base < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = typeDefIR as polyTypeDefIR
      -- let { tid_free*{tid_free <- tid_free*} } = $diff_set<tid>($free_type(typeIR_base), { tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} })
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(theta, tid_free))*{tid_free <- tid_free*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_free) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_free <- typeIR_free*}
      -- let bound_capture = $unions_set<tid>($free_type(typeIR_free)*{typeIR_free <- typeIR_free*})
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}|)
      -- (if ~$in_set<tid>(tid_fresh, bound_capture))*{tid_fresh <- tid_fresh*}
      -- let tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} = tid_fresh*{tid_fresh <- tid_fresh*}[0 : |tid*{tid <- tid*}|]
      -- let tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} = tid_fresh*{tid_fresh <- tid_fresh*}[|tid*{tid <- tid*}| : |tid_hidden*{tid_hidden <- tid_hidden*}|]
      -- let theta' = $adds_map<tid, typeIR>(theta, tid*{tid <- tid*}, tid tid_fresh_spec as typeIR*{tid_fresh_spec <- tid_fresh_spec*})
      -- let theta'' = $adds_map<tid, typeIR>(theta', tid_hidden*{tid_hidden <- tid_hidden*}, tid tid_fresh_hidden as typeIR*{tid_fresh_hidden <- tid_fresh_hidden*})
      -- let typeIR_base_subst = $subst_type(theta'', typeIR_base)

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:18:1-18:67:
def $subst_parameterType(theta, parameterTypeIR) : parameterTypeIR =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:395:1-396:20:
   clause 0(set<pair<tid, typeIR>>, parameterTypeIR) = parameterTypeIR
      -- if (set<pair<tid, typeIR>> = { [] })

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:397:1-399:15:
   clause 1(theta, parameterTypeIR) = $subst_parameterType'(theta, parameterTypeIR)
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:19:1-19:68:
def $subst_parameterType'(theta, parameterTypeIR) : parameterTypeIR =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:401:1-403:51:
   clause 0(theta, direction typeIR id value?{value <- value?}) = direction typeIR_subst id value?{value <- value?}
      -- let typeIR_subst = $subst_type'(theta, typeIR)

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:20:1-20:61:
def $subst_routineType(theta, routineTypeIR) : routineTypeIR =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:409:1-410:18:
   clause 0(set<pair<tid, typeIR>>, routineTypeIR) = routineTypeIR
      -- if (set<pair<tid, typeIR>> = { [] })

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:411:1-413:15:
   clause 1(theta, routineTypeIR) = $subst_routineType'(theta, routineTypeIR)
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:21:1-21:62:
def $subst_routineType'(theta, routineTypeIR) : routineTypeIR =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:415:1-422:59:
   clause 0(theta, routineTypeIR) = builtin_function( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let builtin_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:424:1-431:59:
   clause 1(theta, routineTypeIR) = function( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:433:1-440:59:
   clause 2(theta, routineTypeIR) = extern_function( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let extern_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:442:1-448:58:
   clause 3(theta, routineTypeIR) = action( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} ) as routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:450:1-457:59:
   clause 4(theta, routineTypeIR) = builtin_method( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let builtin_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:459:1-466:59:
   clause 5(theta, routineTypeIR) = extern_method( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:468:1-475:59:
   clause 6(theta, routineTypeIR) = extern_methodabstract( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:477:1-483:58:
   clause 7(theta, routineTypeIR) = parser_apply( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} ) as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:485:1-491:58:
   clause 8(theta, routineTypeIR) = control_apply( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} ) as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:493:1-498:59:
   clause 9(theta, routineTypeIR) = table_apply-> typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let table_apply-> typeIR_ret = methodTypeIR
      -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:22:1-22:70:
def $subst_routineTypeDef(theta, routineTypeDefIR) : routineTypeDefIR =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:504:1-505:21:
   clause 0(set<pair<tid, typeIR>>, routineTypeDefIR) = routineTypeDefIR
      -- if (set<pair<tid, typeIR>> = { [] })

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:506:1-508:15:
   clause 1(theta, routineTypeDefIR) = $subst_routineTypeDef'(theta, routineTypeDefIR)
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:23:1-23:71:
def $subst_routineTypeDef'(theta, routineTypeDefIR) : routineTypeDefIR =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:510:1-511:46:
   clause 0(theta, routineTypeDefIR) = $subst_routineType'(theta, routineTypeIR) as routineTypeDefIR
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR = routineTypeDefIR as routineTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:513:1-532:73:
   clause 1(theta, routineTypeDefIR) = routineTypeIR_subst < tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} , tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} > as routineTypeDefIR
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = routineTypeDefIR as polyRoutineTypeDefIR
      -- let { tid_free*{tid_free <- tid_free*} } = $diff_set<tid>($free_routineType(routineTypeIR), { tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} })
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(theta, tid_free))*{tid_free <- tid_free*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_free) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_free <- typeIR_free*}
      -- let bound_capture = $unions_set<tid>($free_type(typeIR_free)*{typeIR_free <- typeIR_free*})
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}|)
      -- (if ~$in_set<tid>(tid_fresh, bound_capture))*{tid_fresh <- tid_fresh*}
      -- let tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} = tid_fresh*{tid_fresh <- tid_fresh*}[0 : |tid*{tid <- tid*}|]
      -- let tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} = tid_fresh*{tid_fresh <- tid_fresh*}[|tid*{tid <- tid*}| : |tid_hidden*{tid_hidden <- tid_hidden*}|]
      -- let theta' = $adds_map<tid, typeIR>(theta, tid*{tid <- tid*}, tid tid_fresh_spec as typeIR*{tid_fresh_spec <- tid_fresh_spec*})
      -- let theta'' = $adds_map<tid, typeIR>(theta', tid_hidden*{tid_hidden <- tid_hidden*}, tid tid_fresh_hidden as typeIR*{tid_fresh_hidden <- tid_fresh_hidden*})
      -- let routineTypeIR_subst = $subst_routineType(theta'', routineTypeIR)

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:24:1-24:73:
def $subst_constructorType(theta, constructorTypeIR) : constructorTypeIR =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:538:1-539:22:
   clause 0(set<pair<tid, typeIR>>, constructorTypeIR) = constructorTypeIR
      -- if (set<pair<tid, typeIR>> = { [] })

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:540:1-542:15:
   clause 1(theta, constructorTypeIR) = $subst_constructorType'(theta, constructorTypeIR)
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:25:1-25:74:
def $subst_constructorType'(theta, constructorTypeIR) : constructorTypeIR =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:544:1-551:59:
   clause 0(theta, constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_obj) = constructor( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_obj_subst
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_obj_subst = $subst_type'(theta, typeIR_obj)

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:561:1-561:53:
def $specialize_typeDef(typeDefIR, typeIR*) : typeIR =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:563:1-563:46:
   clause 0(typeDefIR, typeIR'*{typeIR' <- typeIR'*}) = typeIR
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches []

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:565:1-568:49:
   clause 1(typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = $subst_type(theta, typeIR_base)
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR_base < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = typeDefIR as polyTypeDefIR
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- let theta = { tid_tparam : typeIR_arg*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*} }

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:574:1-575:29:
def $specialize_routineTypeDef(routineTypeDefIR, typeIR*) : (routineTypeDefIR, tid*) =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:577:1-578:25:
   clause 0(routineTypeDefIR, typeIR*{typeIR <- typeIR*}) = (routineTypeIR as routineTypeDefIR, [])
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR = routineTypeDefIR as routineTypeIR
      -- if typeIR*{typeIR <- typeIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:580:1-587:49:
   clause 1(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR) as routineTypeDefIR, [])
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = routineTypeDefIR as polyRoutineTypeDefIR
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if (|tid_tparam*{tid_tparam <- tid_tparam*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)
      -- let theta = { tid_tparam : typeIR_arg*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*} }

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:589:1-597:54:
   clause 2(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR), tid_fresh*{tid_fresh <- tid_fresh*}) as (routineTypeDefIR, tid*)
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = routineTypeDefIR as polyRoutineTypeDefIR
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if ((|tid_tparam*{tid_tparam <- tid_tparam*}| > 0) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| = 0))
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_tparam*{tid_tparam <- tid_tparam*}|)
      -- let theta = { tid_tparam : tid tid_fresh as typeIR*{tid_fresh <- tid_fresh*, tid_tparam <- tid_tparam*} }

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:599:1-610:53:
   clause 3(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR), tid_fresh*{tid_fresh <- tid_fresh*}) as (routineTypeDefIR, tid*)
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = routineTypeDefIR as polyRoutineTypeDefIR
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if (((|tid_hidden*{tid_hidden <- tid_hidden*}| > 0) /\ (|tid*{tid <- tid*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| > 0))
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_hidden*{tid_hidden <- tid_hidden*}|)
      -- let typeIR_arg_new*{typeIR_arg_new <- typeIR_arg_new*} = typeIR_arg*{typeIR_arg <- typeIR_arg*} ++ tid tid_fresh as typeIR*{tid_fresh <- tid_fresh*}
      -- let theta = { tid_tparam : typeIR_arg_new*{tid_tparam <- tid_tparam*, typeIR_arg_new <- typeIR_arg_new*} }

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:616:1-617:30:
def $specialize_constructorTypeDef(constructorTypeDefIR, typeIR*) : (constructorTypeIR, tid*) =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:619:1-628:57:
   clause 0(constructorTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} >, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = (constructorTypeIR_subst, [])
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if (|tid_tparam*{tid_tparam <- tid_tparam*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)
      -- let theta = { tid_tparam : typeIR_arg*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*} }
      -- let constructorTypeIR_subst = $subst_constructorType(theta, constructorTypeIR)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:630:1-640:57:
   clause 1(constructorTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} >, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = (constructorTypeIR_subst, tid_fresh*{tid_fresh <- tid_fresh*})
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if ((|tid_tparam*{tid_tparam <- tid_tparam*}| > 0) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| = 0))
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_tparam*{tid_tparam <- tid_tparam*}|)
      -- let theta = { tid_tparam : tid tid_fresh as typeIR*{tid_fresh <- tid_fresh*, tid_tparam <- tid_tparam*} }
      -- let constructorTypeIR_subst = $subst_constructorType(theta, constructorTypeIR)

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:642:1-655:57:
   clause 2(constructorTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} >, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = (constructorTypeIR_subst, tid_fresh*{tid_fresh <- tid_fresh*})
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if (((|tid_hidden*{tid_hidden <- tid_hidden*}| > 0) /\ (|tid*{tid <- tid*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| > 0))
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_hidden*{tid_hidden <- tid_hidden*}|)
      -- let typeIR_arg_new*{typeIR_arg_new <- typeIR_arg_new*} = typeIR_arg*{typeIR_arg <- typeIR_arg*} ++ tid tid_fresh as typeIR*{tid_fresh <- tid_fresh*}
      -- let theta = { tid_tparam : typeIR_arg_new*{tid_tparam <- tid_tparam*, typeIR_arg_new <- typeIR_arg_new*} }
      -- let constructorTypeIR_subst = $subst_constructorType(theta, constructorTypeIR)

;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:662:1-662:28:
def $canon(typeIR) : typeIR =

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:664:1-665:65:
   clause 0(typeIR') = $canon(typeIR)
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR
      -- let typeIR = $specialize_typeDef(polyTypeDefIR as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:667:1-667:46:
   clause 1(typeIR') = $canon(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let typedef _tid typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.3-type-subst.spectec:669:1-670:15:
   clause 2(typeIR) = typeIR
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:7:1-7:38:
def $is_nominal_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:10:1-11:40:
   clause 0(typeIR) = $is_nominal_typeIR'($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:8:1-8:39:
def $is_nominal_typeIR'(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:12:1-12:41:
   clause 0(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid _typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:13:1-13:48:
   clause 1(typeIR) = true
      -- if typeIR <: structTypeIR
      -- let struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as structTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:14:1-14:48:
   clause 2(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:15:1-15:54:
   clause 3(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:16:1-16:46:
   clause 4(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:17:1-17:51:
   clause 5(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:18:1-18:43:
   clause 6(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let extern _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:19:1-19:45:
   clause 7(typeIR) = true
      -- if typeIR <: tableObjectTypeIR
      -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:20:1-21:15:
   clause 8(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:25:1-25:42:
def $is_defaultable_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:28:1-29:44:
   clause 0(typeIR) = $is_defaultable_typeIR'($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:26:1-26:43:
def $is_defaultable_typeIR'(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:30:1-30:41:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:31:1-31:42:
   clause 1(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ERROR`

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:32:1-32:43:
   clause 2(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `STRING`

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:33:1-33:49:
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:34:1-35:35:
   clause 4(typeIR') = $is_defaultable_typeIR(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:36:1-37:40:
   clause 5(typeIR') = true
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
      -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:38:1-39:35:
   clause 6(typeIR') = $is_defaultable_typeIR(typeIR)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:40:1-41:40:
   clause 7(typeIR') = true
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR
      -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:42:1-43:40:
   clause 8(typeIR') = true
      -- if typeIR' <: headerTypeIR
      -- let header _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerTypeIR
      -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:44:1-45:40:
   clause 9(typeIR') = true
      -- if typeIR' <: headerUnionTypeIR
      -- let header_union _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerUnionTypeIR
      -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:46:1-46:50:
   clause 10(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:47:1-48:35:
   clause 11(typeIR') = $is_defaultable_typeIR(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:49:1-50:15:
   clause 12(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:54:1-54:40:
def $is_equalable_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:57:1-58:42:
   clause 0(typeIR) = $is_equalable_typeIR'($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:55:1-55:41:
def $is_equalable_typeIR'(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:59:1-59:40:
   clause 0(typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `VOID`

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:60:1-60:43:
   clause 1(typeIR) = false
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:61:1-61:46:
   clause 2(typeIR) = false
      -- if typeIR <: externObjectTypeIR
      -- let extern _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:62:1-62:49:
   clause 3(typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:63:1-63:50:
   clause 4(typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:64:1-64:50:
   clause 5(typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:65:1-65:48:
   clause 6(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:66:1-66:43:
   clause 7(typeIR) = false
      -- if typeIR <: defaultTypeIR
      -- let defaultTypeIR = typeIR as defaultTypeIR
      -- if (defaultTypeIR = default)

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:67:1-67:54:
   clause 8(typeIR) = false
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let seq< _typeIR*{_typeIR <- _typeIR*} ,...> = sequenceTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:68:1-68:57:
   clause 9(typeIR) = false
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let record{ _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} ,...} = recordTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:69:1-69:50:
   clause 10(typeIR) = false
      -- if typeIR <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR = typeIR as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR = header_invalid)

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:70:1-70:46:
   clause 11(typeIR) = false
      -- if typeIR <: setTypeIR
      -- let set< _typeIR*{_typeIR <- _typeIR*} > = typeIR as setTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:71:1-71:55:
   clause 12(typeIR) = false
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_ENUM%{%}`
      -- let table_enum _tid { _id*{_id <- _id*} } = tableTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:72:1-72:57:
   clause 13(typeIR) = false
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let table_struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = tableTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:73:1-74:15:
   clause 14(typeIR) = true
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:78:1-78:41:
def $is_assignable_typeIR(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:81:1-82:43:
   clause 0(typeIR) = $is_assignable_typeIR'($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:79:1-79:42:
def $is_assignable_typeIR'(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:83:1-83:41:
   clause 0(typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `VOID`

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:84:1-84:43:
   clause 1(typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `STRING`

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:85:1-85:40:
   clause 2(typeIR) = false
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:86:1-86:49:
   clause 3(typeIR) = false
      -- if typeIR <: objectTypeIR
      -- let objectTypeIR = typeIR as objectTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:87:1-87:54:
   clause 4(typeIR) = false
      -- if typeIR <: synthesizedTypeIR
      -- let synthesizedTypeIR = typeIR as synthesizedTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.4-type-util.spectec:88:1-89:15:
   clause 5(typeIR) = true
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:5:1-7:20:
relation Type_alpha: typeIR ~~ typeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:27:1-28:27:
   rule basetype: typeIR ~~ typeIR'
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR
      -- if typeIR' <: baseTypeIR
      -- let baseTypeIR' = typeIR' as baseTypeIR
      -- if (baseTypeIR = baseTypeIR')

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:32:1-33:26:
   rule nametype: typeIR ~~ typeIR'
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid tid = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `TID%`
      -- let tid tid' = namedTypeIR'
      -- if (tid = tid')

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:35:1-43:41:
   rule spectype-nominal: typeIR ~~ typeIR'
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR_a < typeIR_a*{typeIR_a <- typeIR_a*} > = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `%<%>`
      -- let polyTypeDefIR_b < typeIR_b*{typeIR_b <- typeIR_b*} > = namedTypeIR'
      -- let typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a as typeDefIR, typeIR_a*{typeIR_a <- typeIR_a*})
      -- let typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b as typeDefIR, typeIR_b*{typeIR_b <- typeIR_b*})
      -- if Type_alpha: typeIR_a_spec ~~ typeIR_b_spec holds
      -- if ($is_nominal_typeIR(typeIR_a_spec) /\ $is_nominal_typeIR(typeIR_b_spec))
      -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:45:1-52:46:
   rule spectype-structural: typeIR ~~ typeIR'
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR_a < typeIR_a*{typeIR_a <- typeIR_a*} > = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `%<%>`
      -- let polyTypeDefIR_b < typeIR_b*{typeIR_b <- typeIR_b*} > = namedTypeIR'
      -- let typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a as typeDefIR, typeIR_a*{typeIR_a <- typeIR_a*})
      -- let typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b as typeDefIR, typeIR_b*{typeIR_b <- typeIR_b*})
      -- if Type_alpha: typeIR_a_spec ~~ typeIR_b_spec holds
      -- if (~$is_nominal_typeIR(typeIR_a_spec) /\ ~$is_nominal_typeIR(typeIR_b_spec))

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:56:1-58:38:
   rule typedeftype-left: typeIR ~~ typeIR_b
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let typedef _tid typeIR_a = aliasTypeIR
      -- if Type_alpha: typeIR_a ~~ typeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:60:1-62:38:
   rule typedeftype-right: typeIR_a ~~ typeIR
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let typedef _tid typeIR_b = aliasTypeIR
      -- if Type_alpha: typeIR_a ~~ typeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:64:1-66:38:
   rule newtype: typeIR ~~ typeIR'
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type tid typeIR_a = aliasTypeIR
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR' = typeIR' as aliasTypeIR
      -- if aliasTypeIR' matches `TYPE%%`
      -- let type tid' typeIR_b = aliasTypeIR'
      -- if (tid = tid')
      -- if Type_alpha: typeIR_a ~~ typeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:70:1-72:38:
   rule listtype: typeIR ~~ typeIR'
      -- if typeIR <: listTypeIR
      -- let list< typeIR_a > = typeIR as listTypeIR
      -- if typeIR' <: listTypeIR
      -- let list< typeIR_b > = typeIR' as listTypeIR
      -- if Type_alpha: typeIR_a ~~ typeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:74:1-76:41:
   rule tupletype: typeIR ~~ typeIR'
      -- if typeIR <: tupleTypeIR
      -- let tuple< typeIR_a*{typeIR_a <- typeIR_a*} > = typeIR as tupleTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR' as tupleTypeIR
      -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:78:1-80:38:
   rule stacktype: typeIR ~~ typeIR'
      -- if typeIR <: headerStackTypeIR
      -- let typeIR_a [ n_s ] = typeIR as headerStackTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_b [ n_s' ] = typeIR' as headerStackTypeIR
      -- if (n_s = n_s')
      -- if Type_alpha: typeIR_a ~~ typeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:82:1-85:45:
   rule structtype: typeIR ~~ typeIR'
      -- if typeIR <: structTypeIR
      -- let struct tid { typeIR_f_a id_f ;*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} } = typeIR as structTypeIR
      -- if typeIR' <: structTypeIR
      -- let struct tid' { typeIR_f_b id_f' ;*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} } = typeIR' as structTypeIR
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if Type_alpha: typeIR_f_a ~~ typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:87:1-90:45:
   rule headertype: typeIR ~~ typeIR'
      -- if typeIR <: headerTypeIR
      -- let header tid { typeIR_f_a id_f ;*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} } = typeIR as headerTypeIR
      -- if typeIR' <: headerTypeIR
      -- let header tid' { typeIR_f_b id_f' ;*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} } = typeIR' as headerTypeIR
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if Type_alpha: typeIR_f_a ~~ typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:92:1-95:45:
   rule headeruniontype: typeIR ~~ typeIR'
      -- if typeIR <: headerUnionTypeIR
      -- let header_union tid { typeIR_f_a id_f ;*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} } = typeIR as headerUnionTypeIR
      -- if typeIR' <: headerUnionTypeIR
      -- let header_union tid' { typeIR_f_b id_f' ;*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} } = typeIR' as headerUnionTypeIR
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if Type_alpha: typeIR_f_a ~~ typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:97:1-98:49:
   rule enumtype: typeIR ~~ typeIR'
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum tid { id_f*{id_f <- id_f*} } = enumTypeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR' = typeIR' as enumTypeIR
      -- if enumTypeIR' matches `ENUM%{%}`
      -- let enum tid' { id_f'*{id_f' <- id_f'*} } = enumTypeIR'
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:100:1-103:38:
   rule serenumtype: typeIR ~~ typeIR'
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum tid # typeIR_a { id_f = value_f ;*{id_f <- id_f*, value_f <- value_f*} } = enumTypeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR' = typeIR' as enumTypeIR
      -- if enumTypeIR' matches `ENUM%#%{%}`
      -- let enum tid' # typeIR_b { id_f' = value_f' ;*{id_f' <- id_f'*, value_f' <- value_f'*} } = enumTypeIR'
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if (value_f = value_f'))*{value_f <- value_f*, value_f' <- value_f'*}
      -- if Type_alpha: typeIR_a ~~ typeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:107:1-119:73:
   rule externtype: typeIR ~~ typeIR'
      -- if typeIR <: externObjectTypeIR
      -- let extern tid { rid_a : routineTypeDefIR_a*{rid_a <- rid_a*, routineTypeDefIR_a <- routineTypeDefIR_a*} } = typeIR as externObjectTypeIR
      -- if typeIR' <: externObjectTypeIR
      -- let extern tid' { rid_b : routineTypeDefIR_b*{rid_b <- rid_b*, routineTypeDefIR_b <- routineTypeDefIR_b*} } = typeIR' as externObjectTypeIR
      -- if (tid = tid')
      -- if $eq_set<rid>({ rid_a*{rid_a <- rid_a*} }, { rid_b*{rid_b <- rid_b*} })
      -- (let routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?} = $find_map<rid, routineTypeDefIR>({ rid_a : routineTypeDefIR_a*{rid_a <- rid_a*, routineTypeDefIR_a <- routineTypeDefIR_a*} }, rid_a))*{rid_a <- rid_a*, routineTypeDefIR? <- routineTypeDefIR?*}
      -- (if routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?} matches (_))*{routineTypeDefIR? <- routineTypeDefIR?*}
      -- (let ?(routineTypeDefIR_a') = routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?})*{routineTypeDefIR? <- routineTypeDefIR?*, routineTypeDefIR_a' <- routineTypeDefIR_a'*}
      -- (let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_map<rid, routineTypeDefIR>({ rid_b : routineTypeDefIR_b*{rid_b <- rid_b*, routineTypeDefIR_b <- routineTypeDefIR_b*} }, rid_a))*{rid_a <- rid_a*, routineTypeDefIR'? <- routineTypeDefIR'?*}
      -- (if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_))*{routineTypeDefIR'? <- routineTypeDefIR'?*}
      -- (let ?(routineTypeDefIR_b') = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?})*{routineTypeDefIR'? <- routineTypeDefIR'?*, routineTypeDefIR_b' <- routineTypeDefIR_b'*}
      -- (if RoutineTypeDef_alpha: routineTypeDefIR_a' ~~ routineTypeDefIR_b' holds)*{routineTypeDefIR_a' <- routineTypeDefIR_a'*, routineTypeDefIR_b' <- routineTypeDefIR_b'*}

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:121:1-123:68:
   rule parsertype: typeIR ~~ typeIR'
      -- if typeIR <: parserObjectTypeIR
      -- let parser( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} ) = typeIR as parserObjectTypeIR
      -- if typeIR' <: parserObjectTypeIR
      -- let parser( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} ) = typeIR' as parserObjectTypeIR
      -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:125:1-127:68:
   rule controltype: typeIR ~~ typeIR'
      -- if typeIR <: controlObjectTypeIR
      -- let control( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} ) = typeIR as controlObjectTypeIR
      -- if typeIR' <: controlObjectTypeIR
      -- let control( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} ) = typeIR' as controlObjectTypeIR
      -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:129:1-131:41:
   rule packagetype: typeIR ~~ typeIR'
      -- if typeIR <: packageObjectTypeIR
      -- let package< typeIR_a*{typeIR_a <- typeIR_a*} > = typeIR as packageObjectTypeIR
      -- if typeIR' <: packageObjectTypeIR
      -- let package< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR' as packageObjectTypeIR
      -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:133:1-135:38:
   rule tabletype: typeIR ~~ typeIR'
      -- if typeIR <: tableObjectTypeIR
      -- let table tid # typeIR_a = typeIR as tableObjectTypeIR
      -- if typeIR' <: tableObjectTypeIR
      -- let table tid' # typeIR_b = typeIR' as tableObjectTypeIR
      -- if (tid = tid')
      -- if Type_alpha: typeIR_a ~~ typeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:139:1-140:21:
   rule defaulttype: typeIR ~~ typeIR'
      -- if typeIR <: defaultTypeIR
      -- let defaultTypeIR = typeIR as defaultTypeIR
      -- if (defaultTypeIR = default)
      -- if typeIR' <: defaultTypeIR
      -- let defaultTypeIR' = typeIR' as defaultTypeIR
      -- if (defaultTypeIR' = default)

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:142:1-144:41:
   rule sequencetype: typeIR ~~ typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR' matches `SEQ<%>`
      -- let seq< typeIR_b*{typeIR_b <- typeIR_b*} > = sequenceTypeIR'
      -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:146:1-148:41:
   rule sequencedefaulttype: typeIR ~~ typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR' matches `SEQ<%,...>`
      -- let seq< typeIR_b*{typeIR_b <- typeIR_b*} ,...> = sequenceTypeIR'
      -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:150:1-152:41:
   rule recordtype: typeIR ~~ typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let record{ typeIR_a id ;*{id <- id*, typeIR_a <- typeIR_a*} } = recordTypeIR
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR' = typeIR' as recordTypeIR
      -- if recordTypeIR' matches `RECORD{%}`
      -- let record{ typeIR_b id' ;*{id' <- id'*, typeIR_b <- typeIR_b*} } = recordTypeIR'
      -- (if (id = id'))*{id <- id*, id' <- id'*}
      -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:154:1-157:41:
   rule recorddefaulttype: typeIR ~~ typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let record{ typeIR_a id ;*{id <- id*, typeIR_a <- typeIR_a*} ,...} = recordTypeIR
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR' = typeIR' as recordTypeIR
      -- if recordTypeIR' matches `RECORD{%,...}`
      -- let record{ typeIR_b id' ;*{id' <- id'*, typeIR_b <- typeIR_b*} ,...} = recordTypeIR'
      -- (if (id = id'))*{id <- id*, id' <- id'*}
      -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:159:1-160:35:
   rule invalidtype: typeIR ~~ typeIR'
      -- if typeIR <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR = typeIR as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR = header_invalid)
      -- if typeIR' <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR' = typeIR' as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR' = header_invalid)

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:162:1-164:38:
   rule settype: typeIR' ~~ typeIR'''
      -- if typeIR' <: setTypeIR
      -- let set< typeIR*{typeIR <- typeIR*} > = typeIR' as setTypeIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_a] = typeIR*{typeIR <- typeIR*}
      -- if typeIR''' <: setTypeIR
      -- let set< typeIR''*{typeIR'' <- typeIR''*} > = typeIR''' as setTypeIR
      -- if typeIR''*{typeIR'' <- typeIR''*} matches [ _/1 ]
      -- let [typeIR_b] = typeIR''*{typeIR'' <- typeIR''*}
      -- if Type_alpha: typeIR_a ~~ typeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:166:1-167:61:
   rule tableenumtype: typeIR ~~ typeIR'
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_ENUM%{%}`
      -- let table_enum tid { id_f*{id_f <- id_f*} } = tableTypeIR
      -- if typeIR' <: tableTypeIR
      -- let tableTypeIR' = typeIR' as tableTypeIR
      -- if tableTypeIR' matches `TABLE_ENUM%{%}`
      -- let table_enum tid' { id_f'*{id_f' <- id_f'*} } = tableTypeIR'
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:169:1-172:45:
   rule tablestructtype: typeIR ~~ typeIR'
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let table_struct tid { typeIR_f_a id_f ;*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} } = tableTypeIR
      -- if typeIR' <: tableTypeIR
      -- let tableTypeIR' = typeIR' as tableTypeIR
      -- if tableTypeIR' matches `TABLE_STRUCT%{%}`
      -- let table_struct tid' { typeIR_f_b id_f' ;*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} } = tableTypeIR'
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if Type_alpha: typeIR_f_a ~~ typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}

;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:9:1-11:20:
relation ParameterType_alpha: parameterTypeIR ~~ parameterTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:178:1-180:38:
   rule : _direction typeIR_a _id _value?{_value <- _value?} ~~ _direction' typeIR_b _id' _value'?{_value' <- _value'?}
      -- if Type_alpha: typeIR_a ~~ typeIR_b holds

;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:13:1-15:20:
relation RoutineType_alpha: routineTypeIR ~~ routineTypeIR

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:186:1-190:46:
   rule builtinfunction: routineTypeIR ~~ routineTypeIR'
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let builtin_function( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = functionTypeIR
      -- if routineTypeIR' <: functionTypeIR
      -- let functionTypeIR' = routineTypeIR' as functionTypeIR
      -- if functionTypeIR' matches `BUILTIN_FUNCTION(%)->%`
      -- let builtin_function( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = functionTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:192:1-196:46:
   rule function: routineTypeIR ~~ routineTypeIR'
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let function( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = functionTypeIR
      -- if routineTypeIR' <: functionTypeIR
      -- let functionTypeIR' = routineTypeIR' as functionTypeIR
      -- if functionTypeIR' matches `FUNCTION(%)->%`
      -- let function( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = functionTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:198:1-200:68:
   rule action: routineTypeIR ~~ routineTypeIR'
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let action( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} ) = functionTypeIR
      -- if routineTypeIR' <: functionTypeIR
      -- let functionTypeIR' = routineTypeIR' as functionTypeIR
      -- if functionTypeIR' matches `ACTION(%)`
      -- let action( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} ) = functionTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:202:1-206:46:
   rule externfunction: routineTypeIR ~~ routineTypeIR'
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let extern_function( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = functionTypeIR
      -- if routineTypeIR' <: functionTypeIR
      -- let functionTypeIR' = routineTypeIR' as functionTypeIR
      -- if functionTypeIR' matches `EXTERN_FUNCTION(%)->%`
      -- let extern_function( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = functionTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:208:1-212:46:
   rule builtinmethod: routineTypeIR ~~ routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let builtin_method( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `BUILTIN_METHOD(%)->%`
      -- let builtin_method( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = methodTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:214:1-218:46:
   rule externmethod: routineTypeIR ~~ routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let extern_method( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `EXTERN_METHOD(%)->%`
      -- let extern_method( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = methodTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:220:1-224:46:
   rule externmethod-abstract: routineTypeIR ~~ routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let extern_methodabstract( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `EXTERN_METHODABSTRACT(%)->%`
      -- let extern_methodabstract( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = methodTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:226:1-229:68:
   rule parserapply: routineTypeIR ~~ routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let parser_apply( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} ) = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `PARSER_APPLY(%)`
      -- let parser_apply( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} ) = methodTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:231:1-234:68:
   rule controlapply: routineTypeIR ~~ routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let control_apply( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} ) = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `CONTROL_APPLY(%)`
      -- let control_apply( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} ) = methodTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:236:1-239:46:
   rule tableapply: routineTypeIR ~~ routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let table_apply-> typeIR_ret_a = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `TABLE_APPLY->%`
      -- let table_apply-> typeIR_ret_b = methodTypeIR'
      -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds

;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:17:1-19:20:
relation RoutineTypeDef_alpha: routineTypeDefIR ~~ routineTypeDefIR

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:245:1-247:59:
   rule mono: routineTypeDefIR ~~ routineTypeDefIR'
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR_a = routineTypeDefIR as routineTypeIR
      -- if routineTypeDefIR' <: routineTypeIR
      -- let routineTypeIR_b = routineTypeDefIR' as routineTypeIR
      -- if RoutineType_alpha: routineTypeIR_a ~~ routineTypeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/2.2.5-type-alpha.spectec:249:1-268:71:
   rule poly: routineTypeDefIR ~~ routineTypeDefIR'
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR_a < tid_a*{tid_a <- tid_a*} , tid_hidden_a*{tid_hidden_a <- tid_hidden_a*} > = routineTypeDefIR as polyRoutineTypeDefIR
      -- if routineTypeDefIR' <: polyRoutineTypeDefIR
      -- let routineTypeIR_b < tid_b*{tid_b <- tid_b*} , tid_hidden_b*{tid_hidden_b <- tid_hidden_b*} > = routineTypeDefIR' as polyRoutineTypeDefIR
      -- if (|tid_a*{tid_a <- tid_a*}| = |tid_b*{tid_b <- tid_b*}|)
      -- if (|tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}| = |tid_hidden_b*{tid_hidden_b <- tid_hidden_b*}|)
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids((|tid_a*{tid_a <- tid_a*}| + |tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}|))
      -- let tid_a'*{tid_a' <- tid_a'*} = tid_a*{tid_a <- tid_a*} ++ tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}
      -- let theta_a = { tid_a' : tid tid_fresh as typeIR*{tid_a' <- tid_a'*, tid_fresh <- tid_fresh*} }
      -- let routineTypeIR_a_subst = $subst_routineType(theta_a, routineTypeIR_a)
      -- let tid_b'*{tid_b' <- tid_b'*} = tid_b*{tid_b <- tid_b*} ++ tid_hidden_b*{tid_hidden_b <- tid_hidden_b*}
      -- let theta_b = { tid_b' : tid tid_fresh as typeIR*{tid_b' <- tid_b'*, tid_fresh <- tid_fresh*} }
      -- let routineTypeIR_b_subst = $subst_routineType(theta_b, routineTypeIR_b)
      -- if RoutineType_alpha: routineTypeIR_a_subst ~~ routineTypeIR_b_subst holds

;; ../../../../reference-specs/p4-concrete/2.3-compile-time-known.spectec:5:14-5:30:
syntax ctk = 
   | lctk
   | ctk
   | dyn

;; ../../../../reference-specs/p4-concrete/2.3-compile-time-known.spectec:7:1-7:30:
def $join_ctk(ctk, ctk) : ctk =

   ;; ../../../../reference-specs/p4-concrete/2.3-compile-time-known.spectec:9:1-9:33:
   clause 0(ctk, ctk') = lctk
      -- if ctk matches `LCTK`
      -- if ctk' matches `LCTK`

   ;; ../../../../reference-specs/p4-concrete/2.3-compile-time-known.spectec:10:1-10:31:
   clause 1(ctk, ctk') = ctk
      -- if ctk matches `LCTK`
      -- if ctk' matches `CTK`

   ;; ../../../../reference-specs/p4-concrete/2.3-compile-time-known.spectec:11:1-11:31:
   clause 2(ctk, ctk') = ctk
      -- if ctk matches `CTK`
      -- if ctk' matches `LCTK`

   ;; ../../../../reference-specs/p4-concrete/2.3-compile-time-known.spectec:12:1-12:30:
   clause 3(ctk, ctk') = ctk
      -- if ctk matches `CTK`
      -- if ctk' matches `CTK`

   ;; ../../../../reference-specs/p4-concrete/2.3-compile-time-known.spectec:13:1-14:15:
   clause 4(ctk_a, ctk_b) = dyn
      -- otherwise

;; ../../../../reference-specs/p4-concrete/2.3-compile-time-known.spectec:16:1-16:27:
def $joins_ctk(ctk*) : ctk =

   ;; ../../../../reference-specs/p4-concrete/2.3-compile-time-known.spectec:18:1-18:26:
   clause 0(ctk*{ctk <- ctk*}) = dyn
      -- if ctk*{ctk <- ctk*} matches []

   ;; ../../../../reference-specs/p4-concrete/2.3-compile-time-known.spectec:19:1-19:26:
   clause 1(ctk'*{ctk' <- ctk'*}) = ctk
      -- if ctk'*{ctk' <- ctk'*} matches [ _/1 ]
      -- let [ctk] = ctk'*{ctk' <- ctk'*}

   ;; ../../../../reference-specs/p4-concrete/2.3-compile-time-known.spectec:20:1-20:57:
   clause 2(ctk'*{ctk' <- ctk'*}) = $join_ctk(ctk_a, ctk_b)
      -- if ctk'*{ctk' <- ctk'*} matches _ :: _
      -- let ctk_a :: ctk*{ctk <- ctk*} = ctk'*{ctk' <- ctk'*}
      -- if ctk*{ctk <- ctk*} matches [ _/1 ]
      -- let [ctk_b] = ctk*{ctk <- ctk*}

   ;; ../../../../reference-specs/p4-concrete/2.3-compile-time-known.spectec:21:1-22:40:
   clause 3(ctk'*{ctk' <- ctk'*}) = $joins_ctk(ctk_d :: ctk_c*{ctk_c <- ctk_c*})
      -- if ctk'*{ctk' <- ctk'*} matches _ :: _
      -- let ctk_a :: ctk*{ctk <- ctk*} = ctk'*{ctk' <- ctk'*}
      -- if ctk*{ctk <- ctk*} matches _ :: _
      -- let ctk_b :: ctk_c*{ctk_c <- ctk_c*} = ctk*{ctk <- ctk*}
      -- let ctk_d = $join_ctk(ctk_a, ctk_b)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:5:1-5:21:
def $pow2(nat) : int =

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:7:1-7:25:
def $shl(int, int) : int =

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:8:1-8:25:
def $shr(int, int) : int =

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:9:1-9:36:
def $shr_arith(int, int, int) : int =

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:11:1-11:21:
def $bneg(int) : int =

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:12:1-12:26:
def $band(int, int) : int =

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:13:1-13:26:
def $bxor(int, int) : int =

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:14:1-14:25:
def $bor(int, int) : int =

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:16:1-16:33:
def $bitacc(int, int, int) : int =

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:24:1-24:28:
def $un_bnot(value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:26:1-27:22:
   clause 0(value) = w w i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w i = number
      -- let i' = $bneg(i)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:31:1-31:28:
def $un_lnot(value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:33:1-33:27:
   clause 0(value) = b ~b as value
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `B%`
      -- let b b = primitiveValue

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:37:1-37:28:
def $un_plus(value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:39:1-39:24:
   clause 0(value) = d i as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i = number

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:40:1-40:28:
   clause 1(value) = w w i as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w i = number

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:41:1-41:28:
   clause 2(value) = w s i as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w s i = number

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:45:1-45:29:
def $un_minus(value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:47:1-47:29:
   clause 0(value) = d -i as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i = number

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:48:1-49:29:
   clause 1(value) = w w i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w i = number
      -- let i' = ($pow2(w) - i)

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:50:1-51:46:
   clause 2(value) = w s i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w s i = number
      -- let i' = $to_bitstr(w as int, $to_int(w as int, -i))

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:59:1-59:36:
def $bin_plus(value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:61:1-61:45:
   clause 0(value, value') = d (i_l + i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_r = number'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:62:1-65:43:
   clause 1(value, value') = w w i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' w i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' + i_r'))

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:66:1-69:43:
   clause 2(value, value') = w s i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' s i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' + i_r'))

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:84:1-87:43:
   clause 3(value, value') = w s i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' s i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' - i_r'))

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:102:1-105:43:
   clause 4(value, value') = w s i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' s i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' * i_r'))

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:73:1-73:39:
def $bin_satplus(value, value) : value =

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:77:1-77:37:
def $bin_minus(value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:79:1-79:46:
   clause 0(value, value') = d (i_l - i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_r = number'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:80:1-83:43:
   clause 1(value, value') = w w i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' w i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' - i_r'))

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:98:1-101:43:
   clause 2(value, value') = w w i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' w i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' * i_r'))

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:91:1-91:40:
def $bin_satminus(value, value) : value =

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:95:1-95:35:
def $bin_mul(value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:97:1-97:44:
   clause 0(value, value') = d (i_l * i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_r = number'

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:109:1-109:35:
def $bin_div(value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:111:1-111:44:
   clause 0(value, value') = d (i_l / i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_r = number'

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:115:1-115:35:
def $bin_mod(value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:117:1-117:44:
   clause 0(value, value') = d (i_l \ i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_r = number'

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:121:1-121:35:
def $bin_shl(value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:123:1-123:46:
   clause 0(value, value') = d $shl(i_l, i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_r = number'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:124:1-124:50:
   clause 1(value, value') = d $shl(i_l, i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r w i_r = number'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:125:1-126:33:
   clause 2(value, value') = d $shl(i_l, i_r') as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r s i_r = number'
      -- let i_r' = $to_int(w_r as int, i_r)

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:128:1-129:49:
   clause 3(value, value') = $bin_shl(w_l w i_l as value, w_l w $to_int(w_l as int, i_r) as value)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_l w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_r = number'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:130:1-131:45:
   clause 4(value, value') = w_l w i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_l w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r w i_r = number'
      -- let i' = $to_bitstr(w_l as int, $shl(i_l, i_r))

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:132:1-134:46:
   clause 5(value, value') = w_l w i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_l w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r s i_r = number'
      -- let i_r' = $to_int(w_r as int, i_r)
      -- let i' = $to_bitstr(w_l as int, $shl(i_l, i_r'))

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:136:1-137:49:
   clause 6(value, value') = $bin_shl(w_l s i_l as value, w_l s $to_int(w_l as int, i_r) as value)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_r = number'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:138:1-140:46:
   clause 7(value, value') = w_l s i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r w i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i' = $to_bitstr(w_l as int, $shl(i_l', i_r))

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:141:1-144:47:
   clause 8(value, value') = w_l s i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r s i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_r' = $to_int(w_r as int, i_r)
      -- let i' = $to_bitstr(w_l as int, $shl(i_l', i_r'))

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:148:1-148:35:
def $bin_shr(value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:150:1-150:46:
   clause 0(value, value') = d $shr(i_l, i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_r = number'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:151:1-151:50:
   clause 1(value, value') = d $shr(i_l, i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r w i_r = number'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:152:1-153:33:
   clause 2(value, value') = d $shr(i_l, i_r') as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r s i_r = number'
      -- let i_r' = $to_int(w_r as int, i_r)

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:155:1-156:49:
   clause 3(value, value') = $bin_shr(w_l w i_l as value, w_l w $to_int(w_l as int, i_r) as value)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_l w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_r = number'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:157:1-158:45:
   clause 4(value, value') = w_l w i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_l w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r w i_r = number'
      -- let i' = $to_bitstr(w_l as int, $shr(i_l, i_r))

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:159:1-161:46:
   clause 5(value, value') = w_l w i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_l w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r s i_r = number'
      -- let i_r' = $to_int(w_r as int, i_r)
      -- let i' = $to_bitstr(w_l as int, $shr(i_l, i_r'))

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:163:1-167:34:
   clause 6(value, value') = w_l s i'' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- if (i_l' < 0 as int)
      -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:168:1-172:34:
   clause 7(value, value') = w_l s i'' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- if (i_l' >= 0 as int)
      -- let i' = $shr(i_l, i_r)
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:173:1-177:34:
   clause 8(value, value') = w_l s i'' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r w i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- if (i_l' < 0 as int)
      -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:178:1-182:34:
   clause 9(value, value') = w_l s i'' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r w i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- if (i_l' >= 0 as int)
      -- let i' = $shr(i_l, i_r)
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:183:1-188:34:
   clause 10(value, value') = w_l s i'' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r s i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_r' = $to_int(w_r as int, i_r)
      -- if (i_l' < 0 as int)
      -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:189:1-194:34:
   clause 11(value, value') = w_l s i'' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r s i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_r' = $to_int(w_r as int, i_r)
      -- if (i_l' >= 0 as int)
      -- let i' = $shr(i_l, i_r)
      -- let i'' = $to_bitstr(w_l as int, i')

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:198:1-198:33:
def $bin_le(value, value) : bool =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:200:1-200:42:
   clause 0(value, value') = (i_l <= i_r)
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_r = number'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:201:1-201:46:
   clause 1(value, value') = (i_l <= i_r)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' w i_r = number'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:202:1-204:31:
   clause 2(value, value') = (i_l' <= i_r')
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' s i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:208:1-208:33:
def $bin_ge(value, value) : bool =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:210:1-210:42:
   clause 0(value, value') = (i_l >= i_r)
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_r = number'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:211:1-211:46:
   clause 1(value, value') = (i_l >= i_r)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' w i_r = number'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:212:1-214:31:
   clause 2(value, value') = (i_l' >= i_r')
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' s i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:218:1-218:33:
def $bin_lt(value, value) : bool =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:220:1-220:41:
   clause 0(value, value') = (i_l < i_r)
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_r = number'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:221:1-221:45:
   clause 1(value, value') = (i_l < i_r)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' w i_r = number'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:222:1-224:31:
   clause 2(value, value') = (i_l' < i_r')
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' s i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:228:1-228:33:
def $bin_gt(value, value) : bool =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:230:1-230:41:
   clause 0(value, value') = (i_l > i_r)
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_r = number'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:231:1-231:45:
   clause 1(value, value') = (i_l > i_r)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' w i_r = number'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:232:1-234:31:
   clause 2(value, value') = (i_l' > i_r')
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' s i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:238:1-238:33:
def $bin_eq(value, value) : bool =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:242:1-243:42:
   clause 0(value, value') = (primitiveValue_a = primitiveValue_b)
      -- if value <: primitiveValue
      -- let primitiveValue_a = value as primitiveValue
      -- if value' <: primitiveValue
      -- let primitiveValue_b = value' as primitiveValue

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:245:1-245:40:
   clause 1(value, value') = (i_a = i_b)
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i_a = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let d i_b = number'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:246:1-246:63:
   clause 2(value, value') = ((w_a = w_b) /\ (i_a = i_b))
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_a w i_a = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_b w i_b = number'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:247:1-247:63:
   clause 3(value, value') = ((w_a = w_b) /\ (i_a = i_b))
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_a s i_a = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_b s i_b = number'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:248:1-248:73:
   clause 4(value, value') = ((w_a = w_b) /\ (i_a = i_b))
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%V%#%`
      -- let w_a v i_a # _nat = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%V%#%`
      -- let w_b v i_b # _nat' = numberValue'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:250:1-251:33:
   clause 5(value, value') = $bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*})
      -- if value <: listValue
      -- let [ value_a*{value_a <- value_a*} ] = value as listValue
      -- if value' <: listValue
      -- let [ value_b*{value_b <- value_b*} ] = value' as listValue

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:252:1-253:33:
   clause 6(value, value') = $bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*})
      -- if value <: tupleValue
      -- let ( value_a*{value_a <- value_a*} ) = value as tupleValue
      -- if value' <: tupleValue
      -- let ( value_b*{value_b <- value_b*} ) = value' as tupleValue

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:254:1-255:52:
   clause 7(value, value') = ($bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*}) /\ (n_s_a = n_s_b))
      -- if value <: headerStackValue
      -- let [ value_a*{value_a <- value_a*} #( _nat ; n_s_a )] = value as headerStackValue
      -- if value' <: headerStackValue
      -- let [ value_b*{value_b <- value_b*} #( _nat' ; n_s_b )] = value' as headerStackValue

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:256:1-261:67:
   clause 8(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
      -- if value <: structValue
      -- let struct tid_a { value_f_a id_f_a ;*{id_f_a <- id_f_a*, value_f_a <- value_f_a*} } = value as structValue
      -- if value' <: structValue
      -- let struct tid_b { value_f_b id_f_b ;*{id_f_b <- id_f_b*, value_f_b <- value_f_b*} } = value' as structValue

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:262:1-267:67:
   clause 9(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
      -- if value <: headerValue
      -- let header tid_a { value_f_a id_f_a ;*{id_f_a <- id_f_a*, value_f_a <- value_f_a*} } = value as headerValue
      -- if value' <: headerValue
      -- let header tid_b { value_f_b id_f_b ;*{id_f_b <- id_f_b*, value_f_b <- value_f_b*} } = value' as headerValue

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:268:1-273:67:
   clause 10(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
      -- if value <: headerUnionValue
      -- let header_union tid_a { value_f_a id_f_a ;*{id_f_a <- id_f_a*, value_f_a <- value_f_a*} } = value as headerUnionValue
      -- if value' <: headerUnionValue
      -- let header_union tid_b { value_f_b id_f_b ;*{id_f_b <- id_f_b*, value_f_b <- value_f_b*} } = value' as headerUnionValue

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:274:1-275:41:
   clause 11(value, value') = ((tid_a = tid_b) /\ (id_f_a = id_f_b))
      -- if value <: enumValue
      -- let enumValue = value as enumValue
      -- if enumValue matches `%.%`
      -- let tid_a . id_f_a = enumValue
      -- if value' <: enumValue
      -- let enumValue' = value' as enumValue
      -- if enumValue' matches `%.%`
      -- let tid_b . id_f_b = enumValue'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:276:1-277:74:
   clause 12(value, value') = (((tid_a = tid_b) /\ (id_f_a = id_f_b)) /\ $bin_eq(value_f_a, value_f_b))
      -- if value <: enumValue
      -- let enumValue = value as enumValue
      -- if enumValue matches `%.%#%`
      -- let tid_a . id_f_a # value_f_a = enumValue
      -- if value' <: enumValue
      -- let enumValue' = value' as enumValue
      -- if enumValue' matches `%.%#%`
      -- let tid_b . id_f_b # value_f_b = enumValue'

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:278:1-278:31:
   clause 13(value, value') = true
      -- if value <: invalidHeaderValue
      -- let invalidHeaderValue = value as invalidHeaderValue
      -- if (invalidHeaderValue = {#})
      -- if value' <: invalidHeaderValue
      -- let invalidHeaderValue' = value' as invalidHeaderValue
      -- if (invalidHeaderValue' = {#})

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:239:1-239:36:
def $bin_eqs(value*, value*) : bool =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:280:1-280:30:
   clause 0(value*{value <- value*}, value'*{value' <- value'*}) = true
      -- if value*{value <- value*} matches []
      -- if value'*{value' <- value'*} matches []

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:281:1-281:34:
   clause 1(value*{value <- value*}, value'*{value' <- value'*}) = false
      -- if value*{value <- value*} matches []
      -- if value'*{value' <- value'*} matches _ :: _
      -- let _value :: _value'*{_value' <- _value'*} = value'*{value' <- value'*}

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:282:1-282:34:
   clause 2(value*{value <- value*}, value'*{value' <- value'*}) = false
      -- if value*{value <- value*} matches _ :: _
      -- let _value :: _value'*{_value' <- _value'*} = value*{value <- value*}
      -- if value'*{value' <- value'*} matches []

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:283:1-284:70:
   clause 3(value*{value <- value*}, value'*{value' <- value'*}) = ($bin_eq(value_a_h, value_b_h) /\ $bin_eqs(value_a_t*{value_a_t <- value_a_t*}, value_b_t*{value_b_t <- value_b_t*}))
      -- if value*{value <- value*} matches _ :: _
      -- let value_a_h :: value_a_t*{value_a_t <- value_a_t*} = value*{value <- value*}
      -- if value'*{value' <- value'*} matches _ :: _
      -- let value_b_h :: value_b_t*{value_b_t <- value_b_t*} = value'*{value' <- value'*}

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:240:1-240:55:
def $bin_eqs_fields((value, id)*, (value, id)*) : bool =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:286:1-286:37:
   clause 0((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = true
      -- if (value, id)*{(value, id) <- (value, id)*} matches []
      -- if (value, id)'*{(value, id)' <- (value, id)'*} matches []

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:287:1-287:41:
   clause 1((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = false
      -- if (value, id)*{(value, id) <- (value, id)*} matches []
      -- if (value, id)'*{(value, id)' <- (value, id)'*} matches _ :: _
      -- let _(value, id) :: _(value, id)'*{_(value, id)' <- _(value, id)'*} = (value, id)'*{(value, id)' <- (value, id)'*}

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:288:1-288:41:
   clause 2((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = false
      -- if (value, id)*{(value, id) <- (value, id)*} matches _ :: _
      -- let _(value, id) :: _(value, id)'*{_(value, id)' <- _(value, id)'*} = (value, id)*{(value, id) <- (value, id)*}
      -- if (value, id)'*{(value, id)' <- (value, id)'*} matches []

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:289:1-293:67:
   clause 3((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = (((id_a_h = id_b_h) /\ $bin_eq(value_a_h, value_b_h)) /\ $bin_eqs_fields((value_a_t, id_a_t)*{id_a_t <- id_a_t*, value_a_t <- value_a_t*}, (value_b_t, id_b_t)*{id_b_t <- id_b_t*, value_b_t <- value_b_t*}))
      -- if (value, id)*{(value, id) <- (value, id)*} matches _ :: _
      -- let (value_a_h, id_a_h) :: (value_a_t, id_a_t)*{id_a_t <- id_a_t*, value_a_t <- value_a_t*} = (value, id)*{(value, id) <- (value, id)*}
      -- if (value, id)'*{(value, id)' <- (value, id)'*} matches _ :: _
      -- let (value_b_h, id_b_h) :: (value_b_t, id_b_t)*{id_b_t <- id_b_t*, value_b_t <- value_b_t*} = (value, id)'*{(value, id)' <- (value, id)'*}

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:297:1-297:33:
def $bin_ne(value, value) : bool =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:299:1-299:59:
   clause 0(value_l, value_r) = ~$bin_eq(value_l, value_r)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:303:1-303:36:
def $bin_band(value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:305:1-306:44:
   clause 0(value, value') = w w i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' w i_r = number'
      -- if (w = w')
      -- let i' = $to_bitstr(w as int, $band(i_l, i_r))

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:308:1-311:46:
   clause 1(value, value') = w s i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' s i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, $band(i_l', i_r'))

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:315:1-315:36:
def $bin_bxor(value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:317:1-318:44:
   clause 0(value, value') = w w i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' w i_r = number'
      -- if (w = w')
      -- let i' = $to_bitstr(w as int, $bxor(i_l, i_r))

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:320:1-323:46:
   clause 1(value, value') = w s i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' s i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, $bxor(i_l', i_r'))

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:327:1-327:35:
def $bin_bor(value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:329:1-330:43:
   clause 0(value, value') = w w i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' w i_r = number'
      -- if (w = w')
      -- let i' = $to_bitstr(w as int, $bor(i_l, i_r))

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:332:1-335:45:
   clause 1(value, value') = w s i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' s i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, $bor(i_l', i_r'))

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:339:1-339:38:
def $bin_concat(value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:341:1-345:35:
   clause 0(value, value') = w w i'' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_l w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r w i_r = number'
      -- let i_l' = $shl(i_l, w_r as int)
      -- let i_l'' = (i_l' + i_r)
      -- let w = (w_l + w_r)
      -- let i'' = $to_bitstr(w as int, i_l'')

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:346:1-350:35:
   clause 1(value, value') = w w i'' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_l w i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r s i_r = number'
      -- let i_l' = $shl(i_l, w_r as int)
      -- let i_l'' = (i_l' + i_r)
      -- let w = (w_l + w_r)
      -- let i'' = $to_bitstr(w as int, i_l'')

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:352:1-357:37:
   clause 2(value, value') = w s i''' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r w i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_l'' = $shl(i_l', w_r as int)
      -- let i_l''' = (i_l'' + i_r)
      -- let w = (w_l + w_r)
      -- let i''' = $to_bitstr(w as int, i_l''')

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:358:1-363:37:
   clause 3(value, value') = w s i''' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l s i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r s i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_l'' = $shl(i_l', w_r as int)
      -- let i_l''' = (i_l'' + i_r)
      -- let w = (w_l + w_r)
      -- let i''' = $to_bitstr(w as int, i_l''')

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:367:1-367:36:
def $bin_land(value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:369:1-369:45:
   clause 0(value, value') = b (b_l /\ b_r) as value
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `B%`
      -- let b b_l = primitiveValue
      -- if value' <: primitiveValue
      -- let primitiveValue' = value' as primitiveValue
      -- if primitiveValue' matches `B%`
      -- let b b_r = primitiveValue'

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:373:1-373:35:
def $bin_lor(value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:375:1-375:44:
   clause 0(value, value') = b (b_l \/ b_r) as value
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `B%`
      -- let b b_l = primitiveValue
      -- if value' <: primitiveValue
      -- let primitiveValue' = value' as primitiveValue
      -- if primitiveValue' matches `B%`
      -- let b b_r = primitiveValue'

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:381:1-381:36:
def $cast_op(typeIR, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:398:1-398:50:
   clause 0(typeIR, value) = $cast_bool(typeIR, b)
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `B%`
      -- let b b = primitiveValue

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:414:1-414:52:
   clause 1(typeIR, value) = $cast_arbint(typeIR, i)
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let d i = number

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:432:1-432:57:
   clause 2(typeIR, value) = $cast_fixbit(typeIR, w, i)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w i = number

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:449:1-449:57:
   clause 3(typeIR, value) = $cast_fixint(typeIR, w, i)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w s i = number

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:462:1-463:48:
   clause 4(typeIR, value) = $cast_struct(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
      -- if value <: structValue
      -- let struct tid { value_f id_f ;*{id_f <- id_f*, value_f <- value_f*} } = value as structValue

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:476:1-477:48:
   clause 5(typeIR, value) = $cast_header(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
      -- if value <: headerValue
      -- let header tid { value_f id_f ;*{id_f <- id_f*, value_f <- value_f*} } = value as headerValue

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:481:1-481:64:
   clause 6(typeIR, value') = $cast_op(typeIR, value)
      -- if value' <: enumValue
      -- let enumValue = value' as enumValue
      -- if enumValue matches `%.%#%`
      -- let _tid . _id # value = enumValue

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:510:1-510:71:
   clause 7(typeIR, value') = $cast_sequence(typeIR, value*{value <- value*})
      -- if value' <: sequenceValue
      -- let sequenceValue = value' as sequenceValue
      -- if sequenceValue matches `SEQ(%)`
      -- let seq( value*{value <- value*} ) = sequenceValue

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:538:1-539:39:
   clause 8(typeIR, value') = $cast_record(typeIR, (value, id)*{id <- id*, value <- value*})
      -- if value' <: recordValue
      -- let recordValue = value' as recordValue
      -- if recordValue matches `RECORD{%}`
      -- let record{ value id ;*{id <- id*, value <- value*} } = recordValue

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:545:1-545:49:
   clause 9(typeIR, value) = $default(typeIR)
      -- if value <: defaultValue
      -- let defaultValue = value as defaultValue
      -- if (defaultValue = default)

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:582:1-583:39:
   clause 10(typeIR, value') = $cast_set_singleton(typeIR, value)
      -- if value' <: setValue
      -- let setValue = value' as setValue
      -- if setValue matches `SET{%}`
      -- let set{ value } = setValue

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:584:1-585:45:
   clause 11(typeIR, value) = $cast_set_mask(typeIR, value_b, value_m)
      -- if value <: setValue
      -- let setValue = value as setValue
      -- if setValue matches `SET{%&&&%}`
      -- let set{ value_b &&& value_m } = setValue

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:586:1-587:46:
   clause 12(typeIR, value) = $cast_set_range(typeIR, value_l, value_u)
      -- if value <: setValue
      -- let setValue = value as setValue
      -- if setValue matches `SET{%..%}`
      -- let set{ value_l .. value_u } = setValue

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:383:1-383:29:
def $default(typeIR) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:594:1-594:49:
   clause 0(typeIR) = $default'($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:384:1-384:30:
def $default'(typeIR) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:596:1-596:30:
   clause 0(typeIR) = b false as value
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:597:1-597:42:
   clause 1(typeIR) = error. "NoError" as value
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ERROR`

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:598:1-599:24:
   clause 2(typeIR) = " text_empty " as value
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `STRING`
      -- let text_empty = ""

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:601:1-601:25:
   clause 3(typeIR) = d 0 as int as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:602:1-602:34:
   clause 4(typeIR) = w w 0 as int as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:603:1-603:34:
   clause 5(typeIR) = w s 0 as int as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:604:1-604:42:
   clause 6(typeIR) = w v 0 as int # 0 as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let varbit< w > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:606:1-606:59:
   clause 7(typeIR') = [ $default(typeIR)*{typeIR <- typeIR*} ] as value
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:608:1-609:56:
   clause 8(typeIR') = [ value*{value <- value*} #( 0 ; n_s )] as value
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ n_s ] = typeIR' as headerStackTypeIR
      -- let value*{value <- value*} = $repeat_<value>($default(typeIR), n_s)

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:611:1-612:50:
   clause 9(typeIR) = struct tid { $default(typeIR_f) id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } as value
      -- if typeIR <: structTypeIR
      -- let struct tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as structTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:614:1-615:50:
   clause 10(typeIR) = header tid { $default(typeIR_f) id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } as value
      -- if typeIR <: headerTypeIR
      -- let header tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as headerTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:617:1-618:56:
   clause 11(typeIR) = header_union tid { $default(typeIR_f) id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } as value
      -- if typeIR <: headerUnionTypeIR
      -- let header_union tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as headerUnionTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:620:1-620:57:
   clause 12(typeIR) = tid . id_f_h as value
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum tid { id*{id <- id*} } = enumTypeIR
      -- if id*{id <- id*} matches _ :: _
      -- let id_f_h :: _id*{_id <- _id*} = id*{id <- id*}

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:622:1-625:67:
   clause 13(typeIR') = tid . id_zero # value_zero as value
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum tid # typeIR { id_f = value_f ;*{id_f <- id_f*, value_f <- value_f*} } = enumTypeIR
      -- let value_zero = $cast_arbint(typeIR, 0 as int)
      -- let id?{id <- id?} = $assoc_<value, id>(value_zero, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
      -- if id?{id <- id?} matches (_)
      -- let ?(id_zero) = id?{id <- id?}

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:627:1-631:34:
   clause 14(typeIR') = tid . id_zero # value_zero as value
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum tid # typeIR { id_f = value_f ;*{id_f <- id_f*, value_f <- value_f*} } = enumTypeIR
      -- let value_zero = $cast_arbint(typeIR, 0 as int)
      -- if (?() = $assoc_<value, id>(value_zero, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}))
      -- let id_zero = "__UNSPECIFIED"

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:388:1-388:37:
def $cast_bool(typeIR, bool) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:391:1-391:59:
   clause 0(typeIR, b) = $cast_bool'($canon(typeIR), b)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:389:1-389:38:
def $cast_bool'(typeIR, bool) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:393:1-393:31:
   clause 0(typeIR, b) = b b as value
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:394:1-394:42:
   clause 1(typeIR, bool) = w w 1 as int as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w > = numberTypeIR
      -- if (bool = true)

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:395:1-395:43:
   clause 2(typeIR, bool) = w w 0 as int as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w > = numberTypeIR
      -- if (bool = false)

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:396:1-396:58:
   clause 3(typeIR', b) = $cast_bool(typeIR, b)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid typeIR = aliasTypeIR

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:402:1-402:38:
def $cast_arbint(typeIR, int) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:405:1-405:63:
   clause 0(typeIR, i) = $cast_arbint'($canon(typeIR), i)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:403:1-403:39:
def $cast_arbint'(typeIR, int) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:407:1-407:39:
   clause 0(typeIR, i) = b (i = 0 as int) as value
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:408:1-408:32:
   clause 1(typeIR, i) = d i as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:409:1-409:58:
   clause 2(typeIR, i) = w w $to_bitstr(w as int, i) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:410:1-410:58:
   clause 3(typeIR, i) = w s $to_bitstr(w as int, i) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:411:1-411:62:
   clause 4(typeIR', i) = $cast_arbint(typeIR, i)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:412:1-412:73:
   clause 5(typeIR'', i) = set{ $cast_arbint(typeIR, i) } as value
      -- if typeIR'' <: setTypeIR
      -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:418:1-418:43:
def $cast_fixbit(typeIR, nat, int) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:421:1-421:69:
   clause 0(typeIR, w, i) = $cast_fixbit'($canon(typeIR), w, i)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:419:1-419:44:
def $cast_fixbit'(typeIR, nat, int) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:423:1-423:42:
   clause 0(typeIR, w, i) = b (i = 1 as int) as value
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:424:1-424:35:
   clause 1(typeIR, _nat, i) = d i as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:425:1-426:33:
   clause 2(typeIR, _nat, i) = w_to w i' as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w_to > = numberTypeIR
      -- let i' = $to_bitstr(w_to as int, i)

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:427:1-428:33:
   clause 3(typeIR, _nat, i) = w_to s i' as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w_to > = numberTypeIR
      -- let i' = $to_bitstr(w_to as int, i)

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:429:1-429:68:
   clause 4(typeIR', w, i) = $cast_fixbit(typeIR, w, i)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:430:1-430:79:
   clause 5(typeIR'', w, i) = set{ $cast_fixbit(typeIR, w, i) } as value
      -- if typeIR'' <: setTypeIR
      -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:436:1-436:43:
def $cast_fixint(typeIR, nat, int) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:439:1-439:69:
   clause 0(typeIR, w, i) = $cast_fixint'($canon(typeIR), w, i)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:437:1-437:44:
def $cast_fixint'(typeIR, nat, int) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:441:1-441:47:
   clause 0(typeIR, w, i) = d $to_int(w as int, i) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:442:1-443:50:
   clause 1(typeIR, w_from, i) = w_to w i' as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w_to > = numberTypeIR
      -- let i' = $to_bitstr(w_to as int, $to_int(w_from as int, i))

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:444:1-445:50:
   clause 2(typeIR, w_from, i) = w_to s i' as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w_to > = numberTypeIR
      -- let i' = $to_bitstr(w_to as int, $to_int(w_from as int, i))

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:446:1-446:68:
   clause 3(typeIR', w, i) = $cast_fixint(typeIR, w, i)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:447:1-447:79:
   clause 4(typeIR'', w, i) = set{ $cast_fixint(typeIR, w, i) } as value
      -- if typeIR'' <: setTypeIR
      -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:453:1-453:52:
def $cast_struct(typeIR, tid, (value, id)*) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:456:1-457:57:
   clause 0(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = $cast_struct'($canon(typeIR), tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:454:1-454:53:
def $cast_struct'(typeIR, tid, (value, id)*) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:459:1-460:39:
   clause 0(typeIR, tid', (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = struct tid { value_f id_f ;*{id_f <- id_f*, value_f <- value_f*} } as value
      -- if typeIR <: structTypeIR
      -- let struct tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as structTypeIR
      -- if (tid = tid')

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:467:1-467:52:
def $cast_header(typeIR, tid, (value, id)*) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:470:1-471:57:
   clause 0(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = $cast_header'($canon(typeIR), tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:468:1-468:53:
def $cast_header'(typeIR, tid, (value, id)*) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:473:1-474:39:
   clause 0(typeIR, tid', (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = header tid { value_f id_f ;*{id_f <- id_f*, value_f <- value_f*} } as value
      -- if typeIR <: headerTypeIR
      -- let header tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR
      -- if (tid = tid')

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:485:1-485:43:
def $cast_sequence(typeIR, value*) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:488:1-489:44:
   clause 0(typeIR, value*{value <- value*}) = $cast_sequence'($canon(typeIR), value*{value <- value*})

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:486:1-486:44:
def $cast_sequence'(typeIR, value*) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:491:1-492:34:
   clause 0(typeIR', value*{value <- value*}) = [ $cast_op(typeIR, value)*{value <- value*} ] as value
      -- if typeIR' <: listTypeIR
      -- let list< typeIR > = typeIR' as listTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:494:1-495:34:
   clause 1(typeIR', value*{value <- value*}) = ( $cast_op(typeIR, value)*{typeIR <- typeIR*, value <- value*} ) as value
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:497:1-500:25:
   clause 2(typeIR', value*{value <- value*}) = [ value_cast*{value_cast <- value_cast*} #( n_idx ; n_s )] as value
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ n_s ] = typeIR' as headerStackTypeIR
      -- (let value_cast = $cast_op(typeIR, value))*{value <- value*, value_cast <- value_cast*}
      -- let n_idx = |value*{value <- value*}|

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:502:1-504:50:
   clause 3(typeIR, value*{value <- value*}) = struct tid { value_cast id_f ;*{id_f <- id_f*, value_cast <- value_cast*} } as value
      -- if typeIR <: structTypeIR
      -- let struct tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as structTypeIR
      -- (let value_cast = $cast_op(typeIR_f, value))*{typeIR_f <- typeIR_f*, value <- value*, value_cast <- value_cast*}

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:506:1-508:50:
   clause 4(typeIR, value*{value <- value*}) = header tid { value_cast id_f ;*{id_f <- id_f*, value_cast <- value_cast*} } as value
      -- if typeIR <: headerTypeIR
      -- let header tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as headerTypeIR
      -- (let value_cast = $cast_op(typeIR_f, value))*{typeIR_f <- typeIR_f*, value <- value*, value_cast <- value_cast*}

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:516:1-516:47:
def $cast_record(typeIR, (value, id)*) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:519:1-520:48:
   clause 0(typeIR, (value, id)*{id <- id*, value <- value*}) = $cast_record'($canon(typeIR), (value, id)*{id <- id*, value <- value*})

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:517:1-517:48:
def $cast_record'(typeIR, (value, id)*) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:522:1-528:57:
   clause 0(typeIR, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = struct tid { value_f_cast id_f ;*{id_f <- id_f*, value_f_cast <- value_f_cast*} } as value
      -- if typeIR <: structTypeIR
      -- let struct tid { typeIR_t_f id_t_f ;*{id_t_f <- id_t_f*, typeIR_t_f <- typeIR_t_f*} } = typeIR as structTypeIR
      -- (let value?{value <- value?} = $find_map<id, value>({ id_f : value_f*{id_f <- id_f*, value_f <- value_f*} }, id_t_f))*{id_t_f <- id_t_f*, value? <- value?*}
      -- (if value?{value <- value?} matches (_))*{value? <- value?*}
      -- (let ?(value_f') = value?{value <- value?})*{value? <- value?*, value_f' <- value_f'*}
      -- (let value_f_cast = $cast_op(typeIR_t_f, value_f'))*{typeIR_t_f <- typeIR_t_f*, value_f' <- value_f'*, value_f_cast <- value_f_cast*}

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:530:1-536:57:
   clause 1(typeIR, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = header tid { value_f_cast id_f ;*{id_f <- id_f*, value_f_cast <- value_f_cast*} } as value
      -- if typeIR <: headerTypeIR
      -- let header tid { typeIR_t_f id_t_f ;*{id_t_f <- id_t_f*, typeIR_t_f <- typeIR_t_f*} } = typeIR as headerTypeIR
      -- (let value?{value <- value?} = $find_map<id, value>({ id_f : value_f*{id_f <- id_f*, value_f <- value_f*} }, id_t_f))*{id_t_f <- id_t_f*, value? <- value?*}
      -- (if value?{value <- value?} matches (_))*{value? <- value?*}
      -- (let ?(value_f') = value?{value <- value?})*{value? <- value?*, value_f' <- value_f'*}
      -- (let value_f_cast = $cast_op(typeIR_t_f, value_f'))*{typeIR_t_f <- typeIR_t_f*, value_f' <- value_f'*, value_f_cast <- value_f_cast*}

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:551:1-551:47:
def $cast_set_singleton(typeIR, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:554:1-555:48:
   clause 0(typeIR, value) = $cast_set_singleton'($canon(typeIR), value)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:552:1-552:48:
def $cast_set_singleton'(typeIR, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:557:1-558:37:
   clause 0(typeIR'', value) = set{ $cast_op(typeIR, value) } as value
      -- if typeIR'' <: setTypeIR
      -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:560:1-560:49:
def $cast_set_mask(typeIR, value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:563:1-564:54:
   clause 0(typeIR, value_b, value_m) = $cast_set_mask'($canon(typeIR), value_b, value_m)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:561:1-561:50:
def $cast_set_mask'(typeIR, value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:566:1-569:49:
   clause 0(typeIR'', value_b, value_m) = set{ value_b_cast &&& value_m_cast } as value
      -- if typeIR'' <: setTypeIR
      -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
      -- let value_b_cast = $cast_op(typeIR, value_b)
      -- let value_m_cast = $cast_op(typeIR, value_m)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:571:1-571:50:
def $cast_set_range(typeIR, value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:574:1-575:55:
   clause 0(typeIR, value_l, value_u) = $cast_set_range'($canon(typeIR), value_l, value_u)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:572:1-572:51:
def $cast_set_range'(typeIR, value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:577:1-580:49:
   clause 0(typeIR'', value_l, value_u) = set{ value_l_cast .. value_u_cast } as value
      -- if typeIR'' <: setTypeIR
      -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
      -- let value_l_cast = $cast_op(typeIR, value_l)
      -- let value_u_cast = $cast_op(typeIR, value_u)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:637:1-637:44:
def $bitacc_op(value, value, value) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:639:1-644:35:
   clause 0(value_b, value_h, value_l) = w w i as value
      -- let i_b = $to_number(value_b)
      -- let i_h = $to_number(value_h)
      -- let i_l = $to_number(value_l)
      -- let int = ((i_h + 1 as int) - i_l)
      -- if int <: nat
      -- let w = int as nat
      -- let i = $bitacc(i_b, i_h, i_l)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:650:1-650:32:
def $sizeof(typeIR, id) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:681:1-681:69:
   clause 0(typeIR, text) = $sizeof_minSizeInBits(typeIR)
      -- if (text = "minSizeInBits")

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:688:1-688:71:
   clause 1(typeIR, text) = $sizeof_minSizeInBytes(typeIR)
      -- if (text = "minSizeInBytes")

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:707:1-707:69:
   clause 2(typeIR, text) = $sizeof_maxSizeInBits(typeIR)
      -- if (text = "maxSizeInBits")

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:714:1-714:71:
   clause 3(typeIR, text) = $sizeof_maxSizeInBytes(typeIR)
      -- if (text = "maxSizeInBytes")

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:652:1-652:42:
def $sizeof_minSizeInBits(typeIR) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:666:1-666:69:
   clause 0(typeIR) = d $sizeof_minSizeInBits'(typeIR) as int as value

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:653:1-653:41:
def $sizeof_minSizeInBits'(typeIR) : nat =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:667:1-667:77:
   clause 0(typeIR) = $sizeof_minSizeInBits''($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:654:1-654:42:
def $sizeof_minSizeInBits''(typeIR) : nat =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:669:1-669:38:
   clause 0(typeIR) = 1
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:670:1-670:44:
   clause 1(typeIR) = w
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:671:1-671:44:
   clause 2(typeIR) = w
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:672:1-672:47:
   clause 3(typeIR) = 0
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let varbit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:673:1-673:76:
   clause 4(typeIR') = $sizeof_minSizeInBits'(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:674:1-674:86:
   clause 5(typeIR') = $sizeof_minSizeInBits'(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:675:1-675:88:
   clause 6(typeIR') = $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:676:1-676:93:
   clause 7(typeIR') = ($sizeof_minSizeInBits'(typeIR) * n_size)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:677:1-677:98:
   clause 8(typeIR') = $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:678:1-678:98:
   clause 9(typeIR') = $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerTypeIR
      -- let header _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:679:1-679:104:
   clause 10(typeIR') = $min($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerUnionTypeIR
      -- let header_union _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerUnionTypeIR

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:656:1-656:43:
def $sizeof_minSizeInBytes(typeIR) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:685:1-686:48:
   clause 0(typeIR) = d (n_size / 8) as int as value
      -- let n_size = $sizeof_minSizeInBits'(typeIR)

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:658:1-658:42:
def $sizeof_maxSizeInBits(typeIR) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:692:1-692:69:
   clause 0(typeIR) = d $sizeof_maxSizeInBits'(typeIR) as int as value

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:659:1-659:41:
def $sizeof_maxSizeInBits'(typeIR) : nat =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:693:1-693:77:
   clause 0(typeIR) = $sizeof_maxSizeInBits''($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:660:1-660:42:
def $sizeof_maxSizeInBits''(typeIR) : nat =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:695:1-695:38:
   clause 0(typeIR) = 1
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:696:1-696:44:
   clause 1(typeIR) = w
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:697:1-697:44:
   clause 2(typeIR) = w
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:698:1-698:47:
   clause 3(typeIR) = w
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let varbit< w > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:699:1-699:76:
   clause 4(typeIR') = $sizeof_maxSizeInBits'(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:700:1-700:86:
   clause 5(typeIR') = $sizeof_maxSizeInBits'(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:701:1-701:88:
   clause 6(typeIR') = $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:702:1-702:93:
   clause 7(typeIR') = ($sizeof_maxSizeInBits'(typeIR) * n_size)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:703:1-703:98:
   clause 8(typeIR') = $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:704:1-704:98:
   clause 9(typeIR') = $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerTypeIR
      -- let header _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerTypeIR

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:705:1-705:104:
   clause 10(typeIR') = $max($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerUnionTypeIR
      -- let header_union _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerUnionTypeIR

;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:662:1-662:43:
def $sizeof_maxSizeInBytes(typeIR) : value =

   ;; ../../../../reference-specs/p4-concrete/3-numerics.spectec:711:1-712:48:
   clause 0(typeIR) = d (n_size / 8) as int as value
      -- let n_size = $sizeof_maxSizeInBits'(typeIR)

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:6:1-7:14:
syntax prefixedNameIR = 
   | ` nameIR
   | . nameIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:9:1-9:63:
def $prefixedNonTypeName(prefixedNonTypeName) : prefixedNameIR =

   ;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:10:1-10:62:
   clause 0(prefixedNonTypeName) = ` $name(nonTypeName as name)
      -- if prefixedNonTypeName <: nonTypeName
      -- let nonTypeName = prefixedNonTypeName as nonTypeName

   ;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:11:1-11:69:
   clause 1(prefixedNonTypeName) = . $name(nonTypeName as name)
      -- if prefixedNonTypeName matches ``ID.%`
      -- let . nonTypeName = prefixedNonTypeName

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:13:1-13:57:
def $prefixedTypeName(prefixedTypeName) : prefixedNameIR =

   ;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:14:1-14:53:
   clause 0(prefixedTypeName) = ` $name(typeName as name)
      -- if prefixedTypeName <: typeName
      -- let typeName = prefixedTypeName as typeName

   ;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:15:1-15:61:
   clause 1(prefixedTypeName) = . $name(typeName as name)
      -- if prefixedTypeName matches ``TID.%`
      -- let . typeName = prefixedTypeName

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:17:1-17:53:
def $flatten_prefixedNameIR(prefixedNameIR) : nameIR =

   ;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:18:1-18:48:
   clause 0(prefixedNameIR) = nameIR
      -- if prefixedNameIR matches ``%`
      -- let ` nameIR = prefixedNameIR

   ;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:19:1-19:55:
   clause 1(prefixedNameIR) = "." ++ nameIR
      -- if prefixedNameIR matches `.%`
      -- let . nameIR = prefixedNameIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:21:21-21:28:
syntax nameListIR = nameIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:27:26-27:29:
syntax typeParameterIR = tid

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:29:30-29:46:
syntax typeParameterListIR = typeParameterIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:38:3-38:66:
syntax parameterIR = 
   | annotationList direction typeIR nameIR constantInitializerOptIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:40:26-40:38:
syntax parameterListIR = parameterIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:46:33-46:44:
syntax constructorParameterIR = parameterIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:48:37-48:49:
syntax constructorParameterListIR = parameterIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:56:28-56:55:
syntax namedExpressionIR = 
   | nameIR = typedExpressionIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:58:32-58:50:
syntax namedExpressionListIR = namedExpressionIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:68:30-68:47:
syntax literalExpressionIR = literalExpression

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:74:32-74:46:
syntax referenceExpressionIR = prefixedNameIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:80:30-80:47:
syntax defaultExpressionIR = defaultExpression

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:86:28-86:50:
syntax unaryExpressionIR = 
   | unop typedExpressionIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:89:3-89:44:
syntax binaryExpressionIR = 
   | typedExpressionIR binop typedExpressionIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:92:3-92:62:
syntax ternaryExpressionIR = 
   | typedExpressionIR ? typedExpressionIR : typedExpressionIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:98:27-98:56:
syntax castExpressionIR = 
   | ( typeIR ) typedExpressionIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:107:1-111:46:
syntax dataExpressionIR = 
   | {#}
   | seq{ typedExpressionListIR }
   | seq{ typedExpressionListIR ,...}
   | record{ namedExpressionListIR }
   | record{ namedExpressionListIR ,...}

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:120:3-120:18:
syntax errorAccessExpressionIR = 
   | error. nameIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:123:3-123:31:
syntax memberAccessExpressionIR = 
   | memberAccessBaseIR . nameIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:126:1-127:66:
syntax indexAccessExpressionIR = 
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:130:1-132:28:
syntax accessExpressionIR = 
   | error. nameIR
   | memberAccessBaseIR . nameIR
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:143:1-146:25:
syntax routineTargetIR = 
   | ` nameIR
   | . nameIR
   | typedExpressionIR . nameIR
   | type prefixedNameIR . nameIR
   | ( routineTargetIR )

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:148:30-148:68:
syntax constructorTargetIR = 
   | prefixedNameIR < typeArgumentListIR >

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:151:1-152:64:
syntax callExpressionIR = 
   | constructorTargetIR ( argumentListIR )
   | routineTargetIR < typeArgumentListIR >( argumentListIR )

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:158:36-158:58:
syntax parenthesizedExpressionIR = 
   | ( typedExpressionIR )

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:165:1-175:30:
syntax expressionIR = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | ` nameIR
   | . nameIR
   | ...
   | unop typedExpressionIR
   | typedExpressionIR binop typedExpressionIR
   | typedExpressionIR ? typedExpressionIR : typedExpressionIR
   | ( typeIR ) typedExpressionIR
   | {#}
   | seq{ typedExpressionListIR }
   | seq{ typedExpressionListIR ,...}
   | record{ namedExpressionListIR }
   | record{ namedExpressionListIR ,...}
   | error. nameIR
   | memberAccessBaseIR . nameIR
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]
   | constructorTargetIR ( argumentListIR )
   | routineTargetIR < typeArgumentListIR >( argumentListIR )
   | ( typedExpressionIR )

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:177:27-177:42:
syntax expressionNoteIR = 
   | ( typeIR ctk )

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:180:3-180:35:
syntax typedExpressionIR = 
   | expressionIR # expressionNoteIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:182:32-182:50:
syntax typedExpressionListIR = typedExpressionIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:185:1-186:22:
syntax memberAccessBaseIR = 
   | type prefixedNameIR
   | expressionIR # expressionNoteIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:193:1-197:7:
syntax simpleKeysetExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR &&& typedExpressionIR
   | typedExpressionIR .. typedExpressionIR
   | default
   | _

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:199:39-199:64:
syntax simpleKeysetExpressionListIR = simpleKeysetExpressionIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:201:34-201:67:
syntax tupleKeysetExpressionIR = 
   | ( simpleKeysetExpressionListIR )

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:204:1-205:28:
syntax keysetExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR &&& typedExpressionIR
   | typedExpressionIR .. typedExpressionIR
   | default
   | _
   | ( simpleKeysetExpressionListIR )

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:211:25-211:31:
syntax typeArgumentIR = typeIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:213:29-213:44:
syntax typeArgumentListIR = typeArgumentIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:220:1-223:7:
syntax argumentIR = 
   | expressionIR # expressionNoteIR
   | nameIR = typedExpressionIR
   | nameIR =_
   | _

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:225:25-225:36:
syntax argumentListIR = argumentIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:232:1-236:23:
syntax lvalueIR = 
   | ` nameIR
   | . nameIR
   | typedLvalueIR . nameIR
   | typedLvalueIR [ typedExpressionIR ]
   | typedLvalueIR [ typedExpressionIR : typedExpressionIR ]
   | ( typedLvalueIR )

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:238:24-238:47:
syntax typedLvalueIR = 
   | lvalueIR #( typeIR )

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:248:27-248:41:
syntax emptyStatementIR = emptyStatement

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:255:3-255:46:
syntax assignmentStatementIR = 
   | typedLvalueIR assignop typedExpressionIR ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:262:3-262:65:
syntax callStatementIR = 
   | routineTargetIR < typeArgumentListIR >( argumentListIR );

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:269:3-269:49:
syntax directApplicationStatementIR = 
   | prefixedNameIR .apply( argumentListIR );

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:276:1-277:32:
syntax returnStatementIR = 
   | return;
   | return typedExpressionIR ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:283:26-283:39:
syntax exitStatementIR = exitStatement

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:292:3-292:50:
syntax blockStatementIR = 
   | annotationList { blockElementStatementListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:301:1-302:59:
syntax conditionalStatementIR = 
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:311:1-314:35:
syntax forInitStatementIR = 
   | annotationList typeIR nameIR initializerOptIR
   | lvalueIR ( argumentListIR )
   | lvalueIR < typeArgumentListIR >( argumentListIR )
   | lvalueIR assignop expressionIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:316:33-316:52:
syntax forInitStatementListIR = forInitStatementIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:318:31-318:49:
syntax forUpdateStatementIR = forInitStatementIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:320:35-320:56:
syntax forUpdateStatementListIR = forUpdateStatementIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:323:1-324:44:
syntax forCollectionExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR .. typedExpressionIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:327:1-335:18:
syntax forStatementIR = 
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:342:1-343:22:
syntax switchLabelIR = 
   | default
   | expressionIR # expressionNoteIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:346:1-347:21:
syntax switchCaseIR = 
   | switchLabelIR : blockStatementIR
   | switchLabelIR :

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:349:27-349:40:
syntax switchCaseListIR = switchCaseIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:352:3-352:54:
syntax switchStatementIR = 
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:358:27-358:41:
syntax breakStatementIR = breakStatement

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:360:30-360:47:
syntax continueStatementIR = continueStatement

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:367:1-378:22:
syntax statementIR = 
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | return;
   | return typedExpressionIR ;
   | exit;
   | annotationList { blockElementStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR
   | break;
   | continue;
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:388:32-388:40:
syntax constantInitializerIR = 
   | = value

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:390:35-390:57:
syntax constantInitializerOptIR = constantInitializerIR?

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:393:3-393:62:
syntax constantDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:395:24-395:44:
syntax initializerIR = 
   | = typedExpressionIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:397:27-397:41:
syntax initializerOptIR = initializerIR?

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:400:3-400:51:
syntax variableDeclarationIR = 
   | annotationList typeIR nameIR initializerOptIR ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:403:1-405:16:
syntax blockElementStatementIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | return;
   | return typedExpressionIR ;
   | exit;
   | annotationList { blockElementStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR
   | break;
   | continue;
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:407:38-407:62:
syntax blockElementStatementListIR = blockElementStatementIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:414:3-415:73:
syntax functionPrototypeIR = 
   | typeIR nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR )

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:418:3-418:54:
syntax functionDeclarationIR = 
   | annotationList functionPrototypeIR blockStatementIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:425:3-425:69:
syntax actionDeclarationIR = 
   | annotationList action nameIR ( parameterListIR ) blockStatementIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:433:30-433:61:
syntax objectInitializerIR = 
   | ={ objectDeclarationListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:435:33-435:53:
syntax objectInitializerOptIR = objectInitializerIR?

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:438:3-440:30:
syntax instantiationIR = 
   | annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:443:1-444:20:
syntax objectDeclarationIR = 
   | annotationList functionPrototypeIR blockStatementIR
   | annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:446:34-446:54:
syntax objectDeclarationListIR = objectDeclarationIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:452:29-452:50:
syntax errorDeclarationIR = 
   | error{ nameListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:458:33-458:59:
syntax matchKindDeclarationIR = 
   | match_kind{ nameListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:469:1-470:65:
syntax enumTypeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:476:22-476:53:
syntax typeFieldIR = 
   | annotationList typeIR nameIR ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:478:26-478:38:
syntax typeFieldListIR = typeFieldIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:481:3-482:73:
syntax structTypeDeclarationIR = 
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:485:3-486:73:
syntax headerTypeDeclarationIR = 
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:489:3-490:73:
syntax headerUnionTypeDeclarationIR = 
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:493:1-496:33:
syntax derivedTypeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:503:1-504:29:
syntax typedefTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:507:1-508:41:
syntax typedefDeclarationIR = 
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:515:3-515:47:
syntax externFunctionDeclarationIR = 
   | annotationList extern functionPrototypeIR ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:518:1-520:51:
syntax methodPrototypeIR = 
   | annotationList nameIR <, typeParameterListIR >( parameterListIR );
   | annotationList functionPrototypeIR ;
   | annotationList abstract functionPrototypeIR ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:522:32-522:50:
syntax methodPrototypeListIR = methodPrototypeIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:525:3-527:31:
syntax externObjectDeclarationIR = 
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:530:1-531:30:
syntax externDeclarationIR = 
   | annotationList extern functionPrototypeIR ;
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:541:23-541:54:
syntax selectCaseIR = 
   | keysetExpressionIR : nameIR ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:543:27-543:40:
syntax selectCaseListIR = selectCaseIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:546:3-546:58:
syntax selectExpressionIR = 
   | select( typedExpressionListIR ){ selectCaseListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:553:1-554:23:
syntax stateExpressionIR = 
   | nameIR ;
   | select( typedExpressionListIR ){ selectCaseListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:556:32-556:60:
syntax transitionStatementIR = 
   | transition stateExpressionIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:563:3-563:72:
syntax valueSetDeclarationIR = 
   | annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:570:3-571:76:
syntax parserTypeDeclarationIR = 
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:580:3-580:44:
syntax parserBlockStatementIR = 
   | annotationList { parserStatementListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:583:1-590:27:
syntax parserStatementIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | annotationList { parserStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:592:32-592:50:
syntax parserStatementListIR = parserStatementIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:595:3-596:53:
syntax parserStateIR = 
   | annotationList state nameIR { parserStatementListIR transitionStatementIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:598:28-598:42:
syntax parserStateListIR = parserStateIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:601:1-604:26:
syntax parserLocalDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:607:3-607:28:
syntax parserLocalDeclarationListIR = parserLocalDeclarationIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:610:3-613:56:
syntax parserDeclarationIR = 
   | annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:623:18-623:23:
syntax constIR = const

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:625:21-625:29:
syntax constOptIR = constIR?

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:631:21-631:66:
syntax tableKeyIR = 
   | typedExpressionIR : nameIR annotationList ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:633:25-633:36:
syntax tableKeyListIR = tableKeyIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:639:33-639:67:
syntax tableActionReferenceIR = 
   | prefixedNameIR ( argumentListIR )

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:641:24-641:64:
syntax tableActionIR = 
   | annotationList tableActionReferenceIR ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:643:28-643:42:
syntax tableActionListIR = tableActionIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:650:1-651:42:
syntax tableEntryPriorityIR = 
   | priority= number :
   | priority=( typedExpressionIR ):

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:653:34-653:55:
syntax tableEntryPriorityOptIR = tableEntryPriorityIR?

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:656:3-657:67:
syntax tableEntryIR = 
   | constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:659:27-659:40:
syntax tableEntryListIR = tableEntryIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:666:1-672:75:
syntax tablePropertyIR = 
   | key={ tableKeyListIR }
   | actions={ tableActionListIR }
   | annotationList constOptIR entries={ tableEntryListIR }
   | annotationList constOptIR default_action= tableActionReferenceIR ;
   | annotationList constOptIR custom nameIR initializerIR ;
   | annotationList constOptIR custom_const nameIR constantInitializerIR ;

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:674:30-674:46:
syntax tablePropertyListIR = tablePropertyIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:677:3-677:62:
syntax tableDeclarationIR = 
   | annotationList table typeIR nameIR { tablePropertyListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:684:3-686:28:
syntax controlTypeDeclarationIR = 
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:692:24-692:40:
syntax controlBodyIR = blockStatementIR

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:695:1-699:23:
syntax controlLocalDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | annotationList action nameIR ( parameterListIR ) blockStatementIR
   | annotationList table typeIR nameIR { tablePropertyListIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:702:3-702:29:
syntax controlLocalDeclarationListIR = controlLocalDeclarationIR*

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:705:3-708:59:
syntax controlDeclarationIR = 
   | annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:715:3-717:28:
syntax packageTypeDeclarationIR = 
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:724:1-728:29:
syntax typeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:735:1-744:22:
syntax declarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList functionPrototypeIR blockStatementIR
   | annotationList action nameIR ( parameterListIR ) blockStatementIR
   | error{ nameListIR }
   | match_kind{ nameListIR }
   | annotationList extern functionPrototypeIR ;
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }
   | annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }
   | annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../reference-specs/p4-concrete/4-ir-syntax.spectec:750:22-750:39:
syntax p4programIR = 
   | declarationIR* ;

;; ../../../../reference-specs/p4-concrete/5.0-flow.spectec:5:15-5:25:
syntax flow = 
   | cont
   | ret

;; ../../../../reference-specs/p4-concrete/5.0-flow.spectec:9:1-9:34:
def $join_flow(flow, flow) : flow =

   ;; ../../../../reference-specs/p4-concrete/5.0-flow.spectec:10:1-10:31:
   clause 0(flow, flow') = ret
      -- if flow matches `RET`
      -- if flow' matches `RET`

   ;; ../../../../reference-specs/p4-concrete/5.0-flow.spectec:11:1-12:15:
   clause 1(f_a, f_b) = cont
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:5:20-5:47:
syntax varTypeIR = 
   | direction typeIR ctk value?

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:12:16-12:34:
syntax frame = map<id, varTypeIR>

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:14:1-14:27:
def $empty_frame : frame =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:15:1-15:47:
   clause 0 = $empty_map<id, varTypeIR>

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:18:16-18:35:
syntax tdenv = map<tid, typeDefIR>

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:20:1-20:27:
def $empty_tdenv : tdenv =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:21:1-21:48:
   clause 0 = $empty_map<tid, typeDefIR>

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:24:16-24:42:
syntax rdenv = map<rid, routineTypeDefIR>

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:26:1-26:27:
def $empty_rdenv : rdenv =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:27:1-27:55:
   clause 0 = $empty_map<rid, routineTypeDefIR>

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:30:16-30:46:
syntax cdenv = map<cid, constructorTypeDefIR>

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:32:1-32:27:
def $empty_cdenv : cdenv =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:33:1-33:59:
   clause 0 = $empty_map<cid, constructorTypeDefIR>

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:39:1-39:39:
def $check_routine_name(id, id) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:40:1-40:50:
   clause 0(id_l, id_r) = (id_l = id_r)

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:42:1-42:37:
def $check_arity(id?*, id*) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:43:1-43:72:
   clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| = |id_param*{id_param <- id_param*}|)

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:45:1-45:42:
def $check_arity_more(id?*, id*) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:46:1-46:77:
   clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > |id_param*{id_param <- id_param*}|)

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:48:1-48:42:
def $check_arity_less(id?*, id*) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:49:1-49:77:
   clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| < |id_param*{id_param <- id_param*}|)

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:51:1-51:44:
def $get_missing_parameters(id*, id*) : id* =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:53:1-53:48:
   clause 0(id*{id <- id*}, id_arg*{id_arg <- id_arg*}) = []
      -- if id*{id <- id*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:54:1-59:47:
   clause 1(id*{id <- id*}, id_arg*{id_arg <- id_arg*}) = id_param_h :: $get_missing_parameters(id_param_t*{id_param_t <- id_param_t*}, id_arg*{id_arg <- id_arg*})
      -- if id*{id <- id*} matches _ :: _
      -- let id_param_h :: id_param_t*{id_param_t <- id_param_t*} = id*{id <- id*}
      -- if ~$in_set<id>(id_param_h, { id_arg*{id_arg <- id_arg*} })

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:60:1-65:15:
   clause 2(id*{id <- id*}, id_arg*{id_arg <- id_arg*}) = $get_missing_parameters(id_param_t*{id_param_t <- id_param_t*}, id_arg*{id_arg <- id_arg*})
      -- if id*{id <- id*} matches _ :: _
      -- let id_param_h :: id_param_t*{id_param_t <- id_param_t*} = id*{id <- id*}
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:68:1-68:61:
def $find_match_named<V>(rid, V, id*, pid*) : (rid, V, id*)? =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:70:1-72:50:
   clause 0(rid, V, id_arg*{id_arg <- id_arg*}, id_param # bool_param*{bool_param <- bool_param*, id_param <- id_param*}) = ?((rid, V, []))
      -- if $eq_set<id>({ id_arg*{id_arg <- id_arg*} }, { id_param*{id_param <- id_param*} })

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:73:1-74:15:
   clause 1(rid, V, id_arg*{id_arg <- id_arg*}, pid*{pid <- pid*}) = ?()
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:77:1-77:69:
def $find_match_named_default<V>(rid, V, id*, pid*) : (rid, V, id*)? =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:79:1-86:18:
   clause 0(rid, V, id_arg*{id_arg <- id_arg*}, id_param # bool_param*{bool_param <- bool_param*, id_param <- id_param*}) = ?((rid, V, id_default*{id_default <- id_default*}))
      -- let id_default*{id_default <- id_default*} = $get_missing_parameters(id_param*{id_param <- id_param*}, id_arg*{id_arg <- id_arg*})
      -- if ($find_match_named<V>(rid, V, id_arg*{id_arg <- id_arg*} ++ id_default*{id_default <- id_default*}, id_param # bool_param*{bool_param <- bool_param*, id_param <- id_param*}) =/= ?())

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:87:1-88:15:
   clause 1(rid, V, id_arg*{id_arg <- id_arg*}, pid*{pid <- pid*}) = ?()
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:91:1-91:74:
def $find_match_unnamed_default<V>(rid, V, id?*, pid*) : (rid, V, id*)? =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:93:1-95:74:
   clause 0(rid, V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, pid*{pid <- pid*}) = ?((rid, V, id_default*{id_default <- id_default*}))
      -- let (_pid*{_pid <- _pid*}, id_default # bool*{bool <- bool*, id_default <- id_default*}) = $partition_<pid>(pid*{pid <- pid*}, |id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}|)
      -- (if (bool = true))*{bool <- bool*}

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:96:1-97:15:
   clause 1(rid, V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, pid*{pid <- pid*}) = ?()
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:100:1-100:64:
def $find_matching<V>(id, id?*, id*, rid, V) : (rid, V, id*)? =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:103:1-105:42:
   clause 0(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' ( pid_r'*{pid_r' <- pid_r'*} ), V) = ?()
      -- if ~$check_routine_name(id_r, id_r')

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:107:1-113:50:
   clause 1(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V) = ?()
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity_more(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:115:1-125:45:
   clause 2(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V) = $find_match_named<V>(id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V, id_arg'*{id_arg' <- id_arg'*}, id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*})
      -- if (|id_arg'*{id_arg' <- id_arg'*}| > 0)
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:127:1-133:45:
   clause 3(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id*{id <- id*}, id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V) = ?((id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V, []))
      -- if id*{id <- id*} matches []
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:135:1-145:50:
   clause 4(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V) = $find_match_named_default<V>(id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V, id_arg'*{id_arg' <- id_arg'*}, id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*})
      -- if (|id_arg'*{id_arg' <- id_arg'*}| > 0)
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity_less(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:147:1-156:50:
   clause 5(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id*{id <- id*}, id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V) = $find_match_unnamed_default<V>(id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*})
      -- if id*{id <- id*} matches []
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity_less(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:159:1-159:67:
def $find_matchings<V>(id, id?*, id*, rid*, V*) : (rid, V, id*)* =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:161:1-165:8:
   clause 0(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = []
      -- if rid*{rid <- rid*} matches []
      -- if V*{V <- V*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:166:1-171:72:
   clause 1(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_t*{rid_t <- rid_t*}, V_t*{V_t <- V_t*})
      -- if rid*{rid <- rid*} matches _ :: _
      -- let rid_h :: rid_t*{rid_t <- rid_t*} = rid*{rid <- rid*}
      -- if V*{V <- V*} matches _ :: _
      -- let V_h :: V_t*{V_t <- V_t*} = V*{V <- V*}
      -- if ($find_matching<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_h, V_h) = ?())

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:172:1-178:66:
   clause 2(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid'*{rid' <- rid'*}, V'*{V' <- V'*}) = (rid, V, id_default*{id_default <- id_default*}) :: $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_t*{rid_t <- rid_t*}, V_t*{V_t <- V_t*})
      -- if rid'*{rid' <- rid'*} matches _ :: _
      -- let rid_h :: rid_t*{rid_t <- rid_t*} = rid'*{rid' <- rid'*}
      -- if V'*{V' <- V'*} matches _ :: _
      -- let V_h :: V_t*{V_t <- V_t*} = V'*{V' <- V'*}
      -- let (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?} = $find_matching<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_h, V_h)
      -- if (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?} matches (_)
      -- let ?((rid, V, id_default*{id_default <- id_default*})) = (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?}

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:181:1-181:66:
def $find_overloaded<V>(map<rid, V>, id, id?*) : (rid, V, id*)? =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:184:1-190:71:
   clause 0({ rid : V*{V <- V*, rid <- rid*} }, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?()
      -- if (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > 0)
      -- (let id?{id <- id?} = id_arg?{id_arg <- id_arg?})*{id? <- id?*, id_arg? <- id_arg?*}
      -- (if id?{id <- id?} matches (_))*{id? <- id?*}
      -- (let ?(id_arg') = id?{id <- id?})*{id? <- id?*, id_arg' <- id_arg'*}
      -- if ($find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = [])

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:191:1-198:65:
   clause 1({ rid : V*{V <- V*, rid <- rid*} }, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?((rid', V', id_default*{id_default <- id_default*}))
      -- if (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > 0)
      -- (let id?{id <- id?} = id_arg?{id_arg <- id_arg?})*{id? <- id?*, id_arg? <- id_arg?*}
      -- (if id?{id <- id?} matches (_))*{id? <- id?*}
      -- (let ?(id_arg') = id?{id <- id?})*{id? <- id?*, id_arg' <- id_arg'*}
      -- let (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*})
      -- if (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} matches [ _/1 ]
      -- let [(rid', V', id_default*{id_default <- id_default*})] = (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*}

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:200:1-205:66:
   clause 2({ rid : V*{V <- V*, rid <- rid*} }, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?()
      -- (if (id_arg?{id_arg <- id_arg?} = ?()))*{id_arg? <- id_arg?*}
      -- if ($find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, [], rid*{rid <- rid*}, V*{V <- V*}) = [])

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:206:1-212:60:
   clause 3({ rid : V*{V <- V*, rid <- rid*} }, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?((rid', V', id_default*{id_default <- id_default*}))
      -- (if (id_arg?{id_arg <- id_arg?} = ?()))*{id_arg? <- id_arg?*}
      -- let (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, [], rid*{rid <- rid*}, V*{V <- V*})
      -- if (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} matches [ _/1 ]
      -- let [(rid', V', id_default*{id_default <- id_default*})] = (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*}

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:218:1-218:50:
def $find_non_overloaded<V>(map<rid, V>, id) : V? =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:221:1-222:60:
   clause 0({ rid : V*{V <- V*, rid <- rid*} }, id) = ?(V')
      -- let V''*{V'' <- V''*} = $find_non_overloaded'<V>({ rid : V*{V <- V*, rid <- rid*} }, id)
      -- if V''*{V'' <- V''*} matches [ _/1 ]
      -- let [V'] = V''*{V'' <- V''*}

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:223:1-224:15:
   clause 1({ rid : V*{V <- V*, rid <- rid*} }, id) = ?()
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:219:1-219:51:
def $find_non_overloaded'<V>(map<rid, V>, id) : V* =

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:226:1-226:49:
   clause 0(set<pair<rid, V>>, id) = []
      -- if (set<pair<rid, V>> = { [] })

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:227:1-233:59:
   clause 1({ pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} }, id) = V_h :: V_t_found*{V_t_found <- V_t_found*}
      -- if pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} matches _ :: _
      -- let rid_h : V_h :: rid_t : V_t*{V_t <- V_t*, rid_t <- rid_t*} = pair<rid, V>*{pair<rid, V> <- pair<rid, V>*}
      -- let id' ( _pid*{_pid <- _pid*} ) = rid_h
      -- if (id' = id)
      -- let V_t_found*{V_t_found <- V_t_found*} = $find_non_overloaded'<V>({ rid_t : V_t*{V_t <- V_t*, rid_t <- rid_t*} }, id)

   ;; ../../../../reference-specs/p4-concrete/5.01-env.spectec:234:1-241:59:
   clause 2({ pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} }, id) = V_t_found*{V_t_found <- V_t_found*}
      -- if pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} matches _ :: _
      -- let rid_h : V_h :: rid_t : V_t*{V_t <- V_t*, rid_t <- rid_t*} = pair<rid, V>*{pair<rid, V> <- pair<rid, V>*}
      -- let id_h ( _pid*{_pid <- _pid*} ) = rid_h
      -- if (id =/= id_h)
      -- let V_t_found*{V_t_found <- V_t_found*} = $find_non_overloaded'<V>({ rid_t : V_t*{V_t <- V_t*, rid_t <- rid_t*} }, id)

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:5:17-5:39:
syntax cursor = 
   | global
   | block
   | local

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:16:3-19:18:
syntax globalTypingLayer = {cdenv cdenv, tdenv tdenv, rdenv rdenv, frame frame}

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:24:1-28:12:
syntax blockKind = 
   | 
   | extern
   | parser
   | control
   | package

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:30:1-30:43:
def $is_extern_blockKind(blockKind) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:31:1-31:57:
   clause 0(blockKind) = (blockKind = extern)

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:33:1-33:43:
def $is_parser_blockKind(blockKind) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:34:1-34:57:
   clause 0(blockKind) = (blockKind = parser)

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:36:1-36:44:
def $is_control_blockKind(blockKind) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:37:1-37:59:
   clause 0(blockKind) = (blockKind = control)

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:39:1-39:44:
def $is_package_blockKind(blockKind) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:40:1-40:59:
   clause 0(blockKind) = (blockKind = package)

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:43:3-47:18:
syntax blockTypingLayer = {id id, kind blockKind, tdenv tdenv, rdenv rdenv, frame frame}

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:52:1-60:23:
syntax localKind = 
   | 
   | function-> typeIR
   | extern_function-> typeIR
   | action
   | extern_method-> typeIR
   | extern_methodabstract-> typeIR
   | parser_state
   | control_apply_method
   | table_apply_method

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:62:1-62:45:
def $is_function_localKind(localKind) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:63:1-63:50:
   clause 0(localKind) = true
      -- if localKind matches `FUNCTION->%`
      -- let function-> _typeIR = localKind

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:64:1-65:15:
   clause 1(_localKind) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:67:1-67:52:
def $is_extern_function_localKind(localKind) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:68:1-70:11:
   clause 0(localKind) = true
      -- if localKind matches `EXTERN_FUNCTION->%`
      -- let extern_function-> _typeIR = localKind

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:71:1-72:15:
   clause 1(_localKind) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:74:1-74:43:
def $is_action_localKind(localKind) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:75:1-75:40:
   clause 0(localKind) = true
      -- if localKind matches `ACTION`

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:76:1-77:15:
   clause 1(_localKind) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:79:1-79:50:
def $is_extern_method_localKind(localKind) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:80:1-82:11:
   clause 0(localKind) = true
      -- if localKind matches `EXTERN_METHOD->%`
      -- let extern_method-> _typeIR = localKind

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:83:1-84:15:
   clause 1(_localKind) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:86:1-86:59:
def $is_extern_abstract_method_localKind(localKind) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:87:1-89:11:
   clause 0(localKind) = true
      -- if localKind matches `EXTERN_METHODABSTRACT->%`
      -- let extern_methodabstract-> _typeIR = localKind

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:90:1-91:15:
   clause 1(_localKind) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:93:1-93:49:
def $is_parser_state_localKind(localKind) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:94:1-94:52:
   clause 0(localKind) = true
      -- if localKind matches `PARSER_STATE`

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:95:1-96:15:
   clause 1(_localKind) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:98:1-98:57:
def $is_control_apply_method_localKind(localKind) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:99:1-101:11:
   clause 0(localKind) = true
      -- if localKind matches `CONTROL_APPLY_METHOD`

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:102:1-103:15:
   clause 1(_localKind) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:105:1-105:55:
def $is_table_apply_method_localKind(localKind) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:106:1-108:11:
   clause 0(localKind) = true
      -- if localKind matches `TABLE_APPLY_METHOD`

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:109:1-110:15:
   clause 1(_localKind) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:113:3-116:20:
syntax localTypingLayer = {id id, kind localKind, tdenv tdenv, frames frame*}

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:123:3-125:29:
syntax typingContext = {global globalTypingLayer, block blockTypingLayer, local localTypingLayer}

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:133:1-133:41:
def $empty_typingContext : typingContext =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:135:1-155:35:
   clause 0 = TC
      -- let globalTypingLayer = {cdenv $empty_cdenv, tdenv $empty_tdenv, rdenv $empty_rdenv, frame $empty_frame}
      -- let blockTypingLayer = {id "", kind , tdenv $empty_tdenv, rdenv $empty_rdenv, frame $empty_frame}
      -- let localTypingLayer = {id "", kind , tdenv $empty_tdenv, frames [$empty_frame]}
      -- let TC = {global globalTypingLayer, block blockTypingLayer, local localTypingLayer}

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:161:1-161:42:
def $bound(cursor, typingContext) : bound =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:163:1-163:34:
   clause 0(cursor, TC) = { [] }
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:164:1-164:65:
   clause 1(cursor, TC) = $dom_map<tid, typeDefIR>(TC.block.tdenv)
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:165:1-167:63:
   clause 2(cursor, TC) = $union_set<tid>(bound_block, bound_local)
      -- if cursor matches `LOCAL`
      -- let bound_block = $bound(block, TC)
      -- let bound_local = $dom_map<tid, typeDefIR>(TC.local.tdenv)

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:173:1-173:42:
def $enter(typingContext) : typingContext =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:175:1-175:72:
   clause 0(TC) = TC[local.frames = $empty_frame :: TC.local.frames]

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:177:1-177:41:
def $exit(typingContext) : typingContext =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:179:1-180:46:
   clause 0(TC) = TC[local.frames = frame_t*{frame_t <- frame_t*}]
      -- let frame*{frame <- frame*} = TC.local.frames
      -- if frame*{frame <- frame*} matches _ :: _
      -- let frame_h :: frame_t*{frame_t <- frame_t*} = frame*{frame <- frame*}

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:188:1-188:67:
def $add_var(cursor, typingContext, id, varTypeIR) : typingContext =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:191:1-197:50:
   clause 0(cursor, TC, id, varTypeIR) = TC'
      -- if cursor matches `GLOBAL`
      -- let frame = TC.global.frame
      -- if ~$in_set<id>(id, $dom_map<id, varTypeIR>(frame))
      -- let _direction typeIR _ctk _value?{_value <- _value?} = varTypeIR
      -- if ((id = "main") => $is_package_object_typeIR($canon(typeIR)))
      -- let frame_update = $add_map<id, varTypeIR>(frame, id, varTypeIR)
      -- let TC' = TC[global.frame = frame_update]

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:198:1-203:49:
   clause 1(cursor, TC, id, varTypeIR) = TC'
      -- if cursor matches `BLOCK`
      -- let frame = TC.block.frame
      -- if ~$in_set<id>(id, $dom_map<id, varTypeIR>(frame))
      -- if (id =/= "main")
      -- let frame_update = $add_map<id, varTypeIR>(TC.block.frame, id, varTypeIR)
      -- let TC' = TC[block.frame = frame_update]

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:204:1-210:44:
   clause 2(cursor, TC, id, varTypeIR) = TC'
      -- if cursor matches `LOCAL`
      -- let frame'*{frame' <- frame'*} = TC.local.frames
      -- if frame'*{frame' <- frame'*} matches _ :: _
      -- let frame_h :: frame_t*{frame_t <- frame_t*} = frame'*{frame' <- frame'*}
      -- if ~$in_set<id>(id, $dom_map<id, varTypeIR>(frame_h))
      -- if (id =/= "main")
      -- let frame_h_update = $add_map<id, varTypeIR>(frame_h, id, varTypeIR)
      -- let frame*{frame <- frame*} = frame_h_update :: frame_t*{frame_t <- frame_t*}
      -- let TC' = TC[local.frames = frame*{frame <- frame*}]

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:189:1-189:70:
def $add_vars(cursor, typingContext, id*, varTypeIR*) : typingContext =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:212:1-212:36:
   clause 0(p, TC, id*{id <- id*}, varTypeIR*{varTypeIR <- varTypeIR*}) = TC
      -- if id*{id <- id*} matches []
      -- if varTypeIR*{varTypeIR <- varTypeIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:213:1-215:54:
   clause 1(p, TC, id*{id <- id*}, varTypeIR*{varTypeIR <- varTypeIR*}) = TC''
      -- if id*{id <- id*} matches _ :: _
      -- let id_h :: id_t*{id_t <- id_t*} = id*{id <- id*}
      -- if varTypeIR*{varTypeIR <- varTypeIR*} matches _ :: _
      -- let varTypeIR_h :: varTypeIR_t*{varTypeIR_t <- varTypeIR_t*} = varTypeIR*{varTypeIR <- varTypeIR*}
      -- let TC' = $add_var(p, TC, id_h, varTypeIR_h)
      -- let TC'' = $add_vars(p, TC', id_t*{id_t <- id_t*}, varTypeIR_t*{varTypeIR_t <- varTypeIR_t*})

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:219:1-219:75:
def $add_parameter(cursor, typingContext, parameterTypeIR) : typingContext =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:222:1-224:50:
   clause 0(cursor, TC, direction typeIR id value?{value <- value?}) = TC'
      -- if direction matches ``EMPTY`
      -- let varTypeIR = typeIR ctk value?{value <- value?}
      -- let TC' = $add_var(cursor, TC, id, varTypeIR)

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:225:1-228:50:
   clause 1(cursor, TC, direction typeIR id value?{value <- value?}) = TC'
      -- if (((direction = in) \/ (direction = out)) \/ (direction = inout))
      -- let varTypeIR = direction typeIR dyn value?{value <- value?}
      -- let TC' = $add_var(cursor, TC, id, varTypeIR)

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:220:1-220:77:
def $add_parameters(cursor, typingContext, parameterTypeIR*) : typingContext =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:230:1-230:42:
   clause 0(cursor, TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = TC
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:231:1-233:64:
   clause 1(cursor, TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = TC''
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let TC' = $add_parameter(cursor, TC, parameterTypeIR_h)
      -- let TC'' = $add_parameters(cursor, TC', parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:237:1-237:78:
def $add_constructorParameter(typingContext, parameterTypeIR) : typingContext =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:240:1-242:49:
   clause 0(TC, direction typeIR id value?{value <- value?}) = TC'
      -- if value?{value <- value?} matches ()
      -- let varTypeIR = direction typeIR ctk ?()
      -- let TC' = $add_var(block, TC, id, varTypeIR)

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:243:1-245:49:
   clause 1(TC, direction typeIR id value'?{value' <- value'?}) = TC'
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}
      -- let varTypeIR = direction typeIR ctk ?(value)
      -- let TC' = $add_var(block, TC, id, varTypeIR)

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:238:1-238:80:
def $add_constructorParameters(typingContext, parameterTypeIR*) : typingContext =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:247:1-247:45:
   clause 0(TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = TC
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:248:1-250:67:
   clause 1(TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = TC''
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let TC' = $add_constructorParameter(TC, parameterTypeIR_h)
      -- let TC'' = $add_constructorParameters(TC', parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:254:1-254:69:
def $add_type(cursor, typingContext, tid, typeDefIR) : typingContext =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:255:1-260:50:
   clause 0(cursor, TC, tid, typeDefIR) = TC'
      -- if cursor matches `GLOBAL`
      -- let tdenv = TC.global.tdenv
      -- if ~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))
      -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
      -- let TC' = TC[global.tdenv = tdenv_update]

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:261:1-266:49:
   clause 1(cursor, TC, tid, typeDefIR) = TC'
      -- if cursor matches `BLOCK`
      -- let tdenv = TC.block.tdenv
      -- if ~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))
      -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
      -- let TC' = TC[block.tdenv = tdenv_update]

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:267:1-272:49:
   clause 2(cursor, TC, tid, typeDefIR) = TC'
      -- if cursor matches `LOCAL`
      -- let tdenv = TC.local.tdenv
      -- if ~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))
      -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
      -- let TC' = TC[local.tdenv = tdenv_update]

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:274:1-274:72:
def $add_types(cursor, typingContext, tid*, typeDefIR*) : typingContext =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:275:1-275:37:
   clause 0(p, TC, tid*{tid <- tid*}, typeDefIR*{typeDefIR <- typeDefIR*}) = TC
      -- if tid*{tid <- tid*} matches []
      -- if typeDefIR*{typeDefIR <- typeDefIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:276:1-278:56:
   clause 1(p, TC, tid*{tid <- tid*}, typeDefIR*{typeDefIR <- typeDefIR*}) = TC''
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- if typeDefIR*{typeDefIR <- typeDefIR*} matches _ :: _
      -- let typeDefIR_h :: typeDefIR_t*{typeDefIR_t <- typeDefIR_t*} = typeDefIR*{typeDefIR <- typeDefIR*}
      -- let TC' = $add_type(p, TC, tid_h, typeDefIR_h)
      -- let TC'' = $add_types(p, TC', tid_t*{tid_t <- tid_t*}, typeDefIR_t*{typeDefIR_t <- typeDefIR_t*})

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:282:1-282:88:
def $add_routine_overload(cursor, typingContext, rid, routineTypeDefIR) : typingContext =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:284:1-289:50:
   clause 0(cursor, TC, rid, routineTypeDefIR) = TC'
      -- if cursor matches `GLOBAL`
      -- let rdenv = TC.global.rdenv
      -- if ~$in_set<rid>(rid, $dom_map<rid, routineTypeDefIR>(rdenv))
      -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let TC' = TC[global.rdenv = rdenv_update]

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:290:1-295:49:
   clause 1(cursor, TC, rid, routineTypeDefIR) = TC'
      -- if cursor matches `BLOCK`
      -- let rdenv = TC.block.rdenv
      -- if ~$in_set<rid>(rid, $dom_map<rid, routineTypeDefIR>(rdenv))
      -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let TC' = TC[block.rdenv = rdenv_update]

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:297:1-297:92:
def $add_routine_non_overload(cursor, typingContext, rid, routineTypeDefIR) : typingContext =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:299:1-306:50:
   clause 0(cursor, TC, rid, routineTypeDefIR) = TC'
      -- if cursor matches `GLOBAL`
      -- let rdenv = TC.global.rdenv
      -- let id ( _pid*{_pid <- _pid*} ) = rid
      -- let { id_k ( _pid'*{_pid' <- _pid'*} )*{_pid'* <- _pid'**, id_k <- id_k*} } = $dom_map<rid, routineTypeDefIR>(rdenv)
      -- if ~$in_set<id>(id, { id_k*{id_k <- id_k*} })
      -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let TC' = TC[global.rdenv = rdenv_update]

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:307:1-314:49:
   clause 1(cursor, TC, rid, routineTypeDefIR) = TC'
      -- if cursor matches `BLOCK`
      -- let rdenv = TC.block.rdenv
      -- let id ( _pid*{_pid <- _pid*} ) = rid
      -- let { id_k ( _pid'*{_pid' <- _pid'*} )*{_pid'* <- _pid'**, id_k <- id_k*} } = $dom_map<rid, routineTypeDefIR>(rdenv)
      -- if ~$in_set<id>(id, { id_k*{id_k <- id_k*} })
      -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let TC' = TC[block.rdenv = rdenv_update]

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:318:1-318:79:
def $add_constructor(typingContext, cid, constructorTypeDefIR) : typingContext =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:320:1-325:50:
   clause 0(TC, cid, constructorTypeDefIR) = TC'
      -- let cdenv = TC.global.cdenv
      -- if ~$in_set<cid>(cid, $dom_map<cid, constructorTypeDefIR>(cdenv))
      -- let cdenv_update = $add_map<cid, constructorTypeDefIR>(cdenv, cid, constructorTypeDefIR)
      -- let TC' = TC[global.cdenv = cdenv_update]

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:333:1-333:66:
def $find_var(cursor, typingContext, prefixedNameIR) : varTypeIR? =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:335:1-336:32:
   clause 0(p, TC, prefixedNameIR) = $find_map<id, varTypeIR>(frame, id)
      -- if prefixedNameIR matches `.%`
      -- let . id = prefixedNameIR
      -- let frame = TC.global.frame

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:337:1-338:32:
   clause 1(cursor, TC, prefixedNameIR) = $find_map<id, varTypeIR>(frame, id)
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let frame = TC.global.frame

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:339:1-341:56:
   clause 2(cursor, TC, prefixedNameIR) = ?(varTypeIR)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let frame = TC.block.frame
      -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_map<id, varTypeIR>(frame, id)
      -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
      -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:342:1-344:50:
   clause 3(cursor, TC, prefixedNameIR) = $find_var(global, TC, ` id)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let frame = TC.block.frame
      -- if (?() = $find_map<id, varTypeIR>(frame, id))

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:345:1-347:58:
   clause 4(cursor, TC, prefixedNameIR) = ?(varTypeIR)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let frame*{frame <- frame*} = TC.local.frames
      -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id)
      -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
      -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:348:1-350:52:
   clause 5(cursor, TC, prefixedNameIR) = $find_var(block, TC, ` id)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let frame*{frame <- frame*} = TC.local.frames
      -- if (?() = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id))

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:354:1-354:63:
def $find_value(cursor, typingContext, prefixedNameIR) : value =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:356:1-358:58:
   clause 0(p, TC, prefixedNameIR) = value
      -- if prefixedNameIR matches `.%`
      -- let . id = prefixedNameIR
      -- let frame = TC.global.frame
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:359:1-361:58:
   clause 1(cursor, TC, prefixedNameIR) = value
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let frame = TC.global.frame
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:362:1-364:58:
   clause 2(cursor, TC, prefixedNameIR) = value
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let frame = TC.block.frame
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:365:1-367:50:
   clause 3(cursor, TC, prefixedNameIR) = $find_value(global, TC, ` id)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let frame = TC.block.frame
      -- if (?() = $find_map<id, varTypeIR>(frame, id))

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:368:1-370:60:
   clause 4(cursor, TC, prefixedNameIR) = value
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let frame*{frame <- frame*} = TC.local.frames
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:371:1-373:52:
   clause 5(cursor, TC, prefixedNameIR) = $find_value(block, TC, ` id)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let frame*{frame <- frame*} = TC.local.frames
      -- if (?() = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id))

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:377:1-377:67:
def $find_type(cursor, typingContext, prefixedNameIR) : typeDefIR? =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:379:1-381:32:
   clause 0(p, TC, prefixedNameIR) = $find_map<tid, typeDefIR>(tdenv, tid)
      -- if prefixedNameIR matches `.%`
      -- let . tid = prefixedNameIR
      -- let tdenv = TC.global.tdenv

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:382:1-384:32:
   clause 1(cursor, TC, prefixedNameIR) = $find_map<tid, typeDefIR>(tdenv, tid)
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches ``%`
      -- let ` tid = prefixedNameIR
      -- let tdenv = TC.global.tdenv

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:385:1-387:58:
   clause 2(cursor, TC, prefixedNameIR) = ?(typeDefIR)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ` tid = prefixedNameIR
      -- let tdenv = TC.block.tdenv
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_map<tid, typeDefIR>(tdenv, tid)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:388:1-390:52:
   clause 3(cursor, TC, prefixedNameIR) = $find_type(global, TC, ` tid)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ` tid = prefixedNameIR
      -- let tdenv = TC.block.tdenv
      -- if (?() = $find_map<tid, typeDefIR>(tdenv, tid))

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:391:1-393:60:
   clause 4(cursor, TC, prefixedNameIR) = ?(typeDefIR)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ` tid = prefixedNameIR
      -- let tdenv*{tdenv <- tdenv*} = [TC.local.tdenv]
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_maps<tid, typeDefIR>(tdenv*{tdenv <- tdenv*}, tid)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:394:1-396:54:
   clause 5(cursor, TC, prefixedNameIR) = $find_type(block, TC, ` tid)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ` tid = prefixedNameIR
      -- let tdenv*{tdenv <- tdenv*} = [TC.local.tdenv]
      -- if (?() = $find_maps<tid, typeDefIR>(tdenv*{tdenv <- tdenv*}, tid))

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:400:1-400:41:
def $ids_arguments(argumentIR*) : id?* =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:403:1-403:62:
   clause 0(argumentIR*{argumentIR <- argumentIR*}) = $id_argument(argumentIR)*{argumentIR <- argumentIR*}

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:401:1-401:35:
def $id_argument(argumentIR) : id? =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:404:1-404:42:
   clause 0(argumentIR) = ?()
      -- if argumentIR <: typedExpressionIR
      -- let typedExpressionIR = argumentIR as typedExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:405:1-405:39:
   clause 1(argumentIR) = ?(nameIR)
      -- if argumentIR matches `%=%`
      -- let nameIR = _typedExpressionIR = argumentIR

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:406:1-406:40:
   clause 2(argumentIR) = ?(nameIR)
      -- if argumentIR matches `%=_`
      -- let nameIR =_ = argumentIR

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:407:1-407:27:
   clause 3(argumentIR) = ?()
      -- if argumentIR matches `_`

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:409:1-410:34:
def $find_routine_overloaded(cursor, typingContext, prefixedNameIR, argumentIR*) : (rid, routineTypeDefIR, id*)? =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:412:1-415:49:
   clause 0(cursor, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches `.%`
      -- let . id = prefixedNameIR
      -- let rdenv = TC.global.rdenv
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:416:1-419:49:
   clause 1(cursor, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let rdenv = TC.global.rdenv
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:420:1-425:66:
   clause 2(cursor, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*}))
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let rdenv = TC.block.rdenv
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
      -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
      -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:426:1-431:66:
   clause 3(cursor, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_routine_overloaded(global, TC, ` id, argumentIR*{argumentIR <- argumentIR*})
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let rdenv = TC.block.rdenv
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
      -- if (?() = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}))

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:432:1-433:60:
   clause 4(cursor, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_routine_overloaded(block, TC, ` id, argumentIR*{argumentIR <- argumentIR*})
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:435:1-436:22:
def $find_routine_non_overloaded(cursor, typingContext, prefixedNameIR) : routineTypeDefIR? =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:438:1-439:64:
   clause 0(p, TC, prefixedNameIR) = $find_non_overloaded<routineTypeDefIR>(TC.global.rdenv, id)
      -- if prefixedNameIR matches `.%`
      -- let . id = prefixedNameIR

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:440:1-441:64:
   clause 1(cursor, TC, prefixedNameIR) = $find_non_overloaded<routineTypeDefIR>(TC.global.rdenv, id)
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:442:1-444:67:
   clause 2(cursor, TC, prefixedNameIR) = ?(routineTypeDefIR)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_non_overloaded<routineTypeDefIR>(TC.block.rdenv, id)
      -- if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_)
      -- let ?(routineTypeDefIR) = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?}

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:445:1-448:67:
   clause 3(cursor, TC, prefixedNameIR) = $find_routine_non_overloaded(global, TC, ` id)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- if (?() = $find_non_overloaded<routineTypeDefIR>(TC.block.rdenv, id))

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:449:1-450:51:
   clause 4(cursor, TC, prefixedNameIR) = $find_routine_non_overloaded(block, TC, ` id)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:454:1-455:38:
def $find_constructor_overloaded(typingContext, prefixedNameIR, argumentIR*) : (rid, constructorTypeDefIR, id*)? =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:457:1-460:49:
   clause 0(TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if prefixedNameIR matches `.%`
      -- let . id = prefixedNameIR
      -- let cdenv = TC.global.cdenv
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:461:1-464:49:
   clause 1(TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let cdenv = TC.global.cdenv
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:468:1-468:47:
def $find_return_type(typingContext) : typeIR? =

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:470:1-471:48:
   clause 0(TC) = ?(typeIR_ret)
      -- let localKind = TC.local.kind
      -- if localKind matches `FUNCTION->%`
      -- let function-> typeIR_ret = localKind

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:472:1-473:55:
   clause 1(TC) = ?(typeIR_ret)
      -- let localKind = TC.local.kind
      -- if localKind matches `EXTERN_FUNCTION->%`
      -- let extern_function-> typeIR_ret = localKind

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:474:1-475:31:
   clause 2(TC) = ?(void as typeIR)
      -- if (action = TC.local.kind)

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:476:1-477:53:
   clause 3(TC) = ?(typeIR_ret)
      -- let localKind = TC.local.kind
      -- if localKind matches `EXTERN_METHOD->%`
      -- let extern_method-> typeIR_ret = localKind

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:478:1-480:22:
   clause 4(TC) = ?(typeIR_ret)
      -- let localKind = TC.local.kind
      -- if localKind matches `EXTERN_METHODABSTRACT->%`
      -- let extern_methodabstract-> typeIR_ret = localKind

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:481:1-482:45:
   clause 5(TC) = ?(void as typeIR)
      -- if (control_apply_method = TC.local.kind)

   ;; ../../../../reference-specs/p4-concrete/5.02-context.spectec:483:1-484:15:
   clause 6(TC) = ?()
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:5:19-5:31:
syntax matchKey = (typeIR, id)

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:7:22-7:72:
syntax matchAction = (prefixedNameIR, parameterTypeIR*, argumentListIR)

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:10:3-13:24:
syntax matchPriority = {values nat*, init bool, delta nat, largest_wins bool}

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:16:3-17:17:
syntax matchEntry = {size nat, const bool}

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:21:1-27:11:
syntax matchMode = 
   | nopri
   | noprilpm nat
   | pri
   | prilpm

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:30:3-34:21:
syntax tableContext = {keys matchKey*, actions matchAction*, priorities matchPriority, entries matchEntry, mode matchMode}

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:44:1-46:10:
syntax tableEntryState = 
   | lpm nat
   | nolpm

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:54:1-54:38:
def $empty_tableContext : tableContext =

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:55:1-68:25:
   clause 0 = {keys [], actions [], priorities matchPriority, entries matchEntry, mode nopri}
      -- let matchPriority = {values [], init false, delta 1, largest_wins true}
      -- let matchEntry = {size 0, const true}

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:76:1-76:54:
def $add_key(tableContext, id, typeIR) : tableContext =

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:78:1-80:32:
   clause 0(TBLC, id, typeIR) = TBLC[keys = TBLC.keys ++ [matchKey]]
      -- let matchKey = (typeIR, id)

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:84:1-84:95:
def $add_action(tableContext, prefixedNameIR, parameterTypeIR*, argumentListIR) : tableContext =

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:86:1-88:73:
   clause 0(TBLC, prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR) = TBLC[actions = TBLC.actions ++ [matchAction]]
      -- let matchAction = (prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR)

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:92:1-92:58:
def $add_table_priority(tableContext, nat) : tableContext =

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:94:1-95:65:
   clause 0(TBLC, n) = TBLC[priorities.values = TBLC.priorities.values ++ [n]]

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:103:1-103:58:
def $update_mode(tableContext, id, typeIR) : tableContext =

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:106:1-106:77:
   clause 0(TBLC, id, typeIR) = $update_mode'(TBLC, id, $canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:104:1-104:59:
def $update_mode'(tableContext, id, typeIR) : tableContext =

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:107:1-108:26:
   clause 0(TBLC, text, typeIR) = TBLC[mode = noprilpm n]
      -- if (text = "lpm")
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< n > = numberTypeIR
      -- if (TBLC.mode = nopri)

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:109:1-110:26:
   clause 1(TBLC, text, typeIR) = TBLC[mode = noprilpm n]
      -- if (text = "lpm")
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< n > = numberTypeIR
      -- if (TBLC.mode = nopri)

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:111:1-112:26:
   clause 2(TBLC, text, typeIR) = TBLC[mode = noprilpm n]
      -- if (text = "lpm")
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let varbit< n > = numberTypeIR
      -- if (TBLC.mode = nopri)

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:113:1-114:38:
   clause 3(TBLC, text, typeIR') = $update_mode(TBLC, "lpm", typeIR)
      -- if (text = "lpm")
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:115:1-116:24:
   clause 4(TBLC, text, _typeIR) = TBLC[mode = prilpm]
      -- if (text = "lpm")
      -- if (TBLC.mode = pri)

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:117:1-118:26:
   clause 5(TBLC, text, _typeIR) = TBLC[mode = pri]
      -- if (text = "range")
      -- if (TBLC.mode = nopri)

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:119:1-120:26:
   clause 6(TBLC, text, _typeIR) = TBLC[mode = pri]
      -- if (text = "ternary")
      -- if (TBLC.mode = nopri)

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:121:1-122:26:
   clause 7(TBLC, text, _typeIR) = TBLC[mode = pri]
      -- if (text = "optional")
      -- if (TBLC.mode = nopri)

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:123:1-124:31:
   clause 8(TBLC, text, _typeIR) = TBLC[mode = prilpm]
      -- if (text = "range")
      -- let matchMode = TBLC.mode
      -- if matchMode matches `NOPRILPM%`
      -- let noprilpm _nat = matchMode

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:125:1-126:31:
   clause 9(TBLC, text, _typeIR) = TBLC[mode = prilpm]
      -- if (text = "ternary")
      -- let matchMode = TBLC.mode
      -- if matchMode matches `NOPRILPM%`
      -- let noprilpm _nat = matchMode

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:127:1-128:31:
   clause 10(TBLC, text, _typeIR) = TBLC[mode = prilpm]
      -- if (text = "optional")
      -- let matchMode = TBLC.mode
      -- if matchMode matches `NOPRILPM%`
      -- let noprilpm _nat = matchMode

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:129:1-130:15:
   clause 11(TBLC, _id, _typeIR) = TBLC
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:138:1-138:85:
def $find_action(tableContext, prefixedNameIR) : (parameterTypeIR*, argumentListIR)? =

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:141:1-141:85:
   clause 0(TBLC, prefixedNameIR) = $find_action'(TBLC.actions, prefixedNameIR)

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:139:1-139:86:
def $find_action'(matchAction*, prefixedNameIR) : (parameterTypeIR*, argumentListIR)? =

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:143:1-143:45:
   clause 0(matchAction*{matchAction <- matchAction*}, prefixedNameIR) = ?()
      -- if matchAction*{matchAction <- matchAction*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:145:1-147:75:
   clause 1(matchAction*{matchAction <- matchAction*}, prefixedNameIR) = ?((parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR))
      -- if matchAction*{matchAction <- matchAction*} matches _ :: _
      -- let matchAction_h :: matchAction_t*{matchAction_t <- matchAction_t*} = matchAction*{matchAction <- matchAction*}
      -- let (prefixedNameIR', parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR) = matchAction_h
      -- if (prefixedNameIR' = prefixedNameIR)

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:149:1-152:44:
   clause 2(matchAction*{matchAction <- matchAction*}, prefixedNameIR) = $find_action'(matchAction_t*{matchAction_t <- matchAction_t*}, prefixedNameIR)
      -- if matchAction*{matchAction <- matchAction*} matches _ :: _
      -- let matchAction_h :: matchAction_t*{matchAction_t <- matchAction_t*} = matchAction*{matchAction <- matchAction*}
      -- let (prefixedNameIR_h, _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}, _argumentListIR) = matchAction_h
      -- if (prefixedNameIR_h =/= prefixedNameIR)

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:156:1-156:50:
def $find_table_priority_last(tableContext) : nat =

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:158:1-159:36:
   clause 0(TBLC) = n*{n <- n*}[(|n*{n <- n*}| - 1)]
      -- let n*{n <- n*} = TBLC.priorities.values

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:165:1-165:78:
def $join_tableEntryState(tableEntryState, tableEntryState) : tableEntryState =

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:167:1-167:48:
   clause 0(tableEntryState, tableEntryState') = lpm n
      -- if tableEntryState matches `NOLPM`
      -- if tableEntryState' matches `LPM%`
      -- let lpm n = tableEntryState'

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:168:1-168:48:
   clause 1(tableEntryState, tableEntryState') = lpm n
      -- if tableEntryState matches `LPM%`
      -- let lpm n = tableEntryState
      -- if tableEntryState' matches `NOLPM`

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:169:1-169:48:
   clause 2(tableEntryState, tableEntryState') = nolpm
      -- if tableEntryState matches `NOLPM`
      -- if tableEntryState' matches `NOLPM`

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:171:1-171:40:
def $tableEntry_lpm_prefix(value) : nat =

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:174:1-174:70:
   clause 0(value) = $tableEntry_lpm_prefix'(value, 0)

;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:172:1-172:46:
def $tableEntry_lpm_prefix'(value, nat) : nat =

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:175:1-175:56:
   clause 0(value, n_prefix) = n_prefix
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let nat w _int = number
      -- if (nat = 0)

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:176:1-180:43:
   clause 1(value, n_prefix) = $tableEntry_lpm_prefix'(value', (n_prefix + 1))
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w int = number
      -- if int <: nat
      -- let n = int as nat
      -- if (w > 0)
      -- if ((n \ 2) =/= 0)
      -- let value' = (w - 1) w ((n - 1) / 2) as int as value

   ;; ../../../../reference-specs/p4-concrete/5.03-table-context.spectec:181:1-185:37:
   clause 2(value, nat) = $tableEntry_lpm_prefix'(value', 0)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w w int = number
      -- if int <: nat
      -- let n = int as nat
      -- if (nat = 0)
      -- if (w > 0)
      -- if ((n \ 2) = 0)
      -- let value' = (w - 1) w (n / 2) as int as value

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:5:1-7:20:
relation Type_wf: bound |- typeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:82:1-83:22:
   rule basetype: bound |- typeIR
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:87:1-89:33:
   rule tid: bound |- typeIR
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid tid = namedTypeIR
      -- if $in_set<tid>(tid, bound)

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:91:1-94:30:
   rule spectype: bound |- typeIR'
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR
      -- let typeIR = $specialize_typeDef(polyTypeDefIR as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if Type_wf: bound |- typeIR holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:112:1-115:30:
   rule typedeftype: bound |- typeIR'
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let typedef _tid typeIR = aliasTypeIR
      -- if $nestable_typedef(typeIR)
      -- if Type_wf: bound |- typeIR holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:129:1-132:30:
   rule newtype: bound |- typeIR'
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid typeIR = aliasTypeIR
      -- if $nestable_new(typeIR)
      -- if Type_wf: bound |- typeIR holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:151:1-154:30:
   rule listttype: bound |- typeIR'
      -- if typeIR' <: listTypeIR
      -- let list< typeIR > = typeIR' as listTypeIR
      -- if $nestable_list(typeIR)
      -- if Type_wf: bound |- typeIR holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:177:1-180:33:
   rule tupletype: bound |- typeIR'
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
      -- (if $nestable_tuple(typeIR))*{typeIR <- typeIR*}
      -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:192:1-195:30:
   rule stacktype: bound |- typeIR'
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR
      -- if $nestable_stack(typeIR)
      -- if Type_wf: bound |- typeIR holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:218:1-222:33:
   rule structtype: bound |- typeIR'
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR id ;*{id <- id*, typeIR <- typeIR*} } = typeIR' as structTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if $nestable_struct(typeIR))*{typeIR <- typeIR*}
      -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:255:1-259:33:
   rule headertype: bound |- typeIR'
      -- if typeIR' <: headerTypeIR
      -- let header _tid { typeIR id ;*{id <- id*, typeIR <- typeIR*} } = typeIR' as headerTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if $nestable_header(typeIR))*{typeIR <- typeIR*}
      -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:272:1-276:33:
   rule headeruniontype: bound |- typeIR'
      -- if typeIR' <: headerUnionTypeIR
      -- let header_union _tid { typeIR id ;*{id <- id*, typeIR <- typeIR*} } = typeIR' as headerUnionTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if $nestable_headerunion(typeIR))*{typeIR <- typeIR*}
      -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:278:1-280:28:
   rule enumtype: bound |- typeIR
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum _tid { id*{id <- id*} } = enumTypeIR
      -- if $distinct_<id>(id*{id <- id*})

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:306:1-310:30:
   rule serenumtype: bound |- typeIR'
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # typeIR { id = _value ;*{_value <- _value*, id <- id*} } = enumTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- if $nestable_serenum(typeIR)
      -- if Type_wf: bound |- typeIR holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:314:1-316:53:
   rule externtype: bound |- typeIR
      -- if typeIR <: externObjectTypeIR
      -- let extern _tid { _rid : routineTypeDefIR*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} } = typeIR as externObjectTypeIR
      -- (if RoutineTypeDef_wf: bound |- routineTypeDefIR holds)*{routineTypeDefIR <- routineTypeDefIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:318:1-320:50:
   rule parsertype: bound |- typeIR
      -- if typeIR <: parserObjectTypeIR
      -- let parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as parserObjectTypeIR
      -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:322:1-324:50:
   rule controltype: bound |- typeIR
      -- if typeIR <: controlObjectTypeIR
      -- let control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as controlObjectTypeIR
      -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:326:1-328:33:
   rule packagetype: bound |- typeIR'
      -- if typeIR' <: packageObjectTypeIR
      -- let package< typeIR*{typeIR <- typeIR*} > = typeIR' as packageObjectTypeIR
      -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:330:1-333:30:
   rule tabletype: bound |- typeIR'
      -- if typeIR' <: tableObjectTypeIR
      -- let table _tid # typeIR = typeIR' as tableObjectTypeIR
      -- let typeIR'' = $canon(typeIR)
      -- if typeIR'' <: tableTypeIR
      -- let tableTypeIR = typeIR'' as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let table_struct _tid' { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = tableTypeIR
      -- if Type_wf: bound |- typeIR holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:337:1-338:19:
   rule defaulttype: bound |- typeIR
      -- if typeIR <: defaultTypeIR
      -- let defaultTypeIR = typeIR as defaultTypeIR
      -- if (defaultTypeIR = default)

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:340:1-342:33:
   rule sequencetype: bound |- typeIR'
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR*{typeIR <- typeIR*} > = sequenceTypeIR
      -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:344:1-346:33:
   rule sequencedefaulttype: bound |- typeIR'
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let seq< typeIR*{typeIR <- typeIR*} ,...> = sequenceTypeIR
      -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:348:1-351:33:
   rule recordtype: bound |- typeIR'
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR = typeIR' as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let record{ typeIR id ;*{id <- id*, typeIR <- typeIR*} } = recordTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:353:1-356:33:
   rule recorddefaulttype: bound |- typeIR'
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR = typeIR' as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let record{ typeIR id ;*{id <- id*, typeIR <- typeIR*} ,...} = recordTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:358:1-359:26:
   rule invalidtype: bound |- typeIR
      -- if typeIR <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR = typeIR as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR = header_invalid)

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:414:1-417:30:
   rule settype: bound |- typeIR''
      -- if typeIR'' <: setTypeIR
      -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
      -- if $nestable_set(typeIR)
      -- if Type_wf: bound |- typeIR holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:419:1-421:28:
   rule tableenumtype: bound |- typeIR
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_ENUM%{%}`
      -- let table_enum _tid { id*{id <- id*} } = tableTypeIR
      -- if $distinct_<id>(id*{id <- id*})

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:423:1-424:33:
   rule tablestructtype: bound |- typeIR
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let table_struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = tableTypeIR

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:9:1-11:20:
relation TypeDef_wf: bound |- typeDefIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:440:1-443:30:
   rule mono: bound |- typeDefIR
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR
      -- if $definable_type_mono(typeIR)
      -- if Type_wf: bound |- typeIR holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:459:1-465:36:
   rule poly: bound |- typeDefIR
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > = typeDefIR as polyTypeDefIR
      -- if $definable_type_poly(typeIR)
      -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
      -- let bound_inner = $union_set<tid>(bound, { tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} })
      -- if Type_wf: bound_inner |- typeIR holds

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:13:1-15:20:
relation ParameterType_wf: bound |- parameterTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:49:1-52:49:
   rule default-empty-extern: bound |- direction typeIR _id value?{value <- value?}
      -- if direction matches ``EMPTY`
      -- if value?{value <- value?} matches ()
      -- if Type_wf: bound |- typeIR holds
      -- if $is_extern_object_typeIR($canon(typeIR))

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:54:1-57:50:
   rule default-none-not-extern: bound |- direction typeIR _id value?{value <- value?}
      -- if value?{value <- value?} matches ()
      -- if Type_wf: bound |- typeIR holds
      -- if ~$is_extern_object_typeIR($canon(typeIR))

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:59:1-62:49:
   rule default-some-extern: bound |- direction typeIR _id value'?{value' <- value'?}
      -- if direction matches ``EMPTY`
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}
      -- if Type_wf: bound |- typeIR holds
      -- if $is_extern_object_typeIR($canon(typeIR))

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:64:1-68:45:
   rule default-some-not-extern: bound |- direction typeIR _id value'?{value' <- value'?}
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}
      -- if Type_wf: bound |- typeIR holds
      -- if ~$is_extern_object_typeIR($canon(typeIR))
      -- if ((direction = in) \/ (direction = ))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:17:1-19:20:
relation ParameterTypes_wf: bound |- parameterTypeIR*

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:70:1-74:51:
   rule : bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- (let _direction _typeIR id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
      -- if $distinct_<id>(id*{id <- id*})
      -- (if ParameterType_wf: bound |- parameterTypeIR holds)*{parameterTypeIR <- parameterTypeIR*}

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:21:1-23:20:
relation RoutineType_wf: bound |- routineTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:473:1-476:34:
   rule builtinfunction: bound |- routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let builtin_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
      -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound |- typeIR_ret holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:491:1-496:34:
   rule functiontype: bound |- routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
      -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_function(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
      -- if Type_wf: bound |- typeIR_ret holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:524:1-529:45:
   rule actiontype: bound |- routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
      -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- if $directionless_trailing(direction*{direction <- direction*})
      -- (if $nestable_action(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:547:1-552:34:
   rule externfunctiontype: bound |- routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let extern_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
      -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_externfunction(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
      -- if Type_wf: bound |- typeIR_ret holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:556:1-559:34:
   rule builtinmethod: bound |- routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let builtin_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
      -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound |- typeIR_ret holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:577:1-582:34:
   rule externmethod: bound |- routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
      -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_externmethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
      -- if Type_wf: bound |- typeIR_ret holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:600:1-605:34:
   rule externabstractmethod: bound |- routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
      -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_externabstractmethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
      -- if Type_wf: bound |- typeIR_ret holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:623:1-627:56:
   rule parserapplymethod: bound |- routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
      -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_parserapplymethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:644:1-648:57:
   rule controlapplymethod: bound |- routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
      -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_controlapplymethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:650:1-651:51:
   rule tableapplymethod: bound |- routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let table_apply-> typeIR = methodTypeIR
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let table_struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = tableTypeIR

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:25:1-27:20:
relation RoutineTypeDef_wf: bound |- routineTypeDefIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:668:1-671:44:
   rule mono: bound |- routineTypeDefIR
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR = routineTypeDefIR as routineTypeIR
      -- if $definable_routine_mono(routineTypeIR)
      -- if RoutineType_wf: bound |- routineTypeIR holds

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:682:1-688:50:
   rule poly: bound |- routineTypeDefIR
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > = routineTypeDefIR as polyRoutineTypeDefIR
      -- if $definable_routine_poly(routineTypeIR)
      -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
      -- let bound_inner = $union_set<tid>(bound, { tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} })
      -- if RoutineType_wf: bound_inner |- routineTypeIR holds

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:29:1-31:20:
relation ConstructorParameterType_wf: bound |- parameterTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:694:1-696:30:
   rule : bound |- direction typeIR _id _value?{_value <- _value?}
      -- if direction matches ``EMPTY`
      -- if Type_wf: bound |- typeIR holds

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:33:1-35:20:
relation ConstructorParameterTypes_wf: bound |- parameterTypeIR*

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:698:1-702:62:
   rule : bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- (let _direction _typeIR id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
      -- if $distinct_<id>(id*{id <- id*})
      -- (if ConstructorParameterType_wf: bound |- parameterTypeIR holds)*{parameterTypeIR <- parameterTypeIR*}

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:37:1-39:20:
relation ConstructorType_wf: bound |- constructorTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:720:1-726:46:
   rule externtype: bound |- constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object
      -- if ConstructorParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound |- typeIR_object holds
      -- let typeIR' = $canon(typeIR_object)
      -- if typeIR' <: externObjectTypeIR
      -- let extern _tid _map<rid, routineTypeDefIR> = typeIR' as externObjectTypeIR
      -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_constructor_extern(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:739:1-745:46:
   rule parsertype: bound |- constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object
      -- if ConstructorParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound |- typeIR_object holds
      -- let typeIR' = $canon(typeIR_object)
      -- if typeIR' <: parserObjectTypeIR
      -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR' as parserObjectTypeIR
      -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_constructor_parser(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:758:1-764:47:
   rule controltype: bound |- constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object
      -- if ConstructorParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound |- typeIR_object holds
      -- let typeIR' = $canon(typeIR_object)
      -- if typeIR' <: controlObjectTypeIR
      -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR' as controlObjectTypeIR
      -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_constructor_control(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:775:1-781:47:
   rule packagetype: bound |- constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object
      -- if ConstructorParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound |- typeIR_object holds
      -- let typeIR' = $canon(typeIR_object)
      -- if typeIR' <: packageObjectTypeIR
      -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR' as packageObjectTypeIR
      -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_constructor_package(typeIR))*{typeIR <- typeIR*}

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:41:1-43:20:
relation ConstructorTypeDef_wf: bound |- constructorTypeDefIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:799:1-806:58:
   rule : bound |- constructorTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >
      -- let constructor( _constructorParameterTypeIR*{_constructorParameterTypeIR <- _constructorParameterTypeIR*} )-> typeIR_object = constructorTypeIR
      -- if $definable_constructor(typeIR_object)
      -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
      -- let bound_inner = $union_set<tid>(bound, { tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} })
      -- if ConstructorType_wf: bound_inner |- constructorTypeIR holds

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:98:1-98:37:
def $nestable_typedef(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:101:1-101:67:
   clause 0(typeIR) = $nestable'_typedef($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:99:1-99:38:
def $nestable'_typedef(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:102:1-102:36:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:103:1-103:37:
   clause 1(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ERROR`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:104:1-104:38:
   clause 2(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `STRING`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:105:1-105:44:
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:106:1-106:37:
   clause 4(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid _tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:107:1-107:40:
   clause 5(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid _typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:108:1-108:42:
   clause 6(typeIR) = true
      -- if typeIR <: dataTypeIR
      -- let dataTypeIR = typeIR as dataTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:109:1-110:15:
   clause 7(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:117:1-117:33:
def $nestable_new(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:120:1-120:59:
   clause 0(typeIR) = $nestable'_new($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:118:1-118:34:
def $nestable'_new(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:121:1-121:32:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:122:1-122:38:
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:123:1-123:38:
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:124:1-124:33:
   clause 3(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid _tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:125:1-125:36:
   clause 4(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid _typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:126:1-127:15:
   clause 5(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:136:1-136:34:
def $nestable_list(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:139:1-139:61:
   clause 0(typeIR) = $nestable'_list($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:137:1-137:35:
def $nestable'_list(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:140:1-140:33:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:141:1-141:34:
   clause 1(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ERROR`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:142:1-142:39:
   clause 2(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `MATCH_KIND`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:143:1-143:35:
   clause 3(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `STRING`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:144:1-144:41:
   clause 4(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:145:1-145:34:
   clause 5(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid _tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:146:1-146:37:
   clause 6(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid _typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:147:1-147:39:
   clause 7(typeIR) = true
      -- if typeIR <: dataTypeIR
      -- let dataTypeIR = typeIR as dataTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:148:1-149:15:
   clause 8(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:156:1-156:35:
def $nestable_tuple(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:159:1-159:63:
   clause 0(typeIR) = $nestable'_tuple($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:157:1-157:36:
def $nestable'_tuple(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:160:1-160:34:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:161:1-161:35:
   clause 1(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ERROR`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:162:1-162:40:
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:163:1-163:40:
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:164:1-164:43:
   clause 4(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let varbit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:165:1-165:35:
   clause 5(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid _tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:166:1-166:38:
   clause 6(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid _typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:167:1-167:42:
   clause 7(typeIR) = true
      -- if typeIR <: tupleTypeIR
      -- let tuple< _typeIR*{_typeIR <- _typeIR*} > = typeIR as tupleTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:168:1-168:43:
   clause 8(typeIR') = true
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:169:1-169:45:
   clause 9(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:170:1-170:51:
   clause 10(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:171:1-171:45:
   clause 11(typeIR) = true
      -- if typeIR <: structTypeIR
      -- let struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as structTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:172:1-172:43:
   clause 12(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:173:1-173:48:
   clause 13(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:174:1-175:15:
   clause 14(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:182:1-182:35:
def $nestable_stack(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:185:1-185:63:
   clause 0(typeIR) = $nestable'_stack($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:183:1-183:36:
def $nestable'_stack(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:186:1-186:35:
   clause 0(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid _tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:187:1-187:45:
   clause 1(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:188:1-188:51:
   clause 2(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:189:1-190:15:
   clause 3(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:197:1-197:36:
def $nestable_struct(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:200:1-200:65:
   clause 0(typeIR) = $nestable'_struct($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:198:1-198:37:
def $nestable'_struct(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:201:1-201:35:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:202:1-202:36:
   clause 1(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ERROR`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:203:1-203:41:
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:204:1-204:41:
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:205:1-205:44:
   clause 4(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let varbit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:206:1-206:36:
   clause 5(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid _tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:207:1-207:39:
   clause 6(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid _typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:208:1-208:43:
   clause 7(typeIR) = true
      -- if typeIR <: tupleTypeIR
      -- let tuple< _typeIR*{_typeIR <- _typeIR*} > = typeIR as tupleTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:209:1-209:44:
   clause 8(typeIR') = true
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:210:1-210:46:
   clause 9(typeIR) = true
      -- if typeIR <: structTypeIR
      -- let struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as structTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:211:1-211:46:
   clause 10(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:212:1-212:52:
   clause 11(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:213:1-213:44:
   clause 12(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:214:1-214:49:
   clause 13(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:215:1-216:15:
   clause 14(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:224:1-224:36:
def $nestable_header(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:229:1-229:65:
   clause 0(typeIR) = $nestable'_header($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:225:1-225:37:
def $nestable'_header(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:230:1-230:35:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:231:1-231:41:
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:232:1-232:41:
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:233:1-233:44:
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let varbit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:234:1-234:36:
   clause 4(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid _tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:235:1-235:39:
   clause 5(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid _typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:236:1-236:49:
   clause 6(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:237:1-238:44:
   clause 7(typeIR') = true
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR
      -- (if $nestable_struct_in_header(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:239:1-240:15:
   clause 8(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:226:1-226:46:
def $nestable_struct_in_header(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:242:1-243:48:
   clause 0(typeIR) = $nestable'_struct_in_header($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:227:1-227:47:
def $nestable'_struct_in_header(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:244:1-244:45:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:245:1-245:51:
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:246:1-246:51:
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:247:1-247:46:
   clause 3(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid _tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:248:1-248:49:
   clause 4(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid _typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:249:1-249:59:
   clause 5(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:250:1-251:44:
   clause 6(typeIR') = true
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR
      -- (if $nestable_struct_in_header(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:252:1-253:15:
   clause 7(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:261:1-261:41:
def $nestable_headerunion(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:264:1-265:43:
   clause 0(typeIR) = $nestable'_headerunion($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:262:1-262:42:
def $nestable'_headerunion(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:266:1-266:41:
   clause 0(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid _tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:267:1-267:44:
   clause 1(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid _typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:268:1-268:51:
   clause 2(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:269:1-270:15:
   clause 3(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:282:1-282:37:
def $nestable_serenum(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:287:1-288:39:
   clause 0(typeIR) = $nestable'_serenum($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:283:1-283:38:
def $nestable'_serenum(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:289:1-289:42:
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:290:1-290:42:
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:291:1-291:37:
   clause 2(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid _tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:292:1-293:37:
   clause 3(typeIR') = $nestable_new_in_serenum(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:294:1-295:15:
   clause 4(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:284:1-284:44:
def $nestable_new_in_serenum(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:297:1-298:46:
   clause 0(typeIR) = $nestable_new_in_serenum'($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:285:1-285:45:
def $nestable_new_in_serenum'(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:299:1-299:49:
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:300:1-300:49:
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:301:1-301:44:
   clause 2(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid _tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:302:1-302:47:
   clause 3(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid _typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:303:1-304:15:
   clause 4(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:361:1-361:33:
def $nestable_set(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:368:1-368:59:
   clause 0(typeIR) = $nestable'_set($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:362:1-362:34:
def $nestable'_set(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:369:1-369:32:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:370:1-370:33:
   clause 1(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ERROR`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:371:1-371:38:
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:372:1-372:38:
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:373:1-373:33:
   clause 4(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid _tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:374:1-374:36:
   clause 5(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid _typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:375:1-376:40:
   clause 6(typeIR') = true
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
      -- (if $nestable_tuple_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:377:1-377:41:
   clause 7(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:378:1-378:46:
   clause 8(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:379:1-380:43:
   clause 9(typeIR') = true
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR*{typeIR <- typeIR*} > = sequenceTypeIR
      -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:381:1-382:15:
   clause 10(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:363:1-363:42:
def $nestable_tuple_in_set(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:384:1-385:44:
   clause 0(typeIR) = $nestable'_tuple_in_set($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:364:1-364:43:
def $nestable'_tuple_in_set(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:386:1-386:41:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:387:1-387:47:
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:388:1-388:47:
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:389:1-389:42:
   clause 3(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid _tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:390:1-390:45:
   clause 4(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid _typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:391:1-392:40:
   clause 5(typeIR') = true
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
      -- (if $nestable_tuple_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:393:1-393:50:
   clause 6(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:394:1-394:55:
   clause 7(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:395:1-396:15:
   clause 8(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:365:1-365:45:
def $nestable_sequence_in_set(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:398:1-399:47:
   clause 0(typeIR) = $nestable'_sequence_in_set($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:366:1-366:46:
def $nestable'_sequence_in_set(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:400:1-400:44:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:401:1-401:50:
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:402:1-402:50:
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:403:1-403:45:
   clause 3(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid _tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:404:1-404:48:
   clause 4(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid _typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:405:1-406:43:
   clause 5(typeIR') = true
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
      -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:407:1-407:53:
   clause 6(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:408:1-408:58:
   clause 7(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:409:1-410:43:
   clause 8(typeIR') = true
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR*{typeIR <- typeIR*} > = sequenceTypeIR
      -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:411:1-412:15:
   clause 9(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:430:1-430:40:
def $definable_type_mono(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:432:1-432:39:
   clause 0(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid _tid = namedTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:433:1-433:45:
   clause 1(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:434:1-434:47:
   clause 2(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:435:1-435:52:
   clause 3(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:436:1-436:46:
   clause 4(typeIR) = true
      -- if typeIR <: tableObjectTypeIR
      -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:437:1-438:15:
   clause 5(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:445:1-445:40:
def $definable_type_poly(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:447:1-447:46:
   clause 0(typeIR) = true
      -- if typeIR <: tupleTypeIR
      -- let tuple< _typeIR*{_typeIR <- _typeIR*} > = typeIR as tupleTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:448:1-448:42:
   clause 1(typeIR) = true
      -- if typeIR <: headerStackTypeIR
      -- let _typeIR [ _nat ] = typeIR as headerStackTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:449:1-449:49:
   clause 2(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:450:1-450:55:
   clause 3(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:451:1-451:49:
   clause 4(typeIR) = true
      -- if typeIR <: structTypeIR
      -- let struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as structTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:452:1-452:44:
   clause 5(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let extern _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:453:1-453:47:
   clause 6(typeIR) = true
      -- if typeIR <: parserObjectTypeIR
      -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:454:1-454:48:
   clause 7(typeIR) = true
      -- if typeIR <: controlObjectTypeIR
      -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:455:1-455:48:
   clause 8(typeIR) = true
      -- if typeIR <: packageObjectTypeIR
      -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:456:1-457:15:
   clause 9(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:478:1-478:49:
def $nestable_function(direction, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:481:1-482:51:
   clause 0(direction, typeIR) = $nestable_function'(direction, $canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:479:1-479:50:
def $nestable_function'(direction, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:483:1-484:29:
   clause 0(direction, typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `STRING`
      -- if (direction =/= )

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:485:1-486:29:
   clause 1(direction, typeIR) = false
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if (direction =/= )

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:487:1-487:57:
   clause 2(direction, typeIR) = false
      -- if typeIR <: objectTypeIR
      -- let objectTypeIR = typeIR as objectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:488:1-489:15:
   clause 3(_direction, _typeIR) = true
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:498:1-498:47:
def $directionless_trailing(direction*) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:501:1-502:65:
   clause 0(direction*{direction <- direction*}) = $directionless_trailing'(true, $rev_<direction>(direction*{direction <- direction*}))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:499:1-499:54:
def $directionless_trailing'(bool, direction*) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:504:1-504:44:
   clause 0(_bool, direction*{direction <- direction*}) = true
      -- if direction*{direction <- direction*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:505:1-506:49:
   clause 1(bool, direction'*{direction' <- direction'*}) = $directionless_trailing'(true, direction_t*{direction_t <- direction_t*})
      -- if (bool = true)
      -- if direction'*{direction' <- direction'*} matches _ :: _
      -- let direction :: direction_t*{direction_t <- direction_t*} = direction'*{direction' <- direction'*}
      -- if direction matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:507:1-507:68:
   clause 2(bool, direction'*{direction' <- direction'*}) = false
      -- if (bool = false)
      -- if direction'*{direction' <- direction'*} matches _ :: _
      -- let direction :: direction_t*{direction_t <- direction_t*} = direction'*{direction' <- direction'*}
      -- if direction matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:508:1-510:31:
   clause 3(_bool, direction*{direction <- direction*}) = $directionless_trailing'(false, direction_t*{direction_t <- direction_t*})
      -- if direction*{direction <- direction*} matches _ :: _
      -- let direction_h :: direction_t*{direction_t <- direction_t*} = direction*{direction <- direction*}
      -- if (direction_h =/= )

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:512:1-512:47:
def $nestable_action(direction, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:515:1-516:49:
   clause 0(direction, typeIR) = $nestable_action'(direction, $canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:513:1-513:48:
def $nestable_action'(direction, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:517:1-518:29:
   clause 0(direction, typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `STRING`
      -- if (direction =/= )

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:519:1-519:38:
   clause 1(_direction, typeIR) = false
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:520:1-520:47:
   clause 2(_direction, typeIR) = false
      -- if typeIR <: objectTypeIR
      -- let objectTypeIR = typeIR as objectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:521:1-522:15:
   clause 3(_direction, _typeIR) = true
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:531:1-531:55:
def $nestable_externfunction(direction, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:534:1-535:57:
   clause 0(direction, typeIR) = $nestable_externfunction'(direction, $canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:532:1-532:56:
def $nestable_externfunction'(direction, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:536:1-537:29:
   clause 0(direction, typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `STRING`
      -- if (direction =/= )

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:538:1-539:29:
   clause 1(direction, typeIR) = false
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if (direction =/= )

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:540:1-540:64:
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:541:1-541:65:
   clause 3(direction, typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:542:1-542:65:
   clause 4(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:543:1-543:63:
   clause 5(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:544:1-545:15:
   clause 6(_direction, _typeIR) = true
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:561:1-561:53:
def $nestable_externmethod(direction, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:564:1-565:55:
   clause 0(direction, typeIR) = $nestable_externmethod'(direction, $canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:562:1-562:54:
def $nestable_externmethod'(direction, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:566:1-567:29:
   clause 0(direction, typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `STRING`
      -- if (direction =/= )

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:568:1-569:29:
   clause 1(direction, typeIR) = false
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if (direction =/= )

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:570:1-570:62:
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:571:1-571:63:
   clause 3(direction, typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:572:1-572:63:
   clause 4(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:573:1-573:61:
   clause 5(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:574:1-575:15:
   clause 6(_direction, _typeIR) = true
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:584:1-584:61:
def $nestable_externabstractmethod(direction, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:587:1-588:63:
   clause 0(direction, typeIR) = $nestable_externabstractmethod'(direction, $canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:585:1-585:62:
def $nestable_externabstractmethod'(direction, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:589:1-590:29:
   clause 0(direction, typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `STRING`
      -- if (direction =/= )

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:591:1-592:29:
   clause 1(direction, typeIR) = false
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if (direction =/= )

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:593:1-593:70:
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:594:1-594:71:
   clause 3(direction, typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:595:1-595:71:
   clause 4(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:596:1-596:69:
   clause 5(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:597:1-598:15:
   clause 6(_direction, _typeIR) = true
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:607:1-607:58:
def $nestable_parserapplymethod(direction, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:610:1-611:60:
   clause 0(direction, typeIR) = $nestable_parserapplymethod'(direction, $canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:608:1-608:59:
def $nestable_parserapplymethod'(direction, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:612:1-613:29:
   clause 0(direction, typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `STRING`
      -- if (direction =/= )

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:614:1-615:29:
   clause 1(direction, typeIR) = false
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if (direction =/= )

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:616:1-616:67:
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:617:1-617:68:
   clause 3(direction, typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:618:1-618:68:
   clause 4(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:619:1-619:66:
   clause 5(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:620:1-621:15:
   clause 6(_direction, _typeIR) = true
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:629:1-629:59:
def $nestable_controlapplymethod(direction, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:632:1-633:61:
   clause 0(direction, typeIR) = $nestable_controlapplymethod'(direction, $canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:630:1-630:60:
def $nestable_controlapplymethod'(direction, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:634:1-635:29:
   clause 0(direction, typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `STRING`
      -- if (direction =/= )

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:636:1-637:29:
   clause 1(direction, typeIR) = false
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if (direction =/= )

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:638:1-638:68:
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:639:1-639:69:
   clause 3(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:640:1-640:67:
   clause 4(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:641:1-642:15:
   clause 5(_direction, _typeIR) = true
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:657:1-657:50:
def $definable_routine_mono(routineTypeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:659:1-659:66:
   clause 0(routineTypeIR) = true
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let builtin_function( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = functionTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:660:1-660:50:
   clause 1(routineTypeIR) = true
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let action( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = functionTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:661:1-661:64:
   clause 2(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let builtin_method( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = methodTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:662:1-662:56:
   clause 3(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let parser_apply( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = methodTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:663:1-663:57:
   clause 4(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let control_apply( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = methodTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:664:1-664:54:
   clause 5(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let table_apply-> _typeIR = methodTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:665:1-666:15:
   clause 6(_routineTypeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:673:1-673:50:
def $definable_routine_poly(routineTypeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:675:1-675:58:
   clause 0(routineTypeIR) = true
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let function( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = functionTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:676:1-676:65:
   clause 1(routineTypeIR) = true
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let extern_function( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = functionTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:677:1-677:63:
   clause 2(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let extern_method( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = methodTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:678:1-678:72:
   clause 3(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let extern_methodabstract( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = methodTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:679:1-680:15:
   clause 4(_routineTypeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:708:1-708:48:
def $nestable_constructor_extern(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:711:1-712:50:
   clause 0(typeIR) = $nestable'_constructor_extern($canon(typeIR))

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:713:1-713:56:
   clause 1(typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:709:1-709:49:
def $nestable'_constructor_extern(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:714:1-714:58:
   clause 0(typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:715:1-715:58:
   clause 1(typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:716:1-716:56:
   clause 2(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:717:1-718:15:
   clause 3(_typeIR) = true
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:728:1-728:48:
def $nestable_constructor_parser(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:731:1-732:50:
   clause 0(typeIR) = $nestable'_constructor_parser($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:729:1-729:49:
def $nestable'_constructor_parser(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:733:1-733:58:
   clause 0(typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:734:1-734:58:
   clause 1(typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:735:1-735:56:
   clause 2(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:736:1-737:15:
   clause 3(_typeIR) = true
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:747:1-747:49:
def $nestable_constructor_control(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:750:1-751:51:
   clause 0(typeIR) = $nestable'_constructor_control($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:748:1-748:50:
def $nestable'_constructor_control(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:752:1-752:58:
   clause 0(typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:753:1-753:59:
   clause 1(typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:754:1-754:57:
   clause 2(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:755:1-756:15:
   clause 3(_typeIR) = true
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:766:1-766:49:
def $nestable_constructor_package(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:769:1-770:51:
   clause 0(typeIR) = $nestable'_constructor_package($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:767:1-767:50:
def $nestable'_constructor_package(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:771:1-771:57:
   clause 0(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:772:1-773:15:
   clause 1(_typeIR) = true
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:787:1-787:42:
def $definable_constructor(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:790:1-791:44:
   clause 0(typeIR) = $definable'_constructor($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:788:1-788:43:
def $definable'_constructor(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:792:1-792:47:
   clause 0(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let extern _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:793:1-793:50:
   clause 1(typeIR) = true
      -- if typeIR <: parserObjectTypeIR
      -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:794:1-794:51:
   clause 2(typeIR) = true
      -- if typeIR <: controlObjectTypeIR
      -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:795:1-795:51:
   clause 3(typeIR) = true
      -- if typeIR <: packageObjectTypeIR
      -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.03-wellformed.spectec:796:1-797:15:
   clause 4(_typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:6:1-8:23:
relation Eval_static: cursor typingContext |- typedExpressionIR ~> value

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:16:1-17:37:
   rule literalExpressionIR-true: p TC |- expressionIR # ( _typeIR _ctk ) ~> b true as value
      -- if expressionIR <: literalExpression
      -- let literalExpression = expressionIR as literalExpression
      -- if literalExpression matches `TRUE`

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:19:1-20:39:
   rule literalExpressionIR-false: p TC |- expressionIR # ( _typeIR _ctk ) ~> b false as value
      -- if expressionIR <: literalExpression
      -- let literalExpression = expressionIR as literalExpression
      -- if literalExpression matches `FALSE`

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:24:1-25:35:
   rule literalExpressionIR-number-arbint: p TC |- expressionIR # ( _typeIR _ctk ) ~> d i as value
      -- if expressionIR <: number
      -- let number = expressionIR as number
      -- if number matches `D%`
      -- let d i = number

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:27:1-28:39:
   rule literalExpressionIR-number-fixbit: p TC |- expressionIR # ( _typeIR _ctk ) ~> n w i as value
      -- if expressionIR <: number
      -- let number = expressionIR as number
      -- if number matches `%W%`
      -- let n w i = number

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:30:1-31:39:
   rule literalExpressionIR-number-fixint: p TC |- expressionIR # ( _typeIR _ctk ) ~> n s i as value
      -- if expressionIR <: number
      -- let number = expressionIR as number
      -- if number matches `%S%`
      -- let n s i = number

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:35:1-36:49:
   rule literalExpressionIR-stringliteral: p TC |- expressionIR # ( _typeIR _ctk ) ~> " text " as value
      -- if expressionIR <: stringLiteral
      -- let " text " = expressionIR as stringLiteral

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:41:1-43:51:
   rule referenceExpression: p TC |- expressionIR # ( _typeIR _ctk ) ~> value
      -- if expressionIR <: prefixedNameIR
      -- let prefixedNameIR = expressionIR as prefixedNameIR
      -- let value = $find_value(p, TC, prefixedNameIR)

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:48:1-49:38:
   rule defaultExpressionIR: p TC |- expressionIR # ( _typeIR _ctk ) ~> default as value
      -- if expressionIR <: defaultExpression
      -- let defaultExpression = expressionIR as defaultExpression
      -- if (defaultExpression = ...)

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:54:1-56:53:
   rule unaryExpressionIR-bnot: p TC |- expressionIR # ( _typeIR _ctk ) ~> $un_bnot(value)
      -- if expressionIR <: unaryExpressionIR
      -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
      -- if unop matches `~`
      -- Eval_static: p TC |- typedExpressionIR ~> value

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:58:1-60:53:
   rule unaryExpressionIR-lnot: p TC |- expressionIR # ( _typeIR _ctk ) ~> $un_lnot(value)
      -- if expressionIR <: unaryExpressionIR
      -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
      -- if unop matches `!`
      -- Eval_static: p TC |- typedExpressionIR ~> value

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:62:1-64:53:
   rule unaryExpressionIR-plus: p TC |- expressionIR # ( _typeIR _ctk ) ~> $un_plus(value)
      -- if expressionIR <: unaryExpressionIR
      -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
      -- if unop matches `+`
      -- Eval_static: p TC |- typedExpressionIR ~> value

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:66:1-68:53:
   rule unaryExpressionIR-minus: p TC |- expressionIR # ( _typeIR _ctk ) ~> $un_minus(value)
      -- if expressionIR <: unaryExpressionIR
      -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
      -- if unop matches `-`
      -- Eval_static: p TC |- typedExpressionIR ~> value

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:74:1-78:57:
   rule binaryExpressionIR-plus: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_plus(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `+`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:80:1-84:57:
   rule binaryExpressionIR-satplus: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_satplus(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `|+|`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:86:1-90:57:
   rule binaryExpressionIR-minus: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_minus(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `-`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:92:1-96:57:
   rule binaryExpressionIR-satminus: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_satminus(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `|-|`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:98:1-102:57:
   rule binaryExpressionIR-mul: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_mul(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `*`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:104:1-108:57:
   rule binaryExpressionIR-div: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_div(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `/`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:110:1-114:57:
   rule binaryExpressionIR-shl: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_shl(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `<<`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:116:1-120:57:
   rule binaryExpressionIR-shr: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_shr(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `>>`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:122:1-126:57:
   rule binaryExpressionIR-le: p TC |- expressionIR # ( _typeIR _ctk ) ~> b $bin_le(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `<=`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:128:1-132:57:
   rule binaryExpressionIR-ge: p TC |- expressionIR # ( _typeIR _ctk ) ~> b $bin_ge(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `>=`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:134:1-138:57:
   rule binaryExpressionIR-lt: p TC |- expressionIR # ( _typeIR _ctk ) ~> b $bin_lt(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `<`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:140:1-144:57:
   rule binaryExpressionIR-gt: p TC |- expressionIR # ( _typeIR _ctk ) ~> b $bin_gt(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `>`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:146:1-150:57:
   rule binaryExpressionIR-eq: p TC |- expressionIR # ( _typeIR _ctk ) ~> b $bin_eq(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `==`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:152:1-156:57:
   rule binaryExpressionIR-ne: p TC |- expressionIR # ( _typeIR _ctk ) ~> b $bin_ne(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `!=`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:158:1-162:57:
   rule binaryExpressionIR-band: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_band(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `&`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:164:1-168:57:
   rule binaryExpressionIR-bxor: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_bxor(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `^`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:170:1-174:57:
   rule binaryExpressionIR-bor: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_bor(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `|`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:176:1-180:57:
   rule binaryExpressionIR-concat: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_concat(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `++`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:182:1-186:57:
   rule binaryExpressionIR-land: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_land(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `&&`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:188:1-192:57:
   rule binaryExpressionIR-lor: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_lor(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `||`
      -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
      -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:198:1-203:63:
   rule ternaryExpressionIR-true: p TC |- expressionIR # ( _typeIR _ctk ) ~> value_true
      -- if expressionIR <: ternaryExpressionIR
      -- let typedExpressionIR_cond ? typedExpressionIR_true : typedExpressionIR_false = expressionIR as ternaryExpressionIR
      -- Eval_static: p TC |- typedExpressionIR_cond ~> value
      -- if (value = b true as value)
      -- Eval_static: p TC |- typedExpressionIR_true ~> value_true

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:205:1-210:65:
   rule ternaryExpressionIR-false: p TC |- expressionIR # ( _typeIR _ctk ) ~> value_false
      -- if expressionIR <: ternaryExpressionIR
      -- let typedExpressionIR_cond ? typedExpressionIR_true : typedExpressionIR_false = expressionIR as ternaryExpressionIR
      -- Eval_static: p TC |- typedExpressionIR_cond ~> value
      -- if (value = b false as value)
      -- Eval_static: p TC |- typedExpressionIR_false ~> value_false

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:215:1-218:45:
   rule castExpression: p TC |- expressionIR # ( _typeIR _ctk ) ~> value_cast
      -- if expressionIR <: castExpressionIR
      -- let ( typeIR ) typedExpressionIR = expressionIR as castExpressionIR
      -- Eval_static: p TC |- typedExpressionIR ~> value
      -- let value_cast = $cast_op(typeIR, value)

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:225:1-226:35:
   rule dataExpressionIR-invalid: p TC |- expressionIR # ( _typeIR _ctk ) ~> {#} as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `{#}`

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:230:1-232:56:
   rule dataExpressionIR-sequence: p TC |- expressionIR # ( _typeIR _ctk ) ~> seq( value*{value <- value*} ) as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `SEQ{%}`
      -- let seq{ typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} } = dataExpressionIR
      -- (Eval_static: p TC |- typedExpressionIR ~> value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:236:1-238:56:
   rule dataExpressionIR-sequence-default: p TC |- expressionIR # ( _typeIR _ctk ) ~> seq( value*{value <- value*} ,...) as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `SEQ{%,...}`
      -- let seq{ typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} ,...} = dataExpressionIR
      -- (Eval_static: p TC |- typedExpressionIR ~> value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:242:1-245:56:
   rule dataExpressionIR-record: p TC |- expressionIR # ( _typeIR _ctk ) ~> record{ value nameIR ;*{nameIR <- nameIR*, value <- value*} } as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `RECORD{%}`
      -- let record{ nameIR = typedExpressionIR*{nameIR <- nameIR*, typedExpressionIR <- typedExpressionIR*} } = dataExpressionIR
      -- (Eval_static: p TC |- typedExpressionIR ~> value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:249:1-252:56:
   rule dataExpressionIR-record-default: p TC |- expressionIR # ( _typeIR _ctk ) ~> record{ value nameIR ;*{nameIR <- nameIR*, value <- value*} ,...} as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `RECORD{%,...}`
      -- let record{ nameIR = typedExpressionIR*{nameIR <- nameIR*, typedExpressionIR <- typedExpressionIR*} ,...} = dataExpressionIR
      -- (Eval_static: p TC |- typedExpressionIR ~> value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:260:1-263:58:
   rule errorAccessExpressionIR: p TC |- expressionIR # ( _typeIR _ctk ) ~> value_error
      -- if expressionIR <: errorAccessExpressionIR
      -- let error. nameIR = expressionIR as errorAccessExpressionIR
      -- let nameIR_error = "error." ++ nameIR
      -- let value_error = $find_value(p, TC, ` nameIR_error)

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:271:1-275:29:
   rule memberAccessExpressionIR-prefixedNameIR-enum: p TC |- expressionIR # ( typeIR_base _ctk ) ~> tid . nameIR as value
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessBaseIR . nameIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessBaseIR matches `TYPE%`
      -- let type prefixedNameIR = memberAccessBaseIR
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: enumTypeIR
      -- let enumTypeIR = typeDefIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum tid { id_member*{id_member <- id_member*} } = enumTypeIR
      -- if nameIR <- id_member*{id_member <- id_member*}

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:277:1-283:63:
   rule memberAccessExpressionIR-prefixedNameIR-serenum: p TC |- expressionIR # ( typeIR_base _ctk ) ~> tid . nameIR # value as value
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessBaseIR . nameIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessBaseIR matches `TYPE%`
      -- let type prefixedNameIR = memberAccessBaseIR
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: enumTypeIR
      -- let enumTypeIR = typeDefIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum tid # typeIR { id_member = value_member ;*{id_member <- id_member*, value_member <- value_member*} } = enumTypeIR
      -- let value'?{value' <- value'?} = $assoc_<id, value>(nameIR, (id_member, value_member)*{id_member <- id_member*, value_member <- value_member*})
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:288:1-291:36:
   rule memberAccessExpressionIR-typedExpressionIR-stack-size: p TC |- expressionIR # ( typeIR_base _ctk ) ~> d n_size as int as value
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessBaseIR . text = expressionIR as memberAccessExpressionIR
      -- if memberAccessBaseIR <: typedExpressionIR
      -- let typedExpressionIR_base = memberAccessBaseIR as typedExpressionIR
      -- if (text = "size")
      -- let typeIR = typeIR_base
      -- if typeIR <: headerStackTypeIR
      -- let _typeIR [ n_size ] = typeIR as headerStackTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:301:1-307:59:
   rule indexAccessExpressionIR-bitslice: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bitacc_op(value_base, value_hi, value_lo)
      -- if expressionIR <: indexAccessExpressionIR
      -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
      -- if indexAccessExpressionIR matches `%[%:%]`
      -- let typedExpressionIR_base [ typedExpressionIR_hi : typedExpressionIR_lo ] = indexAccessExpressionIR
      -- Eval_static: p TC |- typedExpressionIR_base ~> value_base
      -- Eval_static: p TC |- typedExpressionIR_hi ~> value_hi
      -- Eval_static: p TC |- typedExpressionIR_lo ~> value_lo

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:323:1-327:91:
   rule callExpressionIR-typedLvalueIR-size: p TC |- expressionIR # ( _typeIR _ctk ) ~> $sizeof(typeIR_base, nameIR)
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%<%>(%)`
      -- let routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base . nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- let _expressionIR # ( typeIR_base _ctk' ) = typedExpressionIR_base
      -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:331:1-335:91:
   rule callExpressionIR-type-size-mono: p TC |- expressionIR # ( _typeIR _ctk ) ~> $sizeof(typeIR_base, nameIR)
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%<%>(%)`
      -- let routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
      -- if routineTargetIR matches `TYPE%.%`
      -- let type prefixedNameIR . nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR_base = typeDefIR as typeIR
      -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:337:1-341:91:
   rule callExpressionIR-type-size-poly: p TC |- expressionIR # ( _typeIR _ctk ) ~> $sizeof(typeIR_base, nameIR)
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%<%>(%)`
      -- let routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
      -- if routineTargetIR matches `TYPE%.%`
      -- let type prefixedNameIR . nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR_base < tid*{tid <- tid*} , tid'*{tid' <- tid'*} > = typeDefIR as polyTypeDefIR
      -- if tid*{tid <- tid*} matches []
      -- if tid'*{tid' <- tid'*} matches []
      -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:345:1-352:21:
   rule callExpressionIR-parenthesized: p TC |- expressionIR # ( typeIR ctk ) ~> value
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%<%>(%)`
      -- let routineTargetIR' < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
      -- if routineTargetIR' matches `(%)`
      -- let ( routineTargetIR ) = routineTargetIR'
      -- Eval_static: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) as expressionIR # ( typeIR ctk ) ~> value

   ;; ../../../../reference-specs/p4-concrete/5.06.1-expression-static-eval.spectec:357:1-359:53:
   rule parenthesizedExpressionIR: p TC |- expressionIR # ( _typeIR _ctk ) ~> value
      -- if expressionIR <: parenthesizedExpressionIR
      -- let ( typedExpressionIR ) = expressionIR as parenthesizedExpressionIR
      -- Eval_static: p TC |- typedExpressionIR ~> value

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:15:1-17:23:
relation Type_ok: cursor typingContext |- typeOrVoid : typeIR # tid*

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:11:1-12:29:
   rule boolean: p TC |- typeOrVoid : bool as typeIR # []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:16:1-17:31:
   rule error: p TC |- typeOrVoid : error as typeIR # []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `ERROR`

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:21:1-22:41:
   rule matchkind: p TC |- typeOrVoid : match_kind as typeIR # []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `MATCH_KIND`

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:26:1-27:33:
   rule string: p TC |- typeOrVoid : string as typeIR # []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `STRING`

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:31:1-32:27:
   rule arbint: p TC |- typeOrVoid : int as typeIR # []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:37:1-38:43:
   rule fixint: p TC |- typeOrVoid : int< n > as typeIR # []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `INT<%>`
      -- let int< int > = baseType
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:40:1-44:30:
   rule fixint-expr: p TC |- typeOrVoid : int< n > as typeIR # []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `INT<(%)>`
      -- let int<( expression )> = baseType
      -- Expr_ok: p TC |- expression : typedExpressionIR
      -- Eval_static: p TC |- typedExpressionIR ~> value
      -- let int = $to_number(value)
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:50:1-51:36:
   rule bit: p TC |- typeOrVoid : bit< 1 > as typeIR # []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `BIT`

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:53:1-54:43:
   rule fixbit: p TC |- typeOrVoid : bit< n > as typeIR # []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `BIT<%>`
      -- let bit< int > = baseType
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:56:1-60:30:
   rule fixbit-expr: p TC |- typeOrVoid : bit< n > as typeIR # []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `BIT<(%)>`
      -- let bit<( expression )> = baseType
      -- Expr_ok: p TC |- expression : typedExpressionIR
      -- Eval_static: p TC |- typedExpressionIR ~> value
      -- let int = $to_number(value)
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:65:1-66:49:
   rule varbit: p TC |- typeOrVoid : varbit< n > as typeIR # []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `VARBIT<%>`
      -- let varbit< int > = baseType
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:68:1-72:30:
   rule varbit-expr: p TC |- typeOrVoid : varbit< n > as typeIR # []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `VARBIT<(%)>`
      -- let varbit<( expression )> = baseType
      -- Expr_ok: p TC |- expression : typedExpressionIR
      -- Eval_static: p TC |- typedExpressionIR ~> value
      -- let int = $to_number(value)
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:79:1-82:51:
   rule prefixedTypeName-mono: p TC |- typeOrVoid : typeIR # []
      -- if typeOrVoid <: prefixedTypeName
      -- let prefixedTypeName = typeOrVoid as prefixedTypeName
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:84:1-87:58:
   rule prefixedTypeName-poly: p TC |- typeOrVoid : polyTypeDefIR < [] > as typeIR # []
      -- if typeOrVoid <: prefixedTypeName
      -- let prefixedTypeName = typeOrVoid as prefixedTypeName
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let polyTypeDefIR = typeDefIR as polyTypeDefIR

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:92:1-95:51:
   rule specializedType-mono: p TC |- typeOrVoid : typeIR # []
      -- if typeOrVoid <: specializedType
      -- let prefixedTypeName < typeArgumentList > = typeOrVoid as specializedType
      -- if typeArgumentList matches ``EMPTY`
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:97:1-104:73:
   rule specializedType-poly: p TC |- typeOrVoid : polyTypeDefIR < typeIR_arg*{typeIR_arg <- typeIR_arg*} > as typeIR # tid_fresh*{tid_fresh <- tid_fresh*}
      -- if typeOrVoid <: specializedType
      -- let prefixedTypeName < typeArgumentList > = typeOrVoid as specializedType
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let polyTypeDefIR = typeDefIR as polyTypeDefIR
      -- let typeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > = polyTypeDefIR
      -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
      -- TypeArguments_ok: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeIR_arg*{typeIR_arg <- typeIR_arg*} # tid_fresh*{tid_fresh <- tid_fresh*}

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:109:1-120:59:
   rule headerStackType-typeName-expression: p TC |- typeOrVoid : polyTypeDefIR_stack < [typeIR_base] > as typeIR # []
      -- if typeOrVoid <: headerStackType
      -- let namedType [ expression_size ] = typeOrVoid as headerStackType
      -- if namedType <: typeName
      -- let typeName = namedType as typeName
      -- Type_ok: p TC |- typeName as typeOrVoid : typeIR_base # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- Expr_ok: p TC |- expression_size : typedExpressionIR_size
      -- Eval_static: p TC |- typedExpressionIR_size ~> value_size
      -- let int = $to_number(value_size)
      -- if int <: nat
      -- let n_size = int as nat
      -- let typeIR_stack = tid "T" as typeIR [ n_size ] as typeIR
      -- let polyTypeDefIR_stack = typeIR_stack < ["T"] , [] >

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:122:1-133:59:
   rule headerStackType-specializedType-expression: p TC |- typeOrVoid : polyTypeDefIR_stack < [typeIR_base] > as typeIR # tid_fresh*{tid_fresh <- tid_fresh*}
      -- if typeOrVoid <: headerStackType
      -- let namedType [ expression_size ] = typeOrVoid as headerStackType
      -- if namedType <: specializedType
      -- let specializedType = namedType as specializedType
      -- Type_ok: p TC |- specializedType as typeOrVoid : typeIR_base # tid_fresh*{tid_fresh <- tid_fresh*}
      -- Expr_ok: p TC |- expression_size : typedExpressionIR_size
      -- Eval_static: p TC |- typedExpressionIR_size ~> value_size
      -- let int = $to_number(value_size)
      -- if int <: nat
      -- let n_size = int as nat
      -- let typeIR_stack = tid "T" as typeIR [ n_size ] as typeIR
      -- let polyTypeDefIR_stack = typeIR_stack < ["T"] , [] >

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:138:1-145:57:
   rule listType: p TC |- typeOrVoid : polyTypeDefIR_list < [typeIR_arg] > as typeIR # tid_fresh*{tid_fresh <- tid_fresh*}
      -- if typeOrVoid <: listType
      -- let list< typeArgument > = typeOrVoid as listType
      -- TypeArgument_ok: p TC |- typeArgument : typeIR_arg # tid_fresh*{tid_fresh <- tid_fresh*}
      -- let typeIR_list = list< tid "T" as typeIR > as typeIR
      -- let polyTypeDefIR_list = typeIR_list < ["T"] , [] >

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:150:1-160:67:
   rule tupleType: p TC |- typeOrVoid : polyTypeDefIR_tuple < typeIR_arg*{typeIR_arg <- typeIR_arg*} > as typeIR # tid_fresh*{tid_fresh <- tid_fresh*}
      -- if typeOrVoid <: tupleType
      -- let tuple< typeArgumentList > = typeOrVoid as tupleType
      -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
      -- TypeArguments_ok: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeIR_arg*{typeIR_arg <- typeIR_arg*} # tid_fresh*{tid_fresh <- tid_fresh*}
      -- let i_idx*{i_idx <- i_idx*} = $init_(|typeIR_arg*{typeIR_arg <- typeIR_arg*}|) as int*
      -- (let tid_tparam = "T" ++ $int_to_text(i_idx))*{i_idx <- i_idx*, tid_tparam <- tid_tparam*}
      -- let typeIR_tuple = tuple< tid tid_tparam as typeIR*{tid_tparam <- tid_tparam*} > as typeIR
      -- let polyTypeDefIR_tuple = typeIR_tuple < tid_tparam*{tid_tparam <- tid_tparam*} , [] >

   ;; ../../../../reference-specs/p4-concrete/5.05.1-typing-type.spectec:164:1-165:29:
   rule void: p TC |- typeOrVoid : void as typeIR # []
      -- if typeOrVoid matches `VOID`

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:19:1-21:23:
relation TypeArgument_ok: cursor typingContext |- typeArgument : typeArgumentIR # tid*

   ;; ../../../../reference-specs/p4-concrete/5.07.1-typing-type-argument.spectec:12:1-14:49:
   rule type: p TC |- typeArgument : typeIR # tid_impl*{tid_impl <- tid_impl*}
      -- if typeArgument <: type
      -- let type = typeArgument as type
      -- Type_ok: p TC |- type as typeOrVoid : typeIR # tid_impl*{tid_impl <- tid_impl*}

   ;; ../../../../reference-specs/p4-concrete/5.07.1-typing-type-argument.spectec:18:1-19:29:
   rule void: p TC |- typeArgument : void as typeArgumentIR # []
      -- if typeArgument <: realTypeArgument
      -- let realTypeArgument = typeArgument as realTypeArgument
      -- if realTypeArgument matches `VOID`

   ;; ../../../../reference-specs/p4-concrete/5.07.1-typing-type-argument.spectec:23:1-25:32:
   rule dontcare: p TC |- typeArgument : tid tid_impl as typeArgumentIR # [tid_impl]
      -- if typeArgument <: realTypeArgument
      -- let realTypeArgument = typeArgument as realTypeArgument
      -- if realTypeArgument matches `_`
      -- let tid_impl = $fresh_tid

   ;; ../../../../reference-specs/p4-concrete/5.07.1-typing-type-argument.spectec:29:1-31:33:
   rule nonTypeName: p TC |- typeArgument : tid tid as typeArgumentIR # []
      -- if typeArgument <: nonTypeName
      -- let nonTypeName = typeArgument as nonTypeName
      -- let tid = $name(nonTypeName as name)

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:23:1-25:23:
relation TypeArguments_ok: cursor typingContext |- typeArgument* : typeArgumentListIR # tid*

   ;; ../../../../reference-specs/p4-concrete/5.07.1-typing-type-argument.spectec:39:1-40:27:
   rule : p TC |- typeArgument*{typeArgument <- typeArgument*} : [] # []
      -- if typeArgument*{typeArgument <- typeArgument*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.07.1-typing-type-argument.spectec:42:1-49:47:
   rule : p TC |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR_h :: typeArgumentIR_t*{typeArgumentIR_t <- typeArgumentIR_t*} # tid_impl*{tid_impl <- tid_impl*}
      -- if typeArgument*{typeArgument <- typeArgument*} matches _ :: _
      -- let typeArgument_h :: typeArgument_t*{typeArgument_t <- typeArgument_t*} = typeArgument*{typeArgument <- typeArgument*}
      -- TypeArgument_ok: p TC |- typeArgument_h : typeArgumentIR_h # tid_impl_h*{tid_impl_h <- tid_impl_h*}
      -- TypeArguments_ok: p TC |- typeArgument_t*{typeArgument_t <- typeArgument_t*} : typeArgumentIR_t*{typeArgumentIR_t <- typeArgumentIR_t*} # tid_impl_t*{tid_impl_t <- tid_impl_t*}
      -- let tid_impl*{tid_impl <- tid_impl*} = tid_impl_h*{tid_impl_h <- tid_impl_h*} ++ tid_impl_t*{tid_impl_t <- tid_impl_t*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:31:1-31:54:
relation Sub_expl: typeIR <: typeIR

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:5:1-9:54:
   rule : typeIR_a <: typeIR_b
      -- let typeIR_a_canon = $canon(typeIR_a)
      -- let typeIR_b_canon = $canon(typeIR_b)
      -- if Sub_expl_canon: typeIR_a_canon <: typeIR_b_canon holds

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:32:1-32:60:
relation Sub_expl_canon: typeIR <: typeIR

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:11:1-13:38:
   rule equals: typeIR_a <: typeIR_b
      -- if Type_alpha: typeIR_a ~~ typeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:15:1-18:46:
   rule not-equals: typeIR_a <: typeIR_b
      -- if ~Type_alpha: typeIR_a ~~ typeIR_b holds
      -- if Sub_expl_canon_neq: typeIR_a <: typeIR_b holds

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:33:1-33:64:
relation Sub_expl_canon_neq: typeIR <: typeIR

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:20:1-21:21:
   rule fixbit-boolean: typeIR <: typeIR'
      -- if (typeIR = bit< 1 > as typeIR)
      -- if typeIR' <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR' as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:23:1-24:21:
   rule boolean-fixbit: typeIR <: typeIR'
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`
      -- if (typeIR' = bit< 1 > as typeIR)

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:26:1-27:14:
   rule arbint-boolean: typeIR <: typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if typeIR' <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR' as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:29:1-30:20:
   rule arbint-fixint: typeIR <: typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< _nat > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:32:1-33:20:
   rule arbint-fixbit: typeIR <: typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:35:1-36:20:
   rule fixint-fixint: typeIR <: typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:38:1-39:31:
   rule fixint-fixint: typeIR <: typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w_a > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< w_b > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:41:1-42:27:
   rule fixint-fixbit: typeIR <: typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< w' > = numberTypeIR'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:44:1-45:20:
   rule fixbit-arbint: typeIR <: typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:47:1-48:27:
   rule fixbit-fixint: typeIR <: typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< w' > = numberTypeIR'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:50:1-51:31:
   rule fixbit-fixbit: typeIR <: typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w_a > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< w_b > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:53:1-55:36:
   rule newtype-left: typeIR <: typeIR_b
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid typeIR_a = aliasTypeIR
      -- if Sub_impl: typeIR_a <: typeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:57:1-59:36:
   rule newtype-right: typeIR_a <: typeIR
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid typeIR_b = aliasTypeIR
      -- if Sub_impl: typeIR_a <: typeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:61:1-63:36:
   rule serenum-left: typeIR <: typeIR_b
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # typeIR_a { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
      -- if Sub_impl: typeIR_a <: typeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:65:1-67:36:
   rule serenum-right: typeIR_a <: typeIR
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # typeIR_b { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
      -- if Sub_impl: typeIR_a <: typeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:69:1-71:41:
   rule default: typeIR <: typeIR_b
      -- if typeIR <: defaultTypeIR
      -- let defaultTypeIR = typeIR as defaultTypeIR
      -- if (defaultTypeIR = default)
      -- if $is_defaultable_typeIR(typeIR_b)

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:73:1-74:36:
   rule invalidheader-header: typeIR <: typeIR'
      -- if typeIR <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR = typeIR as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR = header_invalid)
      -- if typeIR' <: headerTypeIR
      -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR' as headerTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:76:1-77:42:
   rule invalidheader-headerunion: typeIR <: typeIR'
      -- if typeIR <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR = typeIR as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR = header_invalid)
      -- if typeIR' <: headerUnionTypeIR
      -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR' as headerUnionTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:79:1-81:39:
   rule seq-list: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
      -- if typeIR' <: listTypeIR
      -- let list< typeIR_b > = typeIR' as listTypeIR
      -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:83:1-85:39:
   rule seq-tuple: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR' as tupleTypeIR
      -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:87:1-90:39:
   rule seq-stack: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_b [ n_size ] = typeIR' as headerStackTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| <= n_size)
      -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:92:1-94:39:
   rule seq-struct: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR' as structTypeIR
      -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:96:1-98:39:
   rule seq-header: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
      -- if typeIR' <: headerTypeIR
      -- let header _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR' as headerTypeIR
      -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:100:1-106:50:
   rule seqdefault-tuple: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR' as tupleTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_expl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:108:1-112:41:
   rule seqdefault-stack: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_b [ n_size ] = typeIR' as headerStackTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < n_size)
      -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}
      -- if $is_defaultable_typeIR(typeIR_b)

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:114:1-120:50:
   rule seqdefault-struct: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR' as structTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_expl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:122:1-128:50:
   rule seqdefault-header: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
      -- if typeIR' <: headerTypeIR
      -- let header _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR' as headerTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_expl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:130:1-137:55:
   rule record-struct: typeIR <: typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} } = recordTypeIR
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR' as structTypeIR
      -- if $eq_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
      -- (if Sub_expl: typeIR_a_aligned <: typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:139:1-146:55:
   rule record-header: typeIR <: typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} } = recordTypeIR
      -- if typeIR' <: headerTypeIR
      -- let header _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR' as headerTypeIR
      -- if $eq_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
      -- (if Sub_expl: typeIR_a_aligned <: typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:148:1-161:50:
   rule recorddefault-struct: typeIR <: typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} ,...} = recordTypeIR
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR' as structTypeIR
      -- if $sub_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- (if Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- let { id_default*{id_default <- id_default*} } = $diff_set<id>({ id_b*{id_b <- id_b*} }, { id_a*{id_a <- id_a*} })
      -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
      -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
      -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:163:1-176:50:
   rule recorddefault-header: typeIR <: typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} ,...} = recordTypeIR
      -- if typeIR' <: headerTypeIR
      -- let header _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR' as headerTypeIR
      -- if $sub_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- (if Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- let { id_default*{id_default <- id_default*} } = $diff_set<id>({ id_b*{id_b <- id_b*} }, { id_a*{id_a <- id_a*} })
      -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
      -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
      -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:178:1-180:36:
   rule set-set: typeIR' <: typeIR'''
      -- if typeIR' <: setTypeIR
      -- let set< typeIR*{typeIR <- typeIR*} > = typeIR' as setTypeIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_a] = typeIR*{typeIR <- typeIR*}
      -- if typeIR''' <: setTypeIR
      -- let set< typeIR''*{typeIR'' <- typeIR''*} > = typeIR''' as setTypeIR
      -- if typeIR''*{typeIR'' <- typeIR''*} matches [ _/1 ]
      -- let [typeIR_b] = typeIR''*{typeIR'' <- typeIR''*}
      -- if Sub_expl: typeIR_a <: typeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:182:1-185:36:
   rule non-set-set: typeIR_a <: typeIR'
      -- if typeIR' <: setTypeIR
      -- let set< typeIR*{typeIR <- typeIR*} > = typeIR' as setTypeIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_b] = typeIR*{typeIR <- typeIR*}
      -- if ~$is_set_typeIR(typeIR_a)
      -- if Sub_expl: typeIR_a <: typeIR_b holds

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:35:1-35:54:
relation Sub_impl: typeIR <: typeIR

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:191:1-195:54:
   rule : typeIR_a <: typeIR_b
      -- let typeIR_a_canon = $canon(typeIR_a)
      -- let typeIR_b_canon = $canon(typeIR_b)
      -- if Sub_impl_canon: typeIR_a_canon <: typeIR_b_canon holds

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:36:1-36:60:
relation Sub_impl_canon: typeIR <: typeIR

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:197:1-199:38:
   rule equals: typeIR_a <: typeIR_b
      -- if Type_alpha: typeIR_a ~~ typeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:201:1-204:46:
   rule not-equals: typeIR_a <: typeIR_b
      -- if ~Type_alpha: typeIR_a ~~ typeIR_b holds
      -- if Sub_impl_canon_neq: typeIR_a <: typeIR_b holds

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:37:1-37:64:
relation Sub_impl_canon_neq: typeIR <: typeIR

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:206:1-207:20:
   rule arbint-fixint: typeIR <: typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< _nat > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:209:1-210:20:
   rule arbint-fixbit: typeIR <: typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:212:1-214:36:
   rule serenum-left: typeIR <: typeIR_b
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # typeIR_a { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
      -- if Sub_impl: typeIR_a <: typeIR_b holds

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:216:1-218:41:
   rule default: typeIR <: typeIR_b
      -- if typeIR <: defaultTypeIR
      -- let defaultTypeIR = typeIR as defaultTypeIR
      -- if (defaultTypeIR = default)
      -- if $is_defaultable_typeIR(typeIR_b)

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:220:1-221:36:
   rule invalidheader-header: typeIR <: typeIR'
      -- if typeIR <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR = typeIR as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR = header_invalid)
      -- if typeIR' <: headerTypeIR
      -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR' as headerTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:223:1-224:42:
   rule invalidheader-headerunion: typeIR <: typeIR'
      -- if typeIR <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR = typeIR as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR = header_invalid)
      -- if typeIR' <: headerUnionTypeIR
      -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR' as headerUnionTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:226:1-228:39:
   rule seq-list: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
      -- if typeIR' <: listTypeIR
      -- let list< typeIR_b > = typeIR' as listTypeIR
      -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:230:1-232:39:
   rule seq-tuple: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR' as tupleTypeIR
      -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:234:1-237:39:
   rule seq-stack: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_b [ n_size ] = typeIR' as headerStackTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| <= n_size)
      -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:239:1-241:39:
   rule seq-struct: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR' as structTypeIR
      -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:243:1-245:39:
   rule seq-header: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
      -- if typeIR' <: headerTypeIR
      -- let header _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR' as headerTypeIR
      -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:247:1-249:39:
   rule seq-seq: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR' matches `SEQ<%>`
      -- let seq< typeIR_b*{typeIR_b <- typeIR_b*} > = sequenceTypeIR'
      -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:251:1-257:50:
   rule seqdefault-tuple: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR' as tupleTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_impl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:259:1-263:41:
   rule seqdefault-stack: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_b [ n_size ] = typeIR' as headerStackTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < n_size)
      -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}
      -- if $is_defaultable_typeIR(typeIR_b)

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:265:1-271:50:
   rule seqdefault-struct: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR' as structTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_impl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:273:1-279:50:
   rule seqdefault-header: typeIR <: typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
      -- if typeIR' <: headerTypeIR
      -- let header _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR' as headerTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_impl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:281:1-288:55:
   rule record-struct: typeIR <: typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} } = recordTypeIR
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR' as structTypeIR
      -- if $eq_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
      -- (if Sub_impl: typeIR_a_aligned <: typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:290:1-297:55:
   rule record-header: typeIR <: typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} } = recordTypeIR
      -- if typeIR' <: headerTypeIR
      -- let header _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR' as headerTypeIR
      -- if $eq_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
      -- (if Sub_impl: typeIR_a_aligned <: typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:299:1-312:50:
   rule recorddefault-struct: typeIR <: typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} ,...} = recordTypeIR
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR' as structTypeIR
      -- if $sub_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- (if Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- let { id_default*{id_default <- id_default*} } = $diff_set<id>({ id_b*{id_b <- id_b*} }, { id_a*{id_a <- id_a*} })
      -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
      -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
      -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:314:1-327:50:
   rule recorddefault-header: typeIR <: typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} ,...} = recordTypeIR
      -- if typeIR' <: headerTypeIR
      -- let header _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR' as headerTypeIR
      -- if $sub_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- (if Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- let { id_default*{id_default <- id_default*} } = $diff_set<id>({ id_b*{id_b <- id_b*} }, { id_a*{id_a <- id_a*} })
      -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
      -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
      -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:43:1-45:23:
relation Expr_ok: cursor typingContext |- expression : typedExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:12:1-14:42:
   rule literalExpression-true: p TC |- expression : true as expressionIR # expressionNoteIR
      -- if expression <: literalExpression
      -- let literalExpression = expression as literalExpression
      -- if literalExpression matches `TRUE`
      -- let expressionNoteIR = ( bool as typeIR lctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:16:1-18:42:
   rule literalExpression-false: p TC |- expression : false as expressionIR # expressionNoteIR
      -- if expression <: literalExpression
      -- let literalExpression = expression as literalExpression
      -- if literalExpression matches `FALSE`
      -- let expressionNoteIR = ( bool as typeIR lctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:22:1-24:41:
   rule literalExpression-number-arbint: p TC |- expression : d i as expressionIR # expressionNoteIR
      -- if expression <: number
      -- let number = expression as number
      -- if number matches `D%`
      -- let d i = number
      -- let expressionNoteIR = ( int as typeIR lctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:26:1-28:50:
   rule literalExpression-number-fixint: p TC |- expression : n s i as expressionIR # expressionNoteIR
      -- if expression <: number
      -- let number = expression as number
      -- if number matches `%S%`
      -- let n s i = number
      -- let expressionNoteIR = ( int< n > as typeIR lctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:30:1-32:50:
   rule literalExpression-number-fixbit: p TC |- expression : n w i as expressionIR # expressionNoteIR
      -- if expression <: number
      -- let number = expression as number
      -- if number matches `%W%`
      -- let n w i = number
      -- let expressionNoteIR = ( bit< n > as typeIR lctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:36:1-38:44:
   rule literalExpression-stringliteral: p TC |- expression : " text " as expressionIR # expressionNoteIR
      -- if expression <: stringLiteral
      -- let " text " = expression as stringLiteral
      -- let expressionNoteIR = ( string as typeIR lctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:45:1-49:43:
   rule referenceExpression-prefixedNonTypeName: p TC |- expression : prefixedNameIR as expressionIR # expressionNoteIR
      -- if expression <: prefixedNonTypeName
      -- let prefixedNonTypeName = expression as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, TC, prefixedNameIR)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction typeIR ctk _value?{_value <- _value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- let expressionNoteIR = ( typeIR ctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:53:1-57:43:
   rule referenceExpression-this: p TC |- expression : prefixedNameIR as expressionIR # expressionNoteIR
      -- if expression <: referenceExpression
      -- let referenceExpression = expression as referenceExpression
      -- if referenceExpression matches `THIS`
      -- let prefixedNameIR = ` "this"
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, TC, prefixedNameIR)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction typeIR ctk _value?{_value <- _value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- let expressionNoteIR = ( typeIR ctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:61:1-63:45:
   rule defaultExpression: p TC |- expression : ... as expressionIR # expressionNoteIR
      -- if expression <: defaultExpression
      -- let defaultExpression = expression as defaultExpression
      -- if (defaultExpression = ...)
      -- let expressionNoteIR = ( default as typeIR lctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:77:1-86:58:
   rule unaryExpression-lnot: p TC |- expression' : ! typedExpressionIR_reduced as expressionIR # expressionNoteIR
      -- if expression' <: unaryExpression
      -- let unop expression = expression' as unaryExpression
      -- if unop matches `!`
      -- Expr_ok: p TC |- expression : typedExpressionIR
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_lnot)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let _expressionIR # expressionNoteIR = typedExpressionIR_reduced

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:99:1-108:58:
   rule unaryExpression-bnot: p TC |- expression' : ~ typedExpressionIR_reduced as expressionIR # expressionNoteIR
      -- if expression' <: unaryExpression
      -- let unop expression = expression' as unaryExpression
      -- if unop matches `~`
      -- Expr_ok: p TC |- expression : typedExpressionIR
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_bnot)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let _expressionIR # expressionNoteIR = typedExpressionIR_reduced

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:122:1-132:58:
   rule unaryExpression-uplusminus: p TC |- expression' : unop typedExpressionIR_reduced as expressionIR # expressionNoteIR
      -- if expression' <: unaryExpression
      -- let unop expression = expression' as unaryExpression
      -- if ((unop = +) \/ (unop = -))
      -- Expr_ok: p TC |- expression : typedExpressionIR
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_uplusminus)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let _expressionIR # expressionNoteIR = typedExpressionIR_reduced

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:149:1-171:59:
   rule binaryExpression-plusminusmult: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [+, -, *]
      -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
      -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_plusminusmult)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
      -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:185:1-207:59:
   rule binaryExpression-satplusminus: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [|+|, |-|]
      -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
      -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_satplusminus)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
      -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:220:1-247:59:
   rule binaryExpression-divmod-lctk: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [/, %]
      -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
      -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_divmod)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
      -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
      -- if (ctk_r_reduced = lctk)
      -- Eval_static: p TC |- typedExpressionIR_r_reduced ~> value_r
      -- let int = $to_number(value_r)
      -- if int <: nat
      -- let n_r = int as nat
      -- if (n_r > 0)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:249:1-274:59:
   rule binaryExpression-divmod-non-lctk: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [/, %]
      -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
      -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_divmod)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
      -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
      -- if (ctk_r_reduced =/= lctk)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:295:1-317:61:
   rule binaryExpression-shift-fixbit: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [<<, >>]
      -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
      -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_shift)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let _expressionIR # ( typeIR_l_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
      -- let _expressionIR' # ( typeIR_r_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
      -- if $is_fixed_bit_typeIR(typeIR_r_reduced)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = ( typeIR_l_reduced ctk_reduced )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:319:1-343:61:
   rule binaryExpression-shift-integer: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [<<, >>]
      -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
      -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_shift)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let _expressionIR # ( typeIR_l_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
      -- let _expressionIR' # ( typeIR_r_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
      -- if (ctk_r_reduced = lctk)
      -- if ($is_arbitrary_int_typeIR(typeIR_r_reduced) \/ $is_fixed_int_typeIR(typeIR_r_reduced))
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = ( typeIR_l_reduced ctk_reduced )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:347:1-365:46:
   rule binaryExpression-eq: p TC |- expression : typedExpressionIR_l_cast binop typedExpressionIR_r_cast as expressionIR # expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [==, !=]
      -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
      -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let _expressionIR # ( typeIR_cast ctk_l_cast ) = typedExpressionIR_l_cast
      -- let _expressionIR' # ( _typeIR ctk_r_cast ) = typedExpressionIR_r_cast
      -- if $is_equalable_typeIR(typeIR_cast)
      -- let ctk_cast = $join_ctk(ctk_l_cast, ctk_r_cast)
      -- let expressionNoteIR = ( bool as typeIR ctk_cast )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:380:1-402:49:
   rule binaryExpression-compare: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [<=, >=, <, >]
      -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
      -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_compare)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
      -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = ( bool as typeIR ctk_reduced )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:416:1-438:59:
   rule binaryExpression-bitwise: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [&, ^, |]
      -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
      -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_bitwise)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
      -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:466:1-488:59:
   rule binaryExpression-concat: p TC |- expression : typedExpressionIR_l_reduced ++ typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop matches `++`
      -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
      -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_concat)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let _expressionIR # ( typeIR_l_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
      -- let _expressionIR' # ( typeIR_r_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
      -- let typeIR?{typeIR <- typeIR?} = $result_concat(typeIR_l_reduced, typeIR_r_reduced)
      -- if typeIR?{typeIR <- typeIR?} matches (_)
      -- let ?(typeIR_reduced) = typeIR?{typeIR <- typeIR?}
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:501:1-523:59:
   rule binaryExpression-logical: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [&&, ||]
      -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
      -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_logical)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
      -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:529:1-550:48:
   rule ternaryExpression: p TC |- expression : typedExpressionIR_cond ? typedExpressionIR_true_cast : typedExpressionIR_false_cast as expressionIR # expressionNoteIR
      -- if expression <: ternaryExpression
      -- let expression_cond ? expression_true : expression_false = expression as ternaryExpression
      -- Expr_ok: p TC |- expression_cond : typedExpressionIR_cond
      -- let _expressionIR # ( typeIR ctk_cond ) = typedExpressionIR_cond
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`
      -- Expr_ok: p TC |- expression_true : typedExpressionIR_true
      -- Expr_ok: p TC |- expression_false : typedExpressionIR_false
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_true, typedExpressionIR_false)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_true_cast, typedExpressionIR_false_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let _expressionIR' # ( typeIR_cast ctk_true_cast ) = typedExpressionIR_true_cast
      -- let _expressionIR'' # ( _typeIR ctk_false_cast ) = typedExpressionIR_false_cast
      -- if ($is_arbitrary_int_typeIR(typeIR_cast) => (ctk_cond =/= dyn))
      -- let ctk = $joins_ctk([ctk_cond, ctk_true_cast, ctk_false_cast])
      -- let expressionNoteIR = ( typeIR_cast ctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:555:1-568:45:
   rule castExpression: p TC |- expression' : ( typeIR_t ) typedExpressionIR as expressionIR # expressionNoteIR
      -- if expression' <: castExpression
      -- let ( type_t ) expression = expression' as castExpression
      -- Type_ok: p TC |- type_t as typeOrVoid : typeIR_t # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(p, TC) |- typeIR_t holds
      -- Expr_ok: p TC |- expression : typedExpressionIR
      -- let _expressionIR # ( typeIR ctk ) = typedExpressionIR
      -- if Sub_expl: typeIR <: typeIR_t holds
      -- let expressionNoteIR = ( typeIR_t ctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:575:1-577:52:
   rule dataExpression-invalid: p TC |- expression : {#} as expressionIR # expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{#}`
      -- let expressionNoteIR = ( header_invalid as typeIR lctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:585:1-599:43:
   rule dataExpression-sequenceElementExpression-non-default: p TC |- expression : seq{ typedExpressionIR_e*{typedExpressionIR_e <- typedExpressionIR_e*} } as expressionIR # expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let { dataElementExpression _trailingCommaOpt } = dataExpression
      -- if dataElementExpression <: expressionList
      -- let expressionList = dataElementExpression as expressionList
      -- let expression_e*{expression_e <- expression_e*} = $flatten_expressionList(expressionList)
      -- if ~... as expression <- expression_e*{expression_e <- expression_e*}
      -- if (expression_e*{expression_e <- expression_e*} = $flatten_expressionList(expressionList))
      -- (Expr_ok: p TC |- expression_e : typedExpressionIR_e)*{expression_e <- expression_e*, typedExpressionIR_e <- typedExpressionIR_e*}
      -- (let _expressionIR # ( typeIR_e ctk_e ) = typedExpressionIR_e)*{_expressionIR <- _expressionIR*, ctk_e <- ctk_e*, typeIR_e <- typeIR_e*, typedExpressionIR_e <- typedExpressionIR_e*}
      -- let typeIR = seq< typeIR_e*{typeIR_e <- typeIR_e*} > as typeIR
      -- let ctk = $joins_ctk(ctk_e*{ctk_e <- ctk_e*})
      -- let expressionNoteIR = ( typeIR ctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:601:1-617:43:
   rule dataExpression-sequenceElementExpression-default: p TC |- expression : seq{ typedExpressionIR_e_h*{typedExpressionIR_e_h <- typedExpressionIR_e_h*} ,...} as expressionIR # expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let { dataElementExpression _trailingCommaOpt } = dataExpression
      -- if dataElementExpression <: expressionList
      -- let expressionList = dataElementExpression as expressionList
      -- let expression_e*{expression_e <- expression_e*} = $flatten_expressionList(expressionList)
      -- if ... as expression <- expression_e*{expression_e <- expression_e*}
      -- let expression''*{expression'' <- expression''*} = $rev_<expression>(expression_e*{expression_e <- expression_e*})
      -- if expression''*{expression'' <- expression''*} matches _ :: _
      -- let expression' :: expression_e_h_rev*{expression_e_h_rev <- expression_e_h_rev*} = expression''*{expression'' <- expression''*}
      -- if expression' <: defaultExpression
      -- let defaultExpression = expression' as defaultExpression
      -- if (defaultExpression = ...)
      -- let expression_e_h*{expression_e_h <- expression_e_h*} = $rev_<expression>(expression_e_h_rev*{expression_e_h_rev <- expression_e_h_rev*})
      -- if ~... as expression <- expression_e_h*{expression_e_h <- expression_e_h*}
      -- (Expr_ok: p TC |- expression_e_h : typedExpressionIR_e_h)*{expression_e_h <- expression_e_h*, typedExpressionIR_e_h <- typedExpressionIR_e_h*}
      -- (let _expressionIR # ( typeIR_e_h ctk_e_h ) = typedExpressionIR_e_h)*{_expressionIR <- _expressionIR*, ctk_e_h <- ctk_e_h*, typeIR_e_h <- typeIR_e_h*, typedExpressionIR_e_h <- typedExpressionIR_e_h*}
      -- let typeIR = seq< typeIR_e_h*{typeIR_e_h <- typeIR_e_h*} ,...> as typeIR
      -- let ctk = $joins_ctk(ctk_e_h*{ctk_e_h <- ctk_e_h*})
      -- let expressionNoteIR = ( typeIR ctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:624:1-635:45:
   rule dataExpression-recordElementExpression-single: p TC |- expression : record{ [nameIR_f = typedExpressionIR_f] } as expressionIR # expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let { dataElementExpression _trailingCommaOpt } = dataExpression
      -- if dataElementExpression <: recordElementExpression
      -- let recordElementExpression = dataElementExpression as recordElementExpression
      -- if recordElementExpression matches `%=%`
      -- let name_f = expression_f = recordElementExpression
      -- let nameIR_f = $name(name_f)
      -- Expr_ok: p TC |- expression_f : typedExpressionIR_f
      -- let _expressionIR # ( typeIR_f ctk_f ) = typedExpressionIR_f
      -- let typeIR = record{ [typeIR_f nameIR_f ;] } as typeIR
      -- let expressionNoteIR = ( typeIR ctk_f )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:639:1-650:45:
   rule dataExpression-recordElementExpression-single-default: p TC |- expression : record{ [nameIR_f = typedExpressionIR_f] ,...} as expressionIR # expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let { dataElementExpression _trailingCommaOpt } = dataExpression
      -- if dataElementExpression <: recordElementExpression
      -- let recordElementExpression = dataElementExpression as recordElementExpression
      -- if recordElementExpression matches `%=%,...`
      -- let name_f = expression_f ,... = recordElementExpression
      -- let nameIR_f = $name(name_f)
      -- Expr_ok: p TC |- expression_f : typedExpressionIR_f
      -- let _expressionIR # ( typeIR_f ctk_f ) = typedExpressionIR_f
      -- let typeIR = record{ [typeIR_f nameIR_f ;] ,...} as typeIR
      -- let expressionNoteIR = ( typeIR ctk_f )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:654:1-670:43:
   rule dataExpression-recordElementExpression-multiple: p TC |- expression : record{ nameIR_f = typedExpressionIR_f*{nameIR_f <- nameIR_f*, typedExpressionIR_f <- typedExpressionIR_f*} } as expressionIR # expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let { dataElementExpression _trailingCommaOpt } = dataExpression
      -- if dataElementExpression <: recordElementExpression
      -- let recordElementExpression = dataElementExpression as recordElementExpression
      -- if recordElementExpression matches `%=%,%`
      -- let name_f_h = expression_f_h , namedExpressionList_t = recordElementExpression
      -- let name_f_t = expression_f_t*{expression_f_t <- expression_f_t*, name_f_t <- name_f_t*} = $flatten_namedExpressionList(namedExpressionList_t)
      -- let name_f*{name_f <- name_f*} = name_f_h :: name_f_t*{name_f_t <- name_f_t*}
      -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
      -- let expression_f*{expression_f <- expression_f*} = expression_f_h :: expression_f_t*{expression_f_t <- expression_f_t*}
      -- (Expr_ok: p TC |- expression_f : typedExpressionIR_f)*{expression_f <- expression_f*, typedExpressionIR_f <- typedExpressionIR_f*}
      -- (let _expressionIR # ( typeIR_f ctk_f ) = typedExpressionIR_f)*{_expressionIR <- _expressionIR*, ctk_f <- ctk_f*, typeIR_f <- typeIR_f*, typedExpressionIR_f <- typedExpressionIR_f*}
      -- let typeIR = record{ typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } as typeIR
      -- let ctk = $joins_ctk(ctk_f*{ctk_f <- ctk_f*})
      -- let expressionNoteIR = ( typeIR ctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:674:1-690:43:
   rule dataExpression-recordElementExpression-multiple-default: p TC |- expression : record{ nameIR_f = typedExpressionIR_f*{nameIR_f <- nameIR_f*, typedExpressionIR_f <- typedExpressionIR_f*} ,...} as expressionIR # expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let { dataElementExpression _trailingCommaOpt } = dataExpression
      -- if dataElementExpression <: recordElementExpression
      -- let recordElementExpression = dataElementExpression as recordElementExpression
      -- if recordElementExpression matches `%=%,%,...`
      -- let name_f_h = expression_f_h , namedExpressionList_t ,... = recordElementExpression
      -- let name_f_t = expression_f_t*{expression_f_t <- expression_f_t*, name_f_t <- name_f_t*} = $flatten_namedExpressionList(namedExpressionList_t)
      -- let name_f*{name_f <- name_f*} = name_f_h :: name_f_t*{name_f_t <- name_f_t*}
      -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
      -- let expression_f*{expression_f <- expression_f*} = expression_f_h :: expression_f_t*{expression_f_t <- expression_f_t*}
      -- (Expr_ok: p TC |- expression_f : typedExpressionIR_f)*{expression_f <- expression_f*, typedExpressionIR_f <- typedExpressionIR_f*}
      -- (let _expressionIR # ( typeIR_f ctk_f ) = typedExpressionIR_f)*{_expressionIR <- _expressionIR*, ctk_f <- ctk_f*, typeIR_f <- typeIR_f*, typedExpressionIR_f <- typedExpressionIR_f*}
      -- let typeIR = record{ typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} ,...} as typeIR
      -- let ctk = $joins_ctk(ctk_f*{ctk_f <- ctk_f*})
      -- let expressionNoteIR = ( typeIR ctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:698:1-705:43:
   rule accessExpression-errorAccessExpression: p TC |- expression : error. nameIR as expressionIR # expressionNoteIR
      -- if expression <: errorAccessExpression
      -- let error. member = expression as errorAccessExpression
      -- let nameIR = $name(member)
      -- let nameIR_error = "error." ++ nameIR
      -- if (error. nameIR as value = $find_value(p, TC, ` nameIR_error))
      -- let expressionNoteIR = ( error as typeIR lctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:713:1-725:49:
   rule accessExpression-memberAccessExpression-prefixedType-enum: p TC |- expression : type prefixedNameIR_base . nameIR as expressionIR # expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase . member = expression as memberAccessExpression
      -- if memberAccessBase <: prefixedTypeName
      -- let prefixedTypeName_base = memberAccessBase as prefixedTypeName
      -- let prefixedNameIR_base = $prefixedTypeName(prefixedTypeName_base)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR_base)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR_base = typeDefIR as typeIR
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum _tid { nameIR_f*{nameIR_f <- nameIR_f*} } = enumTypeIR
      -- let nameIR = $name(member)
      -- if nameIR <- nameIR_f*{nameIR_f <- nameIR_f*}
      -- let expressionNoteIR = ( typeIR_base lctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:727:1-739:49:
   rule accessExpression-memberAccessExpression-prefixedType-serenum: p TC |- expression : type prefixedNameIR_base . nameIR as expressionIR # expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase . member = expression as memberAccessExpression
      -- if memberAccessBase <: prefixedTypeName
      -- let prefixedTypeName_base = memberAccessBase as prefixedTypeName
      -- let prefixedNameIR_base = $prefixedTypeName(prefixedTypeName_base)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR_base)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR_base = typeDefIR as typeIR
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # _typeIR { nameIR_f = _value ;*{_value <- _value*, nameIR_f <- nameIR_f*} } = enumTypeIR
      -- let nameIR = $name(member)
      -- if nameIR <- nameIR_f*{nameIR_f <- nameIR_f*}
      -- let expressionNoteIR = ( typeIR_base lctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:743:1-755:51:
   rule accessExpression-memberAccessExpression-expression-stack-size: p TC |- expression : typedExpressionIR_base as memberAccessBaseIR . "size" as expressionIR # expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase . member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- if ("size" = $name(member))
      -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
      -- let expressionNoteIR = ( bit< 32 > as typeIR lctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:757:1-772:50:
   rule accessExpression-memberAccessExpression-expression-stack-lastIndex: p TC |- expression : typedExpressionIR_base as memberAccessBaseIR . "lastIndex" as expressionIR # expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase . member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- if ("lastIndex" = $name(member))
      -- if (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind)))
      -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
      -- let expressionNoteIR = ( bit< 32 > as typeIR dyn )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:774:1-789:43:
   rule accessExpression-memberAccessExpression-expression-stack-last: p TC |- expression : typedExpressionIR_base as memberAccessBaseIR . "last" as expressionIR # expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase . member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- if ("last" = $name(member))
      -- if (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind)))
      -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
      -- let expressionNoteIR = ( typeIR dyn )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:791:1-806:43:
   rule accessExpression-memberAccessExpression-expression-stack-next: p TC |- expression : typedExpressionIR_base as memberAccessBaseIR . "next" as expressionIR # expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase . member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- if ("next" = $name(member))
      -- if (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind)))
      -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
      -- let expressionNoteIR = ( typeIR dyn )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:808:1-821:43:
   rule accessExpression-memberAccessExpression-expression-struct: p TC |- expression : typedExpressionIR_base as memberAccessBaseIR . nameIR as expressionIR # expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase . member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as structTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let expressionNoteIR = ( typeIR dyn )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:823:1-836:43:
   rule accessExpression-memberAccessExpression-expression-header: p TC |- expression : typedExpressionIR_base as memberAccessBaseIR . nameIR as expressionIR # expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase . member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerTypeIR
      -- let header _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as headerTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let expressionNoteIR = ( typeIR dyn )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:838:1-851:43:
   rule accessExpression-memberAccessExpression-expression-headerunion: p TC |- expression : typedExpressionIR_base as memberAccessBaseIR . nameIR as expressionIR # expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase . member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerUnionTypeIR
      -- let header_union _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as headerUnionTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let expressionNoteIR = ( typeIR dyn )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:853:1-866:43:
   rule accessExpression-memberAccessExpression-expression-tablestruct: p TC |- expression : typedExpressionIR_base as memberAccessBaseIR . nameIR as expressionIR # expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase . member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: tableTypeIR
      -- let tableTypeIR = typeIR' as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let table_struct _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = tableTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let expressionNoteIR = ( typeIR dyn )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:884:1-909:55:
   rule indexAccessExpression-tuple: p TC |- expression : typedExpressionIR_base [ typedExpressionIR_index_reduced ] as expressionIR # expressionNoteIR
      -- if expression <: indexAccessExpression
      -- let indexAccessExpression = expression as indexAccessExpression
      -- if indexAccessExpression matches `%[%]`
      -- let expression_base [ expression_index ] = indexAccessExpression
      -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
      -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
      -- let _expressionIR # ( typeIR_base ctk_base ) = typedExpressionIR_base
      -- let _expressionIR' # ( typeIR_index ctk_index ) = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: tupleTypeIR
      -- let tuple< typeIR_e*{typeIR_e <- typeIR_e*} > = typeIR as tupleTypeIR
      -- if (ctk_index = lctk)
      -- Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index
      -- let int = $to_number(value_index)
      -- if int <: nat
      -- let n_index = int as nat
      -- if (n_index < |typeIR_e*{typeIR_e <- typeIR_e*}|)
      -- let expressionNoteIR = ( typeIR_e*{typeIR_e <- typeIR_e*}[n_index] dyn )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:911:1-936:43:
   rule indexAccessExpression-stack-lctk: p TC |- expression : typedExpressionIR_base [ typedExpressionIR_index_reduced ] as expressionIR # expressionNoteIR
      -- if expression <: indexAccessExpression
      -- let indexAccessExpression = expression as indexAccessExpression
      -- if indexAccessExpression matches `%[%]`
      -- let expression_base [ expression_index ] = indexAccessExpression
      -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
      -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
      -- let _expressionIR # ( typeIR_base ctk_base ) = typedExpressionIR_base
      -- let _expressionIR' # ( typeIR_index ctk_index ) = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
      -- if (ctk_index = lctk)
      -- Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index
      -- let int = $to_number(value_index)
      -- if int <: nat
      -- let n_index = int as nat
      -- if (n_index < n_size)
      -- let expressionNoteIR = ( typeIR dyn )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:938:1-960:43:
   rule indexAccessExpression-stack-non-lctk: p TC |- expression : typedExpressionIR_base [ typedExpressionIR_index_reduced ] as expressionIR # expressionNoteIR
      -- if expression <: indexAccessExpression
      -- let indexAccessExpression = expression as indexAccessExpression
      -- if indexAccessExpression matches `%[%]`
      -- let expression_base [ expression_index ] = indexAccessExpression
      -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
      -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
      -- let _expressionIR # ( typeIR_base ctk_base ) = typedExpressionIR_base
      -- let _expressionIR' # ( typeIR_index ctk_index ) = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
      -- if (ctk_index =/= lctk)
      -- let expressionNoteIR = ( typeIR dyn )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1001:1-1048:56:
   rule indexAccessExpression-bitslice: p TC |- expression : typedExpressionIR_base [ typedExpressionIR_hi_reduced : typedExpressionIR_lo_reduced ] as expressionIR # expressionNoteIR
      -- if expression <: indexAccessExpression
      -- let indexAccessExpression = expression as indexAccessExpression
      -- if indexAccessExpression matches `%[%:%]`
      -- let expression_base [ expression_hi : expression_lo ] = indexAccessExpression
      -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
      -- Expr_ok: p TC |- expression_hi : typedExpressionIR_hi
      -- Expr_ok: p TC |- expression_lo : typedExpressionIR_lo
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_base, $compat_bitslice_base)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_base_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let _expressionIR # ( typeIR_base_reduced ctk_base_reduced ) = typedExpressionIR_base_reduced
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_hi_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?} = $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index)
      -- if typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?} matches (_)
      -- let ?(typedExpressionIR_lo_reduced) = typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?}
      -- let _expressionIR' # ( typeIR_hi_reduced ctk_hi_reduced ) = typedExpressionIR_hi_reduced
      -- let _expressionIR'' # ( typeIR_lo_reduced ctk_lo_reduced ) = typedExpressionIR_lo_reduced
      -- if (ctk_hi_reduced = lctk)
      -- Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi
      -- let int = $to_number(value_hi)
      -- if int <: nat
      -- let n_hi = int as nat
      -- if (ctk_lo_reduced = lctk)
      -- Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo
      -- let int' = $to_number(value_lo)
      -- if int' <: nat
      -- let n_lo = int' as nat
      -- if $is_valid_bitslice(typeIR_base_reduced, n_lo, n_hi)
      -- let typeIR = bit< ((n_hi - n_lo) + 1) > as typeIR
      -- let expressionNoteIR = ( typeIR ctk_base_reduced )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1056:1-1079:47:
   rule callExpression-routineTarget-no-typeArgumentList: p TC |- expression : callExpressionIR as expressionIR # expressionNoteIR
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `%(%)`
      -- let callTarget ( argumentList ) = callExpression
      -- if callTarget <: routineTarget
      -- let routineTarget = callTarget as routineTarget
      -- RoutineTarget_ok: p TC |- routineTarget : routineTargetIR
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- RoutineType_ok: p TC |- routineTargetIR < [] >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_inserted*{tid_inserted <- tid_inserted*}
      -- Call_ok: p TC |- routineTypeIR < [] # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if (typeIR_ret =/= void as typeIR)
      -- let ctk = $is_static_routineTarget(routineTargetIR)
      -- let callExpressionIR = routineTargetIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- let expressionNoteIR = ( typeIR_ret ctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1081:1-1108:47:
   rule callExpression-routineTarget-typeArgumentList: p TC |- expression : callExpressionIR as expressionIR # expressionNoteIR
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `%<%>(%)`
      -- let routineTarget < realTypeArgumentList >( argumentList ) = callExpression
      -- RoutineTarget_ok: p TC |- routineTarget : routineTargetIR
      -- let realTypeArgument*{realTypeArgument <- realTypeArgument*} = $flatten_realTypeArgumentList(realTypeArgumentList)
      -- TypeArguments_ok: p TC |- realTypeArgument*{realTypeArgument <- realTypeArgument*} as typeArgument* : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_impl*{tid_impl <- tid_impl*}
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- RoutineType_ok: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
      -- Call_ok: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if (typeIR_ret =/= void as typeIR)
      -- let ctk = $is_static_routineTarget(routineTargetIR)
      -- let callExpressionIR = routineTargetIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- let expressionNoteIR = ( typeIR_ret ctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1140:1-1159:50:
   rule callExpression-constructorTarget-prefixedTypeName: p TC |- expression : callExpressionIR as expressionIR # expressionNoteIR
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `%(%)`
      -- let callTarget ( argumentList ) = callExpression
      -- if callTarget <: prefixedTypeName
      -- let prefixedTypeName = callTarget as prefixedTypeName
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- ConstructorType_ok: p TC |- prefixedNameIR < [] >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
      -- Inst_ok: p TC anon |- constructorTypeIR < [] # tid_impl*{tid_impl <- tid_impl*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if $is_concrete_extern_object(typeIR_object)
      -- let callExpressionIR = prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} > ( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- let expressionNoteIR = ( typeIR_object ctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1163:1-1187:50:
   rule callExpression-constructorTarget-specializedType: p TC |- expression : callExpressionIR as expressionIR # expressionNoteIR
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `%(%)`
      -- let callTarget ( argumentList ) = callExpression
      -- if callTarget <: specializedType
      -- let prefixedTypeName < typeArgumentList > = callTarget as specializedType
      -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
      -- TypeArguments_ok: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_impl*{tid_impl <- tid_impl*}
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- ConstructorType_ok: p TC |- prefixedNameIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
      -- Inst_ok: p TC anon |- constructorTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if $is_concrete_extern_object(typeIR_object)
      -- let callExpressionIR = prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} > ( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- let expressionNoteIR = ( typeIR_object ctk )

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1192:1-1195:50:
   rule parenthesizedExpression: p TC |- expression' : ( typedExpressionIR ) as expressionIR # expressionNoteIR
      -- if expression' <: parenthesizedExpression
      -- let ( expression ) = expression' as parenthesizedExpression
      -- Expr_ok: p TC |- expression : typedExpressionIR
      -- let _expressionIR # expressionNoteIR = typedExpressionIR

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:51:1-53:23:
relation Argument_ok: cursor typingContext |- argument : argumentIR

   ;; ../../../../reference-specs/p4-concrete/5.07.2-typing-argument.spectec:9:1-11:53:
   rule expression: p TC |- argument : typedExpressionIR as argumentIR
      -- if argument <: expression
      -- let expression = argument as expression
      -- Expr_ok: p TC |- expression : typedExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.07.2-typing-argument.spectec:15:1-18:53:
   rule name-expression: p TC |- argument : nameIR = typedExpressionIR
      -- if argument matches `%=%`
      -- let name = expression = argument
      -- let nameIR = $name(name)
      -- Expr_ok: p TC |- expression : typedExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.07.2-typing-argument.spectec:22:1-24:29:
   rule name-dontcare: p TC |- argument : nameIR =_
      -- if argument matches `%=_`
      -- let name =_ = argument
      -- let nameIR = $name(name)

   ;; ../../../../reference-specs/p4-concrete/5.07.2-typing-argument.spectec:28:1-29:18:
   rule dontcare: p TC |- argument : _
      -- if argument matches `_`

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:59:1-61:23:
relation Lvalue_ok: cursor typingContext |- lvalue : typedLvalueIR

   ;; ../../../../reference-specs/p4-concrete/5.08-typing-lvalue.spectec:12:1-16:45:
   rule referenceExpression-prefixedNonTypeName-assign: p TC |- lvalue : prefixedNameIR as lvalueIR #( typeIR )
      -- if lvalue <: prefixedNonTypeName
      -- let prefixedNonTypeName = lvalue as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, TC, prefixedNameIR)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(direction typeIR ctk value?{value <- value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if ctk matches `DYN`
      -- if value?{value <- value?} matches ()
      -- if ((direction = out) \/ (direction = inout))

   ;; ../../../../reference-specs/p4-concrete/5.08-typing-lvalue.spectec:23:1-38:54:
   rule lvalue-member-stack-next-last: p TC |- lvalue : typedLvalueIR
      -- if lvalue matches `%.%`
      -- let lvalue_base . member = lvalue
      -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
      -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR
      -- let nameIR = $name(member)
      -- if ((nameIR = "next") \/ (nameIR = "last"))
      -- if (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind)))
      -- let typedLvalueIR = typedLvalueIR_base . nameIR #( typeIR )

   ;; ../../../../reference-specs/p4-concrete/5.08-typing-lvalue.spectec:40:1-52:54:
   rule lvalue-member-struct: p TC |- lvalue : typedLvalueIR
      -- if lvalue matches `%.%`
      -- let lvalue_base . member = lvalue
      -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
      -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: structTypeIR
      -- let struct _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as structTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let typedLvalueIR = typedLvalueIR_base . nameIR #( typeIR )

   ;; ../../../../reference-specs/p4-concrete/5.08-typing-lvalue.spectec:54:1-66:54:
   rule lvalue-member-header: p TC |- lvalue : typedLvalueIR
      -- if lvalue matches `%.%`
      -- let lvalue_base . member = lvalue
      -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
      -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerTypeIR
      -- let header _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as headerTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let typedLvalueIR = typedLvalueIR_base . nameIR #( typeIR )

   ;; ../../../../reference-specs/p4-concrete/5.08-typing-lvalue.spectec:68:1-80:54:
   rule lvalue-member-union: p TC |- lvalue : typedLvalueIR
      -- if lvalue matches `%.%`
      -- let lvalue_base . member = lvalue
      -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
      -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerUnionTypeIR
      -- let header_union _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as headerUnionTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let typedLvalueIR = typedLvalueIR_base . nameIR #( typeIR )

   ;; ../../../../reference-specs/p4-concrete/5.08-typing-lvalue.spectec:84:1-109:25:
   rule lvalue-expression-lctk: p TC |- lvalue : typedLvalueIR
      -- if lvalue matches `%[%]`
      -- let lvalue_base [ expression_index ] = lvalue
      -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
      -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
      -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
      -- let _expressionIR # ( typeIR_index ctk_index ) = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- if (ctk_index = lctk)
      -- Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index
      -- let int = $to_number(value_index)
      -- if int <: nat
      -- let n_index = int as nat
      -- if (n_index < n_size)
      -- let typedLvalueIR = typedLvalueIR_base [ typedExpressionIR_index_reduced ] #( typeIR )

   ;; ../../../../reference-specs/p4-concrete/5.08-typing-lvalue.spectec:111:1-133:25:
   rule lvalue-expression-non-lctk: p TC |- lvalue : typedLvalueIR
      -- if lvalue matches `%[%]`
      -- let lvalue_base [ expression_index ] = lvalue
      -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
      -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
      -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
      -- let _expressionIR # ( typeIR_index ctk_index ) = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- if (ctk_index =/= lctk)
      -- let typedLvalueIR = typedLvalueIR_base [ typedExpressionIR_index_reduced ] #( typeIR )

   ;; ../../../../reference-specs/p4-concrete/5.08-typing-lvalue.spectec:137:1-178:25:
   rule lvalue-expression-expression: p TC |- lvalue : typedLvalueIR
      -- if lvalue matches `%[%:%]`
      -- let lvalue_base [ expression_hi : expression_lo ] = lvalue
      -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
      -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
      -- if $compat_bitslice_base(typeIR_base)
      -- Expr_ok: p TC |- expression_hi : typedExpressionIR_hi
      -- Expr_ok: p TC |- expression_lo : typedExpressionIR_lo
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_hi_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_lo_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let _expressionIR # ( typeIR_hi_reduced ctk_hi_reduced ) = typedExpressionIR_hi_reduced
      -- let _expressionIR' # ( typeIR_lo_reduced ctk_lo_reduced ) = typedExpressionIR_lo_reduced
      -- if (ctk_hi_reduced = lctk)
      -- Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi
      -- let int = $to_number(value_hi)
      -- if int <: nat
      -- let n_hi = int as nat
      -- if (ctk_lo_reduced = lctk)
      -- Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo
      -- let int' = $to_number(value_lo)
      -- if int' <: nat
      -- let n_lo = int' as nat
      -- if $is_valid_bitslice(typeIR_base, n_lo, n_hi)
      -- let typeIR = bit< ((n_hi - n_lo) + 1) > as typeIR
      -- let typedLvalueIR = typedLvalueIR_base [ typedExpressionIR_hi_reduced : typedExpressionIR_lo_reduced ] #( typeIR )

   ;; ../../../../reference-specs/p4-concrete/5.08-typing-lvalue.spectec:182:1-189:54:
   rule parenthesized: p TC |- lvalue : typedLvalueIR
      -- if lvalue matches `(%)`
      -- let ( lvalue_base ) = lvalue
      -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
      -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
      -- let typedLvalueIR = ( typedLvalueIR_base ) #( typeIR_base )

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:67:1-69:26:
relation Stmt_ok: cursor typingContext flow |- statement : typingContext flow statementIR

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:10:1-11:25:
   rule emptyStatement: p TC f |- statement : TC f ; as statementIR
      -- if statement <: emptyStatement
      -- let emptyStatement = statement as emptyStatement
      -- if (emptyStatement = ;)

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:19:1-31:76:
   rule assignmentStatement-eq: p TC f |- statement : TC f typedLvalueIR = typedExpressionIR_cast ; as statementIR
      -- if statement <: assignmentStatement
      -- let lvalue assignop expression ; = statement as assignmentStatement
      -- if assignop matches `=`
      -- Lvalue_ok: p TC |- lvalue : typedLvalueIR
      -- Expr_ok: p TC |- expression : typedExpressionIR
      -- let _lvalueIR #( typeIR_l ) = typedLvalueIR
      -- let _expressionIR # ( typeIR_r _ctk ) = typedExpressionIR
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR_l)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:41:1-58:79:
   rule callStatement-no-typeArgumentList: p TC f |- statement : TC f callStatementIR as statementIR
      -- if statement <: callStatement
      -- let callStatement = statement as callStatement
      -- if callStatement matches `%(%);`
      -- let lvalue_routine ( argumentList ); = callStatement
      -- RoutineTarget_lvalue_ok: p TC |- lvalue_routine : routineTargetIR
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- RoutineType_ok: p TC |- routineTargetIR < [] >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
      -- Call_ok: p TC |- routineTypeIR < [] # tid_impl*{tid_impl <- tid_impl*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- let callStatementIR = routineTargetIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} );

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:62:1-83:79:
   rule callStatement-typeArgumentList: p TC f |- statement : TC f callStatementIR as statementIR
      -- if statement <: callStatement
      -- let callStatement = statement as callStatement
      -- if callStatement matches `%<%>(%);`
      -- let lvalue_routine < typeArgumentList >( argumentList ); = callStatement
      -- RoutineTarget_lvalue_ok: p TC |- lvalue_routine : routineTargetIR
      -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
      -- TypeArguments_ok: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_impl*{tid_impl <- tid_impl*}
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- RoutineType_ok: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
      -- Call_ok: p TC |- routineTypeIR < [] # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- let callStatementIR = routineTargetIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} );

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:98:1-118:57:
   rule directApplicationStatement-prefixedTypeName: p TC_0 f |- statement : TC_0 f directApplicationStatementIR as statementIR
      -- if statement <: directApplicationStatement
      -- let namedType .apply( argumentList ); = statement as directApplicationStatement
      -- Expr_ok: p TC_0 |- namedType as callTarget ( ) as expression : expressionIR # ( typeIR_object _ctk )
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%(%)`
      -- let prefixedNameIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} > ( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if $compat_direct_application(typeIR_object)
      -- let nameIR_object = "__direct_application"
      -- let TC_1 = $add_var(p, TC_0, nameIR_object, typeIR_object ctk ?())
      -- let lvalue = nameIR_object as lvalue . "apply" as member
      -- Stmt_ok: p TC_1 f |- lvalue ( argumentList ); as statement : _typingContext _flow statementIR
      -- if statementIR <: callStatementIR
      -- let callStatementIR = statementIR as callStatementIR
      -- let routineTargetIR < typeArgumentIR'*{typeArgumentIR' <- typeArgumentIR'*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} ); = callStatementIR
      -- if (routineTargetIR = ` nameIR_object as expressionIR # ( typeIR_object ctk ) . "apply")
      -- if typeArgumentIR'*{typeArgumentIR' <- typeArgumentIR'*} matches []
      -- let directApplicationStatementIR = prefixedNameIR .apply( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} );

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:125:1-129:37:
   rule returnStatement-empty: cursor TC f |- statement : TC ret return; as statementIR
      -- if cursor matches `LOCAL`
      -- if statement <: returnStatement
      -- let returnStatement = statement as returnStatement
      -- if returnStatement matches `RETURN;`
      -- if (?(void as typeIR) = $find_return_type(TC))

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:133:1-144:78:
   rule returnStatement-expression: cursor TC f |- statement : TC ret return typedExpressionIR_cast ; as statementIR
      -- if cursor matches `LOCAL`
      -- if statement <: returnStatement
      -- let returnStatement = statement as returnStatement
      -- if returnStatement matches `RETURN%;`
      -- let return expression ; = returnStatement
      -- Expr_ok: local TC |- expression : typedExpressionIR
      -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
      -- let typeIR'?{typeIR' <- typeIR'?} = $find_return_type(TC)
      -- if typeIR'?{typeIR' <- typeIR'?} matches (_)
      -- let ?(typeIR_ret) = typeIR'?{typeIR' <- typeIR'?}
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR_ret)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:149:1-150:37:
   rule exitStatement: p TC f |- statement : TC f exit; as statementIR
      -- if statement <: exitStatement
      -- let exitStatement = statement as exitStatement
      -- if (exitStatement = exit;)

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:154:1-157:53:
   rule blockStatement: cursor TC_0 f_0 |- statement : TC_1 f_1 blockStatementIR as statementIR
      -- if cursor matches `LOCAL`
      -- if statement <: blockStatement
      -- let blockStatement = statement as blockStatement
      -- Block_ok: TC_0 f_0 |- blockStatement : TC_1 f_1 blockStatementIR

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:164:1-173:73:
   rule conditionalStatement-non-else: p TC f |- statement : TC f if( typedExpressionIR_cond ) statementIR_then as statementIR
      -- if statement <: conditionalStatement
      -- let conditionalStatement = statement as conditionalStatement
      -- if conditionalStatement matches `IF(%)%`
      -- let if( expression_cond ) statement_then = conditionalStatement
      -- Expr_ok: p TC |- expression_cond : typedExpressionIR_cond
      -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR_cond
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`
      -- Stmt_ok: p TC f |- statement_then : TC_then f_then statementIR_then

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:177:1-189:44:
   rule conditionalStatement-else: p TC f |- statement : TC f_post if( typedExpressionIR_cond ) statementIR_then else statementIR_else as statementIR
      -- if statement <: conditionalStatement
      -- let conditionalStatement = statement as conditionalStatement
      -- if conditionalStatement matches `IF(%)%ELSE%`
      -- let if( expression_cond ) statement_then else statement_else = conditionalStatement
      -- Expr_ok: p TC |- expression_cond : typedExpressionIR_cond
      -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR_cond
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`
      -- Stmt_ok: p TC f |- statement_then : TC_then f_then statementIR_then
      -- Stmt_ok: p TC f |- statement_else : TC_else f_else statementIR_else
      -- let f_post = $join_flow(f_then, f_else)

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:277:1-294:64:
   rule switch-table-apply: cursor TC f |- statement : TC f_post switchStatementIR as statementIR
      -- if cursor matches `LOCAL`
      -- if statement <: switchStatement
      -- let switch( expression_switch ){ switchCaseList } = statement as switchStatement
      -- Expr_ok: local TC |- expression_switch : typedExpressionIR_switch
      -- let _expressionIR # ( typeIR_switch _ctk ) = typedExpressionIR_switch
      -- let typeIR = $canon(typeIR_switch)
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_ENUM%{%}`
      -- let table_enum tid_table_enum { _id*{_id <- _id*} } = tableTypeIR
      -- let tid_table = $strip_prefix($strip_suffix(tid_table_enum, ")"), "action_list(")
      -- let switchCase*{switchCase <- switchCase*} = $flatten_switchCaseList(switchCaseList)
      -- SwitchCases_table_ok: TC f tid_table |- switchCase*{switchCase <- switchCase*} : f_post switchCaseIR*{switchCaseIR <- switchCaseIR*} # switchLabel*{switchLabel <- switchLabel*}
      -- if $distinct_<switchLabel>(switchLabel*{switchLabel <- switchLabel*})
      -- let switchStatementIR = switch( typedExpressionIR_switch ){ switchCaseIR*{switchCaseIR <- switchCaseIR*} }

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:381:1-397:64:
   rule switch-general: cursor TC f |- statement : TC f_post switchStatementIR as statementIR
      -- if cursor matches `LOCAL`
      -- if statement <: switchStatement
      -- let switch( expression_switch ){ switchCaseList } = statement as switchStatement
      -- Expr_ok: local TC |- expression_switch : typedExpressionIR_switch
      -- let _expressionIR # ( typeIR_switch _ctk ) = typedExpressionIR_switch
      -- if $compat_switch(typeIR_switch)
      -- let switchCase*{switchCase <- switchCase*} = $flatten_switchCaseList(switchCaseList)
      -- SwitchCases_general_ok: TC f typeIR_switch |- switchCase*{switchCase <- switchCase*} : f_post switchCaseIR*{switchCaseIR <- switchCaseIR*} # switchLabel*{switchLabel <- switchLabel*}
      -- if $distinct_<switchLabel>(switchLabel*{switchLabel <- switchLabel*})
      -- let switchStatementIR = switch( typedExpressionIR_switch ){ switchCaseIR*{switchCaseIR <- switchCaseIR*} }

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:71:1-73:26:
relation Stmts_ok: cursor typingContext flow |- statement* : typingContext flow statementIR*

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:75:1-78:23:
relation BlockElementStmt_ok: typingContext flow |- blockElementStatement : typingContext flow blockElementStatementIR

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:405:1-407:77:
   rule constantDeclaration: TC_0 f |- blockElementStatement : TC_1 f constantDeclarationIR as blockElementStatementIR
      -- if blockElementStatement <: constantDeclaration
      -- let constantDeclaration = blockElementStatement as constantDeclaration
      -- Decl_ok: local TC_0 |- constantDeclaration as declaration : TC_1 declarationIR
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = declarationIR as constantDeclarationIR

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:413:1-426:44:
   rule variableDeclaration-empty: TC_0 f |- blockElementStatement : TC_1 f variableDeclarationIR as blockElementStatementIR
      -- if blockElementStatement <: variableDeclaration
      -- let annotationList type name initializerOpt ; = blockElementStatement as variableDeclaration
      -- if initializerOpt matches ``EMPTY`
      -- Type_ok: local TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(local, TC_0) |- typeIR holds
      -- if $is_assignable_typeIR(typeIR)
      -- let nameIR = $name(name)
      -- let TC_1 = $add_var(local, TC_0, nameIR, inout typeIR dyn ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?() ;

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:428:1-447:73:
   rule variableDeclaration-initializer: TC_0 f |- blockElementStatement : TC_1 f variableDeclarationIR as blockElementStatementIR
      -- if blockElementStatement <: variableDeclaration
      -- let annotationList type name initializerOpt ; = blockElementStatement as variableDeclaration
      -- if initializerOpt <: initializer
      -- let = expression_init = initializerOpt as initializer
      -- Type_ok: local TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(local, TC_0) |- typeIR holds
      -- if $is_assignable_typeIR(typeIR)
      -- Expr_ok: local TC_0 |- expression_init : typedExpressionIR_init
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let nameIR = $name(name)
      -- let TC_1 = $add_var(local, TC_0, nameIR, inout typeIR dyn ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?(= typedExpressionIR_init_cast) ;

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:451:1-453:66:
   rule statement: TC_0 f |- blockElementStatement : TC_1 f_post statementIR as blockElementStatementIR
      -- if blockElementStatement <: statement
      -- let statement = blockElementStatement as statement
      -- Stmt_ok: local TC_0 f |- statement : TC_1 f_post statementIR

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:80:1-83:23:
relation BlockElementStmts_ok: typingContext flow |- blockElementStatement* : typingContext flow blockElementStatementIR*

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:459:1-460:25:
   rule nil: TC f |- blockElementStatement*{blockElementStatement <- blockElementStatement*} : TC f []
      -- if blockElementStatement*{blockElementStatement <- blockElementStatement*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:462:1-468:75:
   rule cons: TC_0 f_0 |- blockElementStatement*{blockElementStatement <- blockElementStatement*} : TC_2 f_2 blockElementStatementIR_h :: blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*}
      -- if blockElementStatement*{blockElementStatement <- blockElementStatement*} matches _ :: _
      -- let blockElementStatement_h :: blockElementStatement_t*{blockElementStatement_t <- blockElementStatement_t*} = blockElementStatement*{blockElementStatement <- blockElementStatement*}
      -- BlockElementStmt_ok: TC_0 f_0 |- blockElementStatement_h : TC_1 f_1 blockElementStatementIR_h
      -- BlockElementStmts_ok: TC_1 f_1 |- blockElementStatement_t*{blockElementStatement_t <- blockElementStatement_t*} : TC_2 f_2 blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:85:1-88:23:
relation Block_ok: typingContext flow |- blockStatement : typingContext flow blockStatementIR

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:476:1-487:72:
   rule : TC_0 f |- annotationList { blockElementStatementList } : TC_3 f_post blockStatementIR
      -- let blockElementStatement*{blockElementStatement <- blockElementStatement*} = $flatten_blockElementStatementList(blockElementStatementList)
      -- let TC_1 = $enter(TC_0)
      -- BlockElementStmts_ok: TC_1 f |- blockElementStatement*{blockElementStatement <- blockElementStatement*} : TC_2 f_post blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*}
      -- let TC_3 = $exit(TC_2)
      -- let blockStatementIR = annotationList { blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} }

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:95:1-97:23:
relation Parameter_ok: cursor typingContext |- parameter : parameterIR # tid*

   ;; ../../../../reference-specs/p4-concrete/5.09-typing-parameter.spectec:12:1-19:29:
   rule empty: p TC |- annotationList direction type name initializerOpt : annotationList direction typeIR nameIR ?() # tid_fresh*{tid_fresh <- tid_fresh*}
      -- if initializerOpt matches ``EMPTY`
      -- Type_ok: p TC |- type as typeOrVoid : typeIR # tid_fresh*{tid_fresh <- tid_fresh*}
      -- let bound = $union_set<tid>($bound(p, TC), { tid_fresh*{tid_fresh <- tid_fresh*} })
      -- if Type_wf: bound |- typeIR holds
      -- let nameIR = $name(name)

   ;; ../../../../reference-specs/p4-concrete/5.09-typing-parameter.spectec:23:1-41:68:
   rule empty: p TC |- annotationList direction type name initializerOpt : annotationList direction typeIR nameIR ?(= value_init) # tid_fresh*{tid_fresh <- tid_fresh*}
      -- if initializerOpt <: initializer
      -- let = expression_init = initializerOpt as initializer
      -- Type_ok: p TC |- type as typeOrVoid : typeIR # tid_fresh*{tid_fresh <- tid_fresh*}
      -- let bound = $union_set<tid>($bound(p, TC), { tid_fresh*{tid_fresh <- tid_fresh*} })
      -- if Type_wf: bound |- typeIR holds
      -- Expr_ok: p TC |- expression_init : typedExpressionIR_init
      -- let _expressionIR # ( typeIR_init ctk ) = typedExpressionIR_init
      -- if ctk matches `LCTK`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let nameIR = $name(name)
      -- Eval_static: p TC |- typedExpressionIR_init_cast ~> value_init

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:99:1-101:23:
relation Parameters_ok: cursor typingContext |- parameter* : parameterListIR # tid*

   ;; ../../../../reference-specs/p4-concrete/5.09-typing-parameter.spectec:49:1-50:27:
   rule nil: p TC |- parameter*{parameter <- parameter*} : [] # []
      -- if parameter*{parameter <- parameter*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.09-typing-parameter.spectec:52:1-56:74:
   rule cons: p TC |- parameter*{parameter <- parameter*} : parameterIR_h :: parameterIR_t*{parameterIR_t <- parameterIR_t*} # tid_fresh_h*{tid_fresh_h <- tid_fresh_h*} ++ tid_fresh_t*{tid_fresh_t <- tid_fresh_t*}
      -- if parameter*{parameter <- parameter*} matches _ :: _
      -- let parameter_h :: parameter_t*{parameter_t <- parameter_t*} = parameter*{parameter <- parameter*}
      -- Parameter_ok: p TC |- parameter_h : parameterIR_h # tid_fresh_h*{tid_fresh_h <- tid_fresh_h*}
      -- Parameters_ok: p TC |- parameter_t*{parameter_t <- parameter_t*} : parameterIR_t*{parameterIR_t <- parameterIR_t*} # tid_fresh_t*{tid_fresh_t <- tid_fresh_t*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:103:1-103:48:
def $parameterIR(parameterIR) : parameterTypeIR =

   ;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:104:1-105:32:
   clause 0(_annotationList direction typeIR nameIR constantInitializerIR?{constantInitializerIR <- constantInitializerIR?}) = direction typeIR nameIR ?()
      -- if constantInitializerIR?{constantInitializerIR <- constantInitializerIR?} matches ()

   ;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:106:1-107:34:
   clause 1(_annotationList direction typeIR nameIR constantInitializerOptIR) = direction typeIR nameIR ?(value)
      -- if constantInitializerOptIR matches (_)
      -- let ?(= value) = constantInitializerOptIR

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:109:1-112:23:
relation ConstructorParameter_ok: cursor typingContext |- constructorParameter : constructorParameterIR # tid*

   ;; ../../../../reference-specs/p4-concrete/5.09-typing-parameter.spectec:64:1-67:64:
   rule : p TC |- constructorParameter : constructorParameterIR # tid_fresh*{tid_fresh <- tid_fresh*}
      -- Parameter_ok: p TC |- constructorParameter : constructorParameterIR # tid_fresh*{tid_fresh <- tid_fresh*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:114:1-117:23:
relation ConstructorParameters_ok: cursor typingContext |- constructorParameter* : constructorParameterListIR # tid*

   ;; ../../../../reference-specs/p4-concrete/5.09-typing-parameter.spectec:75:1-78:66:
   rule : p TC |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid_fresh*{tid_fresh <- tid_fresh*}
      -- Parameters_ok: p TC |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid_fresh*{tid_fresh <- tid_fresh*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:119:1-119:81:
def $constructorParameterIR(constructorParameterIR) : constructorParameterTypeIR =

   ;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:120:1-121:41:
   clause 0(constructorParameterIR) = $parameterIR(constructorParameterIR)

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:127:1-129:23:
relation ExternMethod_ok: typingContext tid |- methodPrototype : typingContext methodPrototypeIR

   ;; ../../../../reference-specs/p4-concrete/5.12-typing-extern-method.spectec:9:1-39:79:
   rule non-abstract: TC_0 tid_extern |- methodPrototype : TC_4 methodPrototypeIR
      -- if methodPrototype matches `%%;`
      -- let annotationList typeOrVoid name typeParameterListOpt ( parameterList ) ; = methodPrototype
      -- let nameIR = $name(name)
      -- if (nameIR =/= tid_extern)
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_1 = $add_types(local, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: local TC_1 |- typeOrVoid : typeIR_ret # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- let TC_2 = TC_1[local.kind = extern_method-> typeIR_ret]
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: local TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let TC_3 = $add_parameters(local, TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let rid = $rid(name, parameterList)
      -- let methodTypeIR = extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
      -- let routineTypeDefIR = methodTypeIR as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
      -- if RoutineTypeDef_wf: $bound(block, TC_0) |- routineTypeDefIR holds
      -- let TC_4 = $add_routine_overload(block, TC_0, rid, routineTypeDefIR)
      -- let methodPrototypeIR = annotationList typeIR_ret nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} ) ;

   ;; ../../../../reference-specs/p4-concrete/5.12-typing-extern-method.spectec:43:1-73:79:
   rule abstract: TC_0 tid_extern |- methodPrototype : TC_4 methodPrototypeIR
      -- if methodPrototype matches `%ABSTRACT%;`
      -- let annotationList abstract typeOrVoid name typeParameterListOpt ( parameterList ) ; = methodPrototype
      -- let nameIR = $name(name)
      -- if (nameIR =/= tid_extern)
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_1 = $add_types(local, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: local TC_1 |- typeOrVoid : typeIR_ret # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- let TC_2 = TC_1[local.kind = extern_methodabstract-> typeIR_ret]
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: local TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let TC_3 = $add_parameters(local, TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let rid = $rid(name, parameterList)
      -- let methodTypeIR = extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
      -- let routineTypeDefIR = methodTypeIR as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
      -- if RoutineTypeDef_wf: $bound(block, TC_0) |- routineTypeDefIR holds
      -- let TC_4 = $add_routine_overload(block, TC_0, rid, routineTypeDefIR)
      -- let methodPrototypeIR = annotationList abstract typeIR_ret nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} ) ;

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:131:1-133:23:
relation ExternMethods_ok: typingContext tid |- methodPrototype* : typingContext methodPrototypeIR*

   ;; ../../../../reference-specs/p4-concrete/5.12-typing-extern-method.spectec:81:1-82:32:
   rule nil: TC tid_extern |- methodPrototype*{methodPrototype <- methodPrototype*} : TC []
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.12-typing-extern-method.spectec:84:1-90:68:
   rule cons: TC_0 tid_extern |- methodPrototype*{methodPrototype <- methodPrototype*} : TC_2 methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- ExternMethod_ok: TC_0 tid_extern |- methodPrototype_h : TC_1 methodPrototypeIR_h
      -- ExternMethods_ok: TC_1 tid_extern |- methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} : TC_2 methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:135:1-137:23:
relation ExternConstructor_ok: typingContext tid |- methodPrototype : typingContext methodPrototypeIR

   ;; ../../../../reference-specs/p4-concrete/5.12-typing-extern-method.spectec:100:1-126:80:
   rule : TC_0 tid_extern |- methodPrototype : TC_1 methodPrototypeIR
      -- if methodPrototype matches `%%(%);`
      -- let annotationList typeIdentifier ( parameterList ); = methodPrototype
      -- let nameIR = $name(typeIdentifier as name)
      -- if (nameIR = tid_extern)
      -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_parameterList(parameterList)
      -- ConstructorParameters_ok: block TC_0 |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid_impl*{tid_impl <- tid_impl*}
      -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(global, TC_0, ` nameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR_extern < tid_expl*{tid_expl <- tid_expl*} , tid*{tid <- tid*} > = typeDefIR as polyTypeDefIR
      -- if tid*{tid <- tid*} matches []
      -- let cid = $cid(typeIdentifier as name, ( parameterList ))
      -- let typeIR_extern_spec = typeIR_extern < tid_expl*{tid_expl <- tid_expl*} , [] > < tid tid_expl as typeIR*{tid_expl <- tid_expl*} > as typeIR
      -- let constructorTypeIR = constructor( constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} )-> typeIR_extern_spec
      -- let constructorTypeDefIR = constructorTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >
      -- if ConstructorTypeDef_wf: $bound(block, TC_0) |- constructorTypeDefIR holds
      -- let TC_1 = $add_constructor(TC_0, cid, constructorTypeDefIR)
      -- let methodPrototypeIR = annotationList nameIR <, tid_impl*{tid_impl <- tid_impl*} >( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} );

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:139:1-141:23:
relation ExternConstructors_ok: typingContext tid |- methodPrototype* : typingContext methodPrototypeIR*

   ;; ../../../../reference-specs/p4-concrete/5.12-typing-extern-method.spectec:134:1-135:32:
   rule nil: TC tid_extern |- methodPrototype*{methodPrototype <- methodPrototype*} : TC []
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.12-typing-extern-method.spectec:137:1-143:73:
   rule cons: TC_0 tid_extern |- methodPrototype*{methodPrototype <- methodPrototype*} : TC_2 methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- ExternConstructor_ok: TC_0 tid_extern |- methodPrototype_h : TC_1 methodPrototypeIR_h
      -- ExternConstructors_ok: TC_1 tid_extern |- methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} : TC_2 methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:147:1-149:23:
relation ParserTransition_ok: typingContext nameIR* |- transitionStatement : transitionStatementIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:11:1-15:7:
   rule empty: TC_0 nameIR_state*{nameIR_state <- nameIR_state*} |- transitionStatement : transition "reject" ;
      -- if transitionStatement matches ``EMPTY`

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:19:1-26:55:
   rule name: TC_0 nameIR_state*{nameIR_state <- nameIR_state*} |- transitionStatement : transitionStatementIR
      -- if transitionStatement matches `TRANSITION%`
      -- let transition stateExpression = transitionStatement
      -- if stateExpression matches `%;`
      -- let name ; = stateExpression
      -- let nameIR = $name(name)
      -- if nameIR <- nameIR_state*{nameIR_state <- nameIR_state*}
      -- let transitionStatementIR = transition nameIR ;

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:292:1-306:75:
   rule switch: TC_0 nameIR_state*{nameIR_state <- nameIR_state*} |- transitionStatement : transitionStatementIR
      -- if transitionStatement matches `TRANSITION%`
      -- let transition stateExpression = transitionStatement
      -- if stateExpression <: selectExpression
      -- let select( expressionList_key ){ selectCaseList } = stateExpression as selectExpression
      -- let expression_key*{expression_key <- expression_key*} = $flatten_expressionList(expressionList_key)
      -- (Expr_ok: local TC_0 |- expression_key : typedExpressionIR_key)*{expression_key <- expression_key*, typedExpressionIR_key <- typedExpressionIR_key*}
      -- (let _expressionIR # ( typeIR_key _ctk ) = typedExpressionIR_key)*{_ctk <- _ctk*, _expressionIR <- _expressionIR*, typeIR_key <- typeIR_key*, typedExpressionIR_key <- typedExpressionIR_key*}
      -- (if Type_wf: $bound(local, TC_0) |- set< [typeIR_key] > as typeIR holds)*{typeIR_key <- typeIR_key*}
      -- let selectCase*{selectCase <- selectCase*} = $flatten_selectCaseList(selectCaseList)
      -- (SelectCase_ok: TC_0 nameIR_state*{nameIR_state <- nameIR_state*} typeIR_key*{typeIR_key <- typeIR_key*} |- selectCase : selectCaseIR)*{selectCase <- selectCase*, selectCaseIR <- selectCaseIR*}
      -- let transitionStatementIR = transition select( typedExpressionIR_key*{typedExpressionIR_key <- typedExpressionIR_key*} ){ selectCaseIR*{selectCaseIR <- selectCaseIR*} } as stateExpressionIR

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:151:1-153:20:
relation ParserStmt_ok: typingContext |- parserStatement : typingContext parserStatementIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:316:1-320:55:
   rule constantDeclaration: TC_0 |- parserStatement : TC_1 constantDeclarationIR as parserStatementIR
      -- if parserStatement <: constantDeclaration
      -- let constantDeclaration = parserStatement as constantDeclaration
      -- Decl_ok: local TC_0 |- constantDeclaration as declaration : TC_1 declarationIR
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = declarationIR as constantDeclarationIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:326:1-339:44:
   rule variableDeclaration-empty: TC_0 |- parserStatement : TC_1 variableDeclarationIR as parserStatementIR
      -- if parserStatement <: variableDeclaration
      -- let annotationList type name initializerOpt ; = parserStatement as variableDeclaration
      -- if initializerOpt matches ``EMPTY`
      -- Type_ok: local TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(local, TC_0) |- typeIR holds
      -- if $is_assignable_typeIR(typeIR)
      -- let nameIR = $name(name)
      -- let TC_1 = $add_var(local, TC_0, nameIR, inout typeIR dyn ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?() ;

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:341:1-360:73:
   rule variableDeclaration-initializer: TC_0 |- parserStatement : TC_1 variableDeclarationIR as parserStatementIR
      -- if parserStatement <: variableDeclaration
      -- let annotationList type name initializerOpt ; = parserStatement as variableDeclaration
      -- if initializerOpt <: initializer
      -- let = expression_init = initializerOpt as initializer
      -- Type_ok: local TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(local, TC_0) |- typeIR holds
      -- if $is_assignable_typeIR(typeIR)
      -- Expr_ok: local TC_0 |- expression_init : typedExpressionIR_init
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let nameIR = $name(name)
      -- let TC_1 = $add_var(local, TC_0, nameIR, inout typeIR dyn ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?(= typedExpressionIR_init_cast) ;

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:364:1-368:57:
   rule emptyStatement: TC |- parserStatement : TC emptyStatementIR as parserStatementIR
      -- if parserStatement <: emptyStatement
      -- let emptyStatement = parserStatement as emptyStatement
      -- Stmt_ok: local TC cont |- emptyStatement as statement : typingContext flow statementIR
      -- if (typingContext = TC)
      -- if flow matches `CONT`
      -- if statementIR <: emptyStatementIR
      -- let emptyStatementIR = statementIR as emptyStatementIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:372:1-376:65:
   rule assignmentStatement: TC_0 |- parserStatement : TC_1 assignmentStatementIR as parserStatementIR
      -- if parserStatement <: assignmentStatement
      -- let assignmentStatement = parserStatement as assignmentStatement
      -- Stmt_ok: local TC_0 cont |- assignmentStatement as statement : TC_1 flow statementIR
      -- if flow matches `CONT`
      -- if statementIR <: assignmentStatementIR
      -- let assignmentStatementIR = statementIR as assignmentStatementIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:380:1-384:59:
   rule callStatement: TC_0 |- parserStatement : TC_1 callStatementIR as parserStatementIR
      -- if parserStatement <: callStatement
      -- let callStatement = parserStatement as callStatement
      -- Stmt_ok: local TC_0 cont |- callStatement as statement : TC_1 flow statementIR
      -- if flow matches `CONT`
      -- if statementIR <: callStatementIR
      -- let callStatementIR = statementIR as callStatementIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:388:1-392:72:
   rule directApplicationStatement: TC_0 |- parserStatement : TC_1 directApplicationStatementIR as parserStatementIR
      -- if parserStatement <: directApplicationStatement
      -- let directApplicationStatement = parserStatement as directApplicationStatement
      -- Stmt_ok: local TC_0 cont |- directApplicationStatement as statement : TC_1 flow statementIR
      -- if flow matches `CONT`
      -- if statementIR <: directApplicationStatementIR
      -- let directApplicationStatementIR = statementIR as directApplicationStatementIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:397:1-407:72:
   rule parserBlockStatement: TC_0 |- parserStatement' : TC_1 parserBlockStatementIR as parserStatementIR
      -- if parserStatement' <: parserBlockStatement
      -- let annotationList { parserStatementList } = parserStatement' as parserBlockStatement
      -- let parserStatement*{parserStatement <- parserStatement*} = $flatten_parserStatementList(parserStatementList)
      -- let TC_1 = $enter(TC_0)
      -- ParserStmts_ok: TC_1 |- parserStatement*{parserStatement <- parserStatement*} : TC_2 parserStatementIR*{parserStatementIR <- parserStatementIR*}
      -- let TC_3 = $exit(TC_2)
      -- let parserBlockStatementIR = annotationList { parserStatementIR*{parserStatementIR <- parserStatementIR*} }

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:411:1-415:66:
   rule conditionalStatement: TC_0 |- parserStatement : TC_1 conditionalStatementIR as parserStatementIR
      -- if parserStatement <: conditionalStatement
      -- let conditionalStatement = parserStatement as conditionalStatement
      -- Stmt_ok: local TC_0 cont |- conditionalStatement as statement : TC_1 flow statementIR
      -- if flow matches `CONT`
      -- if statementIR <: conditionalStatementIR
      -- let conditionalStatementIR = statementIR as conditionalStatementIR

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:155:1-157:20:
relation ParserStmts_ok: typingContext |- parserStatement* : typingContext parserStatementIR*

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:423:1-424:21:
   rule nil: TC |- parserStatement*{parserStatement <- parserStatement*} : TC []
      -- if parserStatement*{parserStatement <- parserStatement*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:426:1-432:55:
   rule cons: TC_0 |- parserStatement*{parserStatement <- parserStatement*} : TC_2 parserStatementIR_h :: parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*}
      -- if parserStatement*{parserStatement <- parserStatement*} matches _ :: _
      -- let parserStatement_h :: parserStatement_t*{parserStatement_t <- parserStatement_t*} = parserStatement*{parserStatement <- parserStatement*}
      -- ParserStmt_ok: TC_0 |- parserStatement_h : TC_1 parserStatementIR_h
      -- ParserStmts_ok: TC_1 |- parserStatement_t*{parserStatement_t <- parserStatement_t*} : TC_2 parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:159:1-161:23:
relation ParserState_ok: typingContext nameIR* |- parserState : parserStateIR

   ;; ../../../../reference-specs/p4-concrete/5.13.2-typing-parser-state.spectec:8:1-26:82:
   rule : TC_0 nameIR_state*{nameIR_state <- nameIR_state*} |- annotationList state name { parserStatementList transitionStatement } : parserStateIR
      -- let nameIR = $name(name)
      -- let TC_1 = $enter(TC_0)
      -- let parserStatement*{parserStatement <- parserStatement*} = $flatten_parserStatementList(parserStatementList)
      -- ParserStmts_ok: TC_1 |- parserStatement*{parserStatement <- parserStatement*} : TC_2 parserStatementIR*{parserStatementIR <- parserStatementIR*}
      -- ParserTransition_ok: TC_2 nameIR_state*{nameIR_state <- nameIR_state*} |- transitionStatement : transitionStatementIR
      -- let TC_3 = $exit(TC_2)
      -- let parserStateIR = annotationList state nameIR { parserStatementIR*{parserStatementIR <- parserStatementIR*} transitionStatementIR }

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:163:1-165:20:
relation ParserStates_ok: typingContext |- parserState* : parserStateIR*

   ;; ../../../../reference-specs/p4-concrete/5.13.2-typing-parser-state.spectec:34:1-46:77:
   rule : TC |- parserState*{parserState <- parserState*} : parserStateIR*{parserStateIR <- parserStateIR*}
      -- (let _annotationList state name_state { _parserStatementList _transitionStatement } = parserState)*{_annotationList <- _annotationList*, _parserStatementList <- _parserStatementList*, _transitionStatement <- _transitionStatement*, name_state <- name_state*, parserState <- parserState*}
      -- (let nameIR_state = $name(name_state))*{nameIR_state <- nameIR_state*, name_state <- name_state*}
      -- if $distinct_<nameIR>(nameIR_state*{nameIR_state <- nameIR_state*})
      -- if "start" <- nameIR_state*{nameIR_state <- nameIR_state*}
      -- if (~"accept" <- nameIR_state*{nameIR_state <- nameIR_state*} /\ ~"reject" <- nameIR_state*{nameIR_state <- nameIR_state*})
      -- let nameIR_state_impl*{nameIR_state_impl <- nameIR_state_impl*} = "accept" :: "reject" :: nameIR_state*{nameIR_state <- nameIR_state*}
      -- (ParserState_ok: TC nameIR_state_impl*{nameIR_state_impl <- nameIR_state_impl*} |- parserState : parserStateIR)*{parserState <- parserState*, parserStateIR <- parserStateIR*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:167:1-170:20:
relation ParserLocalDecl_ok: typingContext |- parserLocalDeclaration : typingContext parserLocalDeclarationIR

   ;; ../../../../reference-specs/p4-concrete/5.13.3-typing-parser-declaration.spectec:9:1-13:55:
   rule constantDeclaration: TC_0 |- parserLocalDeclaration : TC_1 constantDeclarationIR as parserLocalDeclarationIR
      -- if parserLocalDeclaration <: constantDeclaration
      -- let constantDeclaration = parserLocalDeclaration as constantDeclaration
      -- Decl_ok: block TC_0 |- constantDeclaration as declaration : TC_1 declarationIR
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = declarationIR as constantDeclarationIR

   ;; ../../../../reference-specs/p4-concrete/5.13.3-typing-parser-declaration.spectec:17:1-21:49:
   rule instantiation: TC_0 |- parserLocalDeclaration : TC_1 instantiationIR as parserLocalDeclarationIR
      -- if parserLocalDeclaration <: instantiation
      -- let instantiation = parserLocalDeclaration as instantiation
      -- Decl_ok: block TC_0 |- instantiation as declaration : TC_1 declarationIR
      -- if declarationIR <: instantiationIR
      -- let instantiationIR = declarationIR as instantiationIR

   ;; ../../../../reference-specs/p4-concrete/5.13.3-typing-parser-declaration.spectec:27:1-40:44:
   rule variableDeclaration-empty: TC_0 |- parserLocalDeclaration : TC_1 variableDeclarationIR as parserLocalDeclarationIR
      -- if parserLocalDeclaration <: variableDeclaration
      -- let annotationList type name initializerOpt ; = parserLocalDeclaration as variableDeclaration
      -- if initializerOpt matches ``EMPTY`
      -- Type_ok: block TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(block, TC_0) |- typeIR holds
      -- if $is_assignable_typeIR(typeIR)
      -- let nameIR = $name(name)
      -- let TC_1 = $add_var(block, TC_0, nameIR, inout typeIR dyn ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?() ;

   ;; ../../../../reference-specs/p4-concrete/5.13.3-typing-parser-declaration.spectec:42:1-61:73:
   rule variableDeclaration-initializer: TC_0 |- parserLocalDeclaration : TC_1 variableDeclarationIR as parserLocalDeclarationIR
      -- if parserLocalDeclaration <: variableDeclaration
      -- let annotationList type name initializerOpt ; = parserLocalDeclaration as variableDeclaration
      -- if initializerOpt <: initializer
      -- let = expression_init = initializerOpt as initializer
      -- Type_ok: block TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(block, TC_0) |- typeIR holds
      -- if $is_assignable_typeIR(typeIR)
      -- Expr_ok: block TC_0 |- expression_init : typedExpressionIR_init
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let nameIR = $name(name)
      -- let TC_1 = $add_var(block, TC_0, nameIR, inout typeIR dyn ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?(= typedExpressionIR_init_cast) ;

   ;; ../../../../reference-specs/p4-concrete/5.13.3-typing-parser-declaration.spectec:67:1-84:78:
   rule valueSetDeclaration: TC_0 |- parserLocalDeclaration : TC_1 valueSetDeclarationIR as parserLocalDeclarationIR
      -- if parserLocalDeclaration <: valueSetDeclaration
      -- let annotationList value_set< valueSetType >( expression ) name ; = parserLocalDeclaration as valueSetDeclaration
      -- Type_ok: block TC_0 |- valueSetType as typeOrVoid : typeIR # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(block, TC_0) |- set< [typeIR] > as typeIR holds
      -- Expr_ok: block TC_0 |- expression : typedExpressionIR
      -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR
      -- if (ctk =/= dyn)
      -- let nameIR = $name(name)
      -- let TC_1 = $add_var(block, TC_0, nameIR, set< [typeIR] > as typeIR ctk ?())
      -- let valueSetDeclarationIR = annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:172:1-175:20:
relation ParserLocalDecls_ok: typingContext |- parserLocalDeclaration* : typingContext parserLocalDeclarationIR*

   ;; ../../../../reference-specs/p4-concrete/5.13.3-typing-parser-declaration.spectec:92:1-93:21:
   rule nil: TC |- parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} : TC []
      -- if parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.13.3-typing-parser-declaration.spectec:95:1-101:67:
   rule cons: TC_0 |- parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} : TC_2 parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*}
      -- if parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} matches _ :: _
      -- let parserLocalDeclaration_h :: parserLocalDeclaration_t*{parserLocalDeclaration_t <- parserLocalDeclaration_t*} = parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*}
      -- ParserLocalDecl_ok: TC_0 |- parserLocalDeclaration_h : TC_1 parserLocalDeclarationIR_h
      -- ParserLocalDecls_ok: TC_1 |- parserLocalDeclaration_t*{parserLocalDeclaration_t <- parserLocalDeclaration_t*} : TC_2 parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:181:1-183:23:
relation TableKey_ok: typingContext tableContext |- tableKey : tableContext tableKeyIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:47:1-64:77:
   rule : TC TBLC_0 |- expression : name_matchkind annotationList ; : TBLC_2 tableKeyIR
      -- Expr_ok: local TC |- expression : typedExpressionIR
      -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
      -- if Type_wf: $bound(local, TC) |- set< [typeIR] > as typeIR holds
      -- let nameIR_matchkind = $name(name_matchkind)
      -- if (match_kind. nameIR_matchkind as value = $find_value(local, TC, ` nameIR_matchkind))
      -- if $compat_table_key(nameIR_matchkind, typeIR)
      -- let TBLC_1 = $update_mode(TBLC_0, nameIR_matchkind, typeIR)
      -- let TBLC_2 = $add_key(TBLC_1, nameIR_matchkind, typeIR)
      -- let tableKeyIR = typedExpressionIR : nameIR_matchkind annotationList ;

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:185:1-187:23:
relation TableKeys_ok: typingContext tableContext |- tableKey* : tableContext tableKeyListIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:72:1-73:28:
   rule nil: TC TBLC |- tableKey*{tableKey <- tableKey*} : TBLC []
      -- if tableKey*{tableKey <- tableKey*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:75:1-79:67:
   rule cons: TC TBLC_0 |- tableKey*{tableKey <- tableKey*} : TBLC_2 tableKeyIR_h :: tableKeyIR_t*{tableKeyIR_t <- tableKeyIR_t*}
      -- if tableKey*{tableKey <- tableKey*} matches _ :: _
      -- let tableKey_h :: tableKey_t*{tableKey_t <- tableKey_t*} = tableKey*{tableKey <- tableKey*}
      -- TableKey_ok: TC TBLC_0 |- tableKey_h : TBLC_1 tableKeyIR_h
      -- TableKeys_ok: TC TBLC_1 |- tableKey_t*{tableKey_t <- tableKey_t*} : TBLC_2 tableKeyIR_t*{tableKeyIR_t <- tableKeyIR_t*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:189:1-192:23:
relation Call_action_partial_ok: typingContext |- parameterTypeIR* @ argumentListIR : parameterTypeIR* , parameterTypeIR* @ argumentListIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:103:1-115:42:
   rule : TC |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} , parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} @ argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
      -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- if (|parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- Call_convention_ok: local TC action |- parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:194:1-196:23:
relation TableAction_ok: typingContext tableContext |- tableAction : tableContext tableActionIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:122:1-136:68:
   rule prefixedNonTypeName: TC TBLC_0 |- annotationList tableActionReference ; : TBLC_1 tableActionIR
      -- if tableActionReference <: prefixedNonTypeName
      -- let prefixedNonTypeName = tableActionReference as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_routine_non_overloaded(local, TC, prefixedNameIR)
      -- if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_)
      -- let ?(routineTypeDefIR) = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?}
      -- if routineTypeDefIR <: functionTypeIR
      -- let functionTypeIR = routineTypeDefIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
      -- Call_action_partial_ok: TC |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ [] : parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} , parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} @ argumentIR*{argumentIR <- argumentIR*}
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- let TBLC_1 = $add_action(TBLC_0, prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, [])
      -- let tableActionIR = annotationList prefixedNameIR ( [] ) ;

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:140:1-157:81:
   rule prefixedNonTypeName-argumentList: TC TBLC_0 |- annotationList tableActionReference ; : TBLC_1 tableActionIR
      -- if tableActionReference matches `%(%)`
      -- let prefixedNonTypeName ( argumentList ) = tableActionReference
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_routine_non_overloaded(local, TC, prefixedNameIR)
      -- if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_)
      -- let ?(routineTypeDefIR) = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?}
      -- if routineTypeDefIR <: functionTypeIR
      -- let functionTypeIR = routineTypeDefIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: local TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Call_action_partial_ok: TC |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} , parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} @ argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
      -- let TBLC_1 = $add_action(TBLC_0, prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- let tableActionIR = annotationList prefixedNameIR ( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} ) ;

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:198:1-200:23:
relation TableActions_ok: typingContext tableContext |- tableAction* : tableContext tableActionListIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:165:1-166:28:
   rule nil: TC TBLC |- tableAction*{tableAction <- tableAction*} : TBLC []
      -- if tableAction*{tableAction <- tableAction*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:168:1-172:76:
   rule cons: TC TBLC_0 |- tableAction*{tableAction <- tableAction*} : TBLC_2 tableActionIR_h :: tableActionIR_t*{tableActionIR_t <- tableActionIR_t*}
      -- if tableAction*{tableAction <- tableAction*} matches _ :: _
      -- let tableAction_h :: tableAction_t*{tableAction_t <- tableAction_t*} = tableAction*{tableAction <- tableAction*}
      -- TableAction_ok: TC TBLC_0 |- tableAction_h : TBLC_1 tableActionIR_h
      -- TableActions_ok: TC TBLC_1 |- tableAction_t*{tableAction_t <- tableAction_t*} : TBLC_2 tableActionIR_t*{tableActionIR_t <- tableActionIR_t*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:202:1-205:23:
relation Call_action_default_ok: typingContext |- parameterTypeIR* @ argumentListIR : parameterTypeIR* , parameterTypeIR* @ argumentListIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:180:1-190:42:
   rule : TC |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} , parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} @ argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
      -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- Call_convention_ok: local TC action |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:207:1-209:23:
relation TableDefaultAction_ok: typingContext tableContext |- initializer : tableActionReferenceIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:194:1-199:56:
   rule prefixedNonTypeName: TC TBLC |- = expression : prefixedNameIR ( [] )
      -- if expression <: prefixedNonTypeName
      -- let prefixedNonTypeName = expression as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- if (?(([], [])) = $find_action(TBLC, prefixedNameIR))

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:203:1-224:57:
   rule prefixedNonTypeName-argumentList: TC TBLC |- = expression : prefixedNameIR ( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `%(%)`
      -- let callTarget ( argumentList ) = callExpression
      -- if callTarget <: prefixedNonTypeName
      -- let prefixedNonTypeName = callTarget as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} = $find_action(TBLC, prefixedNameIR)
      -- if (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} matches (_)
      -- let ?((parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*}, argumentIR_action*{argumentIR_action <- argumentIR_action*})) = (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?}
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: local TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Call_action_default_ok: TC |- parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*} @ argumentIR*{argumentIR <- argumentIR*} : parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*} , parameterTypeIR_action_control*{parameterTypeIR_action_control <- parameterTypeIR_action_control*} @ argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
      -- let argumentIR_action_data*{argumentIR_action_data <- argumentIR_action_data*} = argumentIR_action*{argumentIR_action <- argumentIR_action*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
      -- let argumentIR_cast_data*{argumentIR_cast_data <- argumentIR_cast_data*} = argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
      -- (if (argumentIR_action_data = argumentIR_cast_data))*{argumentIR_action_data <- argumentIR_action_data*, argumentIR_cast_data <- argumentIR_cast_data*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:211:1-213:23:
relation TableEntry_keyset_ok: typingContext tableContext |- keysetExpression : tableEntryState keysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:411:1-418:53:
   rule simpleKeysetExpression-expression: TC TBLC |- keysetExpression : TBLS simpleKeysetExpressionIR as keysetExpressionIR
      -- if keysetExpression <: expression
      -- let expression = keysetExpression as expression
      -- if (|TBLC.keys| = 1)
      -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ [expression as simpleKeysetExpression] : TBLS simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
      -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
      -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:422:1-429:53:
   rule simpleKeysetExpression-mask: TC TBLC |- keysetExpression : TBLS simpleKeysetExpressionIR as keysetExpressionIR
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `%&&&%`
      -- let expression_l &&& expression_r = simpleKeysetExpression
      -- if (|TBLC.keys| = 1)
      -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ [expression_l &&& expression_r] : TBLS simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
      -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
      -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:433:1-440:53:
   rule simpleKeysetExpression-range: TC TBLC |- keysetExpression : TBLS simpleKeysetExpressionIR as keysetExpressionIR
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `%..%`
      -- let expression_l .. expression_r = simpleKeysetExpression
      -- if (|TBLC.keys| = 1)
      -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ [expression_l .. expression_r] : TBLS simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
      -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
      -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:444:1-447:21:
   rule simpleKeysetExpression-default-noprilpm: TC TBLC |- keysetExpression : TBLS default as keysetExpressionIR
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `DEFAULT`
      -- let matchMode = TBLC.mode
      -- if matchMode matches `NOPRILPM%`
      -- let noprilpm n = matchMode
      -- let TBLS = lpm n

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:449:1-452:21:
   rule simpleKeysetExpression-default-else: TC TBLC |- keysetExpression : TBLS default as keysetExpressionIR
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `DEFAULT`
      -- if (((TBLC.mode = nopri) \/ (TBLC.mode = pri)) \/ (TBLC.mode = prilpm))
      -- let TBLS = nolpm

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:456:1-459:21:
   rule simpleKeysetExpression-dontcare-noprilpm: TC TBLC |- keysetExpression : TBLS _ as keysetExpressionIR
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `_`
      -- let matchMode = TBLC.mode
      -- if matchMode matches `NOPRILPM%`
      -- let noprilpm n = matchMode
      -- let TBLS = lpm 0

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:461:1-464:21:
   rule simpleKeysetExpression-dontcare-else: TC TBLC |- keysetExpression : TBLS _ as keysetExpressionIR
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `_`
      -- if (((TBLC.mode = nopri) \/ (TBLC.mode = pri)) \/ (TBLC.mode = prilpm))
      -- let TBLS = nolpm

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:471:1-479:53:
   rule tupleKeysetExpression-mask: TC TBLC |- keysetExpression : TBLS ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(%&&&%)`
      -- let ( expression_l &&& expression_r ) = tupleKeysetExpression
      -- if (|TBLC.keys| = 1)
      -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ [expression_l &&& expression_r] : TBLS simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
      -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
      -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:483:1-491:53:
   rule tupleKeysetExpression-range: TC TBLC |- keysetExpression : TBLS ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(%..%)`
      -- let ( expression_l .. expression_r ) = tupleKeysetExpression
      -- if (|TBLC.keys| = 1)
      -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ [expression_l .. expression_r] : TBLS simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
      -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
      -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:495:1-498:21:
   rule tupleKeysetExpression-default-noprilpm: TC TBLC |- keysetExpression : TBLS ( [default] ) as keysetExpressionIR
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(DEFAULT)`
      -- let matchMode = TBLC.mode
      -- if matchMode matches `NOPRILPM%`
      -- let noprilpm n = matchMode
      -- let TBLS = lpm n

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:500:1-503:21:
   rule tupleKeysetExpression-default-else: TC TBLC |- keysetExpression : TBLS ( [default] ) as keysetExpressionIR
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(DEFAULT)`
      -- if (((TBLC.mode = nopri) \/ (TBLC.mode = pri)) \/ (TBLC.mode = prilpm))
      -- let TBLS = nolpm

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:507:1-510:21:
   rule tupleKeysetExpression-dontcare-noprilpm: TC TBLC |- keysetExpression : TBLS ( [_] ) as keysetExpressionIR
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(_)`
      -- let matchMode = TBLC.mode
      -- if matchMode matches `NOPRILPM%`
      -- let noprilpm n = matchMode
      -- let TBLS = lpm 0

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:512:1-515:21:
   rule simpleKeysetExpression-dontcare-else: TC TBLC |- keysetExpression : TBLS ( [_] ) as keysetExpressionIR
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(_)`
      -- if (((TBLC.mode = nopri) \/ (TBLC.mode = pri)) \/ (TBLC.mode = prilpm))
      -- let TBLS = nolpm

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:519:1-531:54:
   rule tupleKeysetExpression-list: TC TBLC |- keysetExpression : TBLS ( simpleKeysetExpressionIR*{simpleKeysetExpressionIR <- simpleKeysetExpressionIR*} ) as keysetExpressionIR
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(%,%)`
      -- let ( simpleKeysetExpression_h , simpleKeysetExpressionList_t ) = tupleKeysetExpression
      -- let simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*} = $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList_t)
      -- let simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} = simpleKeysetExpression_h :: simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*}
      -- if (|TBLC.keys| = |simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*}|)
      -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} : TBLS simpleKeysetExpressionIR*{simpleKeysetExpressionIR <- simpleKeysetExpressionIR*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:215:1-217:23:
relation TableEntry_action_ok: typingContext tableContext |- tableActionReference : tableActionReferenceIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:541:1-545:56:
   rule prefixedNonTypeName: TC TBLC |- tableActionReference : prefixedNameIR ( [] )
      -- if tableActionReference <: prefixedNonTypeName
      -- let prefixedNonTypeName = tableActionReference as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- if (?(([], [])) = $find_action(TBLC, prefixedNameIR))

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:549:1-570:57:
   rule prefixedNonTypeName-argumentList: TC TBLC |- tableActionReference : prefixedNameIR ( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if tableActionReference matches `%(%)`
      -- let prefixedNonTypeName ( argumentList ) = tableActionReference
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} = $find_action(TBLC, prefixedNameIR)
      -- if (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} matches (_)
      -- let ?((parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*}, argumentIR_action*{argumentIR_action <- argumentIR_action*})) = (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?}
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: local TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Call_action_default_ok: TC |- parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*} @ argumentIR*{argumentIR <- argumentIR*} : parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*} , parameterTypeIR_action_control*{parameterTypeIR_action_control <- parameterTypeIR_action_control*} @ argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
      -- let argumentIR_action_data*{argumentIR_action_data <- argumentIR_action_data*} = argumentIR_action*{argumentIR_action <- argumentIR_action*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
      -- let argumentIR_cast_data*{argumentIR_cast_data <- argumentIR_cast_data*} = argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
      -- (if (argumentIR_action_data = argumentIR_cast_data))*{argumentIR_action_data <- argumentIR_action_data*, argumentIR_cast_data <- argumentIR_cast_data*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:219:1-222:26:
relation TableEntry_priority_ok: typingContext tableContext tableEntryState |- tableEntryPriority? : tableContext tableEntryPriorityOptIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:580:1-582:26:
   rule nopri: TC TBLC TBLS |- tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} : TBLC ?()
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- if (TBLC.mode = nopri)

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:584:1-587:28:
   rule noprilpm: TC TBLC TBLS |- tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} : TBLC ?()
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- let matchMode = TBLC.mode
      -- if matchMode matches `NOPRILPM%`
      -- let noprilpm n = matchMode
      -- let tableEntryState = TBLS
      -- if tableEntryState matches `LPM%`
      -- let lpm n_prefix = tableEntryState

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:589:1-601:48:
   rule pri-prilpm-number-init-largest-wins: TC TBLC_0 TBLS |- tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} : TBLC_1 ?(priority= d n as int :)
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
      -- if (TBLC_0.priorities.values = [])
      -- if TBLC_0.priorities.largest_wins
      -- let n_size = TBLC_0.entries.size
      -- let n_delta = TBLC_0.priorities.delta
      -- let n = (((n_size - 1) * n_delta) + 1)
      -- let TBLC_1 = $add_table_priority(TBLC_0, n)

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:603:1-612:48:
   rule pri-prilpm-number-init-non-largest-wins: TC TBLC_0 TBLS |- tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} : TBLC_1 ?(priority= d 1 as int :)
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
      -- if (TBLC_0.priorities.values = [])
      -- if ~TBLC_0.priorities.largest_wins
      -- let TBLC_1 = $add_table_priority(TBLC_0, 1)

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:614:1-626:48:
   rule pri-prilpm-number-non-init-largest-wins: TC TBLC_0 TBLS |- tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} : TBLC_1 ?(priority= d n as int :)
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
      -- if (TBLC_0.priorities.values =/= [])
      -- if TBLC_0.priorities.largest_wins
      -- let n_last = $find_table_priority_last(TBLC_0)
      -- let n_delta = TBLC_0.priorities.delta
      -- let n = (n_last - n_delta)
      -- let TBLC_1 = $add_table_priority(TBLC_0, n)

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:628:1-640:48:
   rule pri-prilpm-number-non-init-non-largest-wins: TC TBLC_0 TBLS |- tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} : TBLC_1 ?(priority= d n as int :)
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
      -- if (TBLC_0.priorities.values =/= [])
      -- if ~TBLC_0.priorities.largest_wins
      -- let n_last = $find_table_priority_last(TBLC_0)
      -- let n_delta = TBLC_0.priorities.delta
      -- let n = (n_last + n_delta)
      -- let TBLC_1 = $add_table_priority(TBLC_0, n)

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:644:1-655:48:
   rule pri-prilpm-number-init: TC TBLC_0 TBLS |- tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} : TBLC_2 ?(priority= number :)
      -- if tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} matches (_)
      -- let ?(tableEntryPriority) = tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?}
      -- if tableEntryPriority matches `PRIORITY=%:`
      -- let priority= number : = tableEntryPriority
      -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
      -- if ~TBLC_0.entries.const
      -- if (TBLC_0.priorities.values = [])
      -- let int = $to_number(number as value)
      -- if int <: nat
      -- let n = int as nat
      -- let TBLC_1 = TBLC_0[priorities.init = true]
      -- let TBLC_2 = $add_table_priority(TBLC_1, n)

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:657:1-668:48:
   rule pri-prilpm-number-non-init: TC TBLC_0 TBLS |- tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} : TBLC_1 ?(priority= number :)
      -- if tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} matches (_)
      -- let ?(tableEntryPriority) = tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?}
      -- if tableEntryPriority matches `PRIORITY=%:`
      -- let priority= number : = tableEntryPriority
      -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
      -- if ~TBLC_0.entries.const
      -- if (TBLC_0.priorities.values =/= [])
      -- if TBLC_0.priorities.init
      -- let int = $to_number(number as value)
      -- if int <: nat
      -- let n = int as nat
      -- let TBLC_1 = $add_table_priority(TBLC_0, n)

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:672:1-686:48:
   rule pri-prilpm-expression-init: TC TBLC_0 TBLS |- tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} : TBLC_2 ?(priority=( typedExpressionIR ):)
      -- if tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} matches (_)
      -- let ?(tableEntryPriority) = tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?}
      -- if tableEntryPriority matches `PRIORITY=(%):`
      -- let priority=( expression ): = tableEntryPriority
      -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
      -- if ~TBLC_0.entries.const
      -- if (TBLC_0.priorities.values = [])
      -- Expr_ok: local TC |- expression : typedExpressionIR
      -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR
      -- if ctk matches `LCTK`
      -- Eval_static: local TC |- typedExpressionIR ~> value
      -- let int = $to_number(value)
      -- if int <: nat
      -- let n = int as nat
      -- let TBLC_1 = TBLC_0[priorities.init = true]
      -- let TBLC_2 = $add_table_priority(TBLC_1, n)

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:688:1-702:48:
   rule pri-prilpm-expression-non-init: TC TBLC_0 TBLS |- tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} : TBLC_1 ?(priority=( typedExpressionIR ):)
      -- if tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} matches (_)
      -- let ?(tableEntryPriority) = tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?}
      -- if tableEntryPriority matches `PRIORITY=(%):`
      -- let priority=( expression ): = tableEntryPriority
      -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
      -- if ~TBLC_0.entries.const
      -- if (TBLC_0.priorities.values =/= [])
      -- if TBLC_0.priorities.init
      -- Expr_ok: local TC |- expression : typedExpressionIR
      -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR
      -- if ctk matches `LCTK`
      -- Eval_static: local TC |- typedExpressionIR ~> value
      -- let int = $to_number(value)
      -- if int <: nat
      -- let n = int as nat
      -- let TBLC_1 = $add_table_priority(TBLC_0, n)

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:224:1-226:23:
relation TableEntry_ok: typingContext tableContext |- tableEntry : tableContext tableEntryIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:707:1-722:73:
   rule priority: TC TBLC_0 |- tableEntry : TBLC_1 tableEntryIR
      -- if tableEntry matches `%%%:%%;`
      -- let constOpt tableEntryPriority keysetExpression : tableActionReference annotationList ; = tableEntry
      -- TableEntry_keyset_ok: TC TBLC_0 |- keysetExpression : TBLS keysetExpressionIR
      -- TableEntry_action_ok: TC TBLC_0 |- tableActionReference : tableActionReferenceIR
      -- TableEntry_priority_ok: TC TBLC_0 TBLS |- ?(tableEntryPriority) : TBLC_1 tableEntryPriorityOptIR
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tableEntryIR = constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:726:1-740:73:
   rule non-priority: TC TBLC_0 |- tableEntry : TBLC_1 tableEntryIR
      -- if tableEntry matches `%%:%%;`
      -- let constOpt keysetExpression : tableActionReference annotationList ; = tableEntry
      -- TableEntry_keyset_ok: TC TBLC_0 |- keysetExpression : TBLS keysetExpressionIR
      -- TableEntry_action_ok: TC TBLC_0 |- tableActionReference : tableActionReferenceIR
      -- TableEntry_priority_ok: TC TBLC_0 TBLS |- ?() : TBLC_1 tableEntryPriorityOptIR
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tableEntryIR = constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:228:1-230:23:
relation TableEntries_ok: typingContext tableContext |- tableEntry* : tableContext tableEntryListIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:748:1-749:28:
   rule nil: TC TBLC |- tableEntry*{tableEntry <- tableEntry*} : TBLC []
      -- if tableEntry*{tableEntry <- tableEntry*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:751:1-755:74:
   rule cons: TC TBLC_0 |- tableEntry*{tableEntry <- tableEntry*} : TBLC_2 tableEntryIR_h :: tableEntryIR_t*{tableEntryIR_t <- tableEntryIR_t*}
      -- if tableEntry*{tableEntry <- tableEntry*} matches _ :: _
      -- let tableEntry_h :: tableEntry_t*{tableEntry_t <- tableEntry_t*} = tableEntry*{tableEntry <- tableEntry*}
      -- TableEntry_ok: TC TBLC_0 |- tableEntry_h : TBLC_1 tableEntryIR_h
      -- TableEntries_ok: TC TBLC_1 |- tableEntry_t*{tableEntry_t <- tableEntry_t*} : TBLC_2 tableEntryIR_t*{tableEntryIR_t <- tableEntryIR_t*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:232:1-234:23:
relation TableProperty_ok: typingContext tableContext |- tableProperty : tableContext tablePropertyIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:765:1-769:63:
   rule key: TC TBLC_0 |- tableProperty : TBLC_1 key={ tableKeyIR*{tableKeyIR <- tableKeyIR*} }
      -- if tableProperty matches `KEY={%}`
      -- let key={ tableKeyList } = tableProperty
      -- let tableKey*{tableKey <- tableKey*} = $flatten_tableKeyList(tableKeyList)
      -- TableKeys_ok: TC TBLC_0 |- tableKey*{tableKey <- tableKey*} : TBLC_1 tableKeyIR*{tableKeyIR <- tableKeyIR*}

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:773:1-777:72:
   rule actions: TC TBLC_0 |- tableProperty : TBLC_1 actions={ tableActionIR*{tableActionIR <- tableActionIR*} }
      -- if tableProperty matches `ACTIONS={%}`
      -- let actions={ tableActionList } = tableProperty
      -- let tableAction*{tableAction <- tableAction*} = $flatten_tableActionList(tableActionList)
      -- TableActions_ok: TC TBLC_0 |- tableAction*{tableAction <- tableAction*} : TBLC_1 tableActionIR*{tableActionIR <- tableActionIR*}

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:781:1-793:70:
   rule entries: TC TBLC_0 |- tableProperty : TBLC_3 annotationList constOptIR entries={ tableEntryIR*{tableEntryIR <- tableEntryIR*} }
      -- if tableProperty matches `%%ENTRIES={%}`
      -- let annotationList constOpt entries={ tableEntryList } = tableProperty
      -- let tableEntry*{tableEntry <- tableEntry*} = $flatten_tableEntryList(tableEntryList)
      -- if ((|TBLC_0.keys| = 0) => (|tableEntry*{tableEntry <- tableEntry*}| = 0))
      -- let TBLC_1 = TBLC_0[entries.size = |tableEntry*{tableEntry <- tableEntry*}|]
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let TBLC_2 = TBLC_1[entries.const = (constOptIR = ?(const))]
      -- TableEntries_ok: TC TBLC_2 |- tableEntry*{tableEntry <- tableEntry*} : TBLC_3 tableEntryIR*{tableEntryIR <- tableEntryIR*}

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:797:1-807:78:
   rule custom-default-action: TC TBLC |- tableProperty : TBLC tablePropertyIR
      -- if tableProperty matches `%%%%;`
      -- let annotationList constOpt tableCustomName initializer ; = tableProperty
      -- if ("default_action" = $tableCustomName(tableCustomName))
      -- TableDefaultAction_ok: TC TBLC |- initializer : tableActionReferenceIR
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tablePropertyIR = annotationList constOptIR default_action= tableActionReferenceIR ;

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:809:1-823:74:
   rule custom-size: TC TBLC |- tableProperty : TBLC tablePropertyIR
      -- if tableProperty matches `%%%%;`
      -- let annotationList constOpt tableCustomName = expression ; = tableProperty
      -- if ("size" = $tableCustomName(tableCustomName))
      -- Expr_ok: local TC |- expression : typedExpressionIR
      -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
      -- if (($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tablePropertyIR = annotationList constOptIR custom "size" = typedExpressionIR ;

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:825:1-840:70:
   rule custom-largest-priority-wins: TC TBLC_0 |- tableProperty : TBLC_1 tablePropertyIR
      -- if tableProperty matches `%%%%;`
      -- let annotationList constOpt tableCustomName = expression ; = tableProperty
      -- if ("largest_priority_wins" = $tableCustomName(tableCustomName))
      -- Expr_ok: local TC |- expression : typedExpressionIR
      -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`
      -- Eval_static: local TC |- typedExpressionIR ~> value
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `B%`
      -- let b b_largest_priority_wins = primitiveValue
      -- let TBLC_1 = TBLC_0[priorities.largest_wins = b_largest_priority_wins]
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tablePropertyIR = annotationList constOptIR custom_const "largest_priority_wins" = b b_largest_priority_wins as value ;

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:842:1-862:47:
   rule custom-priority-delta: TC TBLC_0 |- tableProperty : TBLC_1 tablePropertyIR
      -- if tableProperty matches `%%%%;`
      -- let annotationList constOpt tableCustomName = expression ; = tableProperty
      -- if ("priority_delta" = $tableCustomName(tableCustomName))
      -- Expr_ok: local TC |- expression : typedExpressionIR
      -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
      -- if (($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))
      -- Eval_static: local TC |- typedExpressionIR ~> value
      -- let int = $to_number(value)
      -- if int <: nat
      -- let n_delta = int as nat
      -- if (n_delta > 0)
      -- let TBLC_1 = TBLC_0[priorities.delta = n_delta]
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tablePropertyIR = annotationList constOptIR custom_const "priority_delta" = d n_delta as int as value ;

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:864:1-877:74:
   rule custom: TC TBLC |- tableProperty : TBLC tablePropertyIR
      -- if tableProperty matches `%%%%;`
      -- let annotationList constOpt tableCustomName = expression ; = tableProperty
      -- let nameIR = $tableCustomName(tableCustomName)
      -- if (((nameIR =/= "size") /\ (nameIR =/= "largest_priority_wins")) /\ (nameIR =/= "priority_delta"))
      -- Expr_ok: local TC |- expression : typedExpressionIR
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tablePropertyIR = annotationList constOptIR custom nameIR = typedExpressionIR ;

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:236:1-238:23:
relation TableProperties_ok: typingContext tableContext |- tableProperty* : tableContext tablePropertyListIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:885:1-886:28:
   rule nil: TC TBLC |- tableProperty*{tableProperty <- tableProperty*} : TBLC []
      -- if tableProperty*{tableProperty <- tableProperty*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:888:1-892:83:
   rule cons: TC TBLC_0 |- tableProperty*{tableProperty <- tableProperty*} : TBLC_2 tablePropertyIR_h :: tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*}
      -- if tableProperty*{tableProperty <- tableProperty*} matches _ :: _
      -- let tableProperty_h :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty*{tableProperty <- tableProperty*}
      -- TableProperty_ok: TC TBLC_0 |- tableProperty_h : TBLC_1 tablePropertyIR_h
      -- TableProperties_ok: TC TBLC_1 |- tableProperty_t*{tableProperty_t <- tableProperty_t*} : TBLC_2 tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:240:1-242:20:
relation Table_ok: typingContext |- tableProperty* : tableContext tablePropertyListIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:926:1-934:79:
   rule : TC |- tableProperty*{tableProperty <- tableProperty*} : TBLC_1 tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
      -- if ($count_table_keys(tableProperty*{tableProperty <- tableProperty*}) <= 1)
      -- if ($count_table_actions(tableProperty*{tableProperty <- tableProperty*}) = 1)
      -- let TBLC_0 = $empty_tableContext
      -- TableProperties_ok: TC TBLC_0 |- tableProperty*{tableProperty <- tableProperty*} : TBLC_1 tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:244:1-246:23:
relation TableType_ok: typingContext tableContext |- name : typingContext typeIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:936:1-962:59:
   rule : TC_0 TBLC |- name : TC_1 typeIR_table
      -- let nameIR = $name(name)
      -- let tid_enum = "action_list(" ++ nameIR ++ ")"
      -- let (prefixedNameIR_action, _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}, _argumentListIR)*{_argumentListIR <- _argumentListIR*, _parameterTypeIR* <- _parameterTypeIR**, prefixedNameIR_action <- prefixedNameIR_action*} = TBLC.actions
      -- (let id_enum_field = $flatten_prefixedNameIR(prefixedNameIR_action))*{id_enum_field <- id_enum_field*, prefixedNameIR_action <- prefixedNameIR_action*}
      -- let typeIR_table_enum = table_enum tid_enum { id_enum_field*{id_enum_field <- id_enum_field*} } as typeIR
      -- (let value_enum_field = table_enum tid_enum . id_enum_field as value)*{id_enum_field <- id_enum_field*, value_enum_field <- value_enum_field*}
      -- (let varTypeIR_enum_field = typeIR_table_enum lctk ?(value_enum_field))*{value_enum_field <- value_enum_field*, varTypeIR_enum_field <- varTypeIR_enum_field*}
      -- let TC_1 = $add_vars(block, TC_0, tid_enum ++ "." ++ id_enum_field*{id_enum_field <- id_enum_field*}, varTypeIR_enum_field*{varTypeIR_enum_field <- varTypeIR_enum_field*})
      -- let tid_struct = "apply_result(" ++ nameIR ++ ")"
      -- let typeIR_table_struct = table_struct tid_struct { [bool as typeIR "hit" ;, bool as typeIR "miss" ;, typeIR_table_enum "action_run" ;] } as typeIR
      -- let typeIR_table = table nameIR # typeIR_table_struct as typeIR

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:248:1-251:20:
relation ControlLocalDecl_ok: typingContext |- controlLocalDeclaration : typingContext controlLocalDeclarationIR

   ;; ../../../../reference-specs/p4-concrete/5.14.2-typing-control-declaration.spectec:9:1-11:77:
   rule constantDeclaration: TC_0 |- controlLocalDeclaration : TC_1 constantDeclarationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: constantDeclaration
      -- let constantDeclaration = controlLocalDeclaration as constantDeclaration
      -- Decl_ok: block TC_0 |- constantDeclaration as declaration : TC_1 declarationIR
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = declarationIR as constantDeclarationIR

   ;; ../../../../reference-specs/p4-concrete/5.14.2-typing-control-declaration.spectec:15:1-17:65:
   rule instantiation: TC_0 |- controlLocalDeclaration : TC_1 instantiationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: instantiation
      -- let instantiation = controlLocalDeclaration as instantiation
      -- Decl_ok: block TC_0 |- instantiation as declaration : TC_1 declarationIR
      -- if declarationIR <: instantiationIR
      -- let instantiationIR = declarationIR as instantiationIR

   ;; ../../../../reference-specs/p4-concrete/5.14.2-typing-control-declaration.spectec:23:1-36:44:
   rule variableDeclaration-empty: TC_0 |- controlLocalDeclaration : TC_1 variableDeclarationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: variableDeclaration
      -- let annotationList type name initializerOpt ; = controlLocalDeclaration as variableDeclaration
      -- if initializerOpt matches ``EMPTY`
      -- Type_ok: block TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(block, TC_0) |- typeIR holds
      -- if $is_assignable_typeIR(typeIR)
      -- let nameIR = $name(name)
      -- let TC_1 = $add_var(block, TC_0, nameIR, inout typeIR dyn ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?() ;

   ;; ../../../../reference-specs/p4-concrete/5.14.2-typing-control-declaration.spectec:38:1-57:73:
   rule variableDeclaration-initializer: TC_0 |- controlLocalDeclaration : TC_1 variableDeclarationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: variableDeclaration
      -- let annotationList type name initializerOpt ; = controlLocalDeclaration as variableDeclaration
      -- if initializerOpt <: initializer
      -- let = expression_init = initializerOpt as initializer
      -- Type_ok: block TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(block, TC_0) |- typeIR holds
      -- if $is_assignable_typeIR(typeIR)
      -- Expr_ok: block TC_0 |- expression_init : typedExpressionIR_init
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let nameIR = $name(name)
      -- let TC_1 = $add_var(block, TC_0, nameIR, inout typeIR dyn ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?(= typedExpressionIR_init_cast) ;

   ;; ../../../../reference-specs/p4-concrete/5.14.2-typing-control-declaration.spectec:61:1-63:73:
   rule actionDeclaration: TC_0 |- controlLocalDeclaration : TC_1 actionDeclarationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: actionDeclaration
      -- let actionDeclaration = controlLocalDeclaration as actionDeclaration
      -- Decl_ok: block TC_0 |- actionDeclaration as declaration : TC_1 declarationIR
      -- if declarationIR <: actionDeclarationIR
      -- let actionDeclarationIR = declarationIR as actionDeclarationIR

   ;; ../../../../reference-specs/p4-concrete/5.14.2-typing-control-declaration.spectec:69:1-83:71:
   rule tableDeclaration: TC_0 |- controlLocalDeclaration : TC_3 tableDeclarationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: tableDeclaration
      -- let annotationList table name { tablePropertyList } = controlLocalDeclaration as tableDeclaration
      -- let TC_1 = TC_0[local.kind = table_apply_method]
      -- let tableProperty*{tableProperty <- tableProperty*} = $flatten_tablePropertyList(tablePropertyList)
      -- Table_ok: TC_1 |- tableProperty*{tableProperty <- tableProperty*} : TBLC tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
      -- let nameIR = $name(name)
      -- TableType_ok: TC_1 TBLC |- name : TC_2 typeIR_table
      -- let TC_3 = $add_var(block, TC_2, nameIR, typeIR_table dyn ?())
      -- let tableDeclarationIR = annotationList table typeIR_table nameIR { tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} }

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:253:1-256:20:
relation ControlLocalDecls_ok: typingContext |- controlLocalDeclaration* : typingContext controlLocalDeclarationIR*

   ;; ../../../../reference-specs/p4-concrete/5.14.2-typing-control-declaration.spectec:91:1-92:21:
   rule nil: TC |- controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} : TC []
      -- if controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.14.2-typing-control-declaration.spectec:94:1-100:69:
   rule cons: TC_0 |- controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} : TC_2 controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*}
      -- if controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} matches _ :: _
      -- let controlLocalDeclaration_h :: controlLocalDeclaration_t*{controlLocalDeclaration_t <- controlLocalDeclaration_t*} = controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*}
      -- ControlLocalDecl_ok: TC_0 |- controlLocalDeclaration_h : TC_1 controlLocalDeclarationIR_h
      -- ControlLocalDecls_ok: TC_1 |- controlLocalDeclaration_t*{controlLocalDeclaration_t <- controlLocalDeclaration_t*} : TC_2 controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:262:1-264:23:
relation Decl_ok: cursor typingContext |- declaration : typingContext declarationIR

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:9:1-29:57:
   rule constantDeclaration: p TC_0 |- declaration : TC_1 constantDeclarationIR as declarationIR
      -- if declaration <: constantDeclaration
      -- let annotationList const type name = expression_value ; = declaration as constantDeclaration
      -- Type_ok: p TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(p, TC_0) |- typeIR holds
      -- Expr_ok: p TC_0 |- expression_value : typedExpressionIR_value
      -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR_value
      -- if ctk matches `LCTK`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_value, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_value_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- Eval_static: p TC_0 |- typedExpressionIR_value_cast ~> value
      -- let nameIR = $name(name)
      -- let TC_1 = $add_var(p, TC_0, nameIR, typeIR lctk ?(value))
      -- let constantDeclarationIR = annotationList const typeIR nameIR = value ;

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:36:1-56:71:
   rule instantiation-prefixedTypeName-non-objectInitializer: p TC_0 |- declaration : TC_1 instantiationIR as declarationIR
      -- if declaration <: instantiation
      -- let instantiation = declaration as instantiation
      -- if instantiation matches `%%(%)%;`
      -- let annotationList type ( argumentList ) name ; = instantiation
      -- if type <: prefixedTypeName
      -- let prefixedTypeName = type as prefixedTypeName
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: p TC_0 |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- ConstructorType_ok: p TC_0 |- prefixedNameIR < [] >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
      -- Inst_ok: p TC_0 named |- constructorTypeIR < [] # tid_impl*{tid_impl <- tid_impl*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- let nameIR = $name(name)
      -- let TC_1 = $add_var(p, TC_0, nameIR, typeIR_object ctk ?())
      -- let instantiationIR = annotationList typeIR_object prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR*{argumentIR <- argumentIR*} ) nameIR ?() ;

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:58:1-84:71:
   rule instantiation-specializedType-non-objectInitializer: p TC_0 |- declaration : TC_1 instantiationIR as declarationIR
      -- if declaration <: instantiation
      -- let instantiation = declaration as instantiation
      -- if instantiation matches `%%(%)%;`
      -- let annotationList type ( argumentList ) name ; = instantiation
      -- if type <: specializedType
      -- let prefixedTypeName < typeArgumentList > = type as specializedType
      -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
      -- TypeArguments_ok: p TC_0 |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_impl*{tid_impl <- tid_impl*}
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: p TC_0 |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- ConstructorType_ok: p TC_0 |- prefixedNameIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
      -- Inst_ok: p TC_0 named |- constructorTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- let nameIR = $name(name)
      -- let TC_1 = $add_var(p, TC_0, nameIR, typeIR_object ctk ?())
      -- let instantiationIR = annotationList typeIR_object prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR*{argumentIR <- argumentIR*} ) nameIR ?() ;

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:190:1-232:98:
   rule instantiation-prefixedTypeName-objectInitializer: p TC_0 |- declaration : TC_2 instantiationIR as declarationIR
      -- if declaration <: instantiation
      -- let instantiation = declaration as instantiation
      -- if instantiation matches `%%(%)%%;`
      -- let annotationList type ( argumentList ) name ={ objectDeclarationList } ; = instantiation
      -- if type <: prefixedTypeName
      -- let prefixedTypeName = type as prefixedTypeName
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: p TC_0 |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- ConstructorType_ok: p TC_0 |- prefixedNameIR < [] >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
      -- Inst_ok: p TC_0 named |- constructorTypeIR < [] # tid_impl*{tid_impl <- tid_impl*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if $is_extern_object_typeIR($canon(typeIR_object))
      -- let typeIR' = typeIR_object
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let typeIR < tid_expl*{tid_expl <- tid_expl*} , tid'*{tid' <- tid'*} > < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR
      -- if typeIR <: externObjectTypeIR
      -- let extern tid_extern rdenv_extern = typeIR as externObjectTypeIR
      -- if (tid'*{tid' <- tid'*} = tid_impl*{tid_impl <- tid_impl*})
      -- let TC_1 = $add_var(local, TC_0, "this", typeIR_object ctk ?())
      -- let objectDeclaration*{objectDeclaration <- objectDeclaration*} = $flatten_objectDeclarationList(objectDeclarationList)
      -- Decls_object_ok: p TC_1 { [] } { [] } |- objectDeclaration*{objectDeclaration <- objectDeclaration*} : frame_init rdenv_init objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*}
      -- let tid*{tid <- tid*} = tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*}
      -- let theta = { tid : typeIR_arg*{tid <- tid*, typeIR_arg <- typeIR_arg*} }
      -- let rdenv_init_subst = $subst_rdenv(theta, rdenv_extern, rdenv_init)
      -- let typeIR_object_init = extern tid_extern rdenv_init_subst as typeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > < typeIR_arg*{typeIR_arg <- typeIR_arg*} > as typeIR
      -- if $is_concrete_extern_object(typeIR_object_init)
      -- let nameIR = $name(name)
      -- let TC_2 = $add_var(p, TC_0, nameIR, typeIR_object_init ctk ?())
      -- let instantiationIR = annotationList typeIR_object_init prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR*{argumentIR <- argumentIR*} ) nameIR ?(={ objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*} }) ;

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:234:1-281:98:
   rule instantiation-specializedType-objectInitializer: p TC_0 |- declaration : TC_2 instantiationIR as declarationIR
      -- if declaration <: instantiation
      -- let instantiation = declaration as instantiation
      -- if instantiation matches `%%(%)%%;`
      -- let annotationList type ( argumentList ) name ={ objectDeclarationList } ; = instantiation
      -- if type <: specializedType
      -- let prefixedTypeName < typeArgumentList > = type as specializedType
      -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
      -- TypeArguments_ok: p TC_0 |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_impl*{tid_impl <- tid_impl*}
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: p TC_0 |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- ConstructorType_ok: p TC_0 |- prefixedNameIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
      -- Inst_ok: p TC_0 named |- constructorTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if $is_extern_object_typeIR($canon(typeIR_object))
      -- let typeIR' = typeIR_object
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let typeIR < tid_expl*{tid_expl <- tid_expl*} , tid'*{tid' <- tid'*} > < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR
      -- if typeIR <: externObjectTypeIR
      -- let extern tid_extern rdenv_extern = typeIR as externObjectTypeIR
      -- if (tid'*{tid' <- tid'*} = tid_impl*{tid_impl <- tid_impl*})
      -- let TC_1 = $add_var(local, TC_0, "this", typeIR_object ctk ?())
      -- let objectDeclaration*{objectDeclaration <- objectDeclaration*} = $flatten_objectDeclarationList(objectDeclarationList)
      -- Decls_object_ok: p TC_1 { [] } { [] } |- objectDeclaration*{objectDeclaration <- objectDeclaration*} : frame_init rdenv_init objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*}
      -- let tid*{tid <- tid*} = tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*}
      -- let theta = { tid : typeIR_arg*{tid <- tid*, typeIR_arg <- typeIR_arg*} }
      -- let rdenv_init_subst = $subst_rdenv(theta, rdenv_extern, rdenv_init)
      -- let typeIR_object_init = extern tid_extern rdenv_init_subst as typeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > < typeIR_arg*{typeIR_arg <- typeIR_arg*} > as typeIR
      -- if $is_concrete_extern_object(typeIR_object_init)
      -- let nameIR = $name(name)
      -- let TC_2 = $add_var(p, TC_0, nameIR, typeIR_object_init ctk ?())
      -- let instantiationIR = annotationList typeIR_object_init prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR*{argumentIR <- argumentIR*} ) nameIR ?(={ objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*} }) ;

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:289:1-320:27:
   rule functionDeclaration: p TC_0 |- declaration : TC_4 functionDeclarationIR as declarationIR
      -- if declaration <: functionDeclaration
      -- let annotationList typeOrVoid name typeParameterListOpt ( parameterList ) blockStatement = declaration as functionDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_1 = $add_types(local, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: local TC_1 |- typeOrVoid : typeIR_ret # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: local TC_1 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let TC_2 = $add_parameters(local, TC_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let TC_3 = TC_2[local.kind = function-> typeIR_ret]
      -- Block_ok: TC_3 cont |- blockStatement : _typingContext f blockStatementIR
      -- if ((f = ret) \/ (typeIR_ret = void as typeIR))
      -- let rid = $rid(name, parameterList)
      -- let functionTypeIR = function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
      -- let routineTypeDefIR = functionTypeIR as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
      -- if RoutineTypeDef_wf: $bound(p, TC_0) |- routineTypeDefIR holds
      -- let TC_4 = $add_routine_overload(p, TC_0, rid, routineTypeDefIR)
      -- let nameIR = $name(name)
      -- let functionDeclarationIR = annotationList typeIR_ret nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} ) blockStatementIR

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:326:1-347:72:
   rule actionDeclaration: p TC_0 |- declaration : TC_3 actionDeclarationIR as declarationIR
      -- if declaration <: actionDeclaration
      -- let annotationList action name ( parameterList ) blockStatement = declaration as actionDeclaration
      -- let TC_1 = TC_0[local.kind = action]
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: local TC_1 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let TC_2 = $add_parameters(local, TC_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- Block_ok: TC_2 cont |- blockStatement : _typingContext _flow blockStatementIR
      -- let rid = $rid(name, parameterList)
      -- let functionTypeIR = action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )
      -- if RoutineTypeDef_wf: $bound(p, TC_0) |- functionTypeIR as routineTypeDefIR holds
      -- let TC_3 = $add_routine_non_overload(p, TC_0, rid, functionTypeIR as routineTypeDefIR)
      -- let nameIR = $name(name)
      -- let actionDeclarationIR = annotationList action nameIR ( parameterIR*{parameterIR <- parameterIR*} ) blockStatementIR

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:352:1-362:88:
   rule errorDeclaration: cursor TC_0 |- declaration : TC_1 error{ nameIR*{nameIR <- nameIR*} } as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: errorDeclaration
      -- let error{ nameList } = declaration as errorDeclaration
      -- let name*{name <- name*} = $flatten_nameList(nameList)
      -- (let nameIR = $name(name))*{name <- name*, nameIR <- nameIR*}
      -- if $distinct_<nameIR>(nameIR*{nameIR <- nameIR*})
      -- (let nameIR_error = "error." ++ nameIR)*{nameIR <- nameIR*, nameIR_error <- nameIR_error*}
      -- (let value_error = error. nameIR as value)*{nameIR <- nameIR*, value_error <- value_error*}
      -- let TC_1 = $add_vars(global, TC_0, nameIR_error*{nameIR_error <- nameIR_error*}, error as typeIR lctk ?(value_error)*{value_error <- value_error*})

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:367:1-376:92:
   rule matchKindDeclaration: cursor TC_0 |- declaration : TC_1 match_kind{ nameIR*{nameIR <- nameIR*} } as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: matchKindDeclaration
      -- let match_kind{ nameList _trailingCommaOpt } = declaration as matchKindDeclaration
      -- let name*{name <- name*} = $flatten_nameList(nameList)
      -- (let nameIR = $name(name))*{name <- name*, nameIR <- nameIR*}
      -- if $distinct_<nameIR>(nameIR*{nameIR <- nameIR*})
      -- (let value_match_kind = match_kind. nameIR as value)*{nameIR <- nameIR*, value_match_kind <- value_match_kind*}
      -- let TC_1 = $add_vars(global, TC_0, nameIR*{nameIR <- nameIR*}, match_kind as typeIR lctk ?(value_match_kind)*{value_match_kind <- value_match_kind*})

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:385:1-412:79:
   rule externDeclaration-externFunctionDeclaration: cursor TC_0 |- declaration : TC_4 externFunctionDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: externFunctionDeclaration
      -- let annotationList extern typeOrVoid name typeParameterListOpt ( parameterList ) ; = declaration as externFunctionDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_1 = $add_types(local, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: local TC_1 |- typeOrVoid : typeIR_ret # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- let TC_2 = TC_1[local.kind = extern_function-> typeIR_ret]
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: local TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let TC_3 = $add_parameters(local, TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let rid = $rid(name, parameterList)
      -- let functionTypeIR = extern_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
      -- let routineTypeDefIR = functionTypeIR as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
      -- if RoutineTypeDef_wf: $bound(global, TC_0) |- routineTypeDefIR holds
      -- let TC_4 = $add_routine_overload(global, TC_0, rid, routineTypeDefIR)
      -- let nameIR = $name(name)
      -- let externFunctionDeclarationIR = annotationList extern typeIR_ret nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} ) ;

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:440:1-473:73:
   rule externDeclaration-externObjectDeclaration: cursor TC_0 |- declaration : TC_8 externObjectDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: externObjectDeclaration
      -- let annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList } = declaration as externObjectDeclaration
      -- let methodPrototype*{methodPrototype <- methodPrototype*} = $flatten_methodPrototypeList(methodPrototypeList)
      -- let (methodPrototype_constructor*{methodPrototype_constructor <- methodPrototype_constructor*}, methodPrototype_method*{methodPrototype_method <- methodPrototype_method*}) = $split_constructors(methodPrototype*{methodPrototype <- methodPrototype*})
      -- let TC_1 = TC_0[block.kind = extern]
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_2 = $add_types(block, TC_1, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let nameIR = $name(nonTypeName as name)
      -- ExternMethods_ok: TC_2 nameIR |- methodPrototype_method*{methodPrototype_method <- methodPrototype_method*} : TC_3 methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*}
      -- let typeIR_extern = extern nameIR TC_3.block.rdenv as typeIR
      -- let typeDefIR_extern = typeIR_extern < tid_expl*{tid_expl <- tid_expl*} , [] > as typeDefIR
      -- let TC_4 = $add_type(global, TC_0, nameIR, typeDefIR_extern)
      -- let TC_5 = TC_4[block.kind = extern]
      -- let TC_6 = $add_types(block, TC_5, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- ExternConstructors_ok: TC_6 nameIR |- methodPrototype_constructor*{methodPrototype_constructor <- methodPrototype_constructor*} : TC_7 methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*}
      -- let TC_8 = TC_4[global.cdenv = TC_7.global.cdenv]
      -- let externObjectDeclarationIR = annotationList extern nameIR < tid_expl*{tid_expl <- tid_expl*} , [] >{ methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*} ++ methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*} }

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:481:1-528:56:
   rule parserDeclaration: cursor TC_0 |- declaration : TC_6 parserDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: parserDeclaration
      -- let annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList } = declaration as parserDeclaration
      -- if typeParameterListOpt matches ``EMPTY`
      -- let TC_1 = TC_0[block.kind = parser]
      -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_constructorParameterListOpt(constructorParameterListOpt)
      -- ConstructorParameters_ok: block TC_1 |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
      -- let TC_2 = $add_parameters(block, TC_1, constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*})
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: block TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid'*{tid' <- tid'*}
      -- if tid'*{tid' <- tid'*} matches []
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let TC_3 = $add_parameters(block, TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} = $flatten_parserLocalDeclarationList(parserLocalDeclarationList)
      -- ParserLocalDecls_ok: TC_3 |- parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} : TC_4 parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*}
      -- let TC_5 = TC_4[local.kind = parser_state]
      -- let parserState*{parserState <- parserState*} = $flatten_parserStateList(parserStateList)
      -- ParserStates_ok: TC_5 |- parserState*{parserState <- parserState*} : parserStateIR*{parserStateIR <- parserStateIR*}
      -- let methodTypeIR = parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )
      -- if RoutineTypeDef_wf: $bound(global, TC_0) |- methodTypeIR as routineTypeDefIR holds
      -- let cid = $cid(name, constructorParameterListOpt)
      -- let typeIR_parser = parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
      -- let typeIR_parser_spec = typeIR_parser < [] , [] > < [] > as typeIR
      -- let constructorTypeIR = constructor( constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} )-> typeIR_parser_spec
      -- let constructorTypeDefIR = constructorTypeIR < [] , [] >
      -- if ConstructorTypeDef_wf: $bound(global, TC_0) |- constructorTypeDefIR holds
      -- let TC_6 = $add_constructor(TC_0, cid, constructorTypeDefIR)
      -- let nameIR = $name(name)
      -- let parserDeclarationIR = annotationList parser nameIR < [] >( parameterIR*{parameterIR <- parameterIR*} )( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ){ parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} parserStateIR*{parserStateIR <- parserStateIR*} }

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:536:1-582:60:
   rule controlDeclaration: cursor TC_0 |- declaration : TC_6 controlDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: controlDeclaration
      -- let annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody } = declaration as controlDeclaration
      -- if typeParameterListOpt matches ``EMPTY`
      -- let TC_1 = TC_0[block.kind = control]
      -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_constructorParameterListOpt(constructorParameterListOpt)
      -- ConstructorParameters_ok: block TC_1 |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
      -- let TC_2 = $add_parameters(block, TC_1, constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*})
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: block TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid'*{tid' <- tid'*}
      -- if tid'*{tid' <- tid'*} matches []
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let TC_3 = $add_parameters(block, TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} = $flatten_controlLocalDeclarationList(controlLocalDeclarationList)
      -- ControlLocalDecls_ok: TC_3 |- controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} : TC_4 controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*}
      -- let TC_5 = TC_4[local.kind = control_apply_method]
      -- Block_ok: TC_5 cont |- controlBody : _typingContext _flow controlBodyIR
      -- let methodTypeIR = control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )
      -- if RoutineTypeDef_wf: $bound(global, TC_0) |- methodTypeIR as routineTypeDefIR holds
      -- let cid = $cid(name, constructorParameterListOpt)
      -- let typeIR_control = control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
      -- let typeIR_control_spec = typeIR_control < [] , [] > < [] > as typeIR
      -- let constructorTypeIR = constructor( constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} )-> typeIR_control_spec
      -- let constructorTypeDefIR = constructorTypeIR < [] , [] >
      -- if ConstructorTypeDef_wf: $bound(global, TC_0) |- constructorTypeDefIR holds
      -- let TC_6 = $add_constructor(TC_0, cid, constructorTypeDefIR)
      -- let nameIR = $name(name)
      -- let controlDeclarationIR = annotationList control nameIR < [] >( parameterIR*{parameterIR <- parameterIR*} )( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ){ controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} apply controlBodyIR }

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:595:1-612:54:
   rule typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration: cursor TC_0 |- declaration : TC_2 enumTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: enumTypeDeclaration
      -- let enumTypeDeclaration = declaration as enumTypeDeclaration
      -- if enumTypeDeclaration matches `%ENUM%{%%}`
      -- let annotationList enum name { nameList_field _trailingCommaOpt } = enumTypeDeclaration
      -- let nameIR = $name(name)
      -- let name_field*{name_field <- name_field*} = $flatten_nameList(nameList_field)
      -- (let nameIR_field = $name(name_field))*{nameIR_field <- nameIR_field*, name_field <- name_field*}
      -- let typeIR_enum = enum nameIR { nameIR_field*{nameIR_field <- nameIR_field*} } as typeIR
      -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_enum as typeDefIR holds
      -- let TC_1 = $add_type(global, TC_0, nameIR, typeIR_enum as typeDefIR)
      -- (let id_field = nameIR ++ "." ++ nameIR_field)*{id_field <- id_field*, nameIR_field <- nameIR_field*}
      -- (let value_field = nameIR . nameIR_field as value)*{nameIR_field <- nameIR_field*, value_field <- value_field*}
      -- let TC_2 = $add_vars(global, TC_1, id_field*{id_field <- id_field*}, typeIR_enum lctk ?(value_field)*{value_field <- value_field*})
      -- let enumTypeDeclarationIR = annotationList enum nameIR { nameIR_field*{nameIR_field <- nameIR_field*} }

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:658:1-681:72:
   rule typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration-serializable: cursor TC_0 |- declaration : TC_3 enumTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: enumTypeDeclaration
      -- let enumTypeDeclaration = declaration as enumTypeDeclaration
      -- if enumTypeDeclaration matches `%ENUM%%{%%}`
      -- let annotationList enum type name { namedExpressionList_field _trailingCommaOpt } = enumTypeDeclaration
      -- Type_ok: global TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(global, TC_0) |- typeIR holds
      -- let nameIR = $name(name)
      -- let namedExpression_field*{namedExpression_field <- namedExpression_field*} = $flatten_namedExpressionList(namedExpressionList_field)
      -- Enum_serializable_fields_ok: TC_0 nameIR typeIR |- namedExpression_field*{namedExpression_field <- namedExpression_field*} : TC_1 namedExpressionIR_field*{namedExpressionIR_field <- namedExpressionIR_field*} # value_field*{value_field <- value_field*}
      -- (let nameIR_field = _typedExpressionIR = namedExpressionIR_field)*{_typedExpressionIR <- _typedExpressionIR*, nameIR_field <- nameIR_field*, namedExpressionIR_field <- namedExpressionIR_field*}
      -- (let id_field = nameIR ++ "." ++ nameIR_field)*{id_field <- id_field*, nameIR_field <- nameIR_field*}
      -- let typeIR_enum = enum nameIR # typeIR { nameIR_field = value_field ;*{nameIR_field <- nameIR_field*, value_field <- value_field*} } as typeIR
      -- let TC_2 = $add_vars(global, TC_0, id_field*{id_field <- id_field*}, typeIR_enum lctk ?(value_field)*{value_field <- value_field*})
      -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_enum as typeDefIR holds
      -- let TC_3 = $add_type(global, TC_2, nameIR, typeIR_enum as typeDefIR)
      -- let enumTypeDeclarationIR = annotationList enum typeIR nameIR { namedExpressionIR_field*{namedExpressionIR_field <- namedExpressionIR_field*} }

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:687:1-709:66:
   rule typeDeclaration-derivedTypeDeclaration-structTypeDeclaration: cursor TC_0 |- declaration : TC_2 structTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: structTypeDeclaration
      -- let annotationList struct name typeParameterListOpt { typeFieldList } = declaration as structTypeDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_1 = $add_types(block, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let annotationList_field type_field name_field ;*{annotationList_field <- annotationList_field*, name_field <- name_field*, type_field <- type_field*} = $flatten_typeFieldList(typeFieldList)
      -- (Type_ok: block TC_1 |- type_field as typeOrVoid : typeIR_field # tid_impl_field*{tid_impl_field <- tid_impl_field*})*{tid_impl_field* <- tid_impl_field**, typeIR_field <- typeIR_field*, type_field <- type_field*}
      -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_field*{tid_impl_field <- tid_impl_field*}*{tid_impl_field* <- tid_impl_field**})
      -- let nameIR = $name(name)
      -- (let nameIR_field = $name(name_field))*{nameIR_field <- nameIR_field*, name_field <- name_field*}
      -- let typeIR_struct = struct nameIR { typeIR_field nameIR_field ;*{nameIR_field <- nameIR_field*, typeIR_field <- typeIR_field*} } as typeIR
      -- let typeDefIR_struct = typeIR_struct < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as typeDefIR
      -- if TypeDef_wf: $bound(global, TC_0) |- typeDefIR_struct holds
      -- let TC_2 = $add_type(global, TC_0, nameIR, typeDefIR_struct)
      -- let structTypeDeclarationIR = annotationList struct nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >{ annotationList_field typeIR_field nameIR_field ;*{annotationList_field <- annotationList_field*, nameIR_field <- nameIR_field*, typeIR_field <- typeIR_field*} }

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:715:1-737:54:
   rule typeDeclaration-derivedTypeDeclaration-headerTypeDeclaration: cursor TC_0 |- declaration : TC_2 headerTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: headerTypeDeclaration
      -- let annotationList header name typeParameterListOpt { typeFieldList } = declaration as headerTypeDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_1 = $add_types(block, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let annotationList_f type_f name_f ;*{annotationList_f <- annotationList_f*, name_f <- name_f*, type_f <- type_f*} = $flatten_typeFieldList(typeFieldList)
      -- (Type_ok: block TC_1 |- type_f as typeOrVoid : typeIR_f # tid_impl_f*{tid_impl_f <- tid_impl_f*})*{tid_impl_f* <- tid_impl_f**, typeIR_f <- typeIR_f*, type_f <- type_f*}
      -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_f*{tid_impl_f <- tid_impl_f*}*{tid_impl_f* <- tid_impl_f**})
      -- let nameIR = $name(name)
      -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
      -- let typeIR_header = header nameIR { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } as typeIR
      -- let typeDefIR_header = typeIR_header < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as typeDefIR
      -- if TypeDef_wf: $bound(global, TC_0) |- typeDefIR_header holds
      -- let TC_2 = $add_type(global, TC_0, nameIR, typeDefIR_header)
      -- let headerTypeDeclarationIR = annotationList header nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >{ annotationList_f typeIR_f nameIR_f ;*{annotationList_f <- annotationList_f*, nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} }

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:743:1-765:54:
   rule typeDeclaration-derivedTypeDeclaration-headerUnionTypeDeclaration: cursor TC_0 |- declaration : TC_2 headerUnionTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: headerUnionTypeDeclaration
      -- let annotationList header_union name typeParameterListOpt { typeFieldList } = declaration as headerUnionTypeDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_1 = $add_types(block, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let annotationList_f type_f name_f ;*{annotationList_f <- annotationList_f*, name_f <- name_f*, type_f <- type_f*} = $flatten_typeFieldList(typeFieldList)
      -- (Type_ok: block TC_1 |- type_f as typeOrVoid : typeIR_f # tid_impl_f*{tid_impl_f <- tid_impl_f*})*{tid_impl_f* <- tid_impl_f**, typeIR_f <- typeIR_f*, type_f <- type_f*}
      -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_f*{tid_impl_f <- tid_impl_f*}*{tid_impl_f* <- tid_impl_f**})
      -- let nameIR = $name(name)
      -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
      -- let typeIR_union = header_union nameIR { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } as typeIR
      -- let typeDefIR_union = typeIR_union < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as typeDefIR
      -- if TypeDef_wf: $bound(global, TC_0) |- typeDefIR_union holds
      -- let TC_2 = $add_type(global, TC_0, nameIR, typeDefIR_union)
      -- let headerUnionTypeDeclarationIR = annotationList header_union nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >{ annotationList_f typeIR_f nameIR_f ;*{annotationList_f <- annotationList_f*, nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} }

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:775:1-788:48:
   rule typeDeclaration-typedefDeclaration-typedef-type: cursor TC_0 |- declaration : TC_1 typedefDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: typedefDeclaration
      -- let typedefDeclaration = declaration as typedefDeclaration
      -- if typedefDeclaration matches `%TYPEDEF%%;`
      -- let annotationList typedef typedefType name ; = typedefDeclaration
      -- if typedefType <: type
      -- let type = typedefType as type
      -- Type_ok: global TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(global, TC_0) |- typeIR holds
      -- let nameIR = $name(name)
      -- let typeIR_typedef = typedef nameIR typeIR as typeIR
      -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_typedef as typeDefIR holds
      -- let TC_1 = $add_type(global, TC_0, nameIR, typeIR_typedef as typeDefIR)
      -- let typedefDeclarationIR = annotationList typedef typeIR as typedefTypeIR nameIR ;

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:792:1-810:66:
   rule typeDeclaration-typedefDeclaration-typedef-derivedTypeDeclaration-mono: cursor TC_0 |- declaration : TC_1 typedefDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: typedefDeclaration
      -- let typedefDeclaration = declaration as typedefDeclaration
      -- if typedefDeclaration matches `%TYPEDEF%%;`
      -- let annotationList typedef typedefType name ; = typedefDeclaration
      -- if typedefType <: derivedTypeDeclaration
      -- let derivedTypeDeclaration = typedefType as derivedTypeDeclaration
      -- Decl_ok: global TC_0 |- derivedTypeDeclaration as declaration : TC_1 declarationIR
      -- if declarationIR <: derivedTypeDeclarationIR
      -- let derivedTypeDeclarationIR = declarationIR as derivedTypeDeclarationIR
      -- let { tid'*{tid' <- tid'*} } = $diff_set<tid>($dom_map<tid, typeDefIR>(TC_1.global.tdenv), $dom_map<tid, typeDefIR>(TC_0.global.tdenv))
      -- if tid'*{tid' <- tid'*} matches [ _/1 ]
      -- let [tid] = tid'*{tid' <- tid'*}
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(global, TC_1, ` tid)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR
      -- let nameIR = $name(name)
      -- let typeIR_typedef = typedef nameIR typeIR as typeIR
      -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_typedef as typeDefIR holds
      -- let TC_2 = $add_type(global, TC_0, nameIR, typeIR_typedef as typeDefIR)
      -- let typedefDeclarationIR = annotationList typedef derivedTypeDeclarationIR as typedefTypeIR nameIR ;

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:812:1-830:66:
   rule typeDeclaration-typedefDeclaration-typedef-derivedTypeDeclaration-poly: cursor TC_0 |- declaration : TC_1 typedefDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: typedefDeclaration
      -- let typedefDeclaration = declaration as typedefDeclaration
      -- if typedefDeclaration matches `%TYPEDEF%%;`
      -- let annotationList typedef typedefType name ; = typedefDeclaration
      -- if typedefType <: derivedTypeDeclaration
      -- let derivedTypeDeclaration = typedefType as derivedTypeDeclaration
      -- Decl_ok: global TC_0 |- derivedTypeDeclaration as declaration : TC_1 declarationIR
      -- if declarationIR <: derivedTypeDeclarationIR
      -- let derivedTypeDeclarationIR = declarationIR as derivedTypeDeclarationIR
      -- let { tid'*{tid' <- tid'*} } = $diff_set<tid>($dom_map<tid, typeDefIR>(TC_1.global.tdenv), $dom_map<tid, typeDefIR>(TC_0.global.tdenv))
      -- if tid'*{tid' <- tid'*} matches [ _/1 ]
      -- let [tid] = tid'*{tid' <- tid'*}
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(global, TC_1, ` tid)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR < tid''*{tid'' <- tid''*} , tid'''*{tid''' <- tid'''*} > = typeDefIR as polyTypeDefIR
      -- if tid''*{tid'' <- tid''*} matches []
      -- if tid'''*{tid''' <- tid'''*} matches []
      -- let nameIR = $name(name)
      -- let typeIR_typedef = typedef nameIR typeIR < [] , [] > < [] > as typeIR as typeIR
      -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_typedef as typeDefIR holds
      -- let TC_2 = $add_type(global, TC_0, nameIR, typeIR_typedef as typeDefIR)
      -- let typedefDeclarationIR = annotationList typedef derivedTypeDeclarationIR as typedefTypeIR nameIR ;

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:834:1-847:45:
   rule typeDeclaration-typedefDeclaration-newtype: cursor TC_0 |- declaration : TC_1 typedefDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: typedefDeclaration
      -- let typedefDeclaration = declaration as typedefDeclaration
      -- if typedefDeclaration matches `%TYPE%%;`
      -- let annotationList type type name ; = typedefDeclaration
      -- Type_ok: global TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(global, TC_0) |- typeIR holds
      -- let nameIR = $name(name)
      -- let typeIR_newtype = type nameIR typeIR as typeIR
      -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_newtype as typeDefIR holds
      -- let TC_1 = $add_type(global, TC_0, nameIR, typeIR_newtype as typeDefIR)
      -- let typedefDeclarationIR = annotationList type typeIR nameIR ;

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:853:1-874:86:
   rule typeDeclaration-parserTypeDeclaration: cursor TC_0 |- declaration : TC_3 parserTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: parserTypeDeclaration
      -- let annotationList parser name typeParameterListOpt ( parameterList ); = declaration as parserTypeDeclaration
      -- let TC_1 = TC_0[block.kind = parser]
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_2 = $add_types(block, TC_1, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: block TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let nameIR = $name(name)
      -- let typeIR_parser = parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
      -- let typeDefIR_parser = typeIR_parser < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as typeDefIR
      -- if TypeDef_wf: $bound(global, TC_0) |- typeDefIR_parser holds
      -- let TC_3 = $add_type(global, TC_0, nameIR, typeDefIR_parser)
      -- let parserTypeDeclarationIR = annotationList parser nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} );

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:880:1-901:87:
   rule typeDeclaration-controlTypeDeclaration: cursor TC_0 |- declaration : TC_3 controlTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: controlTypeDeclaration
      -- let annotationList control name typeParameterListOpt ( parameterList ); = declaration as controlTypeDeclaration
      -- let TC_1 = TC_0[block.kind = control]
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_2 = $add_types(block, TC_1, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: block TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let nameIR = $name(name)
      -- let typeIR_control = control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
      -- let typeDefIR_control = typeIR_control < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as typeDefIR
      -- if TypeDef_wf: $bound(global, TC_0) |- typeDefIR_control holds
      -- let TC_3 = $add_type(global, TC_0, nameIR, typeDefIR_control)
      -- let controlTypeDeclarationIR = annotationList control nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} );

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:907:1-941:40:
   rule typeDeclaration-packageTypeDeclaration: cursor TC_0 |- declaration : TC_4 packageTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: packageTypeDeclaration
      -- let annotationList package name typeParameterListOpt ( parameterList ); = declaration as packageTypeDeclaration
      -- let TC_1 = TC_0[block.kind = package]
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_2 = $add_types(block, TC_1, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_parameterList(parameterList)
      -- ConstructorParameters_ok: block TC_2 |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid_impl*{tid_impl <- tid_impl*}
      -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
      -- let nameIR = $name(name)
      -- (let _direction typeIR_package_inner _id _value?{_value <- _value?} = constructorParameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, constructorParameterTypeIR <- constructorParameterTypeIR*, typeIR_package_inner <- typeIR_package_inner*}
      -- let typeIR_package = package< typeIR_package_inner*{typeIR_package_inner <- typeIR_package_inner*} > as typeIR
      -- let polyTypeDefIR_package = typeIR_package < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >
      -- if TypeDef_wf: $bound(global, TC_0) |- polyTypeDefIR_package as typeDefIR holds
      -- let TC_3 = $add_type(global, TC_0, nameIR, polyTypeDefIR_package as typeDefIR)
      -- let cid = $cid(name, ( parameterList ))
      -- let typeIR_package_spec = polyTypeDefIR_package < tid tid_expl as typeIR*{tid_expl <- tid_expl*} ++ tid tid_impl as typeIR*{tid_impl <- tid_impl*} > as typeIR
      -- let constructorTypeIR = constructor( constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} )-> typeIR_package_spec
      -- let constructorTypeDefIR = constructorTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >
      -- if ConstructorTypeDef_wf: $bound(global, TC_0) |- constructorTypeDefIR holds
      -- let TC_4 = $add_constructor(TC_3, cid, constructorTypeDefIR)
      -- let packageTypeDeclarationIR = annotationList package nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} );

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:266:1-268:23:
relation Decls_ok: cursor typingContext |- declaration* : typingContext declarationIR*

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:947:1-948:23:
   rule nil: p TC |- declaration*{declaration <- declaration*} : TC []
      -- if declaration*{declaration <- declaration*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:950:1-954:64:
   rule cons: p TC_0 |- declaration*{declaration <- declaration*} : TC_2 declarationIR_h :: declarationIR_t*{declarationIR_t <- declarationIR_t*}
      -- if declaration*{declaration <- declaration*} matches _ :: _
      -- let declaration_h :: declaration_t*{declaration_t <- declaration_t*} = declaration*{declaration <- declaration*}
      -- Decl_ok: p TC_0 |- declaration_h : TC_1 declarationIR_h
      -- Decls_ok: p TC_1 |- declaration_t*{declaration_t <- declaration_t*} : TC_2 declarationIR_t*{declarationIR_t <- declarationIR_t*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:270:1-272:17:
relation Program_ok: |- p4program : typingContext p4programIR

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:960:1-964:65:
   rule : |- p4program : TC_1 declarationIR*{declarationIR <- declarationIR*} ;
      -- let declaration*{declaration <- declaration*} = $flatten_p4program(p4program)
      -- let TC_0 = $empty_typingContext
      -- Decls_ok: global TC_0 |- declaration*{declaration <- declaration*} : TC_1 declarationIR*{declarationIR <- declarationIR*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:282:18-282:35:
syntax actctxt = 
   | action
   | noaction

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:284:1-287:29:
relation Call_convention_expr_ok: cursor typingContext actctxt |- parameterTypeIR @ typedExpressionIR : typedExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:51:1-56:59:
   rule in: p TC actctxt |- direction typeIR_param _id _value?{_value <- _value?} @ typedExpressionIR_arg : typedExpressionIR_arg_cast
      -- if direction matches `IN`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_arg, typeIR_param)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_arg_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:97:1-105:51:
   rule out-inout: p TC actctxt |- direction typeIR_param _id _value?{_value <- _value?} @ typedExpressionIR_arg : typedExpressionIR_arg
      -- if ((direction = out) \/ (direction = inout))
      -- let _expressionIR # ( typeIR_arg _ctk ) = typedExpressionIR_arg
      -- if Type_alpha: typeIR_param ~~ typeIR_arg holds
      -- if Expr_lvalue_ok: p TC |- typedExpressionIR_arg holds

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:109:1-114:59:
   rule empty-action: p TC actctxt |- direction typeIR_param _id _value?{_value <- _value?} @ typedExpressionIR_arg : typedExpressionIR_arg_cast
      -- if actctxt matches `ACTION`
      -- if direction matches ``EMPTY`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_arg, typeIR_param)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_arg_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:116:1-123:24:
   rule empty-not-action: p TC actctxt |- direction typeIR_param _id _value?{_value <- _value?} @ typedExpressionIR_arg : typedExpressionIR_arg
      -- if actctxt matches `NOACTION`
      -- if direction matches ``EMPTY`
      -- let _expressionIR # ( typeIR_arg ctk_arg ) = typedExpressionIR_arg
      -- if Type_alpha: typeIR_param ~~ typeIR_arg holds
      -- if (ctk_arg =/= dyn)

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:289:1-292:29:
relation Call_convention_argument_ok: cursor typingContext actctxt |- parameterTypeIR @ argumentIR : argumentIR

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:129:1-134:45:
   rule typedExpression: p TC actctxt |- parameterTypeIR @ argumentIR : typedExpressionIR_cast as argumentIR
      -- if argumentIR <: typedExpressionIR
      -- let typedExpressionIR = argumentIR as typedExpressionIR
      -- Call_convention_expr_ok: p TC actctxt |- parameterTypeIR @ typedExpressionIR : typedExpressionIR_cast

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:138:1-143:45:
   rule nameIR-typedExpression: p TC actctxt |- parameterTypeIR @ argumentIR : nameIR = typedExpressionIR_cast
      -- if argumentIR matches `%=%`
      -- let nameIR = typedExpressionIR = argumentIR
      -- Call_convention_expr_ok: p TC actctxt |- parameterTypeIR @ typedExpressionIR : typedExpressionIR_cast

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:147:1-150:36:
   rule nameIR-dontcare: p TC actctxt |- parameterTypeIR @ argumentIR : nameIR =_
      -- if argumentIR matches `%=_`
      -- let nameIR =_ = argumentIR
      -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR
      -- if direction matches `OUT`

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:154:1-156:36:
   rule dontcare: p TC actctxt |- parameterTypeIR @ argumentIR : _
      -- if argumentIR matches `_`
      -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR
      -- if direction matches `OUT`

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:294:1-297:29:
relation Call_convention_ok: cursor typingContext actctxt |- parameterTypeIR* @ argumentListIR : argumentListIR

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:162:1-163:35:
   rule nil: p TC actctxt |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : []
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:165:1-174:41:
   rule cons: p TC actctxt |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_h_cast :: argumentIR_t_cast*{argumentIR_t_cast <- argumentIR_t_cast*}
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
      -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
      -- Call_convention_argument_ok: p TC actctxt |- parameterTypeIR_h @ argumentIR_h : argumentIR_h_cast
      -- Call_convention_ok: p TC actctxt |- parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} @ argumentIR_t*{argumentIR_t <- argumentIR_t*} : argumentIR_t_cast*{argumentIR_t_cast <- argumentIR_t_cast*}

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:307:1-307:52:
def $is_static_routineTarget(routineTargetIR) : ctk =

   ;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:309:1-311:56:
   clause 0(routineTargetIR) = lctk
      -- if routineTargetIR matches `%.%`
      -- let _typedExpressionIR . nameIR = routineTargetIR
      -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

   ;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:312:1-314:56:
   clause 1(routineTargetIR) = lctk
      -- if routineTargetIR matches `TYPE%.%`
      -- let type _prefixedNameIR . nameIR = routineTargetIR
      -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

   ;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:315:1-316:15:
   clause 2(_routineTargetIR) = dyn
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:318:1-320:23:
relation RoutineTarget_ok: cursor typingContext |- routineTarget : routineTargetIR

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:12:1-18:74:
   rule prefixedNonTypeName: p TC |- routineTarget : prefixedNameIR as routineTargetIR
      -- if routineTarget <: prefixedNonTypeName
      -- let prefixedNonTypeName = routineTarget as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- if (((prefixedNameIR = ` "verify") \/ (prefixedNameIR = . "verify")) => (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind))))

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:22:1-23:29:
   rule this: p TC |- routineTarget : ` "this" as routineTargetIR
      -- if routineTarget <: referenceExpression
      -- let referenceExpression = routineTarget as referenceExpression
      -- if referenceExpression matches `THIS`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:31:1-34:31:
   rule memberAccessExpression-prefixedTypeName: p TC |- routineTarget : type prefixedNameIR . nameIR
      -- if routineTarget <: memberAccessExpression
      -- let memberAccessBase . member = routineTarget as memberAccessExpression
      -- if memberAccessBase <: prefixedTypeName
      -- let prefixedTypeName = memberAccessBase as prefixedTypeName
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let nameIR = $name(member)

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:38:1-41:63:
   rule memberAccessExpression-expression: p TC |- routineTarget : typedExpressionIR_base . nameIR
      -- if routineTarget <: memberAccessExpression
      -- let memberAccessBase . member = routineTarget as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- let nameIR = $name(member)
      -- Expr_ok: p TC |- expression_base : typedExpressionIR_base

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:45:1-47:60:
   rule parenthesizedExpression: p TC |- routineTarget : ( routineTargetIR )
      -- if routineTarget <: parenthesizedExpression
      -- let ( expression ) = routineTarget as parenthesizedExpression
      -- RoutineTarget_ok: p TC |- expression : routineTargetIR

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:322:1-324:23:
relation RoutineTarget_lvalue_ok: cursor typingContext |- lvalue : routineTargetIR

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:69:1-72:60:
   rule : p TC |- lvalue : routineTargetIR
      -- let expression = $lvalue(lvalue)
      -- RoutineTarget_ok: p TC |- expression : routineTargetIR

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:326:1-329:29:
relation RoutineType_ok: cursor typingContext |- routineTargetIR < typeArgumentListIR >( argumentIR* ): routineTypeIR <# tid* >(# id* )

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:83:1-93:45:
   rule referenceExpressionIR: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): functionTypeIR as routineTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
      -- if routineTargetIR <: prefixedNameIR
      -- let prefixedNameIR = routineTargetIR as prefixedNameIR
      -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_routine_overloaded(p, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*})
      -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
      -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}
      -- let (routineTypeDefIR, tid*) = $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- if (routineTypeDefIR, tid*) <: (functionTypeIR, tid*)
      -- let (functionTypeIR, tid_impl*{tid_impl <- tid_impl*}) = (routineTypeDefIR, tid*) as (functionTypeIR, tid*)
      -- let bound = $union_set<tid>($bound(p, TC), { tid_impl*{tid_impl <- tid_impl*} })
      -- if RoutineType_wf: bound |- functionTypeIR as routineTypeIR holds

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:97:1-103:55:
   rule typedExpressionIR-nameIR-builtin-method-minmax-SizeIn-BitsBytes: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): methodTypeIR as routineTypeIR <# [] >(# [] )
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base . nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
      -- let methodTypeIR = builtin_method( [] )-> int as typeIR

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:105:1-116:67:
   rule typedExpressionIR-nameIR-builtin-method-stack-push-pop-front: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR'*{argumentIR' <- argumentIR'*} ): methodTypeIR as routineTypeIR <# [] >(# [] )
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base . nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR'*{argumentIR' <- argumentIR'*} matches [ _/1 ]
      -- let [argumentIR] = argumentIR'*{argumentIR' <- argumentIR'*}
      -- if nameIR <- ["push_front", "pop_front"]
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR
      -- let parameterTypeIR = int as typeIR "count" ?()
      -- let methodTypeIR = builtin_method( [parameterTypeIR] )-> int as typeIR

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:118:1-127:56:
   rule typedExpressionIR-nameIR-builtin-method-header-isValid: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): methodTypeIR as routineTypeIR <# [] >(# [] )
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base . nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if nameIR <- ["isValid"]
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: headerTypeIR
      -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR
      -- let methodTypeIR = builtin_method( [] )-> bool as typeIR

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:129:1-138:56:
   rule typedExpressionIR-nameIR-builtin-method-union-isValid: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): methodTypeIR as routineTypeIR <# [] >(# [] )
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base . nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if nameIR <- ["isValid"]
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: headerUnionTypeIR
      -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR
      -- let methodTypeIR = builtin_method( [] )-> bool as typeIR

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:140:1-149:56:
   rule typedExpressionIR-nameIR-builtin-method-header-set-ValidInvalid: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): methodTypeIR as routineTypeIR <# [] >(# [] )
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base . nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if nameIR <- ["setValid", "setInvalid"]
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: headerTypeIR
      -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR
      -- let methodTypeIR = builtin_method( [] )-> void as typeIR

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:151:1-169:44:
   rule typedExpressionIR-nameIR-extern-method: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base . nameIR = routineTargetIR
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: externObjectTypeIR
      -- let extern _tid { rid_f : routineTypeDefIR_f*{rid_f <- rid_f*, routineTypeDefIR_f <- routineTypeDefIR_f*} } = typeIR as externObjectTypeIR
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
      -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_overloaded<routineTypeDefIR>({ rid_f : routineTypeDefIR_f*{rid_f <- rid_f*, routineTypeDefIR_f <- routineTypeDefIR_f*} }, nameIR, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
      -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}
      -- let (routineTypeDefIR, tid*) = $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- if (routineTypeDefIR, tid*) <: (routineTypeIR, tid*)
      -- let (routineTypeIR, tid_impl*{tid_impl <- tid_impl*}) = (routineTypeDefIR, tid*) as (routineTypeIR, tid*)
      -- let bound = $union_set<tid>($bound(p, TC), { tid_impl*{tid_impl <- tid_impl*} })
      -- if RoutineType_wf: bound |- routineTypeIR holds

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:171:1-189:22:
   rule typedExpressionIR-nameIR-parser-apply-method: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): methodTypeIR as routineTypeIR <# [] >(# id_default*{id_default <- id_default*} )
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base . text = routineTargetIR
      -- if (text = "apply")
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: parserObjectTypeIR
      -- let parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as parserObjectTypeIR
      -- let methodTypeIR = parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )
      -- (let _direction _typeIR id_param value_param?{value_param <- value_param?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, id_param <- id_param*, parameterTypeIR <- parameterTypeIR*, value_param? <- value_param?*}
      -- (let pid = id_param # (value_param?{value_param <- value_param?} =/= ?()))*{id_param <- id_param*, pid <- pid*, value_param? <- value_param?*}
      -- let rid = "apply" ( pid*{pid <- pid*} )
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
      -- let (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} = $find_overloaded<routineTypeDefIR>({ [rid : methodTypeIR as routineTypeDefIR] }, "apply", id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} matches (_)
      -- let ?((rid, routineTypeDefIR, id*)) = (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?}
      -- if (rid, routineTypeDefIR, id*) <: (rid, methodTypeIR, id*)
      -- let (rid', methodTypeIR', id_default*{id_default <- id_default*}) = (rid, routineTypeDefIR, id*) as (rid, methodTypeIR, id*)
      -- if (rid' = rid)
      -- if (methodTypeIR' = methodTypeIR)

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:191:1-209:22:
   rule typedExpressionIR-nameIR-control-apply-method: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): methodTypeIR as routineTypeIR <# [] >(# id_default*{id_default <- id_default*} )
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base . text = routineTargetIR
      -- if (text = "apply")
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: controlObjectTypeIR
      -- let control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as controlObjectTypeIR
      -- let methodTypeIR = control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )
      -- (let _direction _typeIR id_param value_param?{value_param <- value_param?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, id_param <- id_param*, parameterTypeIR <- parameterTypeIR*, value_param? <- value_param?*}
      -- (let pid = id_param # (value_param?{value_param <- value_param?} =/= ?()))*{id_param <- id_param*, pid <- pid*, value_param? <- value_param?*}
      -- let rid = "apply" ( pid*{pid <- pid*} )
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
      -- let (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} = $find_overloaded<routineTypeDefIR>({ [rid : methodTypeIR as routineTypeDefIR] }, "apply", id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} matches (_)
      -- let ?((rid, routineTypeDefIR, id*)) = (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?}
      -- if (rid, routineTypeDefIR, id*) <: (rid, methodTypeIR, id*)
      -- let (rid', methodTypeIR', id_default*{id_default <- id_default*}) = (rid, routineTypeDefIR, id*) as (rid, methodTypeIR, id*)
      -- if (rid' = rid)
      -- if (methodTypeIR' = methodTypeIR)

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:211:1-218:52:
   rule typedExpressionIR-nameIR-table-apply-method: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): methodTypeIR as routineTypeIR <# [] >(# [] )
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base . text = routineTargetIR
      -- if (text = "apply")
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: tableObjectTypeIR
      -- let table _tid # typeIR_table = typeIR as tableObjectTypeIR
      -- let methodTypeIR = table_apply-> typeIR_table

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:224:1-228:85:
   rule parenthesized: p TC |- routineTargetIR' < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
      -- if routineTargetIR' matches `(%)`
      -- let ( routineTargetIR ) = routineTargetIR'
      -- RoutineType_ok: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:336:1-340:35:
relation Call_ok: cursor typingContext |- routineTypeIR < typeArgumentListIR # tid* >( argumentListIR # id* ): typeIR < typeArgumentListIR >( argumentListIR )

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:245:1-262:40:
   rule builtin-function: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let builtin_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- if $callable_builtin_function(p, TC)
      -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:276:1-306:40:
   rule function: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret_inferred < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
      -- let functionTypeIR_inferred = function( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_ret_inferred
      -- if RoutineType_wf: $bound(p, TC) |- functionTypeIR_inferred as routineTypeIR holds
      -- if $callable_function(p, TC)
      -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:318:1-348:40:
   rule externfunction: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret_inferred < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let extern_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
      -- let functionTypeIR_inferred = extern_function( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_ret_inferred
      -- if RoutineType_wf: $bound(p, TC) |- functionTypeIR_inferred as routineTypeIR holds
      -- if $callable_extern_function(p, TC)
      -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:360:1-376:38:
   rule action: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): void as typeIR < [] >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- if $callable_action(p, TC)
      -- Call_convention_ok: p TC action |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:389:1-406:40:
   rule builtin-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let builtin_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- if $callable_builtin_method(p, TC)
      -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:418:1-448:40:
   rule extern-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret_inferred < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
      -- let methodTypeIR_inferred = extern_method( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_ret_inferred
      -- if RoutineType_wf: $bound(p, TC) |- methodTypeIR_inferred as routineTypeIR holds
      -- if $callable_extern_method(p, TC)
      -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:460:1-490:40:
   rule extern-abstract-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret_inferred < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
      -- let methodTypeIR_inferred = extern_methodabstract( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_ret_inferred
      -- if RoutineType_wf: $bound(p, TC) |- methodTypeIR_inferred as routineTypeIR holds
      -- if $callable_extern_abstract_method(p, TC)
      -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:501:1-518:40:
   rule parser-apply-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): void as typeIR < [] >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- if $callable_parser_apply_method(p, TC)
      -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:529:1-546:40:
   rule control-apply-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): void as typeIR < [] >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- if $callable_control_apply_method(p, TC)
      -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:558:1-562:44:
   rule table-apply-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id*{id <- id*} ): typeIR_table < [] >( [] )
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let table_apply-> typeIR_table = methodTypeIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if tid*{tid <- tid*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if id*{id <- id*} matches []
      -- if $callable_table_apply_method(p, TC)

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:350:1-353:29:
relation ConstructorType_ok: cursor typingContext |- prefixedNameIR < typeArgumentListIR >( argumentIR* ): constructorTypeIR <# tid* >(# id* )

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:5:1-15:52:
   rule : p TC |- prefixedNameIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
      -- let (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?} = $find_constructor_overloaded(TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*})
      -- if (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?} matches (_)
      -- let ?((cid, constructorTypeDefIR, id_default*{id_default <- id_default*})) = (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?}
      -- let (constructorTypeIR, tid_impl*{tid_impl <- tid_impl*}) = $specialize_constructorTypeDef(constructorTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- let bound = $union_set<tid>($bound(p, TC), { tid_impl*{tid_impl <- tid_impl*} })
      -- if ConstructorType_wf: bound |- constructorTypeIR holds

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:360:19-360:31:
syntax instctxt = 
   | named
   | anon

;; ../../../../reference-specs/p4-concrete/5.04-typing-relation.spectec:362:1-369:38:
relation Inst_ok: cursor typingContext instctxt |- constructorTypeIR < typeArgumentListIR # tid* >( argumentListIR # id* ): typeIR < typeArgumentListIR >( argumentListIR )

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:79:1-113:44:
   rule package: cursor TC instctxt |- constructorTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object_inferred < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- if cursor matches `GLOBAL`
      -- let constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object = constructorTypeIR
      -- let typeIR = $canon(typeIR_object)
      -- if typeIR <: packageObjectTypeIR
      -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- (let typeIR'?{typeIR' <- typeIR'?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR'? <- typeIR'?*}
      -- (if typeIR'?{typeIR' <- typeIR'?} matches (_))*{typeIR'? <- typeIR'?*}
      -- (let ?(typeIR_inferred) = typeIR'?{typeIR' <- typeIR'?})*{typeIR'? <- typeIR'?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_object_inferred = $subst_type(inference, typeIR_object)
      -- let constructorTypeIR_inferred = constructor( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_object_inferred
      -- if ConstructorType_wf: $bound(global, TC) |- constructorTypeIR_inferred holds
      -- if $instantiable(global, TC, instctxt, typeIR_object_inferred)
      -- Call_convention_ok: block TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:117:1-151:40:
   rule non-package: p TC instctxt |- constructorTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object_inferred < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
      -- let constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object = constructorTypeIR
      -- if ~$is_package_object_typeIR($canon(typeIR_object))
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_object_inferred = $subst_type(inference, typeIR_object)
      -- let constructorTypeIR_inferred = constructor( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_object_inferred
      -- if ConstructorType_wf: $bound(p, TC) |- constructorTypeIR_inferred holds
      -- if $instantiable(p, TC, instctxt, typeIR_object_inferred)
      -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:338:1-342:23:
def $reduce_serenum_unary(typedExpressionIR, $check(typeIR) : bool) : typedExpressionIR? =

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:345:1-348:23:
   clause 0(typedExpressionIR, $check) = ?(typedExpressionIR)
      -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
      -- if $check(typeIR)

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:350:1-356:79:
   clause 1(typedExpressionIR, $check) = $reduce_serenum_unary(typedExpressionIR_cast, $check)
      -- let _expressionIR # ( typeIR ctk ) = typedExpressionIR
      -- if ~$check(typeIR)
      -- let typeIR' = typeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # typeIR_underlying { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
      -- let typedExpressionIR_cast = ( typeIR_underlying ) typedExpressionIR as expressionIR # ( typeIR_underlying ctk )

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:358:1-359:15:
   clause 2(typedExpressionIR, $check) = ?()
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:363:1-368:44:
def $reduce_serenum_binary(typedExpressionIR, typedExpressionIR, $check(typeIR, typeIR) : bool) : (typedExpressionIR, typedExpressionIR)? =

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:370:1-374:35:
   clause 0(typedExpressionIR_l, typedExpressionIR_r, $check) = ?((typedExpressionIR_l, typedExpressionIR_r))
      -- let _expressionIR # ( typeIR_l _ctk ) = typedExpressionIR_l
      -- let _expressionIR' # ( typeIR_r _ctk' ) = typedExpressionIR_r
      -- if $check(typeIR_l, typeIR_r)

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:376:1-384:87:
   clause 1(typedExpressionIR_l, typedExpressionIR_r, $check) = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r, $check)
      -- let _expressionIR # ( typeIR_l ctk_l ) = typedExpressionIR_l
      -- let _expressionIR' # ( typeIR_r _ctk ) = typedExpressionIR_r
      -- if ~$check(typeIR_l, typeIR_r)
      -- let typeIR = typeIR_l
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # typeIR_l_underlying { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
      -- let typedExpressionIR_l_cast = ( typeIR_l_underlying ) typedExpressionIR_l as expressionIR # ( typeIR_l_underlying ctk_l )

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:386:1-394:87:
   clause 2(typedExpressionIR_l, typedExpressionIR_r, $check) = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r_cast, $check)
      -- let _expressionIR # ( typeIR_l _ctk ) = typedExpressionIR_l
      -- let _expressionIR' # ( typeIR_r ctk_r ) = typedExpressionIR_r
      -- if ~$check(typeIR_l, typeIR_r)
      -- let typeIR = typeIR_r
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # typeIR_r_underlying { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
      -- let typedExpressionIR_r_cast = ( typeIR_r_underlying ) typedExpressionIR_r as expressionIR # ( typeIR_r_underlying ctk_r )

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:396:1-397:15:
   clause 3(typedExpressionIR_l, typedExpressionIR_r, $check) = ?()
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:408:1-408:66:
def $coerce_unary(typedExpressionIR, typeIR) : typedExpressionIR? =

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:410:1-412:37:
   clause 0(typedExpressionIR, typeIR_to) = ?(typedExpressionIR)
      -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
      -- if Type_alpha: typeIR ~~ typeIR_to holds

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:414:1-419:63:
   clause 1(typedExpressionIR, typeIR_to) = ?(typedExpressionIR_cast)
      -- let _expressionIR # ( typeIR ctk ) = typedExpressionIR
      -- if ~Type_alpha: typeIR ~~ typeIR_to holds
      -- if Sub_impl: typeIR <: typeIR_to holds
      -- let typedExpressionIR_cast = ( typeIR_to ) typedExpressionIR as expressionIR # ( typeIR_to ctk )

;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:423:1-424:44:
def $coerce_binary(typedExpressionIR, typedExpressionIR) : (typedExpressionIR, typedExpressionIR)? =

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:426:1-430:38:
   clause 0(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l, typedExpressionIR_r))
      -- let _expressionIR # ( typeIR_l _ctk ) = typedExpressionIR_l
      -- let _expressionIR' # ( typeIR_r _ctk' ) = typedExpressionIR_r
      -- if Type_alpha: typeIR_l ~~ typeIR_r holds

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:432:1-439:65:
   clause 1(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l_cast, typedExpressionIR_r))
      -- let _expressionIR # ( typeIR_l ctk_l ) = typedExpressionIR_l
      -- let _expressionIR' # ( typeIR_r _ctk ) = typedExpressionIR_r
      -- if ~Type_alpha: typeIR_l ~~ typeIR_r holds
      -- if Sub_impl: typeIR_l <: typeIR_r holds
      -- let typedExpressionIR_l_cast = ( typeIR_r ) typedExpressionIR_l as expressionIR # ( typeIR_r ctk_l )

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:441:1-449:65:
   clause 2(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l, typedExpressionIR_r_cast))
      -- let _expressionIR # ( typeIR_l _ctk ) = typedExpressionIR_l
      -- let _expressionIR' # ( typeIR_r ctk_r ) = typedExpressionIR_r
      -- if ~Type_alpha: typeIR_l ~~ typeIR_r holds
      -- if ~Sub_impl: typeIR_l <: typeIR_r holds
      -- if Sub_impl: typeIR_r <: typeIR_l holds
      -- let typedExpressionIR_r_cast = ( typeIR_l ) typedExpressionIR_r as expressionIR # ( typeIR_l ctk_r )

   ;; ../../../../reference-specs/p4-concrete/5.05.2-subtype.spectec:451:1-452:15:
   clause 3(typedExpressionIR_l, typedExpressionIR_r) = ?()
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:69:1-69:32:
def $compat_lnot(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:72:1-72:57:
   clause 0(typeIR) = $compat'_lnot($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:70:1-70:33:
def $compat'_lnot(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:73:1-73:31:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:74:1-75:14:
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:90:1-90:32:
def $compat_bnot(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:93:1-93:57:
   clause 0(typeIR) = $compat'_bnot($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:91:1-91:33:
def $compat'_bnot(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:94:1-94:37:
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:95:1-95:37:
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:96:1-97:15:
   clause 2(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:112:1-112:38:
def $compat_uplusminus(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:115:1-115:69:
   clause 0(typeIR) = $compat'_uplusminus($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:113:1-113:39:
def $compat'_uplusminus(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:116:1-116:36:
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:117:1-117:43:
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:118:1-118:43:
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:119:1-120:15:
   clause 3(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:138:1-138:49:
def $compat_plusminusmult(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:141:1-142:63:
   clause 0(typeIR_l, typeIR_r) = $compat'_plusminusmult($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:139:1-139:50:
def $compat'_plusminusmult(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:143:1-143:44:
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:144:1-144:58:
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< w' > = numberTypeIR'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:145:1-145:58:
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< w' > = numberTypeIR'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:146:1-147:15:
   clause 3(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:175:1-175:48:
def $compat_satplusminus(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:178:1-179:62:
   clause 0(typeIR_l, typeIR_r) = $compat'_satplusminus($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:176:1-176:49:
def $compat'_satplusminus(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:180:1-180:57:
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< w' > = numberTypeIR'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:181:1-181:57:
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< w' > = numberTypeIR'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:182:1-183:15:
   clause 2(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:211:1-211:42:
def $compat_divmod(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:214:1-215:56:
   clause 0(typeIR_l, typeIR_r) = $compat'_divmod($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:212:1-212:43:
def $compat'_divmod(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:216:1-216:37:
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:217:1-218:15:
   clause 1(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:278:1-278:41:
def $compat_shift(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:281:1-282:55:
   clause 0(typeIR_l, typeIR_r) = $compat'_shift($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:279:1-279:42:
def $compat'_shift(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:283:1-283:36:
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:284:1-284:43:
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< _nat > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:285:1-285:43:
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:286:1-286:43:
   clause 3(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:287:1-287:50:
   clause 4(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< _nat' > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:288:1-288:50:
   clause 5(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< _nat' > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:289:1-289:43:
   clause 6(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:290:1-290:50:
   clause 7(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< _nat' > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:291:1-291:50:
   clause 8(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< _nat' > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:292:1-293:15:
   clause 9(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:369:1-369:43:
def $compat_compare(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:372:1-373:57:
   clause 0(typeIR_l, typeIR_r) = $compat'_compare($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:370:1-370:44:
def $compat'_compare(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:374:1-374:38:
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:375:1-375:52:
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< w' > = numberTypeIR'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:376:1-376:52:
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< w' > = numberTypeIR'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:377:1-378:15:
   clause 3(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:406:1-406:43:
def $compat_bitwise(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:409:1-410:57:
   clause 0(typeIR_l, typeIR_r) = $compat'_bitwise($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:407:1-407:44:
def $compat'_bitwise(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:411:1-411:52:
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< w' > = numberTypeIR'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:412:1-412:52:
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< w' > = numberTypeIR'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:413:1-414:15:
   clause 2(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:442:1-442:42:
def $compat_concat(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:445:1-446:56:
   clause 0(typeIR_l, typeIR_r) = $compat'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:443:1-443:43:
def $compat'_concat(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:447:1-447:51:
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< _nat' > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:448:1-448:51:
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< _nat' > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:449:1-449:51:
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< _nat' > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:450:1-450:51:
   clause 3(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< _nat' > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:451:1-452:15:
   clause 4(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:454:1-454:45:
def $result_concat(typeIR, typeIR) : typeIR? =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:457:1-458:56:
   clause 0(typeIR_l, typeIR_r) = $result'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:455:1-455:46:
def $result'_concat(typeIR, typeIR) : typeIR? =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:459:1-459:72:
   clause 0(typeIR, typeIR') = ?(int< (w_a + w_b) > as typeIR)
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w_a > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< w_b > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:460:1-460:72:
   clause 1(typeIR, typeIR') = ?(int< (w_a + w_b) > as typeIR)
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w_a > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< w_b > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:461:1-461:72:
   clause 2(typeIR, typeIR') = ?(bit< (w_a + w_b) > as typeIR)
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w_a > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< w_b > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:462:1-462:72:
   clause 3(typeIR, typeIR') = ?(bit< (w_a + w_b) > as typeIR)
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w_a > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< w_b > = numberTypeIR'

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:463:1-464:15:
   clause 4(typeIR_l, typeIR_r) = ?()
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:492:1-492:43:
def $compat_logical(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:495:1-496:57:
   clause 0(typeIR_l, typeIR_r) = $compat'_logical($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:493:1-493:44:
def $compat'_logical(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:497:1-497:40:
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`
      -- if typeIR' <: primitiveTypeIR
      -- let primitiveTypeIR' = typeIR' as primitiveTypeIR
      -- if primitiveTypeIR' matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:498:1-499:15:
   clause 1(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:873:1-873:39:
def $compat_array_index(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:876:1-877:40:
   clause 0(typeIR) = $compat'_arrayindex($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:874:1-874:39:
def $compat'_arrayindex(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:878:1-878:36:
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:879:1-879:43:
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:880:1-880:43:
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:881:1-882:15:
   clause 3(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:964:1-964:41:
def $compat_bitslice_base(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:967:1-968:43:
   clause 0(typeIR) = $compat'_bitslice_base($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:965:1-965:42:
def $compat'_bitslice_base(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:969:1-969:39:
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:970:1-970:50:
   clause 1(typeIR) = (w > 0)
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:971:1-971:46:
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:972:1-973:15:
   clause 3(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:975:1-975:42:
def $compat_bitslice_index(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:978:1-979:44:
   clause 0(typeIR) = $compat'_bitslice_index($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:976:1-976:43:
def $compat'_bitslice_index(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:980:1-980:40:
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:981:1-981:47:
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:982:1-982:47:
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:983:1-984:15:
   clause 3(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:986:1-986:48:
def $is_valid_bitslice(typeIR, nat, nat) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:989:1-990:71:
   clause 0(typeIR, n_lo, n_hi) = ((n_lo <= n_hi) /\ $is_valid_bitslice'($canon(typeIR), n_lo, n_hi))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:987:1-987:49:
def $is_valid_bitslice'(typeIR, nat, nat) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:991:1-991:42:
   clause 0(typeIR, _nat, _nat') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:992:1-994:37:
   clause 1(typeIR, n_lo, n_hi) = ((n_hi <= w) /\ (w_slice <= w))
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w > = numberTypeIR
      -- let w_slice = ((n_hi - n_lo) + 1)

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:995:1-997:37:
   clause 2(typeIR, n_lo, n_hi) = ((n_hi <= w) /\ (w_slice <= w))
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w > = numberTypeIR
      -- let w_slice = ((n_hi - n_lo) + 1)

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:998:1-999:15:
   clause 3(_typeIR, _nat, _nat') = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1114:1-1114:46:
def $is_concrete_extern_object(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1119:1-1120:50:
   clause 0(typeIR) = $is_concrete_extern_object'($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1115:1-1115:47:
def $is_concrete_extern_object'(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1122:1-1123:42:
   clause 0(typeIR) = true
      -- if ~$is_extern_object_typeIR(typeIR)

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1124:1-1125:58:
   clause 1(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let extern _tid { _rid : routineTypeDefIR*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} } = typeIR as externObjectTypeIR
      -- (if $is_concrete_extern_object''(routineTypeDefIR))*{routineTypeDefIR <- routineTypeDefIR*}

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1126:1-1127:15:
   clause 2(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1116:1-1116:58:
def $is_concrete_extern_object''(routineTypeDefIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1129:1-1130:49:
   clause 0(routineTypeDefIR) = $is_concrete_extern_object'''(routineTypeIR)
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR = routineTypeDefIR as routineTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1131:1-1132:50:
   clause 1(routineTypeDefIR) = (true = $is_concrete_extern_object'''(routineTypeIR))
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR < _tid*{_tid <- _tid*} , _tid'*{_tid' <- _tid'*} > = routineTypeDefIR as polyRoutineTypeDefIR

;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1117:1-1117:56:
def $is_concrete_extern_object'''(routineTypeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1134:1-1134:79:
   clause 0(routineTypeIR) = false
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let extern_methodabstract( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = methodTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.06.2-typing-expression.spectec:1135:1-1136:15:
   clause 1(_routineTypeIR) = true
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:88:1-88:46:
def $compat_direct_application(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:91:1-92:48:
   clause 0(typeIR) = $compat'_direct_application($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:89:1-89:47:
def $compat'_direct_application(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:93:1-93:54:
   clause 0(typeIR) = true
      -- if typeIR <: parserObjectTypeIR
      -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:94:1-94:55:
   clause 1(typeIR) = true
      -- if typeIR <: controlObjectTypeIR
      -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:95:1-96:15:
   clause 2(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:204:1-206:26:
relation SwitchLabel_table_ok: typingContext tid bool |- switchLabel : switchLabelIR

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:210:1-211:41:
   rule default: TC tid_table bool |- switchLabel : default
      -- if (bool = true)
      -- if switchLabel matches `DEFAULT`

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:215:1-227:57:
   rule expressionNonBrace-prefixedNonTypeName: TC tid_table _bool |- switchLabel : typedExpressionIR_label as switchLabelIR
      -- if switchLabel <: prefixedNonTypeName
      -- let prefixedNonTypeName = switchLabel as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- if prefixedNameIR matches ``%`
      -- let ` nameIR_label = prefixedNameIR
      -- let tid_table_enum = "action_list(" ++ tid_table ++ ")"
      -- let id_label = tid_table_enum ++ "." ++ nameIR_label
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(local, TC, ` id_label)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction typeIR_label ctk_label value?{value <- value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if value?{value <- value?} matches (_)
      -- let ?(value_label) = value?{value <- value?}
      -- if (value_label = table_enum tid_table_enum . nameIR_label as value)
      -- let typedExpressionIR_label = ` nameIR_label as expressionIR # ( typeIR_label ctk_label )

;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:233:1-235:29:
relation SwitchCase_table_ok: typingContext flow tid bool |- switchCase : flow switchCaseIR # switchLabel

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:239:1-247:57:
   rule switchLabel-blockStatement: TC f tid_table b_last |- switchCase : f_post switchCaseIR # switchLabel
      -- if switchCase matches `%:%`
      -- let switchLabel : blockStatement = switchCase
      -- SwitchLabel_table_ok: TC tid_table b_last |- switchLabel : switchLabelIR
      -- Block_ok: TC f |- blockStatement : TC_post f_post blockStatementIR
      -- let switchCaseIR = switchLabelIR : blockStatementIR

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:251:1-257:40:
   rule switchLabel: TC f tid_table b_last |- switchCase : f switchCaseIR # switchLabel
      -- if switchCase matches `%:`
      -- let switchLabel : = switchCase
      -- SwitchLabel_table_ok: TC tid_table b_last |- switchLabel : switchLabelIR
      -- let switchCaseIR = switchLabelIR :

;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:261:1-263:26:
relation SwitchCases_table_ok: typingContext flow tid |- switchCase* : flow switchCaseListIR # switchLabel*

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:265:1-266:39:
   rule nil: TC f tid_table |- switchCase*{switchCase <- switchCase*} : f [] # []
      -- if switchCase*{switchCase <- switchCase*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:268:1-275:80:
   rule cons: TC f tid_table |- switchCase*{switchCase <- switchCase*} : f_t switchCaseIR_h :: switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} # switchLabel_h :: switchLabel_t*{switchLabel_t <- switchLabel_t*}
      -- if switchCase*{switchCase <- switchCase*} matches _ :: _
      -- let switchCase_h :: switchCase_t*{switchCase_t <- switchCase_t*} = switchCase*{switchCase <- switchCase*}
      -- let b_last = (switchCase_t*{switchCase_t <- switchCase_t*} = [])
      -- SwitchCase_table_ok: TC f tid_table b_last |- switchCase_h : f_h switchCaseIR_h # switchLabel_h
      -- SwitchCases_table_ok: TC f_h tid_table |- switchCase_t*{switchCase_t <- switchCase_t*} : f_t switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} # switchLabel_t*{switchLabel_t <- switchLabel_t*}

;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:300:1-302:26:
relation SwitchLabel_general_ok: typingContext typeIR bool |- switchLabel : switchLabelIR

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:306:1-307:33:
   rule default: TC _typeIR bool |- switchLabel : default
      -- if (bool = true)
      -- if switchLabel matches `DEFAULT`

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:311:1-319:56:
   rule expressionNonBrace: TC typeIR_switch _bool |- switchLabel : typedExpressionIR_label_cast as switchLabelIR
      -- if switchLabel <: expressionNonBrace
      -- let expressionNonBrace_label = switchLabel as expressionNonBrace
      -- let expression_label = $expressionNonBrace(expressionNonBrace_label)
      -- Expr_ok: local TC |- expression_label : typedExpressionIR_label
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_label, typeIR_switch)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_label_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR_label_cast
      -- if ctk matches `LCTK`

;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:323:1-325:29:
relation SwitchCase_general_ok: typingContext flow typeIR bool |- switchCase : flow switchCaseIR # switchLabel

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:329:1-337:57:
   rule switchLabel-blockStatement: TC f typeIR_switch b_last |- switchCase : f_post switchCaseIR # switchLabel
      -- if switchCase matches `%:%`
      -- let switchLabel : blockStatement = switchCase
      -- SwitchLabel_general_ok: TC typeIR_switch b_last |- switchLabel : switchLabelIR
      -- Block_ok: TC f |- blockStatement : TC_post f_post blockStatementIR
      -- let switchCaseIR = switchLabelIR : blockStatementIR

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:341:1-347:40:
   rule switchLabel: TC f typeIR_switch b_last |- switchCase : f switchCaseIR # switchLabel
      -- if switchCase matches `%:`
      -- let switchLabel : = switchCase
      -- SwitchLabel_general_ok: TC typeIR_switch b_last |- switchLabel : switchLabelIR
      -- let switchCaseIR = switchLabelIR :

;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:351:1-353:26:
relation SwitchCases_general_ok: typingContext flow typeIR |- switchCase* : flow switchCaseListIR # switchLabel*

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:355:1-356:43:
   rule nil: TC f typeIR_switch |- switchCase*{switchCase <- switchCase*} : f [] # []
      -- if switchCase*{switchCase <- switchCase*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:358:1-366:84:
   rule cons: TC f typeIR_switch |- switchCase*{switchCase <- switchCase*} : f_t switchCaseIR_h :: switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} # switchLabel_h :: switchLabel_t*{switchLabel_t <- switchLabel_t*}
      -- if switchCase*{switchCase <- switchCase*} matches _ :: _
      -- let switchCase_h :: switchCase_t*{switchCase_t <- switchCase_t*} = switchCase*{switchCase <- switchCase*}
      -- let b_last = (switchCase_t*{switchCase_t <- switchCase_t*} = [])
      -- SwitchCase_general_ok: TC f typeIR_switch b_last |- switchCase_h : f_h switchCaseIR_h # switchLabel_h
      -- SwitchCases_general_ok: TC f_h typeIR_switch |- switchCase_t*{switchCase_t <- switchCase_t*} : f_t switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} # switchLabel_t*{switchLabel_t <- switchLabel_t*}

;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:368:1-368:34:
def $compat_switch(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:371:1-372:36:
   clause 0(typeIR) = $compat'_switch($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:369:1-369:35:
def $compat'_switch(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:373:1-373:34:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ERROR`

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:374:1-374:39:
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:375:1-375:39:
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:376:1-376:42:
   clause 3(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:377:1-377:47:
   clause 4(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.10-typing-statement.spectec:378:1-379:15:
   clause 5(typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:88:1-91:29:
relation Decl_object_ok: cursor typingContext frame rdenv |- objectDeclaration : frame rdenv objectDeclarationIR

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:101:1-136:27:
   rule functionDeclaration: p TC_0 frame rdenv |- objectDeclaration : frame rdenv_init functionDeclarationIR as objectDeclarationIR
      -- if objectDeclaration <: functionDeclaration
      -- let annotationList typeOrVoid name typeParameterListOpt ( parameterList ) blockStatement = objectDeclaration as functionDeclaration
      -- let TC_1 = TC_0[block.kind = extern]
      -- let TC_2 = TC_1[block.frame = frame]
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_3 = $add_types(local, TC_2, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: local TC_3 |- typeOrVoid : typeIR_ret # tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: local TC_3 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let TC_4 = $add_parameters(local, TC_3, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let TC_5 = TC_4[local.kind = extern_method-> typeIR_ret]
      -- Block_ok: TC_5 cont |- blockStatement : _typingContext f blockStatementIR
      -- if ((f = ret) \/ (typeIR_ret = void as typeIR))
      -- let rid = $rid(name, parameterList)
      -- let methodTypeIR = extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
      -- let routineTypeDefIR = methodTypeIR as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
      -- if RoutineTypeDef_wf: $bound(p, TC_0) |- routineTypeDefIR holds
      -- let rdenv_init = $update_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let nameIR = $name(name)
      -- let functionDeclarationIR = annotationList typeIR_ret nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} ) blockStatementIR

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:140:1-149:61:
   rule instantiation: p TC_0 frame rdenv |- objectDeclaration : frame_init rdenv instantiationIR as objectDeclarationIR
      -- if objectDeclaration <: instantiation
      -- let instantiation = objectDeclaration as instantiation
      -- Decl_ok: p TC_0 |- instantiation as declaration : TC_1 declarationIR
      -- if declarationIR <: instantiationIR
      -- let instantiationIR = declarationIR as instantiationIR
      -- let _annotationList _typeIR _prefixedNameIR < _typeArgumentListIR >( _argumentListIR ) nameIR _objectInitializerOptIR ; = instantiationIR
      -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_var(p, TC_1, ` nameIR)
      -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
      -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}
      -- let frame_init = $update_map<id, varTypeIR>(frame, nameIR, varTypeIR)

;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:151:1-154:29:
relation Decls_object_ok: cursor typingContext frame rdenv |- objectDeclaration* : frame rdenv objectDeclarationListIR

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:156:1-157:44:
   rule nil: p TC frame rdenv |- objectDeclaration*{objectDeclaration <- objectDeclaration*} : frame rdenv []
      -- if objectDeclaration*{objectDeclaration <- objectDeclaration*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:159:1-167:69:
   rule cons: p TC frame_0 rdenv_0 |- objectDeclaration*{objectDeclaration <- objectDeclaration*} : frame_2 rdenv_2 objectDeclarationIR_h :: objectDeclarationIR_t*{objectDeclarationIR_t <- objectDeclarationIR_t*}
      -- if objectDeclaration*{objectDeclaration <- objectDeclaration*} matches _ :: _
      -- let objectDeclaration_h :: objectDeclaration_t*{objectDeclaration_t <- objectDeclaration_t*} = objectDeclaration*{objectDeclaration <- objectDeclaration*}
      -- Decl_object_ok: p TC frame_0 rdenv_0 |- objectDeclaration_h : frame_1 rdenv_1 objectDeclarationIR_h
      -- Decls_object_ok: p TC frame_1 rdenv_1 |- objectDeclaration_t*{objectDeclaration_t <- objectDeclaration_t*} : frame_2 rdenv_2 objectDeclarationIR_t*{objectDeclarationIR_t <- objectDeclarationIR_t*}

;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:169:1-169:46:
def $subst_rdenv(theta, rdenv, rdenv) : rdenv =

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:171:1-171:63:
   clause 0(theta, rdenv_extern, set<pair<rid, routineTypeDefIR>>) = rdenv_extern
      -- if (set<pair<rid, routineTypeDefIR>> = { [] })

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:172:1-188:93:
   clause 1(theta, rdenv_extern, { pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*} }) = $subst_rdenv(theta, rdenv_extern_subst, { rid_init_t : routineTypeDefIR_init_t*{rid_init_t <- rid_init_t*, routineTypeDefIR_init_t <- routineTypeDefIR_init_t*} })
      -- if pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*} matches _ :: _
      -- let rid_init_h : routineTypeDefIR_init_h :: rid_init_t : routineTypeDefIR_init_t*{rid_init_t <- rid_init_t*, routineTypeDefIR_init_t <- routineTypeDefIR_init_t*} = pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*}
      -- let routineTypeDefIR''?{routineTypeDefIR'' <- routineTypeDefIR''?} = $find_map<rid, routineTypeDefIR>(rdenv_extern, rid_init_h)
      -- if routineTypeDefIR''?{routineTypeDefIR'' <- routineTypeDefIR''?} matches (_)
      -- let ?(routineTypeDefIR') = routineTypeDefIR''?{routineTypeDefIR'' <- routineTypeDefIR''?}
      -- if routineTypeDefIR' <: polyRoutineTypeDefIR
      -- let routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > = routineTypeDefIR' as polyRoutineTypeDefIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
      -- let routineTypeDefIR = extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
      -- let routineTypeDefIR_subst = $subst_routineTypeDef(theta, routineTypeDefIR)
      -- if RoutineTypeDef_alpha: routineTypeDefIR_subst ~~ routineTypeDefIR_init_h holds
      -- let rdenv_extern_subst = $update_map<rid, routineTypeDefIR>(rdenv_extern, rid_init_h, routineTypeDefIR_subst)

;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:418:1-418:81:
def $split_constructors(methodPrototype*) : (methodPrototype*, methodPrototype*) =

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:420:1-420:42:
   clause 0(methodPrototype*{methodPrototype <- methodPrototype*}) = ([], [])
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:421:1-426:48:
   clause 1(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_h :: methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- let methodPrototype' = methodPrototype_h
      -- if methodPrototype' matches `%%(%);`
      -- let _annotationList _typeIdentifier ( _parameterList ); = methodPrototype'
      -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:427:1-432:48:
   clause 2(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_h :: methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- let methodPrototype' = methodPrototype_h
      -- if methodPrototype' matches `%%;`
      -- let _annotationList _functionPrototype ; = methodPrototype'
      -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:433:1-438:48:
   clause 3(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_h :: methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- let methodPrototype' = methodPrototype_h
      -- if methodPrototype' matches `%ABSTRACT%;`
      -- let _annotationList abstract _functionPrototype ; = methodPrototype'
      -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:616:1-619:26:
relation Enum_serializable_field_ok: typingContext nameIR typeIR |- namedExpression : typingContext namedExpressionIR # value

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:621:1-636:74:
   rule : TC_0 nameIR_enum typeIR |- name = expression : TC_1 nameIR = typedExpressionIR_cast # value
      -- Expr_ok: block TC_0 |- expression : typedExpressionIR
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR_cast
      -- if ctk matches `LCTK`
      -- Eval_static: block TC_0 |- typedExpressionIR_cast ~> value
      -- let nameIR = $name(name)
      -- let typeIR_enum = enum nameIR_enum # typeIR { [] } as typeIR
      -- let value_enum = nameIR_enum . nameIR # value as value
      -- let TC_1 = $add_var(block, TC_0, nameIR, typeIR_enum lctk ?(value_enum))

;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:638:1-641:26:
relation Enum_serializable_fields_ok: typingContext nameIR typeIR |- namedExpression* : typingContext namedExpressionIR* # value*

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:643:1-644:47:
   rule nil: TC nameIR_enum typeIR |- namedExpression*{namedExpression <- namedExpression*} : TC [] # []
      -- if namedExpression*{namedExpression <- namedExpression*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.11-typing-declaration.spectec:646:1-656:55:
   rule cons: TC_0 nameIR_enum typeIR |- namedExpression*{namedExpression <- namedExpression*} : TC_2 namedExpressionIR*{namedExpressionIR <- namedExpressionIR*} # value_field*{value_field <- value_field*}
      -- if namedExpression*{namedExpression <- namedExpression*} matches _ :: _
      -- let namedExpression_h :: namedExpression_t*{namedExpression_t <- namedExpression_t*} = namedExpression*{namedExpression <- namedExpression*}
      -- Enum_serializable_field_ok: TC_0 nameIR_enum typeIR |- namedExpression_h : TC_1 namedExpressionIR_h # value_field_h
      -- Enum_serializable_fields_ok: TC_1 nameIR_enum typeIR |- namedExpression_t*{namedExpression_t <- namedExpression_t*} : TC_2 namedExpressionIR_t*{namedExpressionIR_t <- namedExpressionIR_t*} # value_field_t*{value_field_t <- value_field_t*}
      -- let namedExpressionIR*{namedExpressionIR <- namedExpressionIR*} = namedExpressionIR_h :: namedExpressionIR_t*{namedExpressionIR_t <- namedExpressionIR_t*}
      -- let value_field*{value_field <- value_field*} = value_field_h :: value_field_t*{value_field_t <- value_field_t*}

;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:33:1-35:23:
relation SelectCase_keyset_simple_ok: typingContext typeIR |- simpleKeysetExpression : simpleKeysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:39:1-45:38:
   rule expression-set-alpha: TC typeIR_key |- simpleKeysetExpression : typedExpressionIR as simpleKeysetExpressionIR
      -- if simpleKeysetExpression <: expression
      -- let expression = simpleKeysetExpression as expression
      -- Expr_ok: local TC |- expression : typedExpressionIR
      -- let _expressionIR # ( typeIR'' _ctk ) = typedExpressionIR
      -- if typeIR'' <: setTypeIR
      -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
      -- if Type_alpha: typeIR ~~ typeIR_key holds

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:47:1-58:69:
   rule expression-set-subtype: TC typeIR_key |- simpleKeysetExpression : typedExpressionIR_cast as simpleKeysetExpressionIR
      -- if simpleKeysetExpression <: expression
      -- let expression = simpleKeysetExpression as expression
      -- Expr_ok: local TC |- expression : typedExpressionIR
      -- let _expressionIR # ( typeIR'' _ctk ) = typedExpressionIR
      -- if typeIR'' <: setTypeIR
      -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
      -- if ~Type_alpha: typeIR ~~ typeIR_key holds
      -- if Sub_impl: typeIR <: typeIR_key holds
      -- let typeIR_cast = set< [typeIR_key] > as typeIR
      -- let typedExpressionIR_cast = ( typeIR_cast ) typedExpressionIR as expressionIR # ( typeIR_cast dyn )

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:60:1-72:69:
   rule expression-non-set: TC typeIR_key |- simpleKeysetExpression : typedExpressionIR_cast as simpleKeysetExpressionIR
      -- if simpleKeysetExpression <: expression
      -- let expression = simpleKeysetExpression as expression
      -- Expr_ok: local TC |- expression : typedExpressionIR
      -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
      -- if ~$is_set_typeIR(typeIR)
      -- if Sub_impl: typeIR <: typeIR_key holds
      -- let typeIR_cast = set< [typeIR_key] > as typeIR
      -- let typedExpressionIR_cast = ( typeIR_cast ) typedExpressionIR as expressionIR # ( typeIR_cast dyn )

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:87:1-109:63:
   rule mask: TC typeIR_key |- simpleKeysetExpression : typedExpressionIR_l_coerced &&& typedExpressionIR_r_coerced
      -- if simpleKeysetExpression matches `%&&&%`
      -- let expression_l &&& expression_r = simpleKeysetExpression
      -- Expr_ok: local TC |- expression_l : typedExpressionIR_l
      -- Expr_ok: local TC |- expression_r : typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR # ( typeIR_reduced _ctk ) = typedExpressionIR_l_reduced
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_l_reduced, typeIR_key)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_l_coerced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR_r_reduced, typeIR_key)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_r_coerced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:124:1-147:63:
   rule range: TC typeIR_key |- simpleKeysetExpression : typedExpressionIR_l_coerced .. typedExpressionIR_r_coerced
      -- if simpleKeysetExpression matches `%..%`
      -- let expression_l .. expression_r = simpleKeysetExpression
      -- Expr_ok: local TC |- expression_l : typedExpressionIR_l
      -- Expr_ok: local TC |- expression_r : typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR # ( typeIR_reduced _ctk ) = typedExpressionIR_l_reduced
      -- let _expressionIR' # ( typeIR _ctk' ) = typedExpressionIR_r_reduced
      -- if (typeIR = typeIR_reduced)
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_l_reduced, typeIR_key)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_l_coerced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR_r_reduced, typeIR_key)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_r_coerced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:151:1-152:37:
   rule default: TC typeIR_key |- simpleKeysetExpression : default
      -- if simpleKeysetExpression matches `DEFAULT`

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:156:1-157:27:
   rule dontcare: TC typeIR_key |- simpleKeysetExpression : _
      -- if simpleKeysetExpression matches `_`

;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:76:1-76:40:
def $compat_mask(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:79:1-80:54:
   clause 0(typeIR_l, typeIR_r) = $compat'_mask($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:77:1-77:41:
def $compat'_mask(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:81:1-81:35:
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:82:1-82:49:
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< w' > = numberTypeIR'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:83:1-83:49:
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< w' > = numberTypeIR'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:84:1-85:15:
   clause 3(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:113:1-113:41:
def $compat_range(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:116:1-117:55:
   clause 0(typeIR_l, typeIR_r) = $compat'_range($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:114:1-114:42:
def $compat'_range(typeIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:118:1-118:36:
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:119:1-119:50:
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< w > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let int< w' > = numberTypeIR'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:120:1-120:50:
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< w > = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let bit< w' > = numberTypeIR'
      -- if (w = w')

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:121:1-122:15:
   clause 3(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:161:1-163:23:
relation SelectCase_keyset_ok: typingContext typeIR* |- keysetExpression : keysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:170:1-173:61:
   rule simpleKeysetExpression-expression: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : simpleKeysetExpressionIR as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if keysetExpression <: expression
      -- let expression = keysetExpression as expression
      -- SelectCase_keyset_simple_ok: TC typeIR_key |- expression as simpleKeysetExpression : simpleKeysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:177:1-180:81:
   rule simpleKeysetExpression-mask: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : simpleKeysetExpressionIR as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `%&&&%`
      -- let expression_l &&& expression_r = simpleKeysetExpression
      -- SelectCase_keyset_simple_ok: TC typeIR_key |- expression_l &&& expression_r : simpleKeysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:184:1-187:80:
   rule simpleKeysetExpression-range: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : simpleKeysetExpressionIR as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `%..%`
      -- let expression_l .. expression_r = simpleKeysetExpression
      -- SelectCase_keyset_simple_ok: TC typeIR_key |- expression_l .. expression_r : simpleKeysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:191:1-192:30:
   rule simpleKeysetExpression-default-zero-to-one: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : default as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches []
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `DEFAULT`

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:194:1-197:58:
   rule simpleKeysetExpression-default-one-to-one: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : simpleKeysetExpressionIR as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `DEFAULT`
      -- SelectCase_keyset_simple_ok: TC typeIR_key |- default : simpleKeysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:199:1-203:70:
   rule simpleKeysetExpression-default-many-to-one: TC typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : simpleKeysetExpressionIR as keysetExpressionIR
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `DEFAULT`
      -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
      -- SelectCase_keyset_simple_ok: TC seq< typeIR_key*{typeIR_key <- typeIR_key*} > as typeIR |- default : simpleKeysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:207:1-210:53:
   rule simpleKeysetExpression-dontcare-one-to-one: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : simpleKeysetExpressionIR as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `_`
      -- SelectCase_keyset_simple_ok: TC typeIR_key |- _ : simpleKeysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:212:1-216:65:
   rule simpleKeysetExpression-dontcare-many-to-one: TC typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : simpleKeysetExpressionIR as keysetExpressionIR
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `_`
      -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
      -- SelectCase_keyset_simple_ok: TC seq< typeIR_key*{typeIR_key <- typeIR_key*} > as typeIR |- _ : simpleKeysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:223:1-226:81:
   rule tupleKeysetExpression-mask: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(%&&&%)`
      -- let ( expression_l &&& expression_r ) = tupleKeysetExpression
      -- SelectCase_keyset_simple_ok: TC typeIR_key |- expression_l &&& expression_r : simpleKeysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:230:1-233:80:
   rule tupleKeysetExpression-range: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(%..%)`
      -- let ( expression_l .. expression_r ) = tupleKeysetExpression
      -- SelectCase_keyset_simple_ok: TC typeIR_key |- expression_l .. expression_r : simpleKeysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:237:1-240:58:
   rule tupleKeysetExpression-default-one-to-one: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(DEFAULT)`
      -- SelectCase_keyset_simple_ok: TC typeIR_key |- default : simpleKeysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:242:1-246:70:
   rule tupleKeysetExpression-default-many-to-one: TC typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(DEFAULT)`
      -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
      -- SelectCase_keyset_simple_ok: TC seq< typeIR_key*{typeIR_key <- typeIR_key*} > as typeIR |- default : simpleKeysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:250:1-253:53:
   rule tupleKeysetExpression-dontcare-one-to-one: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(_)`
      -- SelectCase_keyset_simple_ok: TC typeIR_key |- _ : simpleKeysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:255:1-259:65:
   rule tupleKeysetExpression-dontcare-many-to-one: TC typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(_)`
      -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
      -- SelectCase_keyset_simple_ok: TC seq< typeIR_key*{typeIR_key <- typeIR_key*} > as typeIR |- _ : simpleKeysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:263:1-274:75:
   rule tupleKeysetExpression-list: TC typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : ( simpleKeysetExpressionIR*{simpleKeysetExpressionIR <- simpleKeysetExpressionIR*} ) as keysetExpressionIR
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(%,%)`
      -- let ( simpleKeysetExpression_h , simpleKeysetExpressionList_t ) = tupleKeysetExpression
      -- let simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*} = $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList_t)
      -- let simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} = simpleKeysetExpression_h :: simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*}
      -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| = |simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*}|)
      -- (SelectCase_keyset_simple_ok: TC typeIR_key |- simpleKeysetExpression : simpleKeysetExpressionIR)*{simpleKeysetExpression <- simpleKeysetExpression*, simpleKeysetExpressionIR <- simpleKeysetExpressionIR*, typeIR_key <- typeIR_key*}

;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:278:1-280:26:
relation SelectCase_ok: typingContext nameIR* typeIR* |- selectCase : selectCaseIR

   ;; ../../../../reference-specs/p4-concrete/5.13.1-typing-parser-statement.spectec:282:1-290:32:
   rule : TC nameIR_state*{nameIR_state <- nameIR_state*} typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : name ; : keysetExpressionIR : nameIR ;
      -- SelectCase_keyset_ok: TC typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : keysetExpressionIR
      -- let nameIR = $name(name)
      -- if nameIR <- nameIR_state*{nameIR_state <- nameIR_state*}

;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:7:1-7:52:
def $compat_table_exact_optional_key(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:10:1-11:54:
   clause 0(typeIR) = $compat'_table_exact_optional_key($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:8:1-8:53:
def $compat'_table_exact_optional_key(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:12:1-12:51:
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BOOL`

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:13:1-13:52:
   clause 1(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ERROR`

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:14:1-14:59:
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:15:1-16:45:
   clause 3(typeIR') = $compat_table_exact_optional_key(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:17:1-17:60:
   clause 4(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:18:1-19:45:
   clause 5(typeIR') = $compat_table_exact_optional_key(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:21:1-21:55:
def $compat_table_lpm_ternary_range_key(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:24:1-25:57:
   clause 0(typeIR) = $compat'_table_lpm_ternary_range_key($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:22:1-22:56:
def $compat'_table_lpm_ternary_range_key(typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:26:1-26:53:
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT`

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:27:1-27:60:
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let int< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:28:1-28:60:
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let bit< _nat > = numberTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:29:1-30:48:
   clause 3(typeIR') = $compat_table_lpm_ternary_range_key(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type _tid typeIR = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:31:1-32:48:
   clause 4(typeIR') = $compat_table_lpm_ternary_range_key(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:34:1-34:45:
def $compat_table_key(nameIR, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:36:1-38:49:
   clause 0(nameIR, typeIR) = true
      -- if ((nameIR = "exact") \/ (nameIR = "optional"))
      -- if $compat_table_exact_optional_key(typeIR)

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:40:1-42:52:
   clause 1(nameIR, typeIR) = true
      -- if (((nameIR = "lpm") \/ (nameIR = "ternary")) \/ (nameIR = "range"))
      -- if $compat_table_lpm_ternary_range_key(typeIR)

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:44:1-45:15:
   clause 2(nameIR, typeIR) = false
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:87:1-88:41:
def $split_dataplane_parameters(parameterTypeIR*) : (parameterTypeIR*, parameterTypeIR*) =

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:90:1-90:50:
   clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = ([], [])
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:91:1-95:56:
   clause 1(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_h :: parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR_h
      -- if direction matches ``EMPTY`
      -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:96:1-101:56:
   clause 2(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = (parameterTypeIR_h :: parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR_h
      -- if (direction =/= )
      -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:238:1-241:26:
relation TableEntry_keyset_simple_ok: typingContext tableContext |- matchKey @ simpleKeysetExpression : tableEntryState simpleKeysetExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:245:1-258:67:
   rule expression-lpm: TC TBLC |- (typeIR_key, text) @ simpleKeysetExpression : lpm n typedExpressionIR_set as simpleKeysetExpressionIR
      -- if (text = "lpm")
      -- if simpleKeysetExpression <: expression
      -- let expression = simpleKeysetExpression as expression
      -- let matchMode = TBLC.mode
      -- if matchMode matches `NOPRILPM%`
      -- let noprilpm n = matchMode
      -- Expr_ok: local TC |- expression : typedExpressionIR
      -- let _expressionIR # ( typeIR ctk ) = typedExpressionIR
      -- if Sub_impl: typeIR <: typeIR_key holds
      -- let typeIR_set = set< [typeIR_key] > as typeIR
      -- let typedExpressionIR_set = ( typeIR_set ) typedExpressionIR as expressionIR # ( typeIR_set ctk )

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:260:1-273:67:
   rule expression-non-lpm: TC TBLC |- (typeIR_key, nameIR_matchkind) @ simpleKeysetExpression : nolpm typedExpressionIR_set as simpleKeysetExpressionIR
      -- if simpleKeysetExpression <: expression
      -- let expression = simpleKeysetExpression as expression
      -- if (nameIR_matchkind =/= "lpm")
      -- Expr_ok: local TC |- expression : typedExpressionIR
      -- let _expressionIR # ( typeIR ctk ) = typedExpressionIR
      -- if Sub_impl: typeIR <: typeIR_key holds
      -- let typeIR_set = set< [typeIR_key] > as typeIR
      -- let typedExpressionIR_set = ( typeIR_set ) typedExpressionIR as expressionIR # ( typeIR_set ctk )

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:277:1-304:66:
   rule mask-lpm: TC TBLC |- (typeIR_key, text) @ simpleKeysetExpression : lpm n_prefix typedExpressionIR_l_reduced &&& typedExpressionIR_r_reduced
      -- if (text = "lpm")
      -- if simpleKeysetExpression matches `%&&&%`
      -- let expression_l &&& expression_r = simpleKeysetExpression
      -- let matchMode = TBLC.mode
      -- if matchMode matches `NOPRILPM%`
      -- let noprilpm n = matchMode
      -- Expr_ok: local TC |- expression_l : typedExpressionIR_l
      -- Expr_ok: local TC |- expression_r : typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR # ( typeIR_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
      -- if Sub_impl: typeIR_reduced <: typeIR_key holds
      -- if (ctk_r_reduced = lctk)
      -- Eval_static: local TC |- typedExpressionIR_r_reduced ~> value_r
      -- let i_r = $to_number(value_r)
      -- let n_prefix = $tableEntry_lpm_prefix(n w $to_bitstr(n as int, i_r) as value)

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:306:1-325:44:
   rule mask-ternary: TC TBLC |- (typeIR_key, text) @ simpleKeysetExpression : nolpm typedExpressionIR_l_reduced &&& typedExpressionIR_r_reduced
      -- if (text = "ternary")
      -- if simpleKeysetExpression matches `%&&&%`
      -- let expression_l &&& expression_r = simpleKeysetExpression
      -- Expr_ok: local TC |- expression_l : typedExpressionIR_l
      -- Expr_ok: local TC |- expression_r : typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR # ( typeIR_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
      -- if Sub_impl: typeIR_reduced <: typeIR_key holds

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:329:1-348:44:
   rule range-range: TC TBLC |- (typeIR_key, text) @ simpleKeysetExpression : nolpm typedExpressionIR_l_reduced .. typedExpressionIR_r_reduced
      -- if (text = "range")
      -- if simpleKeysetExpression matches `%..%`
      -- let expression_l .. expression_r = simpleKeysetExpression
      -- Expr_ok: local TC |- expression_l : typedExpressionIR_l
      -- Expr_ok: local TC |- expression_r : typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR # ( typeIR_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
      -- if Sub_impl: typeIR_reduced <: typeIR_key holds

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:352:1-355:31:
   rule default-lpm: TC TBLC |- (typeIR_key, text) @ simpleKeysetExpression : lpm n default
      -- if (text = "lpm")
      -- if simpleKeysetExpression matches `DEFAULT`
      -- let matchMode = TBLC.mode
      -- if matchMode matches `NOPRILPM%`
      -- let noprilpm n = matchMode

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:357:1-360:37:
   rule default-else: TC TBLC |- (typeIR_key, nameIR_matchkind) @ simpleKeysetExpression : nolpm default
      -- if simpleKeysetExpression matches `DEFAULT`
      -- if (nameIR_matchkind =/= "exact")

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:364:1-367:31:
   rule dontcare-lpm: TC TBLC |- (typeIR_key, text) @ simpleKeysetExpression : lpm 0 _
      -- if (text = "lpm")
      -- if simpleKeysetExpression matches `_`
      -- let matchMode = TBLC.mode
      -- if matchMode matches `NOPRILPM%`
      -- let noprilpm _nat = matchMode

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:369:1-372:37:
   rule dontcare-else: TC TBLC |- (typeIR_key, nameIR_matchkind) @ simpleKeysetExpression : nolpm _
      -- if simpleKeysetExpression matches `_`
      -- if (nameIR_matchkind =/= "exact")

;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:380:1-383:29:
relation TableEntry_keysets_simple_ok: typingContext tableContext tableEntryState |- matchKey* @ simpleKeysetExpression* : tableEntryState simpleKeysetExpressionIR*

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:385:1-386:40:
   rule nil: TC TBLC TBLS |- matchKey*{matchKey <- matchKey*} @ simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} : TBLS []
      -- if matchKey*{matchKey <- matchKey*} matches []
      -- if simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:388:1-398:59:
   rule cons: TC TBLC TBLS_0 |- matchKey*{matchKey <- matchKey*} @ simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} : TBLS_3 simpleKeysetExpressionIR_h :: simpleKeysetExpressionIR_t*{simpleKeysetExpressionIR_t <- simpleKeysetExpressionIR_t*}
      -- if matchKey*{matchKey <- matchKey*} matches _ :: _
      -- let matchKey_h :: matchKey_t*{matchKey_t <- matchKey_t*} = matchKey*{matchKey <- matchKey*}
      -- if simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} matches _ :: _
      -- let simpleKeysetExpression_h :: simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*} = simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*}
      -- TableEntry_keyset_simple_ok: TC TBLC |- matchKey_h @ simpleKeysetExpression_h : TBLS_1 simpleKeysetExpressionIR_h
      -- let TBLS_2 = $join_tableEntryState(TBLS_0, TBLS_1)
      -- TableEntry_keysets_simple_ok: TC TBLC TBLS_2 |- matchKey_t*{matchKey_t <- matchKey_t*} @ simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*} : TBLS_3 simpleKeysetExpressionIR_t*{simpleKeysetExpressionIR_t <- simpleKeysetExpressionIR_t*}

;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:900:1-900:44:
def $count_table_keys(tableProperty*) : nat =

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:902:1-902:31:
   clause 0(tableProperty*{tableProperty <- tableProperty*}) = 0
      -- if tableProperty*{tableProperty <- tableProperty*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:903:1-906:47:
   clause 1(tableProperty'*{tableProperty' <- tableProperty'*}) = (1 + $count_table_keys(tableProperty_t*{tableProperty_t <- tableProperty_t*}))
      -- if tableProperty'*{tableProperty' <- tableProperty'*} matches _ :: _
      -- let tableProperty :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty'*{tableProperty' <- tableProperty'*}
      -- if tableProperty matches `KEY={%}`
      -- let key={ _tableKeyList } = tableProperty

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:907:1-911:15:
   clause 2(tableProperty*{tableProperty <- tableProperty*}) = $count_table_keys(tableProperty_t*{tableProperty_t <- tableProperty_t*})
      -- if tableProperty*{tableProperty <- tableProperty*} matches _ :: _
      -- let tableProperty_h :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty*{tableProperty <- tableProperty*}
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:913:1-913:47:
def $count_table_actions(tableProperty*) : nat =

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:915:1-915:34:
   clause 0(tableProperty*{tableProperty <- tableProperty*}) = 0
      -- if tableProperty*{tableProperty <- tableProperty*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:916:1-919:50:
   clause 1(tableProperty'*{tableProperty' <- tableProperty'*}) = (1 + $count_table_actions(tableProperty_t*{tableProperty_t <- tableProperty_t*}))
      -- if tableProperty'*{tableProperty' <- tableProperty'*} matches _ :: _
      -- let tableProperty :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty'*{tableProperty' <- tableProperty'*}
      -- if tableProperty matches `ACTIONS={%}`
      -- let actions={ _tableActionList } = tableProperty

   ;; ../../../../reference-specs/p4-concrete/5.14.1-typing-control-table.spectec:920:1-924:15:
   clause 2(tableProperty*{tableProperty <- tableProperty*}) = $count_table_actions(tableProperty_t*{tableProperty_t <- tableProperty_t*})
      -- if tableProperty*{tableProperty <- tableProperty*} matches _ :: _
      -- let tableProperty_h :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty*{tableProperty <- tableProperty*}
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:7:1-7:73:
def $filter_default_parameters(parameterTypeIR*, id*) : parameterTypeIR* =

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:9:1-9:55:
   clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = []
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:10:1-16:28:
   clause 1(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = $filter_default_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}, id_default*{id_default <- id_default*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let _direction _typeIR id_h _value?{_value <- _value?} = parameterTypeIR_h
      -- if id_h <- id_default*{id_default <- id_default*}

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:17:1-22:15:
   clause 2(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = parameterTypeIR_h :: $filter_default_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}, id_default*{id_default <- id_default*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:26:1-26:71:
def $align_parameters(parameterTypeIR*, argumentIR*) : parameterTypeIR* =

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:29:1-32:90:
   clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}) = parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}
      -- (let _direction _typeIR id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
      -- (let parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?} = $align_parameters'({ id : parameterTypeIR*{id <- id*, parameterTypeIR <- parameterTypeIR*} }, parameterTypeIR, argumentIR))*{argumentIR <- argumentIR*, parameterTypeIR <- parameterTypeIR*, parameterTypeIR'? <- parameterTypeIR'?*}
      -- (if parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?} matches (_))*{parameterTypeIR'? <- parameterTypeIR'?*}
      -- (let ?(parameterTypeIR_aligned) = parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?})*{parameterTypeIR'? <- parameterTypeIR'?*, parameterTypeIR_aligned <- parameterTypeIR_aligned*}

;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:27:1-27:96:
def $align_parameters'(map<id, parameterTypeIR>, parameterTypeIR, argumentIR) : parameterTypeIR? =

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:34:1-35:20:
   clause 0(_map<id, parameterTypeIR>, parameterTypeIR, argumentIR) = ?(parameterTypeIR)
      -- if argumentIR <: typedExpressionIR
      -- let typedExpressionIR = argumentIR as typedExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:36:1-37:80:
   clause 1({ id_param : parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} }, _parameterTypeIR, argumentIR) = $find_map<id, parameterTypeIR>({ id_param : parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} }, nameIR)
      -- if argumentIR matches `%=%`
      -- let nameIR = _typedExpressionIR = argumentIR

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:38:1-39:80:
   clause 2({ id_param : parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} }, _parameterTypeIR, argumentIR) = $find_map<id, parameterTypeIR>({ id_param : parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} }, nameIR)
      -- if argumentIR matches `%=_`
      -- let nameIR =_ = argumentIR

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:40:1-41:20:
   clause 3(_map<id, parameterTypeIR>, parameterTypeIR, argumentIR) = ?(parameterTypeIR)
      -- if argumentIR matches `_`

;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:60:1-62:23:
relation Expr_lvalue_ok: cursor typingContext |- typedExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:64:1-67:45:
   rule referenceExpressionIR: p TC |- expressionIR # ( _typeIR _ctk )
      -- if expressionIR <: prefixedNameIR
      -- let prefixedNameIR = expressionIR as prefixedNameIR
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, TC, prefixedNameIR)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(direction _typeIR' ctk _value?{_value <- _value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if ctk matches `DYN`
      -- if ((direction = out) \/ (direction = inout))

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:69:1-79:68:
   rule accessExpressionIR-memberAccessExpressionIR-stack: p TC |- expressionIR # ( _typeIR _ctk )
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessBaseIR . nameIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessBaseIR <: typedExpressionIR
      -- let typedExpressionIR_base = memberAccessBaseIR as typedExpressionIR
      -- if Expr_lvalue_ok: p TC |- typedExpressionIR_base holds
      -- let _expressionIR # ( typeIR_base _ctk' ) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR
      -- if ((nameIR = "next") \/ (nameIR = "last"))
      -- if (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind)))

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:81:1-86:52:
   rule accessExpressionIR-memberAccessExpressionIR-non-stack: p TC |- expressionIR # ( _typeIR _ctk )
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessBaseIR . nameIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessBaseIR <: typedExpressionIR
      -- let typedExpressionIR_base = memberAccessBaseIR as typedExpressionIR
      -- if Expr_lvalue_ok: p TC |- typedExpressionIR_base holds
      -- let _expressionIR # ( typeIR_base _ctk' ) = typedExpressionIR_base
      -- if ~$is_headerStackTypeIR($canon(typeIR_base))

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:88:1-90:52:
   rule accessExpressionIR-indexAccessExpressionIR: p TC |- expressionIR # ( _typeIR _ctk )
      -- if expressionIR <: indexAccessExpressionIR
      -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
      -- if indexAccessExpressionIR matches `%[%]`
      -- let typedExpressionIR_base [ typedExpressionIR_index ] = indexAccessExpressionIR
      -- if Expr_lvalue_ok: p TC |- typedExpressionIR_base holds

   ;; ../../../../reference-specs/p4-concrete/5.15.1-typing-call-convention.spectec:92:1-95:52:
   rule accessExpressionIR-indexAccessExpressionIR-bitslice: p TC |- expressionIR # ( _typeIR _ctk )
      -- if expressionIR <: indexAccessExpressionIR
      -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
      -- if indexAccessExpressionIR matches `%[%:%]`
      -- let typedExpressionIR_base [ typedExpressionIR_hi : typedExpressionIR_lo ] = indexAccessExpressionIR
      -- if Expr_lvalue_ok: p TC |- typedExpressionIR_base holds

;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:6:1-7:12:
syntax infer = 
   | knownas typeIR
   | unknown

;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:9:21-9:36:
syntax constraint = map<tid, infer>

;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:11:1-11:41:
def $empty_constraint(tid*) : constraint =

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:12:1-12:53:
   clause 0(tid*{tid <- tid*}) = { tid : unknown*{tid <- tid*} }

;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:14:20-14:36:
syntax inference = map<tid, typeIR>

;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:20:1-20:60:
def $infer(tid*, parameterTypeIR*, argumentIR*) : inference =

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:44:1-52:61:
   clause 0(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}) = inference
      -- let constraint_init = $empty_constraint(tid_infer*{tid_infer <- tid_infer*})
      -- (let constraint_pair = $infer'(constraint_init, parameterTypeIR, argumentIR))*{argumentIR <- argumentIR*, constraint_pair <- constraint_pair*, parameterTypeIR <- parameterTypeIR*}
      -- let constraint_inferred = $merge_constraints(constraint_init, constraint_pair*{constraint_pair <- constraint_pair*})
      -- let inference = $resolve_constraint(constraint_inferred)

;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:21:1-21:66:
def $infer'(constraint, parameterTypeIR, argumentIR) : constraint =

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:54:1-57:51:
   clause 0(constraint, parameterTypeIR, argumentIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if argumentIR <: typedExpressionIR
      -- let typedExpressionIR = argumentIR as typedExpressionIR
      -- let _direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR
      -- let _expressionIR # ( typeIR_arg _ctk ) = typedExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:59:1-62:51:
   clause 1(constraint, parameterTypeIR, argumentIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if argumentIR matches `%=%`
      -- let nameIR = typedExpressionIR = argumentIR
      -- let _direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR
      -- let _expressionIR # ( typeIR_arg _ctk ) = typedExpressionIR

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:64:1-64:68:
   clause 2(constraint, parameterTypeIR, argumentIR) = constraint
      -- if argumentIR matches `%=_`
      -- let nameIR =_ = argumentIR

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:66:1-66:58:
   clause 3(constraint, parameterTypeIR, argumentIR) = constraint
      -- if argumentIR matches `_`

;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:23:1-23:66:
def $gen_constraint_type(constraint, typeIR, typeIR) : constraint =

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:74:1-76:66:
   clause 0(constraint, typeIR, typeIR_arg) = $update_map<tid, infer>(constraint, tid_param, knownas typeIR_arg)
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let tid tid_param = namedTypeIR
      -- if $in_set<tid>(tid_param, $dom_map<tid, infer>(constraint))

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:78:1-99:26:
   clause 1(constraint_0, typeIR, typeIR') = constraint_2
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR_param < typeIR_param*{typeIR_param <- typeIR_param*} > = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `%<%>`
      -- let polyTypeDefIR_arg < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR'
      -- let typeIR_specialized_param = $specialize_typeDef(polyTypeDefIR_param as typeDefIR, typeIR_param*{typeIR_param <- typeIR_param*})
      -- let typeIR_specialized_arg = $specialize_typeDef(polyTypeDefIR_arg as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if ($is_nominal_typeIR(typeIR_specialized_param) /\ $is_nominal_typeIR(typeIR_specialized_arg))
      -- let constraint_1 = $gen_constraint_type(constraint_0, typeIR_specialized_param, typeIR_specialized_arg)
      -- let constraint_2 = $gen_constraint_types(constraint_1, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:101:1-117:26:
   clause 2(constraint_0, typeIR, typeIR') = constraint_1
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR_param < typeIR_param*{typeIR_param <- typeIR_param*} > = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `%<%>`
      -- let polyTypeDefIR_arg < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR'
      -- let typeIR_specialized_param = $specialize_typeDef(polyTypeDefIR_param as typeDefIR, typeIR_param*{typeIR_param <- typeIR_param*})
      -- let typeIR_specialized_arg = $specialize_typeDef(polyTypeDefIR_arg as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if (~$is_nominal_typeIR(typeIR_specialized_param) /\ ~$is_nominal_typeIR(typeIR_specialized_arg))
      -- let constraint_1 = $gen_constraint_type(constraint_0, typeIR_specialized_param, typeIR_specialized_arg)

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:121:1-122:63:
   clause 3(constraint, typeIR, typeIR_arg) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let typedef _tid typeIR_param = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:124:1-125:63:
   clause 4(constraint, typeIR_param, typeIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let typedef _tid typeIR_arg = aliasTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:127:1-128:63:
   clause 5(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let type tid typeIR_param = aliasTypeIR
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR' = typeIR' as aliasTypeIR
      -- if aliasTypeIR' matches `TYPE%%`
      -- let type tid' typeIR_arg = aliasTypeIR'
      -- if (tid = tid')

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:132:1-137:63:
   clause 6(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: listTypeIR
      -- let list< typeIR_param > = typeIR as listTypeIR
      -- if typeIR' <: listTypeIR
      -- let list< typeIR_arg > = typeIR' as listTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:139:1-144:66:
   clause 7(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: tupleTypeIR
      -- let tuple< typeIR_param*{typeIR_param <- typeIR_param*} > = typeIR as tupleTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let tuple< typeIR_arg*{typeIR_arg <- typeIR_arg*} > = typeIR' as tupleTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:146:1-151:63:
   clause 8(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: headerStackTypeIR
      -- let typeIR_param [ n_size ] = typeIR as headerStackTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_arg [ n_size' ] = typeIR' as headerStackTypeIR
      -- if (n_size = n_size')

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:153:1-158:66:
   clause 9(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: structTypeIR
      -- let struct tid { typeIR_param id_field ;*{id_field <- id_field*, typeIR_param <- typeIR_param*} } = typeIR as structTypeIR
      -- if typeIR' <: structTypeIR
      -- let struct tid' { typeIR_arg id_field' ;*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*} } = typeIR' as structTypeIR
      -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
      -- if (tid = tid')

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:160:1-165:66:
   clause 10(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: headerTypeIR
      -- let header tid { typeIR_param id_field ;*{id_field <- id_field*, typeIR_param <- typeIR_param*} } = typeIR as headerTypeIR
      -- if typeIR' <: headerTypeIR
      -- let header tid' { typeIR_arg id_field' ;*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*} } = typeIR' as headerTypeIR
      -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
      -- if (tid = tid')

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:167:1-172:66:
   clause 11(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: headerUnionTypeIR
      -- let header_union tid { typeIR_param id_field ;*{id_field <- id_field*, typeIR_param <- typeIR_param*} } = typeIR as headerUnionTypeIR
      -- if typeIR' <: headerUnionTypeIR
      -- let header_union tid' { typeIR_arg id_field' ;*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*} } = typeIR' as headerUnionTypeIR
      -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
      -- if (tid = tid')

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:176:1-185:6:
   clause 12(constraint, typeIR, typeIR') = $gen_constraint_routines(constraint, routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}, routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*})
      -- if typeIR <: externObjectTypeIR
      -- let extern tid { rid : routineTypeDefIR_param*{rid <- rid*, routineTypeDefIR_param <- routineTypeDefIR_param*} } = typeIR as externObjectTypeIR
      -- if typeIR' <: externObjectTypeIR
      -- let extern tid' { rid' : routineTypeDefIR_arg*{rid' <- rid'*, routineTypeDefIR_arg <- routineTypeDefIR_arg*} } = typeIR' as externObjectTypeIR
      -- (if (rid = rid'))*{rid <- rid*, rid' <- rid'*}
      -- if (tid = tid')

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:187:1-194:58:
   clause 13(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: parserObjectTypeIR
      -- let parser( parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} ) = typeIR as parserObjectTypeIR
      -- if typeIR' <: parserObjectTypeIR
      -- let parser( parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} ) = typeIR' as parserObjectTypeIR
      -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
      -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
      -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:196:1-203:58:
   clause 14(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: controlObjectTypeIR
      -- let control( parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} ) = typeIR as controlObjectTypeIR
      -- if typeIR' <: controlObjectTypeIR
      -- let control( parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} ) = typeIR' as controlObjectTypeIR
      -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
      -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
      -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:205:1-210:66:
   clause 15(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: packageObjectTypeIR
      -- let package< typeIR_param*{typeIR_param <- typeIR_param*} > = typeIR as packageObjectTypeIR
      -- if typeIR' <: packageObjectTypeIR
      -- let package< typeIR_arg*{typeIR_arg <- typeIR_arg*} > = typeIR' as packageObjectTypeIR

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:214:1-216:15:
   clause 16(constraint, typeIR_param, typeIR_arg) = constraint
      -- otherwise

;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:24:1-24:69:
def $gen_constraint_types(constraint, typeIR*, typeIR*) : constraint =

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:220:1-223:69:
   clause 0(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = $merge_constraints(constraint, constraint_pair*{constraint_pair <- constraint_pair*})
      -- (let constraint_pair = $gen_constraint_type(constraint, typeIR_param, typeIR_arg))*{constraint_pair <- constraint_pair*, typeIR_arg <- typeIR_arg*, typeIR_param <- typeIR_param*}

;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:25:1-28:15:
def $gen_constraint_routine(constraint, routineTypeDefIR, routineTypeDefIR) : constraint =

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:227:1-238:77:
   clause 0(constraint_0, routineTypeDefIR, routineTypeDefIR') = constraint_2
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR < _tid*{_tid <- _tid*} , _tid'*{_tid' <- _tid'*} > = routineTypeDefIR as polyRoutineTypeDefIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let extern_method( parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} )-> typeIR_ret_param = methodTypeIR
      -- if routineTypeDefIR' <: polyRoutineTypeDefIR
      -- let routineTypeIR' < _tid''*{_tid'' <- _tid''*} , _tid'''*{_tid''' <- _tid'''*} > = routineTypeDefIR' as polyRoutineTypeDefIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `EXTERN_METHOD(%)->%`
      -- let extern_method( parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} )-> typeIR_ret_arg = methodTypeIR'
      -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
      -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
      -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}
      -- let constraint_1 = $gen_constraint_types(constraint_0, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- let constraint_2 = $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg)

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:240:1-251:77:
   clause 1(constraint_0, routineTypeDefIR, routineTypeDefIR') = constraint_2
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR < _tid*{_tid <- _tid*} , _tid'*{_tid' <- _tid'*} > = routineTypeDefIR as polyRoutineTypeDefIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let extern_methodabstract( parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} )-> typeIR_ret_param = methodTypeIR
      -- if routineTypeDefIR' <: polyRoutineTypeDefIR
      -- let routineTypeIR' < _tid''*{_tid'' <- _tid''*} , _tid'''*{_tid''' <- _tid'''*} > = routineTypeDefIR' as polyRoutineTypeDefIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `EXTERN_METHODABSTRACT(%)->%`
      -- let extern_methodabstract( parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} )-> typeIR_ret_arg = methodTypeIR'
      -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
      -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
      -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}
      -- let constraint_1 = $gen_constraint_types(constraint_0, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- let constraint_2 = $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg)

;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:29:1-32:15:
def $gen_constraint_routines(constraint, routineTypeDefIR*, routineTypeDefIR*) : constraint =

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:255:1-266:12:
   clause 0(constraint, routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}, routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*}) = $merge_constraints(constraint, constraint_pair*{constraint_pair <- constraint_pair*})
      -- (let constraint_pair = $gen_constraint_routine(constraint, routineTypeDefIR_param, routineTypeDefIR_arg))*{constraint_pair <- constraint_pair*, routineTypeDefIR_arg <- routineTypeDefIR_arg*, routineTypeDefIR_param <- routineTypeDefIR_param*}

;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:34:1-34:59:
def $merge_constraint(constraint, constraint) : constraint =

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:272:1-276:52:
   clause 0(constraint_pre, constraint_post) = $merge_constraint'(constraint_pre, constraint_post, tid_pre*{tid_pre <- tid_pre*}, { [] })
      -- let { tid_pre*{tid_pre <- tid_pre*} } = $dom_map<tid, infer>(constraint_pre)
      -- let { tid_post*{tid_post <- tid_post*} } = $dom_map<tid, infer>(constraint_post)
      -- if $eq_set<tid>({ tid_pre*{tid_pre <- tid_pre*} }, { tid_post*{tid_post <- tid_post*} })

;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:35:1-35:78:
def $merge_constraint'(constraint, constraint, tid*, constraint) : constraint =

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:278:1-281:15:
   clause 0(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = constraint
      -- if tid*{tid <- tid*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:283:1-292:60:
   clause 1(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- if (?(unknown) = $find_map<tid, infer>(constraint_pre, tid_h))
      -- if (?(unknown) = $find_map<tid, infer>(constraint_post, tid_h))
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, unknown)

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:294:1-303:73:
   clause 2(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- if (?(unknown) = $find_map<tid, infer>(constraint_pre, tid_h))
      -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_post, tid_h)
      -- if infer'?{infer' <- infer'?} matches (_)
      -- let ?(infer) = infer'?{infer' <- infer'?}
      -- if infer matches `KNOWNAS%`
      -- let knownas typeIR_post = infer
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, knownas typeIR_post)

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:305:1-314:72:
   clause 3(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
      -- if infer'?{infer' <- infer'?} matches (_)
      -- let ?(infer) = infer'?{infer' <- infer'?}
      -- if infer matches `KNOWNAS%`
      -- let knownas typeIR_pre = infer
      -- if (?(unknown) = $find_map<tid, infer>(constraint_post, tid_h))
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, knownas typeIR_pre)

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:316:1-326:73:
   clause 4(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
      -- if infer'?{infer' <- infer'?} matches (_)
      -- let ?(infer) = infer'?{infer' <- infer'?}
      -- if infer matches `KNOWNAS%`
      -- let knownas typeIR_pre = infer
      -- let infer'''?{infer''' <- infer'''?} = $find_map<tid, infer>(constraint_post, tid_h)
      -- if infer'''?{infer''' <- infer'''?} matches (_)
      -- let ?(infer'') = infer'''?{infer''' <- infer'''?}
      -- if infer'' matches `KNOWNAS%`
      -- let knownas typeIR_post = infer''
      -- if Sub_impl: typeIR_pre <: typeIR_post holds
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, knownas typeIR_post)

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:328:1-339:72:
   clause 5(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
      -- if infer'?{infer' <- infer'?} matches (_)
      -- let ?(infer) = infer'?{infer' <- infer'?}
      -- if infer matches `KNOWNAS%`
      -- let knownas typeIR_pre = infer
      -- let infer'''?{infer''' <- infer'''?} = $find_map<tid, infer>(constraint_post, tid_h)
      -- if infer'''?{infer''' <- infer'''?} matches (_)
      -- let ?(infer'') = infer'''?{infer''' <- infer'''?}
      -- if infer'' matches `KNOWNAS%`
      -- let knownas typeIR_post = infer''
      -- if ~Sub_impl: typeIR_pre <: typeIR_post holds
      -- if Sub_impl: typeIR_post <: typeIR_pre holds
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, knownas typeIR_pre)

;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:36:1-36:61:
def $merge_constraints(constraint, constraint*) : constraint =

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:341:1-341:61:
   clause 0(constraint_pre, constraint*{constraint <- constraint*}) = constraint_pre
      -- if constraint*{constraint <- constraint*} matches []

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:343:1-351:65:
   clause 1(constraint_pre_0, constraint*{constraint <- constraint*}) = constraint_pre_2
      -- if constraint*{constraint <- constraint*} matches _ :: _
      -- let constraint_post_h :: constraint_post_t*{constraint_post_t <- constraint_post_t*} = constraint*{constraint <- constraint*}
      -- let constraint_pre_1 = $merge_constraint(constraint_pre_0, constraint_post_h)
      -- let constraint_pre_2 = $merge_constraints(constraint_pre_1, constraint_post_t*{constraint_post_t <- constraint_post_t*})

;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:38:1-38:48:
def $resolve_constraint(constraint) : inference =

   ;; ../../../../reference-specs/p4-concrete/5.15.2-typing-call-inference.spectec:357:1-359:35:
   clause 0({ tid : infer*{infer <- infer*, tid <- tid*} }) = { tid : typeIR*{tid <- tid*, typeIR <- typeIR*} }
      -- (let infer' = infer)*{infer <- infer*, infer' <- infer'*}
      -- (if infer' matches `KNOWNAS%`)*{infer' <- infer'*}
      -- (let knownas typeIR = infer')*{infer' <- infer'*, typeIR <- typeIR*}

;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:21:1-21:65:
def $instantiable_extern(cursor, typingContext, instctxt) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:23:1-23:54:
   clause 0(cursor, TC, instctxt) = true
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:24:1-24:53:
   clause 1(cursor, TC, instctxt) = true
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:25:1-25:53:
   clause 2(cursor, TC, instctxt) = true
      -- if cursor matches `LOCAL`

;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:27:1-27:65:
def $instantiable_parser(cursor, typingContext, instctxt) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:29:1-30:20:
   clause 0(cursor, TC, instctxt) = (instctxt = anon)
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:31:1-32:40:
   clause 1(cursor, TC, instctxt) = $is_parser_blockKind(TC.block.kind)
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:33:1-34:46:
   clause 2(cursor, TC, instctxt) = $is_parser_state_localKind(TC.local.kind)
      -- if cursor matches `LOCAL`

;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:36:1-36:66:
def $instantiable_control(cursor, typingContext, instctxt) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:38:1-39:20:
   clause 0(cursor, TC, instctxt) = (instctxt = anon)
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:40:1-41:41:
   clause 1(cursor, TC, instctxt) = $is_control_blockKind(TC.block.kind)
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:42:1-43:54:
   clause 2(cursor, TC, instctxt) = $is_control_apply_method_localKind(TC.local.kind)
      -- if cursor matches `LOCAL`

;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:45:1-45:66:
def $instantiable_package(cursor, typingContext, instctxt) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:47:1-47:55:
   clause 0(cursor, TC, instctxt) = true
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:48:1-49:41:
   clause 1(cursor, TC, instctxt) = $is_package_blockKind(TC.block.kind)
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:50:1-50:55:
   clause 2(cursor, TC, instctxt) = false
      -- if cursor matches `LOCAL`

;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:52:1-52:64:
def $instantiable_table(cursor, typingContext, instctxt) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:54:1-54:54:
   clause 0(cursor, TC, instctxt) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:55:1-56:41:
   clause 1(cursor, TC, instctxt) = $is_control_blockKind(TC.block.kind)
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:57:1-57:53:
   clause 2(cursor, TC, instctxt) = false
      -- if cursor matches `LOCAL`

;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:59:1-59:66:
def $instantiable(cursor, typingContext, instctxt, typeIR) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:61:1-63:49:
   clause 0(p, TC, instctxt, typeIR) = $instantiable_extern(p, TC, instctxt)
      -- if $is_extern_object_typeIR($canon(typeIR))

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:64:1-66:49:
   clause 1(p, TC, instctxt, typeIR) = $instantiable_parser(p, TC, instctxt)
      -- if $is_parser_object_typeIR($canon(typeIR))

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:67:1-69:50:
   clause 2(p, TC, instctxt, typeIR) = $instantiable_control(p, TC, instctxt)
      -- if $is_control_object_typeIR($canon(typeIR))

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:70:1-72:50:
   clause 3(p, TC, instctxt, typeIR) = $instantiable_package(p, TC, instctxt)
      -- if $is_package_object_typeIR($canon(typeIR))

   ;; ../../../../reference-specs/p4-concrete/5.15.3-typing-constructor-call.spectec:73:1-75:48:
   clause 4(p, TC, instctxt, typeIR) = $instantiable_table(p, TC, instctxt)
      -- if $is_table_object_typeIR($canon(typeIR))

;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:55:1-55:33:
def $lvalue(lvalue) : expression =

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:56:1-56:55:
   clause 0(lvalue) = referenceExpression as expression
      -- if lvalue <: referenceExpression
      -- let referenceExpression = lvalue as referenceExpression

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:57:1-59:47:
   clause 1(lvalue) = expression_base as memberAccessBase . member as expression
      -- if lvalue matches `%.%`
      -- let lvalue_base . member = lvalue
      -- let expression_base = $lvalue(lvalue_base)

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:60:1-62:47:
   clause 2(lvalue) = expression_base [ expression_index ] as expression
      -- if lvalue matches `%[%]`
      -- let lvalue_base [ expression_index ] = lvalue
      -- let expression_base = $lvalue(lvalue_base)

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:63:1-65:47:
   clause 3(lvalue) = expression_base [ expression_hi : expression_lo ] as expression
      -- if lvalue matches `%[%:%]`
      -- let lvalue_base [ expression_hi : expression_lo ] = lvalue
      -- let expression_base = $lvalue(lvalue_base)

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:66:1-67:37:
   clause 4(lvalue') = ( expression ) as expression
      -- if lvalue' matches `(%)`
      -- let ( lvalue ) = lvalue'
      -- let expression = $lvalue(lvalue)

;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:239:1-239:61:
def $callable_builtin_function(cursor, typingContext) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:241:1-241:50:
   clause 0(cursor, TC) = true
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:242:1-242:49:
   clause 1(cursor, TC) = true
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:243:1-243:49:
   clause 2(cursor, TC) = true
      -- if cursor matches `LOCAL`

;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:266:1-266:53:
def $callable_function(cursor, typingContext) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:268:1-268:43:
   clause 0(cursor, TC) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:269:1-271:44:
   clause 1(cursor, TC) = ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:272:1-274:60:
   clause 2(cursor, TC) = (~$is_extern_method_localKind(TC.local.kind) /\ ~$is_extern_abstract_method_localKind(TC.local.kind))
      -- if cursor matches `LOCAL`

;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:310:1-310:60:
def $callable_extern_function(cursor, typingContext) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:312:1-312:50:
   clause 0(cursor, TC) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:313:1-315:44:
   clause 1(cursor, TC) = ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:316:1-316:48:
   clause 2(cursor, TC) = true
      -- if cursor matches `LOCAL`

;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:352:1-352:51:
def $callable_action(cursor, typingContext) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:354:1-354:41:
   clause 0(cursor, TC) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:355:1-355:40:
   clause 1(cursor, TC) = false
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:356:1-358:57:
   clause 2(cursor, TC) = ($is_action_localKind(TC.local.kind) \/ $is_control_apply_method_localKind(TC.local.kind))
      -- if cursor matches `LOCAL`

;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:383:1-383:59:
def $callable_builtin_method(cursor, typingContext) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:385:1-385:48:
   clause 0(cursor, TC) = true
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:386:1-386:47:
   clause 1(cursor, TC) = true
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:387:1-387:47:
   clause 2(cursor, TC) = true
      -- if cursor matches `LOCAL`

;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:410:1-410:58:
def $callable_extern_method(cursor, typingContext) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:412:1-412:48:
   clause 0(cursor, TC) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:413:1-415:44:
   clause 1(cursor, TC) = ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:416:1-416:46:
   clause 2(cursor, TC) = true
      -- if cursor matches `LOCAL`

;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:452:1-452:67:
def $callable_extern_abstract_method(cursor, typingContext) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:454:1-454:57:
   clause 0(cursor, TC) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:455:1-457:44:
   clause 1(cursor, TC) = ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:458:1-458:55:
   clause 2(cursor, TC) = true
      -- if cursor matches `LOCAL`

;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:494:1-494:64:
def $callable_parser_apply_method(cursor, typingContext) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:496:1-496:54:
   clause 0(cursor, TC) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:497:1-497:53:
   clause 1(cursor, TC) = false
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:498:1-499:46:
   clause 2(cursor, TC) = $is_parser_state_localKind(TC.local.kind)
      -- if cursor matches `LOCAL`

;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:522:1-522:65:
def $callable_control_apply_method(cursor, typingContext) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:524:1-524:55:
   clause 0(cursor, TC) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:525:1-525:54:
   clause 1(cursor, TC) = false
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:526:1-527:54:
   clause 2(cursor, TC) = $is_control_apply_method_localKind(TC.local.kind)
      -- if cursor matches `LOCAL`

;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:550:1-550:63:
def $callable_table_apply_method(cursor, typingContext) : bool =

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:552:1-552:53:
   clause 0(cursor, TC) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:553:1-553:52:
   clause 1(cursor, TC) = false
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/5.15.4-typing-routine-call.spectec:554:1-556:55:
   clause 2(cursor, TC) = ($is_control_apply_method_localKind(TC.local.kind) \/ $is_table_apply_method_localKind(TC.local.kind))
      -- if cursor matches `LOCAL`

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:5:1-5:27:
def $empty_theta : theta =

   ;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:6:1-6:47:
   clause 0 = $empty_map<tid, typeIR>

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:9:15-9:29:
syntax venv = map<id, value>

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:11:1-11:25:
def $empty_venv : venv =

   ;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:12:1-12:42:
   clause 0 = $empty_map<id, value>

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:15:19-15:41:
syntax stateDyn = parserBlockStatementIR

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:18:15-18:36:
syntax senv = map<nameIR, stateDyn>

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:20:1-20:25:
def $empty_senv : senv =

   ;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:21:1-21:49:
   clause 0 = $empty_map<nameIR, stateDyn>

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:28:1-31:34:
syntax lvalueDyn = 
   | ` nameIR
   | . nameIR
   | lvalueDyn . nameIR
   | lvalueDyn [ value ]
   | lvalueDyn [ value : value ]

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:40:1-43:96:
syntax funcDyn = 
   | builtin_function< typeParameterListIR >( parameterListIR ){ blockElementStatementListIR }
   | function< typeParameterListIR >( parameterListIR ) blockStatementIR
   | action( parameterListIR ){ blockStatementIR }
   | extern_function< typeParameterListIR >( parameterListIR ){ blockElementStatementIR? }

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:46:1-51:41:
syntax methodDyn = 
   | builtin_method( parameterListIR )# lvalueDyn
   | extern_method< typeParameterListIR >( parameterListIR ) blockStatementIR?
   | extern_methodabstract< typeParameterListIR >( parameterListIR )
   | parser_apply( parameterListIR ){ parserLocalDeclarationListIR ; senv }
   | control_apply( parameterListIR ){ controlLocalDeclarationListIR ; renv ; blockElementStatementListIR }
   | table_apply{ tablePropertyListIR }

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:54:1-55:14:
syntax routineDyn = 
   | builtin_function< typeParameterListIR >( parameterListIR ){ blockElementStatementListIR }
   | function< typeParameterListIR >( parameterListIR ) blockStatementIR
   | action( parameterListIR ){ blockStatementIR }
   | extern_function< typeParameterListIR >( parameterListIR ){ blockElementStatementIR? }
   | builtin_method( parameterListIR )# lvalueDyn
   | extern_method< typeParameterListIR >( parameterListIR ) blockStatementIR?
   | extern_methodabstract< typeParameterListIR >( parameterListIR )
   | parser_apply( parameterListIR ){ parserLocalDeclarationListIR ; senv }
   | control_apply( parameterListIR ){ controlLocalDeclarationListIR ; renv ; blockElementStatementListIR }
   | table_apply{ tablePropertyListIR }

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:58:15-58:35:
syntax renv = map<rid, routineDyn>

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:60:1-60:25:
def $empty_renv : renv =

   ;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:61:1-61:48:
   clause 0 = $empty_map<rid, routineDyn>

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:68:1-72:42:
syntax consDyn = 
   | extern nameIR < typeParameterListIR >( constructorParameterListIR ){ methodPrototypeListIR }
   | parser< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }
   | control< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }
   | package< typeParameterListIR >( constructorParameterListIR )
   | table nameIR { tablePropertyListIR }

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:75:15-75:32:
syntax cenv = map<cid, consDyn>

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:77:1-77:25:
def $empty_cenv : cenv =

   ;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:78:1-78:45:
   clause 0 = $empty_map<cid, consDyn>

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:85:1-89:44:
syntax objDyn = 
   | extern{ tid theta venv renv }
   | parser{ venv parameterListIR parserLocalDeclarationListIR senv }
   | control{ venv parameterListIR controlLocalDeclarationListIR renv controlBodyIR }
   | package{ theta venv }
   | table{ tid venv tablePropertyListIR }

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:92:14-92:30:
syntax sto = map<oid, objDyn>

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:94:1-94:23:
def $empty_sto : sto =

   ;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:96:1-96:43:
   clause 0 = $empty_map<oid, objDyn>

;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:98:1-98:37:
def $add_sto(sto, oid, objDyn) : sto =

   ;; ../../../../reference-specs/p4-concrete/6.01-env-dynamic.spectec:100:1-101:44:
   clause 0(sto, oid, objDyn) = $add_map<oid, objDyn>(sto, oid, objDyn)

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:8:3-11:16:
syntax globalInstantiationLayer = {cenv cenv, tdenv tdenv, renv renv, venv venv}

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:16:3-19:16:
syntax blockInstantiationLayer = {theta theta, renv renv, senv senv, venv venv}

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:24:3-25:18:
syntax localInstantiationLayer = {theta theta, venvs venv*}

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:32:3-35:36:
syntax contextInst = {path oid, global globalInstantiationLayer, block blockInstantiationLayer, local localInstantiationLayer}

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:43:1-43:45:
def $empty_block : blockInstantiationLayer =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:45:1-49:23:
   clause 0 = {theta $empty_theta, renv $empty_renv, senv $empty_senv, venv $empty_venv}

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:51:1-51:45:
def $empty_local : localInstantiationLayer =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:53:1-55:17:
   clause 0 = {theta $empty_theta, venvs []}

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:57:1-57:40:
def $empty_context_inst : contextInst =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:59:1-71:11:
   clause 0 = Ci
      -- let globalInstantiationLayer = {cenv $empty_cenv, tdenv $empty_tdenv, renv $empty_renv, venv $empty_venv}
      -- let blockInstantiationLayer = $empty_block
      -- let localInstantiationLayer = $empty_local
      -- let Ci = {path [], global globalInstantiationLayer, block blockInstantiationLayer, local localInstantiationLayer}

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:78:1-78:43:
def $enter_inst(contextInst) : contextInst =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:80:1-80:73:
   clause 0(Ci) = Ci[local.venvs = $empty_venv :: Ci.local.venvs]

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:82:1-82:42:
def $exit_inst(contextInst) : contextInst =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:84:1-85:43:
   clause 0(Ci) = Ci[local.venvs = venv_t*{venv_t <- venv_t*}]
      -- let venv*{venv <- venv*} = Ci.local.venvs
      -- if venv*{venv <- venv*} matches _ :: _
      -- let venv_h :: venv_t*{venv_t <- venv_t*} = venv*{venv <- venv*}

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:91:1-91:47:
def $enter_path(contextInst, id) : contextInst =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:93:1-93:54:
   clause 0(Ci, id) = Ci[path = Ci.path ++ [id]]

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:99:1-99:58:
def $copy_context_inst(cursor, contextInst) : contextInst =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:101:1-101:90:
   clause 0(cursor, Ci) = Ci[block = $empty_block][local = $empty_local]
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:102:1-102:64:
   clause 1(cursor, Ci) = Ci[local = $empty_local]
      -- if cursor matches `BLOCK`

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:103:1-103:39:
   clause 2(cursor, Ci) = Ci
      -- if cursor matches `LOCAL`

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:111:1-111:65:
def $add_value_inst(cursor, contextInst, id, value) : contextInst =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:114:1-116:62:
   clause 0(cursor, Ci, id, value) = Ci[global.venv = venv]
      -- if cursor matches `GLOBAL`
      -- if ~$in_set<id>(id, $dom_map<id, value>(Ci.global.venv))
      -- let venv = $add_map<id, value>(Ci.global.venv, id, value)

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:117:1-119:61:
   clause 1(cursor, Ci, id, value) = Ci[block.venv = venv]
      -- if cursor matches `BLOCK`
      -- if ~$in_set<id>(id, $dom_map<id, value>(Ci.block.venv))
      -- let venv = $add_map<id, value>(Ci.block.venv, id, value)

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:120:1-123:57:
   clause 2(cursor, Ci, id, value) = Ci[local.venvs = venv_h' :: venv_t*{venv_t <- venv_t*}]
      -- if cursor matches `LOCAL`
      -- let venv*{venv <- venv*} = Ci.local.venvs
      -- if venv*{venv <- venv*} matches _ :: _
      -- let venv_h :: venv_t*{venv_t <- venv_t*} = venv*{venv <- venv*}
      -- if ~$in_set<id>(id, $dom_map<id, value>(venv_h))
      -- let venv_h' = $add_map<id, value>(venv_h, id, value)

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:112:1-112:68:
def $add_values_inst(cursor, contextInst, id*, value*) : contextInst =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:125:1-125:43:
   clause 0(p, Ci, id*{id <- id*}, value*{value <- value*}) = Ci
      -- if id*{id <- id*} matches []
      -- if value*{value <- value*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:126:1-128:57:
   clause 1(p, Ci, id*{id <- id*}, value*{value <- value*}) = Ci''
      -- if id*{id <- id*} matches _ :: _
      -- let id_h :: id_t*{id_t <- id_t*} = id*{id <- id*}
      -- if value*{value <- value*} matches _ :: _
      -- let value_h :: value_t*{value_t <- value_t*} = value*{value <- value*}
      -- let Ci' = $add_value_inst(p, Ci, id_h, value_h)
      -- let Ci'' = $add_values_inst(p, Ci', id_t*{id_t <- id_t*}, value_t*{value_t <- value_t*})

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:132:1-132:73:
def $add_typedef_inst(cursor, contextInst, tid, typeDefIR) : contextInst =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:134:1-135:74:
   clause 0(cursor, Ci, tid, typeDefIR) = Ci[global.tdenv = tdenv]
      -- if cursor matches `GLOBAL`
      -- let tdenv = $add_map<tid, typeDefIR>(Ci.global.tdenv, tid, typeDefIR)

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:139:1-139:73:
def $add_state_inst(cursor, contextInst, nameIR, stateDyn) : contextInst =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:141:1-143:75:
   clause 0(cursor, Ci, nameIR, stateDyn) = Ci[block.senv = senv]
      -- if cursor matches `BLOCK`
      -- if ~$in_set<nameIR>(nameIR, $dom_map<nameIR, stateDyn>(Ci.block.senv))
      -- let senv = $add_map<nameIR, stateDyn>(Ci.block.senv, nameIR, stateDyn)

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:147:1-147:70:
def $add_types_inst(cursor, contextInst, tid*, typeIR*) : contextInst =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:150:1-150:42:
   clause 0(p, Ci, tid*{tid <- tid*}, typeIR*{typeIR <- typeIR*}) = Ci
      -- if tid*{tid <- tid*} matches []
      -- if typeIR*{typeIR <- typeIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:151:1-153:53:
   clause 1(p, Ci, tid*{tid <- tid*}, typeIR*{typeIR <- typeIR*}) = $add_types_inst(p, Ci', tid_t*{tid_t <- tid_t*}, typeIR_t*{typeIR_t <- typeIR_t*})
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- if typeIR*{typeIR <- typeIR*} matches _ :: _
      -- let typeIR_h :: typeIR_t*{typeIR_t <- typeIR_t*} = typeIR*{typeIR <- typeIR*}
      -- let Ci' = $add_type_inst(p, Ci, tid_h, typeIR_h)

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:148:1-148:67:
def $add_type_inst(cursor, contextInst, tid, typeIR) : contextInst =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:155:1-156:67:
   clause 0(cursor, Ci, tid, typeIR) = Ci[block.theta = theta]
      -- if cursor matches `BLOCK`
      -- let theta = $add_map<tid, typeIR>(Ci.block.theta, tid, typeIR)

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:157:1-158:67:
   clause 1(cursor, Ci, tid, typeIR) = Ci[local.theta = theta]
      -- if cursor matches `LOCAL`
      -- let theta = $add_map<tid, typeIR>(Ci.local.theta, tid, typeIR)

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:162:1-162:83:
def $add_routine_overload_inst(cursor, contextInst, rid, routineDyn) : contextInst =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:164:1-166:74:
   clause 0(cursor, Ci, rid, routineDyn) = Ci[global.renv = renv]
      -- if cursor matches `GLOBAL`
      -- if ~$in_set<rid>(rid, $dom_map<rid, routineDyn>(Ci.global.renv))
      -- let renv = $add_map<rid, routineDyn>(Ci.global.renv, rid, routineDyn)

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:167:1-169:73:
   clause 1(cursor, Ci, rid, routineDyn) = Ci[block.renv = renv]
      -- if cursor matches `BLOCK`
      -- if ~$in_set<rid>(rid, $dom_map<rid, routineDyn>(Ci.block.renv))
      -- let renv = $add_map<rid, routineDyn>(Ci.block.renv, rid, routineDyn)

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:171:1-171:87:
def $add_routine_non_overload_inst(cursor, contextInst, rid, routineDyn) : contextInst =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:173:1-177:74:
   clause 0(cursor, Ci, rid, routineDyn) = Ci[global.renv = renv]
      -- if cursor matches `GLOBAL`
      -- let id ( _pid*{_pid <- _pid*} ) = rid
      -- let { id_k ( _pid'*{_pid' <- _pid'*} )*{_pid'* <- _pid'**, id_k <- id_k*} } = $dom_map<rid, routineDyn>(Ci.global.renv)
      -- if ~$in_set<id>(id, { id_k*{id_k <- id_k*} })
      -- let renv = $add_map<rid, routineDyn>(Ci.global.renv, rid, routineDyn)

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:178:1-182:73:
   clause 1(cursor, Ci, rid, routineDyn) = Ci[block.renv = renv]
      -- if cursor matches `BLOCK`
      -- let id ( _pid*{_pid <- _pid*} ) = rid
      -- let { id_k ( _pid'*{_pid' <- _pid'*} )*{_pid'* <- _pid'**, id_k <- id_k*} } = $dom_map<rid, routineDyn>(Ci.block.renv)
      -- if ~$in_set<id>(id, { id_k*{id_k <- id_k*} })
      -- let renv = $add_map<rid, routineDyn>(Ci.block.renv, rid, routineDyn)

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:186:1-186:75:
def $add_constructor_inst(cursor, contextInst, cid, consDyn) : contextInst =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:188:1-189:68:
   clause 0(cursor, Ci, cid, consDyn) = Ci[global.cenv = cenv]
      -- if cursor matches `GLOBAL`
      -- let cenv = $add_map<cid, consDyn>(Ci.global.cenv, cid, consDyn)

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:197:1-197:66:
def $find_value_inst(cursor, contextInst, prefixedNameIR) : value =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:199:1-200:57:
   clause 0(p, Ci, prefixedNameIR) = value
      -- if prefixedNameIR matches `.%`
      -- let . id = prefixedNameIR
      -- let value'?{value' <- value'?} = $find_map<id, value>(Ci.global.venv, id)
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:201:1-202:57:
   clause 1(cursor, Ci, prefixedNameIR) = value
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let value'?{value' <- value'?} = $find_map<id, value>(Ci.global.venv, id)
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:203:1-204:56:
   clause 2(cursor, Ci, prefixedNameIR) = value
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let value'?{value' <- value'?} = $find_map<id, value>(Ci.block.venv, id)
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:205:1-208:54:
   clause 3(cursor, Ci, prefixedNameIR) = $find_value_inst(global, Ci, ` id)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- if ($find_map<id, value>(Ci.block.venv, id) = ?())

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:209:1-211:49:
   clause 4(cursor, Ci, prefixedNameIR) = value
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let venv*{venv <- venv*} = Ci.local.venvs
      -- let value'?{value' <- value'?} = $find_maps<id, value>(venv*{venv <- venv*}, id)
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:212:1-215:56:
   clause 5(cursor, Ci, prefixedNameIR) = $find_value_inst(block, Ci, ` id)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- if ($find_maps<id, value>(Ci.local.venvs, id) = ?())

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:219:1-219:73:
def $find_typedef_inst(cursor, contextInst, prefixedNameIR) : typeDefIR? =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:221:1-222:55:
   clause 0(_cursor, Ci, prefixedNameIR) = $find_map<tid, typeDefIR>(Ci.global.tdenv, nameIR)
      -- if prefixedNameIR matches ``%`
      -- let ` nameIR = prefixedNameIR

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:223:1-224:55:
   clause 1(_cursor, Ci, prefixedNameIR) = $find_map<tid, typeDefIR>(Ci.global.tdenv, nameIR)
      -- if prefixedNameIR matches `.%`
      -- let . nameIR = prefixedNameIR

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:228:1-228:44:
def $ids_arguments_IR(argumentIR*) : id?* =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:231:1-231:68:
   clause 0(argumentIR*{argumentIR <- argumentIR*}) = $id_argument_IR(argumentIR)*{argumentIR <- argumentIR*}

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:229:1-229:38:
def $id_argument_IR(argumentIR) : id? =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:232:1-232:45:
   clause 0(argumentIR) = ?()
      -- if argumentIR <: typedExpressionIR
      -- let typedExpressionIR = argumentIR as typedExpressionIR

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:233:1-233:42:
   clause 1(argumentIR) = ?(nameIR)
      -- if argumentIR matches `%=%`
      -- let nameIR = _typedExpressionIR = argumentIR

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:234:1-234:43:
   clause 2(argumentIR) = ?(nameIR)
      -- if argumentIR matches `%=_`
      -- let nameIR =_ = argumentIR

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:235:1-235:30:
   clause 3(argumentIR) = ?()
      -- if argumentIR matches `_`

;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:237:1-237:103:
def $find_constructor_overloaded_inst(contextInst, prefixedNameIR, argumentIR*) : (cid, consDyn, id*)? =

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:239:1-241:52:
   clause 0(Ci, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<consDyn>(Ci.global.cenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if prefixedNameIR matches ``%`
      -- let ` id = prefixedNameIR
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments_IR(argumentIR*{argumentIR <- argumentIR*})

   ;; ../../../../reference-specs/p4-concrete/6.02-context-instantiation.spectec:242:1-244:52:
   clause 1(Ci, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<consDyn>(Ci.global.cenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if prefixedNameIR matches `.%`
      -- let . id = prefixedNameIR
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments_IR(argumentIR*{argumentIR <- argumentIR*})

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:6:1-8:35:
relation Constructor_inst: cursor contextInst sto |- consDyn < typeArgumentListIR >( argumentListIR # id* )==> sto objDyn

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:89:1-110:15:
   rule extern: p Ci sto_0 |- consDyn < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} )==> sto_1 objDyn
      -- if consDyn matches `EXTERN%<%>(%){%}`
      -- let extern nameIR < typeParameterIR*{typeParameterIR <- typeParameterIR*} >( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ){ methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} } = consDyn
      -- let p_callee = block
      -- let Ci_callee_0 = $copy_context_inst(global, Ci)
      -- let Ci_callee_1 = $add_types_inst(p_callee, Ci_callee_0, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
      -- (let _annotationList _direction _typeIR id_aligned _constantInitializerOptIR = constructorParameterIR_aligned)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_aligned <- constructorParameterIR_aligned*, id_aligned <- id_aligned*}
      -- Bind_args: p Ci ; p_callee Ci_callee_1 sto_0 |- id_aligned*{id_aligned <- id_aligned*} argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*} ==> Ci_callee_2 sto_1
      -- (let _annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR' = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR' <- _constantInitializerOptIR'*, _direction' <- _direction'*, _typeIR' <- _typeIR'*, constructorParameterIR_default <- constructorParameterIR_default*, id_cparam_default <- id_cparam_default*}
      -- let Ci_callee_3 = $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*{id_cparam_default <- id_cparam_default*}, value_default*{value_default <- value_default*})
      -- ExternMethods_inst: Ci_callee_3 |- methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} ==> Ci_callee_4
      -- let objDyn = extern{ nameIR Ci_callee_4.block.theta Ci_callee_4.block.venv Ci_callee_4.block.renv }

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:114:1-141:15:
   rule parser: p Ci sto_0 |- consDyn < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} )==> sto_3 objDyn
      -- if consDyn matches `PARSER<%>(%)(%){%%}`
      -- let parser< typeParameterIR*{typeParameterIR <- typeParameterIR*} >( parameterIR*{parameterIR <- parameterIR*} )( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ){ parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} parserStateIR*{parserStateIR <- parserStateIR*} } = consDyn
      -- let p_callee = block
      -- let Ci_callee_0 = $copy_context_inst(global, Ci)
      -- let Ci_callee_1 = $add_types_inst(p_callee, Ci_callee_0, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
      -- (let _annotationList _direction _typeIR id_aligned _constantInitializerOptIR = constructorParameterIR_aligned)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_aligned <- constructorParameterIR_aligned*, id_aligned <- id_aligned*}
      -- Bind_args: p Ci ; p_callee Ci_callee_1 sto_0 |- id_aligned*{id_aligned <- id_aligned*} argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*} ==> Ci_callee_2 sto_1
      -- (let _annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR' = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR' <- _constantInitializerOptIR'*, _direction' <- _direction'*, _typeIR' <- _typeIR'*, constructorParameterIR_default <- constructorParameterIR_default*, id_cparam_default <- id_cparam_default*}
      -- let Ci_callee_3 = $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*{id_cparam_default <- id_cparam_default*}, value_default*{value_default <- value_default*})
      -- ParserLocalDecls_inst: Ci_callee_3 sto_1 |- parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} ==> Ci_local sto_2 parserLocalDeclarationIR_inst*{parserLocalDeclarationIR_inst <- parserLocalDeclarationIR_inst*}
      -- let stateDyn_empty = { [] }
      -- let Ci_local_1 = $add_state_inst(block, Ci_local, "accept", stateDyn_empty)
      -- let Ci_local_2 = $add_state_inst(block, Ci_local_1, "reject", stateDyn_empty)
      -- ParserStates_inst: Ci_local_2 sto_2 |- parserStateIR*{parserStateIR <- parserStateIR*} ==> Ci_state sto_3
      -- let objDyn = parser{ Ci_callee_3.block.venv parameterIR*{parameterIR <- parameterIR*} parserLocalDeclarationIR_inst*{parserLocalDeclarationIR_inst <- parserLocalDeclarationIR_inst*} Ci_state.block.senv }

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:145:1-170:15:
   rule control: p Ci sto_0 |- consDyn < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} )==> sto_3 objDyn
      -- if consDyn matches `CONTROL<%>(%)(%){%APPLY%}`
      -- let control< typeParameterIR*{typeParameterIR <- typeParameterIR*} >( parameterIR*{parameterIR <- parameterIR*} )( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ){ controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} apply controlBodyIR } = consDyn
      -- let p_callee = block
      -- let Ci_callee_0 = $copy_context_inst(global, Ci)
      -- let Ci_callee_1 = $add_types_inst(p_callee, Ci_callee_0, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
      -- (let _annotationList _direction _typeIR id_aligned _constantInitializerOptIR = constructorParameterIR_aligned)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_aligned <- constructorParameterIR_aligned*, id_aligned <- id_aligned*}
      -- Bind_args: p Ci ; p_callee Ci_callee_1 sto_0 |- id_aligned*{id_aligned <- id_aligned*} argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*} ==> Ci_callee_2 sto_1
      -- (let _annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR' = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR' <- _constantInitializerOptIR'*, _direction' <- _direction'*, _typeIR' <- _typeIR'*, constructorParameterIR_default <- constructorParameterIR_default*, id_cparam_default <- id_cparam_default*}
      -- let Ci_callee_3 = $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*{id_cparam_default <- id_cparam_default*}, value_default*{value_default <- value_default*})
      -- ControlLocalDecls_inst: Ci_callee_3 sto_1 |- controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} ==> Ci_local sto_2 controlLocalDeclarationIR'*{controlLocalDeclarationIR' <- controlLocalDeclarationIR'*}
      -- Block_inst: local Ci_local sto_2 |- controlBodyIR ==> _contextInst sto_3 controlBodyIR'
      -- let objDyn = control{ Ci_callee_3.block.venv parameterIR*{parameterIR <- parameterIR*} controlLocalDeclarationIR'*{controlLocalDeclarationIR' <- controlLocalDeclarationIR'*} Ci_local.block.renv controlBodyIR' }

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:174:1-193:15:
   rule package: p Ci sto_0 |- consDyn < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} )==> sto_1 objDyn
      -- if consDyn matches `PACKAGE<%>(%)`
      -- let package< typeParameterIR*{typeParameterIR <- typeParameterIR*} >( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ) = consDyn
      -- let p_callee = block
      -- let Ci_callee_0 = $copy_context_inst(global, Ci)
      -- let Ci_callee_1 = $add_types_inst(p_callee, Ci_callee_0, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
      -- (let _annotationList _direction _typeIR id_aligned _constantInitializerOptIR = constructorParameterIR_aligned)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_aligned <- constructorParameterIR_aligned*, id_aligned <- id_aligned*}
      -- Bind_args: p Ci ; p_callee Ci_callee_1 sto_0 |- id_aligned*{id_aligned <- id_aligned*} argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*} ==> Ci_callee_2 sto_1
      -- (let _annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR' = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR' <- _constantInitializerOptIR'*, _direction' <- _direction'*, _typeIR' <- _typeIR'*, constructorParameterIR_default <- constructorParameterIR_default*, id_cparam_default <- id_cparam_default*}
      -- let Ci_callee_3 = $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*{id_cparam_default <- id_cparam_default*}, value_default*{value_default <- value_default*})
      -- let objDyn = package{ Ci_callee_3.block.theta Ci_callee_3.block.venv }

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:202:1-227:15:
   rule table: p Ci sto |- consDyn < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} )==> sto_2 objDyn
      -- if consDyn matches `TABLE%{%}`
      -- let table nameIR { tablePropertyListIR } = consDyn
      -- let p_callee = local
      -- let Ci_callee_0 = $copy_context_inst(block, Ci)
      -- let Ci_callee_1 = $add_types_inst(p_callee, Ci_callee_0, [], typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args([], argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
      -- (let _annotationList _direction _typeIR id_aligned _constantInitializerOptIR = constructorParameterIR_aligned)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_aligned <- constructorParameterIR_aligned*, id_aligned <- id_aligned*}
      -- Bind_args: p Ci ; p_callee Ci_callee_1 sto |- id_aligned*{id_aligned <- id_aligned*} argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*} ==> Ci_callee_2 sto_1
      -- (let _annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR' = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR' <- _constantInitializerOptIR'*, _direction' <- _direction'*, _typeIR' <- _typeIR'*, constructorParameterIR_default <- constructorParameterIR_default*, id_cparam_default <- id_cparam_default*}
      -- let Ci_callee_3 = $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*{id_cparam_default <- id_cparam_default*}, value_default*{value_default <- value_default*})
      -- let Ci_frame = $enter_inst(Ci_callee_3)
      -- TableProperties_inst: Ci_frame sto_1 |- tablePropertyListIR ==> Ci_table sto_2 tablePropertyListIR_inst
      -- let tablePropertyListIR_dynamic = $init_table(tablePropertyListIR_inst)
      -- let venv'*{venv' <- venv'*} = Ci_table.local.venvs
      -- if venv'*{venv' <- venv'*} matches _ :: _
      -- let venv :: _venv*{_venv <- _venv*} = venv'*{venv' <- venv'*}
      -- let objDyn = table{ nameIR venv tablePropertyListIR_dynamic }

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:16:1-18:35:
relation Bind_args: cursor contextInst ; cursor contextInst sto |- id* argumentIR* ==> contextInst sto

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:76:1-77:75:
   rule nil: p_caller Ci_caller ; p_callee Ci_callee sto |- id*{id <- id*} argumentIR*{argumentIR <- argumentIR*} ==> Ci_callee sto
      -- if id*{id <- id*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:79:1-83:109:
   rule cons: p_caller Ci_caller ; p_callee Ci_callee_0 sto_0 |- id*{id <- id*} argumentIR*{argumentIR <- argumentIR*} ==> Ci_callee_2 sto_2
      -- if id*{id <- id*} matches _ :: _
      -- let id_h :: id_t*{id_t <- id_t*} = id*{id <- id*}
      -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
      -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
      -- Bind_arg: p_caller Ci_caller ; p_callee Ci_callee_0 sto_0 |- id_h argumentIR_h ==> Ci_callee_1 sto_1
      -- Bind_args: p_caller Ci_caller ; p_callee Ci_callee_1 sto_1 |- id_t*{id_t <- id_t*} argumentIR_t*{argumentIR_t <- argumentIR_t*} ==> Ci_callee_2 sto_2

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:20:1-22:35:
relation Bind_arg: cursor contextInst ; cursor contextInst sto |- id argumentIR ==> contextInst sto

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:70:1-74:72:
   rule : p_caller Ci_caller ; p_callee Ci_callee_0 sto_0 |- id argumentIR ==> Ci_callee_1 sto_1
      -- let Ci_caller_inner = $enter_path(Ci_caller, id)
      -- Argument_inst: p_caller Ci_caller_inner sto_0 |- argumentIR ==> sto_1 value
      -- let Ci_callee_1 = $add_value_inst(p_callee, Ci_callee_0, id, value)

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:32:1-34:26:
relation Expr_inst: cursor contextInst sto |- typedExpressionIR ==> sto value

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:16:1-17:41:
   rule literalExpressionIR-true: p Ci sto |- expressionIR # _expressionNoteIR ==> sto b true as value
      -- if expressionIR <: literalExpression
      -- let literalExpression = expressionIR as literalExpression
      -- if literalExpression matches `TRUE`

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:19:1-20:43:
   rule literalExpressionIR-false: p Ci sto |- expressionIR # _expressionNoteIR ==> sto b false as value
      -- if expressionIR <: literalExpression
      -- let literalExpression = expressionIR as literalExpression
      -- if literalExpression matches `FALSE`

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:24:1-25:39:
   rule literalExpressionIR-number-arbint: p Ci sto |- expressionIR # _expressionNoteIR ==> sto d i as value
      -- if expressionIR <: number
      -- let number = expressionIR as number
      -- if number matches `D%`
      -- let d i = number

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:27:1-28:43:
   rule literalExpressionIR-number-fixint: p Ci sto |- expressionIR # _expressionNoteIR ==> sto n s i as value
      -- if expressionIR <: number
      -- let number = expressionIR as number
      -- if number matches `%S%`
      -- let n s i = number

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:30:1-31:43:
   rule literalExpressionIR-number-fixbit: p Ci sto |- expressionIR # _expressionNoteIR ==> sto n w i as value
      -- if expressionIR <: number
      -- let number = expressionIR as number
      -- if number matches `%W%`
      -- let n w i = number

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:35:1-36:53:
   rule literalExpressionIR-stringLiteral: p Ci sto |- expressionIR # _expressionNoteIR ==> sto " text " as value
      -- if expressionIR <: stringLiteral
      -- let " text " = expressionIR as stringLiteral

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:41:1-43:56:
   rule referenceExpressionIR-id: p Ci sto |- expressionIR # _expressionNoteIR ==> sto value
      -- if expressionIR <: prefixedNameIR
      -- let prefixedNameIR = expressionIR as prefixedNameIR
      -- let value = $find_value_inst(p, Ci, prefixedNameIR)

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:47:1-48:40:
   rule defaultExpressionIR: p Ci sto |- expressionIR # _expressionNoteIR ==> sto default as value
      -- if expressionIR <: defaultExpression
      -- let defaultExpression = expressionIR as defaultExpression
      -- if (defaultExpression = ...)

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:53:1-55:62:
   rule unaryExpressionIR-bnot: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_1 $un_bnot(value)
      -- if expressionIR <: unaryExpressionIR
      -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
      -- if unop matches `~`
      -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:57:1-59:62:
   rule unaryExpressionIR-lnot: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_1 $un_lnot(value)
      -- if expressionIR <: unaryExpressionIR
      -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
      -- if unop matches `!`
      -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:61:1-63:62:
   rule unaryExpressionIR-plus: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_1 $un_plus(value)
      -- if expressionIR <: unaryExpressionIR
      -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
      -- if unop matches `+`
      -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:65:1-67:62:
   rule unaryExpressionIR-minus: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_1 $un_minus(value)
      -- if expressionIR <: unaryExpressionIR
      -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
      -- if unop matches `-`
      -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:73:1-77:68:
   rule binaryExpressionIR-mul: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 $bin_mul(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `*`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:79:1-83:68:
   rule binaryExpressionIR-div: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 $bin_div(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `/`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:85:1-89:68:
   rule binaryExpressionIR-mod: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 $bin_mod(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `%`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:91:1-95:68:
   rule binaryExpressionIR-plus: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 $bin_plus(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `+`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:97:1-101:68:
   rule binaryExpressionIR-minus: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 $bin_minus(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `-`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:103:1-107:68:
   rule binaryExpressionIR-satplus: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 $bin_satplus(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `|+|`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:109:1-113:68:
   rule binaryExpressionIR-satminus: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 $bin_satminus(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `|-|`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:115:1-119:68:
   rule binaryExpressionIR-shl: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 $bin_shl(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `<<`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:121:1-125:68:
   rule binaryExpressionIR-shr: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 $bin_shr(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `>>`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:127:1-131:68:
   rule binaryExpressionIR-le: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 b $bin_le(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `<=`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:133:1-137:68:
   rule binaryExpressionIR-ge: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 b $bin_ge(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `>=`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:139:1-143:68:
   rule binaryExpressionIR-lt: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 b $bin_lt(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `<`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:145:1-149:68:
   rule binaryExpressionIR-gt: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 b $bin_gt(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `>`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:151:1-155:68:
   rule binaryExpressionIR-ne: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 b $bin_ne(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `!=`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:157:1-161:68:
   rule binaryExpressionIR-eq: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 b $bin_eq(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `==`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:163:1-167:68:
   rule binaryExpressionIR-band: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 $bin_band(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `&`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:169:1-173:68:
   rule binaryExpressionIR-bxor: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 $bin_bxor(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `^`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:175:1-179:68:
   rule binaryExpressionIR-bor: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 $bin_bor(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `|`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:181:1-185:68:
   rule binaryExpressionIR-concat: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 $bin_concat(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `++`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:187:1-191:68:
   rule binaryExpressionIR-land: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 $bin_land(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `&&`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:193:1-197:68:
   rule binaryExpressionIR-lor: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 $bin_lor(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `||`
      -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:203:1-207:71:
   rule ternaryExpressionIR-then: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 value_true
      -- if expressionIR <: ternaryExpressionIR
      -- let typedExpressionIR_c ? typedExpressionIR_t : typedExpressionIR_e = expressionIR as ternaryExpressionIR
      -- Expr_inst: p Ci sto |- typedExpressionIR_c ==> sto_1 value
      -- if (value = b true as value)
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_t ==> sto_2 value_true

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:209:1-213:72:
   rule ternaryExpressionIR-else: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 value_false
      -- if expressionIR <: ternaryExpressionIR
      -- let typedExpressionIR_c ? typedExpressionIR_t : typedExpressionIR_e = expressionIR as ternaryExpressionIR
      -- Expr_inst: p Ci sto |- typedExpressionIR_c ==> sto_1 value
      -- if (value = b false as value)
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_e ==> sto_2 value_false

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:218:1-221:45:
   rule castExpressionIR: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_1 value_cast
      -- if expressionIR <: castExpressionIR
      -- let ( typeIR ) typedExpressionIR = expressionIR as castExpressionIR
      -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value
      -- let value_cast = $cast_op(typeIR, value)

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:228:1-229:37:
   rule dataExpressionIR-invalid: p Ci sto |- expressionIR # _expressionNoteIR ==> sto {#} as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `{#}`

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:233:1-236:68:
   rule dataExpressionIR-sequence: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_1 seq( value*{value <- value*} ) as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `SEQ{%}`
      -- let seq{ typedExpressionListIR } = dataExpressionIR
      -- Exprs_inst: p Ci sto |- typedExpressionListIR ==> sto_1 value*{value <- value*}

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:240:1-243:68:
   rule dataExpressionIR-sequence-default: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_1 seq( value*{value <- value*} ,...) as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `SEQ{%,...}`
      -- let seq{ typedExpressionListIR ,...} = dataExpressionIR
      -- Exprs_inst: p Ci sto |- typedExpressionListIR ==> sto_1 value*{value <- value*}

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:247:1-250:65:
   rule dataExpressionIR-record: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_1 record{ value nameIR ;*{nameIR <- nameIR*, value <- value*} } as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `RECORD{%}`
      -- let record{ nameIR = typedExpressionIR*{nameIR <- nameIR*, typedExpressionIR <- typedExpressionIR*} } = dataExpressionIR
      -- Exprs_inst: p Ci sto |- typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} ==> sto_1 value*{value <- value*}

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:254:1-257:65:
   rule dataExpressionIR-record-default: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_1 record{ value nameIR ;*{nameIR <- nameIR*, value <- value*} ,...} as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `RECORD{%,...}`
      -- let record{ nameIR = typedExpressionIR*{nameIR <- nameIR*, typedExpressionIR <- typedExpressionIR*} ,...} = dataExpressionIR
      -- Exprs_inst: p Ci sto |- typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} ==> sto_1 value*{value <- value*}

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:265:1-268:63:
   rule accessExpressionIR-errorAccessExpressionIR: p Ci sto |- expressionIR # _expressionNoteIR ==> sto value_error
      -- if expressionIR <: errorAccessExpressionIR
      -- let error. nameIR = expressionIR as errorAccessExpressionIR
      -- let nameIR_error = "error." ++ nameIR
      -- let value_error = $find_value_inst(p, Ci, ` nameIR_error)

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:276:1-279:68:
   rule accessExpressionIR-memberAccessExpressionIR-typeaccess-enum: p Ci sto |- expressionIR # _expressionNoteIR ==> sto tid . nameIR as value
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessBaseIR . nameIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessBaseIR matches `TYPE%`
      -- let type prefixedNameIR = memberAccessBaseIR
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(p, Ci, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: enumTypeIR
      -- let enumTypeIR = typeDefIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let enum tid { _id*{_id <- _id*} } = enumTypeIR

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:281:1-286:75:
   rule accessExpressionIR-memberAccessExpressionIR-typeaccess-senum: p Ci sto |- expressionIR # _expressionNoteIR ==> sto tid . nameIR # value as value
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessBaseIR . nameIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessBaseIR matches `TYPE%`
      -- let type prefixedNameIR = memberAccessBaseIR
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(p, Ci, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: enumTypeIR
      -- let enumTypeIR = typeDefIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let enum tid # _typeIR { id_member = value_member ;*{id_member <- id_member*, value_member <- value_member*} } = enumTypeIR
      -- let value'?{value' <- value'?} = $assoc_<nameIR, value>(nameIR, (id_member, value_member)*{id_member <- id_member*, value_member <- value_member*})
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:290:1-294:40:
   rule accessExpressionIR-memberAccessExpressionIR-typedExpressionIR: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_1 d n_size as int as value
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessBaseIR . text = expressionIR as memberAccessExpressionIR
      -- if memberAccessBaseIR <: typedExpressionIR
      -- let typedExpressionIR = memberAccessBaseIR as typedExpressionIR
      -- if (text = "size")
      -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value
      -- let value' = value
      -- if value' <: headerStackValue
      -- let [ _value*{_value <- _value*} #( _nat ; n_size )] = value' as headerStackValue

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:304:1-309:68:
   rule indexAccessExpressionIR-bitslice: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_3 $bitacc_op(value_b, value_l, value_h)
      -- if expressionIR <: indexAccessExpressionIR
      -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
      -- if indexAccessExpressionIR matches `%[%:%]`
      -- let typedExpressionIR_b [ typedExpressionIR_l : typedExpressionIR_h ] = indexAccessExpressionIR
      -- Expr_inst: p Ci sto |- typedExpressionIR_b ==> sto_1 value_b
      -- Expr_inst: p Ci sto_1 |- typedExpressionIR_l ==> sto_2 value_l
      -- Expr_inst: p Ci sto_2 |- typedExpressionIR_h ==> sto_3 value_h

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:316:1-326:25:
   rule callExpressionIR-instantiation: p Ci sto |- expressionIR # _expressionNoteIR ==> sto_2 value
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%(%)`
      -- let prefixedNameIR < typeArgumentListIR > ( argumentListIR ) = callExpressionIR
      -- let (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci, prefixedNameIR, argumentListIR)
      -- if (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} matches (_)
      -- let ?((_cid, consDyn, id_default*{id_default <- id_default*})) = (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?}
      -- Constructor_inst: p Ci sto |- consDyn < typeArgumentListIR >( argumentListIR # id_default*{id_default <- id_default*} )==> sto_1 objDyn
      -- let oid = Ci.path
      -- let sto_2 = $add_sto(sto_1, oid, objDyn)
      -- let value = ! oid as value

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:337:1-341:91:
   rule callExpressionIR-methodTarget-generic: p Ci sto |- expressionIR # _expressionNoteIR ==> sto $sizeof(typeIR_base, nameIR)
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%<%>(%)`
      -- let routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR . nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR
      -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:345:1-349:64:
   rule callExpressionIR-methodTarget-non-generic: p Ci sto |- expressionIR # _expressionNoteIR ==> sto $sizeof(typeIR_base, nameIR)
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%<%>(%)`
      -- let routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
      -- if routineTargetIR matches `TYPE%.%`
      -- let type prefixedNameIR . nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(p, Ci, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR_base = typeDefIR as typeIR

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:353:1-360:32:
   rule callExpressionIR-methodTarget-routine: p Ci sto |- expressionIR # expressionNoteIR ==> sto_1 value
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%<%>(%)`
      -- let routineTargetIR' < typeArgumentListIR >( argumentListIR ) = callExpressionIR
      -- if routineTargetIR' matches `(%)`
      -- let ( routineTargetIR ) = routineTargetIR'
      -- Expr_inst: p Ci sto |- routineTargetIR < typeArgumentListIR >( argumentListIR ) as expressionIR # expressionNoteIR ==> sto_1 value

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:365:1-367:64:
   rule parenthesizedExpressionIR: p Ci sto_0 |- expressionIR # _expressionNoteIR ==> sto_1 value
      -- if expressionIR <: parenthesizedExpressionIR
      -- let ( typedExpressionIR ) = expressionIR as parenthesizedExpressionIR
      -- Expr_inst: p Ci sto_0 |- typedExpressionIR ==> sto_1 value

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:36:1-38:26:
relation Exprs_inst: cursor contextInst sto |- typedExpressionIR* ==> sto value*

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:375:1-376:30:
   rule nil: p Ci sto |- typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} ==> sto []
      -- if typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.05-instantiation-expression.spectec:378:1-382:71:
   rule cons: p Ci sto_0 |- typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} ==> sto_2 value_h :: value_t*{value_t <- value_t*}
      -- if typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} matches _ :: _
      -- let typedExpressionIR_h :: typedExpressionIR_t*{typedExpressionIR_t <- typedExpressionIR_t*} = typedExpressionIR*{typedExpressionIR <- typedExpressionIR*}
      -- Expr_inst: p Ci sto_0 |- typedExpressionIR_h ==> sto_1 value_h
      -- Exprs_inst: p Ci sto_1 |- typedExpressionIR_t*{typedExpressionIR_t <- typedExpressionIR_t*} ==> sto_2 value_t*{value_t <- value_t*}

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:44:1-46:26:
relation Argument_inst: cursor contextInst sto |- argumentIR ==> sto value

   ;; ../../../../reference-specs/p4-concrete/6.06-instantiation-argument.spectec:9:1-11:62:
   rule expression: p Ci sto |- argumentIR ==> sto_1 value
      -- if argumentIR <: typedExpressionIR
      -- let typedExpressionIR = argumentIR as typedExpressionIR
      -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value

   ;; ../../../../reference-specs/p4-concrete/6.06-instantiation-argument.spectec:15:1-17:62:
   rule namedexpression: p Ci sto |- argumentIR ==> sto_1 value
      -- if argumentIR matches `%=%`
      -- let nameIR = typedExpressionIR = argumentIR
      -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:52:1-54:26:
relation Stmt_inst: cursor contextInst sto |- statementIR ==> contextInst sto statementIR

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:9:1-10:59:
   rule emptyStatementIR: p Ci sto |- statementIR ==> Ci sto emptyStatementIR as statementIR
      -- if statementIR <: emptyStatementIR
      -- let emptyStatementIR = statementIR as emptyStatementIR

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:14:1-15:69:
   rule assignmentStatementIR: p Ci sto |- statementIR ==> Ci sto assignmentStatementIR as statementIR
      -- if statementIR <: assignmentStatementIR
      -- let assignmentStatementIR = statementIR as assignmentStatementIR

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:21:1-22:57:
   rule callStatementIR: p Ci sto |- statementIR ==> Ci sto callStatementIR as statementIR
      -- if statementIR <: callStatementIR
      -- let callStatementIR = statementIR as callStatementIR

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:28:1-46:82:
   rule directApplicationStatementIR: p Ci sto_0 |- statementIR ==> Ci sto_2 blockStatementIR as statementIR
      -- if statementIR <: directApplicationStatementIR
      -- let prefixedNameIR .apply( argumentListIR ); = statementIR as directApplicationStatementIR
      -- let (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci, prefixedNameIR, [])
      -- if (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} matches (_)
      -- let ?((_cid, consDyn, _id*{_id <- _id*})) = (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?}
      -- Constructor_inst: p Ci sto_0 |- consDyn < [] >( [] # [] )==> sto_1 objDyn
      -- let tid_fresh = $fresh_tid
      -- let tid = $flatten_prefixedNameIR(prefixedNameIR)
      -- let typeIR = tid tid as typeIR
      -- let nameIR = $concat_text([tid, "_", tid_fresh])
      -- let oid = Ci.path ++ [nameIR]
      -- let sto_2 = $add_sto(sto_1, oid, objDyn)
      -- let constantDeclarationIR = const typeIR nameIR = ! oid as value ;
      -- let routineTargetIR = ` tid as expressionIR # ( typeIR ctk ) . "apply"
      -- let callStatementIR = routineTargetIR < [] >( argumentListIR );
      -- let blockStatementIR = { [constantDeclarationIR as blockElementStatementIR, callStatementIR as blockElementStatementIR] }

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:50:1-51:61:
   rule returnStatementIR: p Ci sto |- statementIR ==> Ci sto returnStatementIR as statementIR
      -- if statementIR <: returnStatementIR
      -- let returnStatementIR = statementIR as returnStatementIR

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:55:1-56:57:
   rule exitStatementIR: p Ci sto |- statementIR ==> Ci sto exitStatementIR as statementIR
      -- if statementIR <: exitStatementIR
      -- let exitStatementIR = statementIR as exitStatementIR

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:61:1-64:130:
   rule blockStatementIR: p Ci sto |- statementIR ==> Ci_1 sto_1 annotationList { blockElementStatementListIR' } as statementIR
      -- if statementIR <: blockStatementIR
      -- let annotationList { blockElementStatementListIR } = statementIR as blockStatementIR
      -- Block_inst: p Ci sto |- annotationList { blockElementStatementListIR } ==> Ci_1 sto_1 _annotationList { blockElementStatementListIR' }

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:71:1-74:68:
   rule conditionalStatementIR-non-else: p Ci sto |- statementIR'' ==> Ci_1 sto_1 if( typedExpressionIR ) statementIR' as statementIR
      -- if statementIR'' <: conditionalStatementIR
      -- let conditionalStatementIR = statementIR'' as conditionalStatementIR
      -- if conditionalStatementIR matches `IF(%)%`
      -- let if( typedExpressionIR ) statementIR = conditionalStatementIR
      -- Stmt_inst: p Ci sto |- statementIR ==> Ci_1 sto_1 statementIR'

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:78:1-84:82:
   rule conditionalStatementIR-else: p Ci sto |- statementIR ==> Ci_2 sto_2 if( typedExpressionIR ) statementIR_then' else statementIR_else' as statementIR
      -- if statementIR <: conditionalStatementIR
      -- let conditionalStatementIR = statementIR as conditionalStatementIR
      -- if conditionalStatementIR matches `IF(%)%ELSE%`
      -- let if( typedExpressionIR ) statementIR_then else statementIR_else = conditionalStatementIR
      -- Stmt_inst: p Ci sto |- statementIR_then ==> Ci_1 sto_1 statementIR_then'
      -- Stmt_inst: p Ci_1 sto_1 |- statementIR_else ==> Ci_2 sto_2 statementIR_else'

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:90:1-91:59:
   rule breakStatementIR: p Ci sto |- statementIR ==> Ci sto breakStatementIR as statementIR
      -- if statementIR <: breakStatementIR
      -- let breakStatementIR = statementIR as breakStatementIR

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:95:1-96:65:
   rule continueStatementIR: p Ci sto |- statementIR ==> Ci sto continueStatementIR as statementIR
      -- if statementIR <: continueStatementIR
      -- let continueStatementIR = statementIR as continueStatementIR

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:101:1-105:85:
   rule switchStatementIR: p Ci sto |- statementIR ==> Ci_1 sto_1 switch( typedExpressionIR ){ switchCaseListIR' } as statementIR
      -- if statementIR <: switchStatementIR
      -- let switch( typedExpressionIR ){ switchCaseListIR } = statementIR as switchStatementIR
      -- SwitchCases_inst: p Ci sto |- switchCaseListIR ==> Ci_1 sto_1 switchCaseListIR'

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:56:1-58:26:
relation Stmts_inst: cursor contextInst sto |- statementIR* ==> contextInst sto statementIR*

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:60:1-62:26:
relation SwitchCases_inst: cursor contextInst sto |- switchCaseIR* ==> contextInst sto switchCaseIR*

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:124:1-125:33:
   rule nil: p Ci sto |- switchCaseIR*{switchCaseIR <- switchCaseIR*} ==> Ci sto []
      -- if switchCaseIR*{switchCaseIR <- switchCaseIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:127:1-131:87:
   rule cons: p Ci_0 sto_0 |- switchCaseIR*{switchCaseIR <- switchCaseIR*} ==> Ci_2 sto_2 switchCaseIR_h' :: switchCaseIR_t'*{switchCaseIR_t' <- switchCaseIR_t'*}
      -- if switchCaseIR*{switchCaseIR <- switchCaseIR*} matches _ :: _
      -- let switchCaseIR_h :: switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} = switchCaseIR*{switchCaseIR <- switchCaseIR*}
      -- SwitchCase_inst: p Ci_0 sto_0 |- switchCaseIR_h ==> Ci_1 sto_1 switchCaseIR_h'
      -- SwitchCases_inst: p Ci_1 sto_1 |- switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} ==> Ci_2 sto_2 switchCaseIR_t'*{switchCaseIR_t' <- switchCaseIR_t'*}

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:64:1-66:26:
relation SwitchCase_inst: cursor contextInst sto |- switchCaseIR ==> contextInst sto switchCaseIR

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:115:1-117:78:
   rule match: p Ci sto |- switchCaseIR ==> Ci_1 sto_1 switchLabelIR : blockStatementIR'
      -- if switchCaseIR matches `%:%`
      -- let switchLabelIR : blockStatementIR = switchCaseIR
      -- Stmt_inst: p Ci sto |- blockStatementIR as statementIR ==> Ci_1 sto_1 statementIR
      -- if statementIR <: blockStatementIR
      -- let blockStatementIR' = statementIR as blockStatementIR

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:121:1-122:61:
   rule fallthrough: p Ci sto |- switchCaseIR ==> Ci sto switchLabelIR :
      -- if switchCaseIR matches `%:`
      -- let switchLabelIR : = switchCaseIR

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:68:1-70:26:
relation BlockElementStmt_inst: cursor contextInst sto |- blockElementStatementIR ==> contextInst sto blockElementStatementIR?

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:139:1-141:88:
   rule constantDeclarationIR: p Ci sto |- blockElementStatementIR ==> Ci_1 sto_1 ?(constantDeclarationIR' as blockElementStatementIR)
      -- if blockElementStatementIR <: constantDeclarationIR
      -- let constantDeclarationIR = blockElementStatementIR as constantDeclarationIR
      -- Decl_inst: p Ci sto |- constantDeclarationIR as declarationIR ==> Ci_1 sto_1 declarationIR'?{declarationIR' <- declarationIR'?}
      -- if declarationIR'?{declarationIR' <- declarationIR'?} matches (_)
      -- let ?(declarationIR) = declarationIR'?{declarationIR' <- declarationIR'?}
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR' = declarationIR as constantDeclarationIR

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:145:1-146:56:
   rule variableDeclarationIR: cursor Ci sto |- blockElementStatementIR ==> Ci sto ?()
      -- if cursor matches `GLOBAL`
      -- if blockElementStatementIR <: variableDeclarationIR
      -- let variableDeclarationIR = blockElementStatementIR as variableDeclarationIR

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:148:1-149:69:
   rule variableDeclarationIR: p Ci sto |- blockElementStatementIR ==> Ci sto ?(variableDeclarationIR as blockElementStatementIR)
      -- if blockElementStatementIR <: variableDeclarationIR
      -- let variableDeclarationIR = blockElementStatementIR as variableDeclarationIR

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:153:1-155:76:
   rule statementIR: p Ci sto |- blockElementStatementIR ==> Ci_1 sto_1 ?(statementIR_inst as blockElementStatementIR)
      -- if blockElementStatementIR <: statementIR
      -- let statementIR = blockElementStatementIR as statementIR
      -- Stmt_inst: local Ci sto |- statementIR ==> Ci_1 sto_1 statementIR_inst

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:72:1-74:26:
relation BlockElementStmts_inst: cursor contextInst sto |- blockElementStatementIR* ==> contextInst sto blockElementStatementIR*

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:157:1-158:33:
   rule nil: p Ci sto |- blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} ==> Ci sto []
      -- if blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:160:1-164:115:
   rule cons: p Ci_0 sto_0 |- blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} ==> Ci_2 sto_2 blockElementStatementIR_h' :: blockElementStatementIR_t'*{blockElementStatementIR_t' <- blockElementStatementIR_t'*}
      -- if blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} matches _ :: _
      -- let blockElementStatementIR_h :: blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*} = blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*}
      -- BlockElementStmt_inst: p Ci_0 sto_0 |- blockElementStatementIR_h ==> Ci_1 sto_1 blockElementStatementIR'?{blockElementStatementIR' <- blockElementStatementIR'?}
      -- if blockElementStatementIR'?{blockElementStatementIR' <- blockElementStatementIR'?} matches (_)
      -- let ?(blockElementStatementIR_h') = blockElementStatementIR'?{blockElementStatementIR' <- blockElementStatementIR'?}
      -- BlockElementStmts_inst: p Ci_1 sto_1 |- blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*} ==> Ci_2 sto_2 blockElementStatementIR_t'*{blockElementStatementIR_t' <- blockElementStatementIR_t'*}

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:76:1-78:26:
relation Block_inst: cursor contextInst sto |- blockStatementIR ==> contextInst sto blockStatementIR

   ;; ../../../../reference-specs/p4-concrete/6.07-instantiation-statement.spectec:173:1-178:32:
   rule : p Ci_0 sto_0 |- annotationList { blockElementStatementListIR } ==> Ci_2 sto_1 annotationList { blockElementStatementListIR_inst }
      -- let Ci_1 = $enter_inst(Ci_0)
      -- BlockElementStmts_inst: p Ci_1 sto_0 |- blockElementStatementListIR ==> Ci_2 sto_1 blockElementStatementListIR_inst
      -- let Ci_3 = $exit_inst(Ci_2)

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:84:1-86:20:
relation Bind_method: rdenv |- methodPrototypeIR ==> rdenv

   ;; ../../../../reference-specs/p4-concrete/6.09-instantiation-extern-method.spectec:9:1-22:18:
   rule non-abstract: rdenv_0 |- methodPrototypeIR ==> rdenv_1
      -- if methodPrototypeIR matches `%%;`
      -- let _annotationList typeIR_ret nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{parameterIR <- parameterIR*} ) ; = methodPrototypeIR
      -- let rid = $rid_IR(nameIR, parameterIR*{parameterIR <- parameterIR*})
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let methodTypeIR = extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
      -- let routineTypeDefIR = methodTypeIR as routineTypeIR < typeParameterListIR , typeParameterListIR_inferred > as routineTypeDefIR
      -- let rdenv_1 = $add_map<rid, routineTypeDefIR>(rdenv_0, rid, routineTypeDefIR)

   ;; ../../../../reference-specs/p4-concrete/6.09-instantiation-extern-method.spectec:24:1-37:18:
   rule abstract: rdenv_0 |- methodPrototypeIR ==> rdenv_1
      -- if methodPrototypeIR matches `%ABSTRACT%;`
      -- let _annotationList abstract typeIR_ret nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{parameterIR <- parameterIR*} ) ; = methodPrototypeIR
      -- let rid = $rid_IR(nameIR, parameterIR*{parameterIR <- parameterIR*})
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let methodTypeIR = extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
      -- let routineTypeDefIR = methodTypeIR as routineTypeIR < typeParameterListIR , typeParameterListIR_inferred > as routineTypeDefIR
      -- let rdenv_1 = $add_map<rid, routineTypeDefIR>(rdenv_0, rid, routineTypeDefIR)

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:88:1-90:20:
relation Bind_methods: rdenv |- methodPrototypeIR* ==> rdenv

   ;; ../../../../reference-specs/p4-concrete/6.09-instantiation-extern-method.spectec:39:1-40:25:
   rule nil: rdenv |- methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} ==> rdenv
      -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.09-instantiation-extern-method.spectec:42:1-45:63:
   rule cons: rdenv_0 |- methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} ==> rdenv_2
      -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches _ :: _
      -- let methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} = methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
      -- Bind_method: rdenv_0 |- methodPrototypeIR_h ==> rdenv_1
      -- Bind_methods: rdenv_1 |- methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} ==> rdenv_2

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:92:1-94:29:
relation Bind_constructor: cursor contextInst typeParameterListIR methodPrototypeListIR |- methodPrototypeIR ==> contextInst

   ;; ../../../../reference-specs/p4-concrete/6.09-instantiation-extern-method.spectec:47:1-56:60:
   rule constructor: p Ci_0 typeParameterListIR methodPrototypeListIR |- methodPrototypeIR ==> Ci_1
      -- if methodPrototypeIR matches `%%<,%>(%);`
      -- let annotationList nameIR <, typeParameterListIR_inferred >( parameterListIR ); = methodPrototypeIR
      -- let cid = $cid_IR(nameIR, parameterListIR)
      -- let consDyn = extern nameIR < typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ){ methodPrototypeListIR }
      -- let Ci_1 = $add_constructor_inst(p, Ci_0, cid, consDyn)

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:96:1-98:29:
relation Bind_constructors: cursor contextInst typeParameterListIR methodPrototypeListIR |- methodPrototypeIR* ==> contextInst

   ;; ../../../../reference-specs/p4-concrete/6.09-instantiation-extern-method.spectec:58:1-59:63:
   rule nil: p Ci typeParameterListIR methodPrototypeListIR |- methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} ==> Ci
      -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.09-instantiation-extern-method.spectec:61:1-65:106:
   rule cons: p Ci_0 typeParameterListIR methodPrototypeListIR |- methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} ==> Ci_2
      -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches _ :: _
      -- let methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} = methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
      -- Bind_constructor: p Ci_0 typeParameterListIR methodPrototypeListIR |- methodPrototypeIR_h ==> Ci_1
      -- Bind_constructors: p Ci_1 typeParameterListIR methodPrototypeListIR |- methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} ==> Ci_2

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:100:1-102:20:
relation ExternMethod_inst: contextInst |- methodPrototypeIR ==> contextInst

   ;; ../../../../reference-specs/p4-concrete/6.09-instantiation-extern-method.spectec:67:1-77:73:
   rule non-abstract: Ci_0 |- methodPrototypeIR ==> Ci_1
      -- if methodPrototypeIR matches `%%;`
      -- let _annotationList _typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR ) ; = methodPrototypeIR
      -- let rid = $rid_IR(nameIR, parameterListIR)
      -- let methodDyn = extern_method< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ) ?()
      -- let Ci_1 = $add_routine_overload_inst(block, Ci_0, rid, methodDyn as routineDyn)

   ;; ../../../../reference-specs/p4-concrete/6.09-instantiation-extern-method.spectec:79:1-90:73:
   rule abstract: Ci_0 |- methodPrototypeIR ==> Ci_1
      -- if methodPrototypeIR matches `%ABSTRACT%;`
      -- let _annotationList abstract _typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR ) ; = methodPrototypeIR
      -- let rid = $rid_IR(nameIR, parameterListIR)
      -- let methodDyn = extern_methodabstract< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR )
      -- let Ci_1 = $add_routine_overload_inst(block, Ci_0, rid, methodDyn as routineDyn)

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:104:1-106:20:
relation ExternMethods_inst: contextInst |- methodPrototypeIR* ==> contextInst

   ;; ../../../../reference-specs/p4-concrete/6.09-instantiation-extern-method.spectec:92:1-93:19:
   rule nil: Ci |- methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} ==> Ci
      -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.09-instantiation-extern-method.spectec:95:1-98:63:
   rule cons: Ci_0 |- methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} ==> Ci_2
      -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches _ :: _
      -- let methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} = methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
      -- ExternMethod_inst: Ci_0 |- methodPrototypeIR_h ==> Ci_1
      -- ExternMethods_inst: Ci_1 |- methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} ==> Ci_2

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:112:1-114:23:
relation ParserStmt_inst: contextInst sto |- parserStatementIR ==> contextInst sto parserStatementIR?

   ;; ../../../../reference-specs/p4-concrete/6.10.1-instantiation-parser-statement.spectec:9:1-11:101:
   rule constantDeclarationIR: Ci_0 sto_0 |- parserStatementIR ==> Ci_1 sto_1 constantDeclarationIR_inst?{constantDeclarationIR_inst <- constantDeclarationIR_inst?} as parserStatementIR?
      -- if parserStatementIR <: constantDeclarationIR
      -- let constantDeclarationIR = parserStatementIR as constantDeclarationIR
      -- Decl_inst: block Ci_0 sto_0 |- constantDeclarationIR as declarationIR ==> Ci_1 sto_1 declarationIR?{declarationIR <- declarationIR?}
      -- if declarationIR?{declarationIR <- declarationIR?} <: constantDeclarationIR?
      -- let constantDeclarationIR_inst?{constantDeclarationIR_inst <- constantDeclarationIR_inst?} = declarationIR?{declarationIR <- declarationIR?} as constantDeclarationIR?

   ;; ../../../../reference-specs/p4-concrete/6.10.1-instantiation-parser-statement.spectec:15:1-17:113:
   rule variableDeclarationIR: Ci_0 sto_0 |- parserStatementIR ==> Ci_1 sto_1 variableDeclarationIR_inst?{variableDeclarationIR_inst <- variableDeclarationIR_inst?} as parserStatementIR?
      -- if parserStatementIR <: variableDeclarationIR
      -- let variableDeclarationIR = parserStatementIR as variableDeclarationIR
      -- BlockElementStmt_inst: block Ci_0 sto_0 |- variableDeclarationIR as blockElementStatementIR ==> Ci_1 sto_1 blockElementStatementIR?{blockElementStatementIR <- blockElementStatementIR?}
      -- if blockElementStatementIR?{blockElementStatementIR <- blockElementStatementIR?} <: variableDeclarationIR?
      -- let variableDeclarationIR_inst?{variableDeclarationIR_inst <- variableDeclarationIR_inst?} = blockElementStatementIR?{blockElementStatementIR <- blockElementStatementIR?} as variableDeclarationIR?

   ;; ../../../../reference-specs/p4-concrete/6.10.1-instantiation-parser-statement.spectec:21:1-23:90:
   rule emptyStatementIR: Ci_0 sto_0 |- parserStatementIR ==> Ci_1 sto_1 ?(emptyStatementIR_inst as parserStatementIR)
      -- if parserStatementIR <: emptyStatementIR
      -- let emptyStatementIR = parserStatementIR as emptyStatementIR
      -- Stmt_inst: block Ci_0 sto_0 |- emptyStatementIR as statementIR ==> Ci_1 sto_1 statementIR
      -- if statementIR <: emptyStatementIR
      -- let emptyStatementIR_inst = statementIR as emptyStatementIR

   ;; ../../../../reference-specs/p4-concrete/6.10.1-instantiation-parser-statement.spectec:27:1-29:100:
   rule assignmentStatementIR: Ci_0 sto_0 |- parserStatementIR ==> Ci_1 sto_1 ?(assignmentStatementIR_inst as parserStatementIR)
      -- if parserStatementIR <: assignmentStatementIR
      -- let assignmentStatementIR = parserStatementIR as assignmentStatementIR
      -- Stmt_inst: block Ci_0 sto_0 |- assignmentStatementIR as statementIR ==> Ci_1 sto_1 statementIR
      -- if statementIR <: assignmentStatementIR
      -- let assignmentStatementIR_inst = statementIR as assignmentStatementIR

   ;; ../../../../reference-specs/p4-concrete/6.10.1-instantiation-parser-statement.spectec:33:1-35:88:
   rule callStatementIR: Ci_0 sto_0 |- parserStatementIR ==> Ci_1 sto_1 ?(callStatementIR_inst as parserStatementIR)
      -- if parserStatementIR <: callStatementIR
      -- let callStatementIR = parserStatementIR as callStatementIR
      -- Stmt_inst: block Ci_0 sto_0 |- callStatementIR as statementIR ==> Ci_1 sto_1 statementIR
      -- if statementIR <: callStatementIR
      -- let callStatementIR_inst = statementIR as callStatementIR

   ;; ../../../../reference-specs/p4-concrete/6.10.1-instantiation-parser-statement.spectec:39:1-58:88:
   rule directApplicationStatementIR: Ci sto_0 |- parserStatementIR ==> Ci sto_2 ?(parserBlockStatementIR as parserStatementIR)
      -- if parserStatementIR <: directApplicationStatementIR
      -- let prefixedNameIR .apply( argumentListIR ); = parserStatementIR as directApplicationStatementIR
      -- let (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci, prefixedNameIR, [])
      -- if (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} matches (_)
      -- let ?((_cid, consDyn, _id*{_id <- _id*})) = (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?}
      -- Constructor_inst: block Ci sto_0 |- consDyn < [] >( [] # [] )==> sto_1 objDyn
      -- let tid = $flatten_prefixedNameIR(prefixedNameIR)
      -- let tid_fresh = $fresh_tid
      -- let nameIR = $concat_text([tid, "_", tid_fresh])
      -- let oid = Ci.path ++ [nameIR]
      -- let sto_2 = $add_sto(sto_1, oid, objDyn)
      -- let typeIR = tid tid as typeIR
      -- let constantDeclarationIR = const typeIR nameIR = ! oid as value ;
      -- let routineTargetIR = ` tid as expressionIR # ( typeIR ctk ) . "apply"
      -- let callStatementIR = routineTargetIR < [] >( argumentListIR );
      -- let parserBlockStatementIR = { [constantDeclarationIR as parserStatementIR, callStatementIR as parserStatementIR] }

   ;; ../../../../reference-specs/p4-concrete/6.10.1-instantiation-parser-statement.spectec:62:1-68:36:
   rule parserBlockStatementIR: Ci_0 sto_0 |- parserStatementIR ==> Ci_1 sto_1 ?(parserBlockStatementIR_inst as parserStatementIR)
      -- if parserStatementIR <: parserBlockStatementIR
      -- let annotationList { parserStatementListIR } = parserStatementIR as parserBlockStatementIR
      -- ParserStmts_inst: Ci_0 sto_0 |- parserStatementListIR ==> Ci_1 sto_1 parserStatementListIR_inst
      -- let parserBlockStatementIR_inst = annotationList { parserStatementListIR_inst }

   ;; ../../../../reference-specs/p4-concrete/6.10.1-instantiation-parser-statement.spectec:72:1-74:102:
   rule conditionalStatementIR: Ci_0 sto_0 |- parserStatementIR ==> Ci_1 sto_1 ?(conditionalStatementIR_inst as parserStatementIR)
      -- if parserStatementIR <: conditionalStatementIR
      -- let conditionalStatementIR = parserStatementIR as conditionalStatementIR
      -- Stmt_inst: block Ci_0 sto_0 |- conditionalStatementIR as statementIR ==> Ci_1 sto_1 statementIR
      -- if statementIR <: conditionalStatementIR
      -- let conditionalStatementIR_inst = statementIR as conditionalStatementIR

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:116:1-118:23:
relation ParserStmts_inst: contextInst sto |- parserStatementIR* ==> contextInst sto parserStatementIR*

   ;; ../../../../reference-specs/p4-concrete/6.10.1-instantiation-parser-statement.spectec:82:1-83:31:
   rule nil: Ci sto |- parserStatementIR*{parserStatementIR <- parserStatementIR*} ==> Ci sto []
      -- if parserStatementIR*{parserStatementIR <- parserStatementIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.10.1-instantiation-parser-statement.spectec:85:1-89:95:
   rule cons-none: Ci_0 sto_0 |- parserStatementIR*{parserStatementIR <- parserStatementIR*} ==> Ci_2 sto_2 parserStatementIR_t'*{parserStatementIR_t' <- parserStatementIR_t'*}
      -- if parserStatementIR*{parserStatementIR <- parserStatementIR*} matches _ :: _
      -- let parserStatementIR_h :: parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*} = parserStatementIR*{parserStatementIR <- parserStatementIR*}
      -- ParserStmt_inst: Ci_0 sto_0 |- parserStatementIR_h ==> Ci_1 sto_1 parserStatementIR'?{parserStatementIR' <- parserStatementIR'?}
      -- if parserStatementIR'?{parserStatementIR' <- parserStatementIR'?} matches ()
      -- ParserStmts_inst: Ci_1 sto_1 |- parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*} ==> Ci_2 sto_2 parserStatementIR_t'*{parserStatementIR_t' <- parserStatementIR_t'*}

   ;; ../../../../reference-specs/p4-concrete/6.10.1-instantiation-parser-statement.spectec:91:1-95:95:
   rule cons-some: Ci_0 sto_0 |- parserStatementIR*{parserStatementIR <- parserStatementIR*} ==> Ci_2 sto_2 parserStatementIR_h' :: parserStatementIR_t'*{parserStatementIR_t' <- parserStatementIR_t'*}
      -- if parserStatementIR*{parserStatementIR <- parserStatementIR*} matches _ :: _
      -- let parserStatementIR_h :: parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*} = parserStatementIR*{parserStatementIR <- parserStatementIR*}
      -- ParserStmt_inst: Ci_0 sto_0 |- parserStatementIR_h ==> Ci_1 sto_1 parserStatementIR'?{parserStatementIR' <- parserStatementIR'?}
      -- if parserStatementIR'?{parserStatementIR' <- parserStatementIR'?} matches (_)
      -- let ?(parserStatementIR_h') = parserStatementIR'?{parserStatementIR' <- parserStatementIR'?}
      -- ParserStmts_inst: Ci_1 sto_1 |- parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*} ==> Ci_2 sto_2 parserStatementIR_t'*{parserStatementIR_t' <- parserStatementIR_t'*}

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:120:1-122:23:
relation ParserState_inst: contextInst sto |- parserStateIR ==> contextInst sto

   ;; ../../../../reference-specs/p4-concrete/6.10.2-instantiation-parser-state.spectec:9:1-18:62:
   rule : Ci_0 sto_0 |- annotationList state nameIR { parserStatementListIR transitionStatementIR } ==> Ci_2 sto_1
      -- ParserStmts_inst: Ci_0 sto_0 |- parserStatementListIR ==> Ci_1 sto_1 parserStatementListIR_inst
      -- let stateDyn = annotationList { parserStatementListIR_inst }
      -- let Ci_2 = $add_state_inst(block, Ci_1, nameIR, stateDyn)

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:124:1-126:23:
relation ParserStates_inst: contextInst sto |- parserStateIR* ==> contextInst sto

   ;; ../../../../reference-specs/p4-concrete/6.10.2-instantiation-parser-state.spectec:20:1-21:27:
   rule nil: Ci sto |- parserStateIR*{parserStateIR <- parserStateIR*} ==> Ci sto
      -- if parserStateIR*{parserStateIR <- parserStateIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.10.2-instantiation-parser-state.spectec:23:1-27:70:
   rule cons: Ci_0 sto_0 |- parserStateIR*{parserStateIR <- parserStateIR*} ==> Ci_2 sto_2
      -- if parserStateIR*{parserStateIR <- parserStateIR*} matches _ :: _
      -- let parserStateIR_h :: parserStateIR_t*{parserStateIR_t <- parserStateIR_t*} = parserStateIR*{parserStateIR <- parserStateIR*}
      -- ParserState_inst: Ci_0 sto_0 |- parserStateIR_h ==> Ci_1 sto_1
      -- ParserStates_inst: Ci_1 sto_1 |- parserStateIR_t*{parserStateIR_t <- parserStateIR_t*} ==> Ci_2 sto_2

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:128:1-130:23:
relation ParserLocalDecl_inst: contextInst sto |- parserLocalDeclarationIR ==> contextInst sto parserLocalDeclarationIR?

   ;; ../../../../reference-specs/p4-concrete/6.10.3-instantiation-parser-declaration.spectec:9:1-11:101:
   rule constantDeclarationIR: Ci_0 sto_0 |- parserLocalDeclarationIR ==> Ci_1 sto_1 constantDeclarationIR_inst?{constantDeclarationIR_inst <- constantDeclarationIR_inst?} as parserLocalDeclarationIR?
      -- if parserLocalDeclarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = parserLocalDeclarationIR as constantDeclarationIR
      -- Decl_inst: block Ci_0 sto_0 |- constantDeclarationIR as declarationIR ==> Ci_1 sto_1 declarationIR?{declarationIR <- declarationIR?}
      -- if declarationIR?{declarationIR <- declarationIR?} <: constantDeclarationIR?
      -- let constantDeclarationIR_inst?{constantDeclarationIR_inst <- constantDeclarationIR_inst?} = declarationIR?{declarationIR <- declarationIR?} as constantDeclarationIR?

   ;; ../../../../reference-specs/p4-concrete/6.10.3-instantiation-parser-declaration.spectec:15:1-17:89:
   rule instantiationIR: Ci_0 sto_0 |- parserLocalDeclarationIR ==> Ci_1 sto_1 instantiationIR_inst?{instantiationIR_inst <- instantiationIR_inst?} as parserLocalDeclarationIR?
      -- if parserLocalDeclarationIR <: instantiationIR
      -- let instantiationIR = parserLocalDeclarationIR as instantiationIR
      -- Decl_inst: block Ci_0 sto_0 |- instantiationIR as declarationIR ==> Ci_1 sto_1 declarationIR?{declarationIR <- declarationIR?}
      -- if declarationIR?{declarationIR <- declarationIR?} <: instantiationIR?
      -- let instantiationIR_inst?{instantiationIR_inst <- instantiationIR_inst?} = declarationIR?{declarationIR <- declarationIR?} as instantiationIR?

   ;; ../../../../reference-specs/p4-concrete/6.10.3-instantiation-parser-declaration.spectec:21:1-22:67:
   rule variableDeclarationIR: Ci sto |- parserLocalDeclarationIR ==> Ci sto ?(variableDeclarationIR as parserLocalDeclarationIR)
      -- if parserLocalDeclarationIR <: variableDeclarationIR
      -- let variableDeclarationIR = parserLocalDeclarationIR as variableDeclarationIR

   ;; ../../../../reference-specs/p4-concrete/6.10.3-instantiation-parser-declaration.spectec:28:1-29:67:
   rule valueSetDeclarationIR: Ci sto |- parserLocalDeclarationIR ==> Ci sto ?(valueSetDeclarationIR as parserLocalDeclarationIR)
      -- if parserLocalDeclarationIR <: valueSetDeclarationIR
      -- let valueSetDeclarationIR = parserLocalDeclarationIR as valueSetDeclarationIR

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:132:1-134:23:
relation ParserLocalDecls_inst: contextInst sto |- parserLocalDeclarationIR* ==> contextInst sto parserLocalDeclarationIR*

   ;; ../../../../reference-specs/p4-concrete/6.10.3-instantiation-parser-declaration.spectec:37:1-38:31:
   rule nil: Ci sto |- parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} ==> Ci sto []
      -- if parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.10.3-instantiation-parser-declaration.spectec:40:1-44:114:
   rule cons-none: Ci_0 sto_0 |- parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} ==> Ci_2 sto_2 parserLocalDeclarationIR_t'*{parserLocalDeclarationIR_t' <- parserLocalDeclarationIR_t'*}
      -- if parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} matches _ :: _
      -- let parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*} = parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*}
      -- ParserLocalDecl_inst: Ci_0 sto_0 |- parserLocalDeclarationIR_h ==> Ci_1 sto_1 parserLocalDeclarationIR'?{parserLocalDeclarationIR' <- parserLocalDeclarationIR'?}
      -- if parserLocalDeclarationIR'?{parserLocalDeclarationIR' <- parserLocalDeclarationIR'?} matches ()
      -- ParserLocalDecls_inst: Ci_1 sto_1 |- parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*} ==> Ci_2 sto_2 parserLocalDeclarationIR_t'*{parserLocalDeclarationIR_t' <- parserLocalDeclarationIR_t'*}

   ;; ../../../../reference-specs/p4-concrete/6.10.3-instantiation-parser-declaration.spectec:46:1-50:114:
   rule cons-some: Ci_0 sto_0 |- parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} ==> Ci_2 sto_2 parserLocalDeclarationIR_h' :: parserLocalDeclarationIR_t'*{parserLocalDeclarationIR_t' <- parserLocalDeclarationIR_t'*}
      -- if parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} matches _ :: _
      -- let parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*} = parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*}
      -- ParserLocalDecl_inst: Ci_0 sto_0 |- parserLocalDeclarationIR_h ==> Ci_1 sto_1 parserLocalDeclarationIR'?{parserLocalDeclarationIR' <- parserLocalDeclarationIR'?}
      -- if parserLocalDeclarationIR'?{parserLocalDeclarationIR' <- parserLocalDeclarationIR'?} matches (_)
      -- let ?(parserLocalDeclarationIR_h') = parserLocalDeclarationIR'?{parserLocalDeclarationIR' <- parserLocalDeclarationIR'?}
      -- ParserLocalDecls_inst: Ci_1 sto_1 |- parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*} ==> Ci_2 sto_2 parserLocalDeclarationIR_t'*{parserLocalDeclarationIR_t' <- parserLocalDeclarationIR_t'*}

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:140:1-142:23:
relation TableProperty_inst: contextInst sto |- tablePropertyIR ==> contextInst sto tablePropertyIR

   ;; ../../../../reference-specs/p4-concrete/6.11.1-instantiation-control-table.spectec:8:1-9:79:
   rule key: Ci sto |- tablePropertyIR ==> Ci sto key={ tableKeyListIR }
      -- if tablePropertyIR matches `KEY={%}`
      -- let key={ tableKeyListIR } = tablePropertyIR

   ;; ../../../../reference-specs/p4-concrete/6.11.1-instantiation-control-table.spectec:12:1-13:93:
   rule actions: Ci sto |- tablePropertyIR ==> Ci sto actions={ tableActionListIR }
      -- if tablePropertyIR matches `ACTIONS={%}`
      -- let actions={ tableActionListIR } = tablePropertyIR

   ;; ../../../../reference-specs/p4-concrete/6.11.1-instantiation-control-table.spectec:16:1-18:76:
   rule entries: Ci sto |- tablePropertyIR ==> Ci sto annotationList constOptIR entries={ tableEntryListIR }
      -- if tablePropertyIR matches `%%ENTRIES={%}`
      -- let annotationList constOptIR entries={ tableEntryListIR } = tablePropertyIR

   ;; ../../../../reference-specs/p4-concrete/6.11.1-instantiation-control-table.spectec:21:1-23:87:
   rule custom-default-action: Ci sto |- tablePropertyIR ==> Ci sto annotationList constOptIR default_action= tableActionReferenceIR ;
      -- if tablePropertyIR matches `%%DEFAULT_ACTION=%;`
      -- let annotationList constOptIR default_action= tableActionReferenceIR ; = tablePropertyIR

   ;; ../../../../reference-specs/p4-concrete/6.11.1-instantiation-control-table.spectec:26:1-31:72:
   rule custom: Ci sto |- tablePropertyIR ==> Ci sto_1 annotationList constOptIR custom_const nameIR = value ;
      -- if tablePropertyIR matches `%%CUSTOM%%;`
      -- let annotationList constOptIR custom nameIR = typedExpressionIR ; = tablePropertyIR
      -- let Ci_inner = $enter_path(Ci, nameIR)
      -- Expr_inst: local Ci_inner sto |- typedExpressionIR ==> sto_1 value

   ;; ../../../../reference-specs/p4-concrete/6.11.1-instantiation-control-table.spectec:34:1-36:88:
   rule custom-const: Ci sto |- tablePropertyIR ==> Ci sto annotationList constOptIR custom_const nameIR constantInitializerIR ;
      -- if tablePropertyIR matches `%%CUSTOM_CONST%%;`
      -- let annotationList constOptIR custom_const nameIR constantInitializerIR ; = tablePropertyIR

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:144:1-146:23:
relation TableProperties_inst: contextInst sto |- tablePropertyIR* ==> contextInst sto tablePropertyIR*

   ;; ../../../../reference-specs/p4-concrete/6.11.1-instantiation-control-table.spectec:38:1-39:31:
   rule nil: Ci sto |- tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} ==> Ci sto []
      -- if tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.11.1-instantiation-control-table.spectec:41:1-45:95:
   rule cons: Ci_0 sto_0 |- tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} ==> Ci_2 sto_2 tablePropertyIR_h' :: tablePropertyIR_t'*{tablePropertyIR_t' <- tablePropertyIR_t'*}
      -- if tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} matches _ :: _
      -- let tablePropertyIR_h :: tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*} = tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
      -- TableProperty_inst: Ci_0 sto_0 |- tablePropertyIR_h ==> Ci_1 sto_1 tablePropertyIR_h'
      -- TableProperties_inst: Ci_1 sto_1 |- tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*} ==> Ci_2 sto_2 tablePropertyIR_t'*{tablePropertyIR_t' <- tablePropertyIR_t'*}

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:148:1-150:23:
relation ControlLocalDecl_inst: contextInst sto |- controlLocalDeclarationIR ==> contextInst sto controlLocalDeclarationIR?

   ;; ../../../../reference-specs/p4-concrete/6.11.2-instantiation-control-declaration.spectec:9:1-11:101:
   rule constantDeclarationIR: Ci_0 sto_0 |- controlLocalDeclarationIR ==> Ci_1 sto_1 constantDeclarationIR_inst?{constantDeclarationIR_inst <- constantDeclarationIR_inst?} as controlLocalDeclarationIR?
      -- if controlLocalDeclarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = controlLocalDeclarationIR as constantDeclarationIR
      -- Decl_inst: block Ci_0 sto_0 |- constantDeclarationIR as declarationIR ==> Ci_1 sto_1 declarationIR?{declarationIR <- declarationIR?}
      -- if declarationIR?{declarationIR <- declarationIR?} <: constantDeclarationIR?
      -- let constantDeclarationIR_inst?{constantDeclarationIR_inst <- constantDeclarationIR_inst?} = declarationIR?{declarationIR <- declarationIR?} as constantDeclarationIR?

   ;; ../../../../reference-specs/p4-concrete/6.11.2-instantiation-control-declaration.spectec:15:1-17:90:
   rule instantiationIR: Ci_0 sto_0 |- controlLocalDeclarationIR ==> Ci_1 sto_1 constantDeclarationIR?{constantDeclarationIR <- constantDeclarationIR?} as controlLocalDeclarationIR?
      -- if controlLocalDeclarationIR <: instantiationIR
      -- let instantiationIR = controlLocalDeclarationIR as instantiationIR
      -- Decl_inst: block Ci_0 sto_0 |- instantiationIR as declarationIR ==> Ci_1 sto_1 declarationIR?{declarationIR <- declarationIR?}
      -- if declarationIR?{declarationIR <- declarationIR?} <: constantDeclarationIR?
      -- let constantDeclarationIR?{constantDeclarationIR <- constantDeclarationIR?} = declarationIR?{declarationIR <- declarationIR?} as constantDeclarationIR?

   ;; ../../../../reference-specs/p4-concrete/6.11.2-instantiation-control-declaration.spectec:21:1-22:67:
   rule variableDeclarationIR: Ci sto |- controlLocalDeclarationIR ==> Ci sto ?(variableDeclarationIR as controlLocalDeclarationIR)
      -- if controlLocalDeclarationIR <: variableDeclarationIR
      -- let variableDeclarationIR = controlLocalDeclarationIR as variableDeclarationIR

   ;; ../../../../reference-specs/p4-concrete/6.11.2-instantiation-control-declaration.spectec:26:1-28:97:
   rule actionDeclarationIR: Ci_0 sto_0 |- controlLocalDeclarationIR ==> Ci_1 sto_1 actionDeclarationIR_inst?{actionDeclarationIR_inst <- actionDeclarationIR_inst?} as controlLocalDeclarationIR?
      -- if controlLocalDeclarationIR <: actionDeclarationIR
      -- let actionDeclarationIR = controlLocalDeclarationIR as actionDeclarationIR
      -- Decl_inst: block Ci_0 sto_0 |- actionDeclarationIR as declarationIR ==> Ci_1 sto_1 declarationIR?{declarationIR <- declarationIR?}
      -- if declarationIR?{declarationIR <- declarationIR?} <: actionDeclarationIR?
      -- let actionDeclarationIR_inst?{actionDeclarationIR_inst <- actionDeclarationIR_inst?} = declarationIR?{declarationIR <- declarationIR?} as actionDeclarationIR?

   ;; ../../../../reference-specs/p4-concrete/6.11.2-instantiation-control-declaration.spectec:30:1-32:97:
   rule actionDeclarationIR: Ci_0 sto_0 |- controlLocalDeclarationIR ==> Ci_1 sto_1 actionDeclarationIR_inst?{actionDeclarationIR_inst <- actionDeclarationIR_inst?} as controlLocalDeclarationIR?
      -- if controlLocalDeclarationIR <: actionDeclarationIR
      -- let actionDeclarationIR = controlLocalDeclarationIR as actionDeclarationIR
      -- Decl_inst: block Ci_0 sto_0 |- actionDeclarationIR as declarationIR ==> Ci_1 sto_1 declarationIR?{declarationIR <- declarationIR?}
      -- if declarationIR?{declarationIR <- declarationIR?} <: actionDeclarationIR?
      -- let actionDeclarationIR_inst?{actionDeclarationIR_inst <- actionDeclarationIR_inst?} = declarationIR?{declarationIR <- declarationIR?} as actionDeclarationIR?

   ;; ../../../../reference-specs/p4-concrete/6.11.2-instantiation-control-declaration.spectec:36:1-49:30:
   rule tableDeclarationIR: Ci_0 sto_0 |- controlLocalDeclarationIR ==> Ci_1 sto_1 ?(constantDeclarationIR as controlLocalDeclarationIR)
      -- if controlLocalDeclarationIR <: tableDeclarationIR
      -- let _annotationList table typeIR nameIR { tablePropertyListIR } = controlLocalDeclarationIR as tableDeclarationIR
      -- let Ci_inner = $enter_path(Ci_0, nameIR)
      -- Constructor_inst: block Ci_0 sto_0 |- table nameIR { tablePropertyListIR } < [] >( [] # [] )==> sto_1 objDyn
      -- let oid = Ci_0.path ++ [nameIR]
      -- let sto_2 = $add_sto(sto_1, oid, objDyn)
      -- let Ci_1 = $add_value_inst(block, Ci_0, nameIR, ! oid as value)
      -- let constantDeclarationIR = const typeIR nameIR = ! oid as value ;

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:152:1-154:23:
relation ControlLocalDecls_inst: contextInst sto |- controlLocalDeclarationIR* ==> contextInst sto controlLocalDeclarationIR*

   ;; ../../../../reference-specs/p4-concrete/6.11.2-instantiation-control-declaration.spectec:56:1-57:31:
   rule nil: Ci sto |- controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} ==> Ci sto []
      -- if controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.11.2-instantiation-control-declaration.spectec:59:1-63:117:
   rule cons-none: Ci_0 sto_0 |- controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} ==> Ci_2 sto_2 controlLocalDeclarationIR_t'*{controlLocalDeclarationIR_t' <- controlLocalDeclarationIR_t'*}
      -- if controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} matches _ :: _
      -- let controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*} = controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*}
      -- ControlLocalDecl_inst: Ci_0 sto_0 |- controlLocalDeclarationIR_h ==> Ci_1 sto_1 controlLocalDeclarationIR'?{controlLocalDeclarationIR' <- controlLocalDeclarationIR'?}
      -- if controlLocalDeclarationIR'?{controlLocalDeclarationIR' <- controlLocalDeclarationIR'?} matches ()
      -- ControlLocalDecls_inst: Ci_1 sto_1 |- controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*} ==> Ci_2 sto_2 controlLocalDeclarationIR_t'*{controlLocalDeclarationIR_t' <- controlLocalDeclarationIR_t'*}

   ;; ../../../../reference-specs/p4-concrete/6.11.2-instantiation-control-declaration.spectec:65:1-69:117:
   rule cons-none: Ci_0 sto_0 |- controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} ==> Ci_2 sto_2 controlLocalDeclarationIR_h' :: controlLocalDeclarationIR_t'*{controlLocalDeclarationIR_t' <- controlLocalDeclarationIR_t'*}
      -- if controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} matches _ :: _
      -- let controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*} = controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*}
      -- ControlLocalDecl_inst: Ci_0 sto_0 |- controlLocalDeclarationIR_h ==> Ci_1 sto_1 controlLocalDeclarationIR'?{controlLocalDeclarationIR' <- controlLocalDeclarationIR'?}
      -- if controlLocalDeclarationIR'?{controlLocalDeclarationIR' <- controlLocalDeclarationIR'?} matches (_)
      -- let ?(controlLocalDeclarationIR_h') = controlLocalDeclarationIR'?{controlLocalDeclarationIR' <- controlLocalDeclarationIR'?}
      -- ControlLocalDecls_inst: Ci_1 sto_1 |- controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*} ==> Ci_2 sto_2 controlLocalDeclarationIR_t'*{controlLocalDeclarationIR_t' <- controlLocalDeclarationIR_t'*}

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:160:1-162:26:
relation Decls_inst: cursor contextInst sto |- declarationIR* ==> contextInst sto declarationIR*

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:489:1-490:33:
   rule nil: p Ci sto |- declarationIR*{declarationIR <- declarationIR*} ==> Ci sto []
      -- if declarationIR*{declarationIR <- declarationIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:492:1-496:83:
   rule cons-none: p Ci_0 sto_0 |- declarationIR*{declarationIR <- declarationIR*} ==> Ci_2 sto_2 declarationIR_t'*{declarationIR_t' <- declarationIR_t'*}
      -- if declarationIR*{declarationIR <- declarationIR*} matches _ :: _
      -- let declarationIR_h :: declarationIR_t*{declarationIR_t <- declarationIR_t*} = declarationIR*{declarationIR <- declarationIR*}
      -- Decl_inst: p Ci_0 sto_0 |- declarationIR_h ==> Ci_1 sto_1 declarationIR'?{declarationIR' <- declarationIR'?}
      -- if declarationIR'?{declarationIR' <- declarationIR'?} matches ()
      -- Decls_inst: p Ci_1 sto_1 |- declarationIR_t*{declarationIR_t <- declarationIR_t*} ==> Ci_2 sto_2 declarationIR_t'*{declarationIR_t' <- declarationIR_t'*}

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:498:1-502:83:
   rule cons-some: p Ci_0 sto_0 |- declarationIR*{declarationIR <- declarationIR*} ==> Ci_2 sto_2 declarationIR_h' :: declarationIR_t'*{declarationIR_t' <- declarationIR_t'*}
      -- if declarationIR*{declarationIR <- declarationIR*} matches _ :: _
      -- let declarationIR_h :: declarationIR_t*{declarationIR_t <- declarationIR_t*} = declarationIR*{declarationIR <- declarationIR*}
      -- Decl_inst: p Ci_0 sto_0 |- declarationIR_h ==> Ci_1 sto_1 declarationIR'?{declarationIR' <- declarationIR'?}
      -- if declarationIR'?{declarationIR' <- declarationIR'?} matches (_)
      -- let ?(declarationIR_h') = declarationIR'?{declarationIR' <- declarationIR'?}
      -- Decls_inst: p Ci_1 sto_1 |- declarationIR_t*{declarationIR_t <- declarationIR_t*} ==> Ci_2 sto_2 declarationIR_t'*{declarationIR_t' <- declarationIR_t'*}

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:164:1-166:26:
relation Decl_inst: cursor contextInst sto |- declarationIR ==> contextInst sto declarationIR?

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:16:1-21:30:
   rule constantDeclarationIR: p Ci_0 sto |- declarationIR ==> Ci_1 sto $wrap_decl(p, constantDeclarationIR as declarationIR)
      -- if declarationIR <: constantDeclarationIR
      -- let annotationList const typeIR nameIR = value ; = declarationIR as constantDeclarationIR
      -- let Ci_1 = $add_value_inst(p, Ci_0, nameIR, value)
      -- let constantDeclarationIR = annotationList const typeIR nameIR = value ;

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:52:1-79:30:
   rule instantiationIR-extern: p Ci_0 sto_0 |- declarationIR ==> Ci_1 sto_2 $wrap_decl(p, constantDeclarationIR as declarationIR)
      -- if declarationIR <: instantiationIR
      -- let _annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ; = declarationIR as instantiationIR
      -- let (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci_0, prefixedNameIR, argumentListIR)
      -- if (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} matches (_)
      -- let ?((_cid, consDyn, id_default*{id_default <- id_default*})) = (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?}
      -- let Ci_inner = $enter_path(Ci_0, nameIR)
      -- Constructor_inst: p Ci_inner sto_0 |- consDyn < typeArgumentListIR >( argumentListIR # id_default*{id_default <- id_default*} )==> sto_1 objDyn
      -- let objDyn' = objDyn
      -- if objDyn' matches `EXTERN{%%%%}`
      -- let extern{ tid theta venv renv } = objDyn'
      -- let Ci_decl = $empty_context_inst[path = Ci_0.path][global = Ci_0.global]
      -- let objectDeclarationListIR = $get_init_decls(objectInitializerOptIR)
      -- Decls_inst: block Ci_decl sto_1 |- objectDeclarationListIR as declarationIR* ==> Ci_decl_post sto_2 _declarationIR*{_declarationIR <- _declarationIR*}
      -- let venv_merged = $merge_venvs(venv, Ci_decl_post.block.venv)
      -- let renv_merged = $merge_renv_with_extern(renv, Ci_decl_post.block.renv)
      -- let objDyn_1 = extern{ tid theta venv_merged renv_merged }
      -- let oid = Ci_0.path ++ [nameIR]
      -- let sto_3 = $add_sto(sto_2, oid, objDyn_1)
      -- let Ci_1 = $add_value_inst(p, Ci_0, nameIR, ! oid as value)
      -- let constantDeclarationIR = const typeIR nameIR = ! oid as value ;

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:85:1-102:30:
   rule instantiationIR-non-extern: p Ci_0 sto_0 |- declarationIR ==> Ci_1 sto_1 $wrap_decl(p, constantDeclarationIR as declarationIR)
      -- if declarationIR <: instantiationIR
      -- let _annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ; = declarationIR as instantiationIR
      -- let (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci_0, prefixedNameIR, argumentListIR)
      -- if (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} matches (_)
      -- let ?((_cid, consDyn, id_default*{id_default <- id_default*})) = (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?}
      -- let Ci_inner = $enter_path(Ci_0, nameIR)
      -- Constructor_inst: p Ci_inner sto_0 |- consDyn < typeArgumentListIR >( argumentListIR # id_default*{id_default <- id_default*} )==> sto_1 objDyn
      -- if ~$is_extern_object(objDyn)
      -- let oid = Ci_0.path ++ [nameIR]
      -- let sto_2 = $add_sto(sto_1, oid, objDyn)
      -- let Ci_1 = $add_value_inst(p, Ci_0, nameIR, ! oid as value)
      -- let constantDeclarationIR = const typeIR nameIR = ! oid as value ;

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:120:1-129:65:
   rule functionDeclarationIR: p Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
      -- if declarationIR <: functionDeclarationIR
      -- let _annotationList typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR ) blockStatementIR = declarationIR as functionDeclarationIR
      -- let rid = $rid_IR(nameIR, parameterListIR)
      -- let funcDyn = function< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ) blockStatementIR
      -- let Ci_1 = $add_routine_overload_inst(p, Ci_0, rid, funcDyn as routineDyn)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:135:1-140:69:
   rule actionDeclarationIR: p Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
      -- if declarationIR <: actionDeclarationIR
      -- let _annotationList action nameIR ( parameterListIR ) blockStatementIR = declarationIR as actionDeclarationIR
      -- let rid = $rid_IR(nameIR, parameterListIR)
      -- let funcDyn = action( parameterListIR ){ blockStatementIR }
      -- let Ci_1 = $add_routine_non_overload_inst(p, Ci_0, rid, funcDyn as routineDyn)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:146:1-150:81:
   rule errorDeclarationIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: errorDeclarationIR
      -- let error{ nameIR*{nameIR <- nameIR*} } = declarationIR as errorDeclarationIR
      -- (let nameIR_field = $concat_text(["error.", nameIR]))*{nameIR <- nameIR*, nameIR_field <- nameIR_field*}
      -- let Ci_1 = $add_values_inst(global, Ci_0, nameIR_field*{nameIR_field <- nameIR_field*}, error. nameIR as value*{nameIR <- nameIR*})

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:156:1-159:80:
   rule matchKindDeclarationIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: matchKindDeclarationIR
      -- let match_kind{ nameIR*{nameIR <- nameIR*} } = declarationIR as matchKindDeclarationIR
      -- let Ci_1 = $add_values_inst(global, Ci_0, nameIR*{nameIR <- nameIR*}, match_kind. nameIR as value*{nameIR <- nameIR*})

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:167:1-178:65:
   rule externFunctionDeclarationIR: p Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
      -- if declarationIR <: externFunctionDeclarationIR
      -- let _annotationList extern typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR ) ; = declarationIR as externFunctionDeclarationIR
      -- let rid = $rid_IR(nameIR, parameterListIR)
      -- let funcDyn = extern_function< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ){ ?() }
      -- let Ci_1 = $add_routine_overload_inst(p, Ci_0, rid, funcDyn as routineDyn)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:204:1-223:60:
   rule extern-object-no-constructors: p Ci_0 sto |- declarationIR ==> Ci_2 sto ?()
      -- if declarationIR <: externObjectDeclarationIR
      -- let annotationList extern nameIR < typeParameterListIR , typeParameterListIR_inferred >{ methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} } = declarationIR as externObjectDeclarationIR
      -- let (methodPrototypeIR'*{methodPrototypeIR' <- methodPrototypeIR'*}, methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*}) = $split_constructors_IR(methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*})
      -- if methodPrototypeIR'*{methodPrototypeIR' <- methodPrototypeIR'*} matches []
      -- Bind_methods: $empty_rdenv |- methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*} ==> rdenv
      -- let externObjectTypeIR = extern nameIR rdenv
      -- let polyTypeDefIR = externObjectTypeIR as typeIR < typeParameterListIR , [] >
      -- let Ci_1 = $add_typedef_inst(p, Ci_0, nameIR, polyTypeDefIR as typeDefIR)
      -- let cid = $cid_IR(nameIR, [])
      -- let consDyn = extern nameIR < typeParameterListIR >( [] ){ methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*} }
      -- let Ci_2 = $add_constructor_inst(p, Ci_1, cid, consDyn)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:225:1-241:120:
   rule extern-object-with-constructors: p Ci_0 sto |- declarationIR ==> Ci_2 sto ?()
      -- if declarationIR <: externObjectDeclarationIR
      -- let annotationList extern nameIR < typeParameterListIR , typeParameterListIR_inferred >{ methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} } = declarationIR as externObjectDeclarationIR
      -- let (methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*}, methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*}) = $split_constructors_IR(methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*})
      -- Bind_methods: $empty_rdenv |- methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*} ==> rdenv
      -- let externObjectTypeIR = extern nameIR rdenv
      -- let polyTypeDefIR = externObjectTypeIR as typeIR < typeParameterListIR , [] >
      -- let Ci_1 = $add_typedef_inst(p, Ci_0, nameIR, polyTypeDefIR as typeDefIR)
      -- Bind_constructors: p Ci_1 typeParameterListIR methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*} |- methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*} ==> Ci_2

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:250:1-260:60:
   rule parserDeclarationIR: p Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
      -- if declarationIR <: parserDeclarationIR
      -- let _annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR } = declarationIR as parserDeclarationIR
      -- let cid = $cid_IR(nameIR, constructorParameterListIR)
      -- let consDyn = parser< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }
      -- let Ci_1 = $add_constructor_inst(p, Ci_0, cid, consDyn)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:269:1-280:60:
   rule controlDeclarationIR: p Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
      -- if declarationIR <: controlDeclarationIR
      -- let _annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR } = declarationIR as controlDeclarationIR
      -- let cid = $cid_IR(nameIR, constructorParameterListIR)
      -- let consDyn = control< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }
      -- let Ci_1 = $add_constructor_inst(p, Ci_0, cid, consDyn)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:293:1-299:85:
   rule typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-enum: cursor Ci_0 sto |- declarationIR ==> Ci_2 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: enumTypeDeclarationIR
      -- let enumTypeDeclarationIR = declarationIR as enumTypeDeclarationIR
      -- if enumTypeDeclarationIR matches `%ENUM%{%}`
      -- let _annotationList enum nameIR { nameIR_mem*{nameIR_mem <- nameIR_mem*} } = enumTypeDeclarationIR
      -- (let nameIR_path = $concat_text([nameIR, ".", nameIR_mem]))*{nameIR_mem <- nameIR_mem*, nameIR_path <- nameIR_path*}
      -- let Ci_1 = $add_values_inst(global, Ci_0, nameIR_path*{nameIR_path <- nameIR_path*}, nameIR . nameIR_mem as value*{nameIR_mem <- nameIR_mem*})
      -- let Ci_2 = $add_typedef_inst(global, Ci_1, nameIR, enum nameIR { nameIR_mem*{nameIR_mem <- nameIR_mem*} } as typeDefIR)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:304:1-313:113:
   rule typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-serializableEnum: cursor Ci_0 sto_0 |- declarationIR ==> Ci_2 sto_1 ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: enumTypeDeclarationIR
      -- let enumTypeDeclarationIR = declarationIR as enumTypeDeclarationIR
      -- if enumTypeDeclarationIR matches `%ENUM%%{%}`
      -- let _annotationList enum typeIR nameIR { nameIR_mem = typedExpressionIR*{nameIR_mem <- nameIR_mem*, typedExpressionIR <- typedExpressionIR*} } = enumTypeDeclarationIR
      -- Exprs_inst: global Ci_0 sto_0 |- typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} ==> sto_1 value_mem*{value_mem <- value_mem*}
      -- (let nameIR_path = $concat_text([nameIR, ".", nameIR_mem]))*{nameIR_mem <- nameIR_mem*, nameIR_path <- nameIR_path*}
      -- let Ci_1 = $add_values_inst(global, Ci_0, nameIR_path*{nameIR_path <- nameIR_path*}, nameIR . nameIR_mem # value_mem as value*{nameIR_mem <- nameIR_mem*, value_mem <- value_mem*})
      -- let Ci_2 = $add_typedef_inst(global, Ci_1, nameIR, enum nameIR # typeIR { nameIR_mem = value_mem ;*{nameIR_mem <- nameIR_mem*, value_mem <- value_mem*} } as typeDefIR)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:321:1-331:66:
   rule typeDeclarationIR-derivedTypeDeclarationIR-structTypeDeclarationIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: structTypeDeclarationIR
      -- let _annotationList struct nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR*{typeFieldIR <- typeFieldIR*} } = declarationIR as structTypeDeclarationIR
      -- (let _annotationList' typeIR nameIR_field ; = typeFieldIR)*{_annotationList' <- _annotationList'*, nameIR_field <- nameIR_field*, typeFieldIR <- typeFieldIR*, typeIR <- typeIR*}
      -- let typeDefIR = struct nameIR { typeIR nameIR_field ;*{nameIR_field <- nameIR_field*, typeIR <- typeIR*} } as typeIR < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
      -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeDefIR)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:339:1-349:66:
   rule typeDeclarationIR-derivedTypeDeclarationIR-headerTypeDeclarationIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: headerTypeDeclarationIR
      -- let _annotationList header nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR*{typeFieldIR <- typeFieldIR*} } = declarationIR as headerTypeDeclarationIR
      -- (let _annotationList' typeIR nameIR_field ; = typeFieldIR)*{_annotationList' <- _annotationList'*, nameIR_field <- nameIR_field*, typeFieldIR <- typeFieldIR*, typeIR <- typeIR*}
      -- let typeDefIR = header nameIR { typeIR nameIR_field ;*{nameIR_field <- nameIR_field*, typeIR <- typeIR*} } as typeIR < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
      -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeDefIR)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:357:1-367:66:
   rule typeDeclarationIR-derivedTypeDeclarationIR-headerUnionTypeDeclarationIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: headerUnionTypeDeclarationIR
      -- let _annotationList header_union nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR*{typeFieldIR <- typeFieldIR*} } = declarationIR as headerUnionTypeDeclarationIR
      -- (let _annotationList' typeIR nameIR_field ; = typeFieldIR)*{_annotationList' <- _annotationList'*, nameIR_field <- nameIR_field*, typeFieldIR <- typeFieldIR*, typeIR <- typeIR*}
      -- let typeDefIR = header_union nameIR { typeIR nameIR_field ;*{nameIR_field <- nameIR_field*, typeIR <- typeIR*} } as typeIR < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
      -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeDefIR)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:377:1-382:71:
   rule typeDeclarationIR-typedefDeclarationIR-typedef-typeIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: typedefDeclarationIR
      -- let typedefDeclarationIR = declarationIR as typedefDeclarationIR
      -- if typedefDeclarationIR matches `%TYPEDEF%%;`
      -- let _annotationList typedef typedefTypeIR nameIR ; = typedefDeclarationIR
      -- if typedefTypeIR <: typeIR
      -- let typeIR = typedefTypeIR as typeIR
      -- let typeIR_typedef = typedef nameIR typeIR as typeIR
      -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeIR_typedef as typeDefIR)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:386:1-399:71:
   rule typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclarationIR-monoTypeDefIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: typedefDeclarationIR
      -- let typedefDeclarationIR = declarationIR as typedefDeclarationIR
      -- if typedefDeclarationIR matches `%TYPEDEF%%;`
      -- let _annotationList typedef typedefTypeIR nameIR ; = typedefDeclarationIR
      -- if typedefTypeIR <: derivedTypeDeclarationIR
      -- let derivedTypeDeclarationIR = typedefTypeIR as derivedTypeDeclarationIR
      -- Decl_inst: global Ci_0 $empty_sto |- derivedTypeDeclarationIR as declarationIR ==> Ci_local _sto _declarationIR?{_declarationIR <- _declarationIR?}
      -- let { tid*{tid <- tid*} } = $diff_set<tid>($dom_map<tid, typeDefIR>(Ci_local.global.tdenv), $dom_map<tid, typeDefIR>(Ci_0.global.tdenv))
      -- if tid*{tid <- tid*} matches [ _/1 ]
      -- let [tid_newtype] = tid*{tid <- tid*}
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(global, Ci_local, . tid_newtype)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- let typeDefIR'' = typeDefIR
      -- if typeDefIR'' <: monoTypeDefIR
      -- let monoTypeDefIR = typeDefIR'' as monoTypeDefIR
      -- let typeIR_typedef = typedef nameIR monoTypeDefIR as typeIR
      -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeIR_typedef as typeDefIR)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:401:1-414:71:
   rule typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclaration-polyTypeDefIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: typedefDeclarationIR
      -- let typedefDeclarationIR = declarationIR as typedefDeclarationIR
      -- if typedefDeclarationIR matches `%TYPEDEF%%;`
      -- let _annotationList typedef typedefTypeIR nameIR ; = typedefDeclarationIR
      -- if typedefTypeIR <: derivedTypeDeclarationIR
      -- let derivedTypeDeclarationIR = typedefTypeIR as derivedTypeDeclarationIR
      -- Decl_inst: global Ci_0 $empty_sto |- derivedTypeDeclarationIR as declarationIR ==> Ci_local _sto _declarationIR?{_declarationIR <- _declarationIR?}
      -- let { tid*{tid <- tid*} } = $diff_set<tid>($dom_map<tid, typeDefIR>(Ci_local.global.tdenv), $dom_map<tid, typeDefIR>(Ci_0.global.tdenv))
      -- if tid*{tid <- tid*} matches [ _/1 ]
      -- let [tid_newtype] = tid*{tid <- tid*}
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(global, Ci_local, . tid_newtype)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- let typeDefIR'' = typeDefIR
      -- if typeDefIR'' <: polyTypeDefIR
      -- let polyTypeDefIR = typeDefIR'' as polyTypeDefIR
      -- let typeIR_typedef = typedef nameIR polyTypeDefIR < [] > as typeIR as typeIR
      -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeIR_typedef as typeDefIR)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:418:1-423:71:
   rule typeDeclarationIR-typedefDeclarationIR-newtype: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: typedefDeclarationIR
      -- let typedefDeclarationIR = declarationIR as typedefDeclarationIR
      -- if typedefDeclarationIR matches `%TYPE%%;`
      -- let _annotationList type typeIR nameIR ; = typedefDeclarationIR
      -- let typeIR_newtype = type nameIR typeIR as typeIR
      -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeIR_newtype as typeDefIR)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:431:1-441:73:
   rule typeDeclarationIR-parserTypeDeclarationIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: parserTypeDeclarationIR
      -- let _annotationList parser nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{parameterIR <- parameterIR*} ); = declarationIR as parserTypeDeclarationIR
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let typeIR_parser = parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
      -- let typeDefIR_parser = typeIR_parser < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
      -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeDefIR_parser)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:449:1-459:74:
   rule typeDeclarationIR-controlTypeDeclarationIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: controlTypeDeclarationIR
      -- let _annotationList control nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{parameterIR <- parameterIR*} ); = declarationIR as controlTypeDeclarationIR
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let typeIR_control = control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
      -- let typeDefIR_control = typeIR_control < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
      -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeDefIR_control)

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:468:1-483:73:
   rule typeDeclarationIR-packageTypeDeclarationIR: p Ci_0 sto |- declarationIR ==> Ci_2 sto ?()
      -- if declarationIR <: packageTypeDeclarationIR
      -- let _annotationList package nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{parameterIR <- parameterIR*} ); = declarationIR as packageTypeDeclarationIR
      -- (let _annotationList' _direction typeIR _nameIR _constantInitializerOptIR = parameterIR)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _nameIR <- _nameIR*, parameterIR <- parameterIR*, typeIR <- typeIR*}
      -- let typeIR_package = package< typeIR*{typeIR <- typeIR*} > as typeIR
      -- let typeDefIR_package = typeIR_package < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
      -- let Ci_1 = $add_typedef_inst(p, Ci_0, nameIR, typeDefIR_package)
      -- let cid = $cid_IR(nameIR, parameterIR*{parameterIR <- parameterIR*})
      -- let consDyn_package = package< typeParameterListIR ++ typeParameterListIR_inferred >( parameterIR*{parameterIR <- parameterIR*} )
      -- let Ci_2 = $add_constructor_inst(global, Ci_1, cid, consDyn_package)

;; ../../../../reference-specs/p4-concrete/6.03-instantiation-relation.spectec:168:1-170:17:
relation Program_inst: |- p4programIR ==> cenv tdenv renv venv sto

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:508:1-514:72:
   rule : |- declarationIR*{declarationIR <- declarationIR*} ; ==> Ci_1.global.cenv Ci_1.global.tdenv Ci_1.global.renv Ci_1.global.venv sto_1
      -- let Ci_0 = $empty_context_inst
      -- let sto_0 = $empty_sto
      -- Decls_inst: global Ci_0 sto_0 |- declarationIR*{declarationIR <- declarationIR*} ==> Ci_1 sto_1 declarationIR'*{declarationIR' <- declarationIR'*}
      -- if declarationIR'*{declarationIR' <- declarationIR'*} matches []

;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:6:1-6:84:
def $partition_default_parameters(parameterIR*, id*) : (parameterIR*, parameterIR*) =

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:8:1-8:65:
   clause 0(parameterIR*{parameterIR <- parameterIR*}, id_default*{id_default <- id_default*}) = ([], [])
      -- if parameterIR*{parameterIR <- parameterIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:9:1-17:28:
   clause 1(parameterIR*{parameterIR <- parameterIR*}, id_default*{id_default <- id_default*}) = (parameterIR_nondefault*{parameterIR_nondefault <- parameterIR_nondefault*}, parameterIR_h :: parameterIR_default*{parameterIR_default <- parameterIR_default*})
      -- if parameterIR*{parameterIR <- parameterIR*} matches _ :: _
      -- let parameterIR_h :: parameterIR_t*{parameterIR_t <- parameterIR_t*} = parameterIR*{parameterIR <- parameterIR*}
      -- let _annotationList _direction _typeIR id_h _constantInitializerOptIR = parameterIR_h
      -- let (parameterIR_nondefault*{parameterIR_nondefault <- parameterIR_nondefault*}, parameterIR_default*{parameterIR_default <- parameterIR_default*}) = $partition_default_parameters(parameterIR_t*{parameterIR_t <- parameterIR_t*}, id_default*{id_default <- id_default*})
      -- if id_h <- id_default*{id_default <- id_default*}

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:19:1-27:31:
   clause 2(parameterIR*{parameterIR <- parameterIR*}, id_default*{id_default <- id_default*}) = (parameterIR_h :: parameterIR_nondefault*{parameterIR_nondefault <- parameterIR_nondefault*}, parameterIR_default*{parameterIR_default <- parameterIR_default*})
      -- if parameterIR*{parameterIR <- parameterIR*} matches _ :: _
      -- let parameterIR_h :: parameterIR_t*{parameterIR_t <- parameterIR_t*} = parameterIR*{parameterIR <- parameterIR*}
      -- let _annotationList _direction _typeIR id_h _constantInitializerOptIR = parameterIR_h
      -- let (parameterIR_nondefault*{parameterIR_nondefault <- parameterIR_nondefault*}, parameterIR_default*{parameterIR_default <- parameterIR_default*}) = $partition_default_parameters(parameterIR_t*{parameterIR_t <- parameterIR_t*}, id_default*{id_default <- id_default*})
      -- if ~id_h <- id_default*{id_default <- id_default*}

;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:30:1-30:146:
def $align_cparams_with_args(constructorParameterIR*, argumentIR*, id*) : (constructorParameterIR*, argumentIR*, constructorParameterIR*, value*) =

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:33:1-40:71:
   clause 0(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}) = (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*})
      -- let (constructorParameterIR_nondefault*{constructorParameterIR_nondefault <- constructorParameterIR_nondefault*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}) = $partition_default_parameters(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, id_default*{id_default <- id_default*})
      -- (let _annotationList _direction _typeIR id _constantInitializerOptIR = constructorParameterIR_nondefault)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_nondefault <- constructorParameterIR_nondefault*, id <- id*}
      -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}) = $align_cparams_with_args'({ id : constructorParameterIR_nondefault*{constructorParameterIR_nondefault <- constructorParameterIR_nondefault*, id <- id*} }, constructorParameterIR_nondefault*{constructorParameterIR_nondefault <- constructorParameterIR_nondefault*}, argumentIR*{argumentIR <- argumentIR*})
      -- (let _annotationList' _direction' _typeIR' _nameIR constantInitializerOptIR = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _direction' <- _direction'*, _nameIR <- _nameIR*, _typeIR' <- _typeIR'*, constantInitializerOptIR <- constantInitializerOptIR*, constructorParameterIR_default <- constructorParameterIR_default*}
      -- (if constantInitializerOptIR matches (_))*{constantInitializerOptIR <- constantInitializerOptIR*}
      -- (let ?(= value_default) = constantInitializerOptIR)*{constantInitializerOptIR <- constantInitializerOptIR*, value_default <- value_default*}

;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:31:1-31:142:
def $align_cparams_with_args'(map<id, constructorParameterIR>, constructorParameterIR*, argumentIR*) : (constructorParameterIR*, argumentIR*) =

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:42:1-42:99:
   clause 0({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}) = ([], [])
      -- if constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:43:1-50:63:
   clause 1({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}) = (constructorParameterIR_h :: constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_h :: argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*})
      -- if constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} matches _ :: _
      -- let constructorParameterIR_h :: constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*} = constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}
      -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
      -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
      -- let argumentIR' = argumentIR_h
      -- if argumentIR' <: typedExpressionIR
      -- let typedExpressionIR = argumentIR' as typedExpressionIR
      -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}) = $align_cparams_with_args'({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*}, argumentIR_t*{argumentIR_t <- argumentIR_t*})

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:51:1-58:63:
   clause 2({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}) = (constructorParameterIR_h :: constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_h :: argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*})
      -- if constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} matches _ :: _
      -- let constructorParameterIR_h :: constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*} = constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}
      -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
      -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
      -- if (argumentIR_h = _)
      -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}) = $align_cparams_with_args'({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*}, argumentIR_t*{argumentIR_t <- argumentIR_t*})

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:59:1-68:63:
   clause 3({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}) = (constructorParameterIR_matching :: constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_h :: argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*})
      -- if constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} matches _ :: _
      -- let constructorParameterIR_h :: constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*} = constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}
      -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
      -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
      -- let argumentIR' = argumentIR_h
      -- if argumentIR' matches `%=%`
      -- let nameIR = _typedExpressionIR = argumentIR'
      -- let constructorParameterIR'?{constructorParameterIR' <- constructorParameterIR'?} = $find_map<id, constructorParameterIR>({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, nameIR)
      -- if constructorParameterIR'?{constructorParameterIR' <- constructorParameterIR'?} matches (_)
      -- let ?(constructorParameterIR_matching) = constructorParameterIR'?{constructorParameterIR' <- constructorParameterIR'?}
      -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}) = $align_cparams_with_args'({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*}, argumentIR_t*{argumentIR_t <- argumentIR_t*})

;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:197:1-197:59:
def $init_table(tablePropertyListIR) : tablePropertyListIR =

   ;; ../../../../reference-specs/p4-concrete/6.04-instantiation-constructor.spectec:200:1-200:59:
   clause 0(tablePropertyListIR) = tablePropertyListIR

;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:11:1-11:55:
def $wrap_decl(cursor, declarationIR) : declarationIR? =

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:13:1-13:44:
   clause 0(cursor, declarationIR) = ?()
      -- if cursor matches `GLOBAL`

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:14:1-14:49:
   clause 1(_cursor, declarationIR) = ?(declarationIR)

;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:28:1-28:70:
def $get_init_decls(objectInitializerOptIR) : objectDeclarationListIR =

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:30:1-30:31:
   clause 0(objectInitializerIR?{objectInitializerIR <- objectInitializerIR?}) = []
      -- if objectInitializerIR?{objectInitializerIR <- objectInitializerIR?} matches ()

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:31:1-31:79:
   clause 1(objectInitializerOptIR) = objectDeclarationListIR
      -- if objectInitializerOptIR matches (_)
      -- let ?(={ objectDeclarationListIR }) = objectInitializerOptIR

;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:34:1-34:36:
def $merge_venvs(venv, venv) : venv =

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:36:1-37:44:
   clause 0(venv, { id : value*{id <- id*, value <- value*} }) = $adds_map<id, value>(venv, id*{id <- id*}, value*{value <- value*})

;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:40:1-40:47:
def $merge_renv_with_extern(renv, renv) : renv =

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:42:1-42:51:
   clause 0(renv, set<pair<rid, routineDyn>>) = renv
      -- if (set<pair<rid, routineDyn>> = { [] })

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:43:1-50:18:
   clause 1(renv, { pair<rid, routineDyn>*{pair<rid, routineDyn> <- pair<rid, routineDyn>*} }) = $merge_renv_with_extern(renv_post, { rid_t : routineDyn_t*{rid_t <- rid_t*, routineDyn_t <- routineDyn_t*} })
      -- if pair<rid, routineDyn>*{pair<rid, routineDyn> <- pair<rid, routineDyn>*} matches _ :: _
      -- let rid_h : routineDyn_h :: rid_t : routineDyn_t*{rid_t <- rid_t*, routineDyn_t <- routineDyn_t*} = pair<rid, routineDyn>*{pair<rid, routineDyn> <- pair<rid, routineDyn>*}
      -- let routineDyn = routineDyn_h
      -- if routineDyn <: funcDyn
      -- let funcDyn = routineDyn as funcDyn
      -- if funcDyn matches `FUNCTION<%>(%)%`
      -- let function< typeParameterListIR >( parameterListIR ) blockStatementIR = funcDyn
      -- let routineDyn_h_post = extern_method< typeParameterListIR >( parameterListIR ) ?(blockStatementIR) as routineDyn
      -- let renv_post = $update_map<rid, routineDyn>(renv, rid_h, routineDyn_h_post)

;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:81:1-81:37:
def $is_extern_object(objDyn) : bool =

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:82:1-82:50:
   clause 0(objDyn) = true
      -- if objDyn matches `EXTERN{%%%%}`
      -- let extern{ _tid _theta _venv _renv } = objDyn

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:83:1-83:33:
   clause 1(_objDyn) = false

;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:108:1-108:43:
def $rid_IR(nameIR, parameterListIR) : rid =

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:111:1-111:70:
   clause 0(nameIR, parameterIR*{parameterIR <- parameterIR*}) = nameIR ( $pid_IR(parameterIR)*{parameterIR <- parameterIR*} )

;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:109:1-109:31:
def $pid_IR(parameterIR) : pid =

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:113:1-113:48:
   clause 0(_annotationList _direction _typeIR nameIR constantInitializerIR?{constantInitializerIR <- constantInitializerIR?}) = nameIR # false
      -- if constantInitializerIR?{constantInitializerIR <- constantInitializerIR?} matches ()

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:114:1-114:65:
   clause 1(_annotationList _direction _typeIR nameIR constantInitializerOptIR) = nameIR # true
      -- if constantInitializerOptIR matches (_)
      -- let ?(constantInitializerIR) = constantInitializerOptIR

;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:116:1-116:54:
def $cid_IR(nameIR, constructorParameterListIR) : cid =

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:118:1-118:94:
   clause 0(nameIR, constructorParameterListIR) = $rid_IR(nameIR, constructorParameterListIR)

;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:182:1-182:90:
def $split_constructors_IR(methodPrototypeIR*) : (methodPrototypeIR*, methodPrototypeIR*) =

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:184:1-184:45:
   clause 0(methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}) = ([], [])
      -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches []

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:185:1-190:53:
   clause 1(methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}) = (methodPrototypeIR_h :: methodPrototypeIR_t_constructor*{methodPrototypeIR_t_constructor <- methodPrototypeIR_t_constructor*}, methodPrototypeIR_t_method*{methodPrototypeIR_t_method <- methodPrototypeIR_t_method*})
      -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches _ :: _
      -- let methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} = methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
      -- let methodPrototypeIR' = methodPrototypeIR_h
      -- if methodPrototypeIR' matches `%%<,%>(%);`
      -- let _annotationList _nameIR <, _typeParameterListIR >( _parameterListIR ); = methodPrototypeIR'
      -- let (methodPrototypeIR_t_constructor*{methodPrototypeIR_t_constructor <- methodPrototypeIR_t_constructor*}, methodPrototypeIR_t_method*{methodPrototypeIR_t_method <- methodPrototypeIR_t_method*}) = $split_constructors_IR(methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*})

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:191:1-196:53:
   clause 2(methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}) = (methodPrototypeIR_t_constructor*{methodPrototypeIR_t_constructor <- methodPrototypeIR_t_constructor*}, methodPrototypeIR_h :: methodPrototypeIR_t_method*{methodPrototypeIR_t_method <- methodPrototypeIR_t_method*})
      -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches _ :: _
      -- let methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} = methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
      -- let methodPrototypeIR' = methodPrototypeIR_h
      -- if methodPrototypeIR' matches `%%;`
      -- let _annotationList _functionPrototypeIR ; = methodPrototypeIR'
      -- let (methodPrototypeIR_t_constructor*{methodPrototypeIR_t_constructor <- methodPrototypeIR_t_constructor*}, methodPrototypeIR_t_method*{methodPrototypeIR_t_method <- methodPrototypeIR_t_method*}) = $split_constructors_IR(methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*})

   ;; ../../../../reference-specs/p4-concrete/6.08-instantiation-declaration.spectec:197:1-202:53:
   clause 3(methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}) = (methodPrototypeIR_t_constructor*{methodPrototypeIR_t_constructor <- methodPrototypeIR_t_constructor*}, methodPrototypeIR_h :: methodPrototypeIR_t_method*{methodPrototypeIR_t_method <- methodPrototypeIR_t_method*})
      -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches _ :: _
      -- let methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} = methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
      -- let methodPrototypeIR' = methodPrototypeIR_h
      -- if methodPrototypeIR' matches `%ABSTRACT%;`
      -- let _annotationList abstract _functionPrototypeIR ; = methodPrototypeIR'
      -- let (methodPrototypeIR_t_constructor*{methodPrototypeIR_t_constructor <- methodPrototypeIR_t_constructor*}, methodPrototypeIR_t_method*{methodPrototypeIR_t_method <- methodPrototypeIR_t_method*}) = $split_constructors_IR(methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*})
