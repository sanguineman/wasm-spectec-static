;; ../../../../examples/p4-concrete/0-aux.spectec:18:1-18:21:
def $sum



;; ../../../../examples/p4-concrete/0-aux.spectec:20:1-20:21:
def $max



;; ../../../../examples/p4-concrete/0-aux.spectec:22:1-22:21:
def $min



;; ../../../../examples/p4-concrete/0-aux.spectec:28:1-28:29:
def $int_to_text



;; ../../../../examples/p4-concrete/0-aux.spectec:30:1-30:31:
def $concat_text(text*)

1. Case analysis on text*

  1. Case (% matches pattern [])

    1. Return ""

  2. Case (% matches pattern _ :: _)

    1. (Let t_h :: t_t* be text*)

    2. Return t_h ++ $concat_text(t_t*)

;; ../../../../examples/p4-concrete/0-aux.spectec:34:1-34:37:
def $strip_prefix



;; ../../../../examples/p4-concrete/0-aux.spectec:35:1-35:37:
def $strip_suffix



;; ../../../../examples/p4-concrete/0-aux.spectec:41:1-41:23:
def $init_(nat')

1. If ((nat' = 0)), then

  1. Return []

2. Otherwise

  1. Return (nat' - 1) :: $init_((nat' - 1))

;; ../../../../examples/p4-concrete/0-aux.spectec:46:1-46:29:
def $repeat_<X>(X, nat')

1. If ((nat' = 0)), then

  1. Return []

2. Otherwise

  1. Return [X] ++ $repeat_<X>(X, (nat' - 1))

;; ../../../../examples/p4-concrete/0-aux.spectec:51:1-51:22:
def $rev_<X>



;; ../../../../examples/p4-concrete/0-aux.spectec:53:1-53:28:
def $concat_<X>



;; ../../../../examples/p4-concrete/0-aux.spectec:55:1-55:39:
def $partition_<X>



;; ../../../../examples/p4-concrete/0-aux.spectec:57:1-57:35:
def $assoc_<X, Y>



;; ../../../../examples/p4-concrete/0-aux.spectec:59:1-59:29:
def $distinct_<K>



;; ../../../../examples/p4-concrete/0-aux.spectec:65:17-65:24:
syntax set<K> = 
   | { K* }

;; ../../../../examples/p4-concrete/0-aux.spectec:67:1-67:27:
def $empty_set<K>

1. Return ({ [] })

;; ../../../../examples/p4-concrete/0-aux.spectec:70:1-70:33:
def $in_set<K>(K, ({ K_e* }))

1. Return K is in K_e*

;; ../../../../examples/p4-concrete/0-aux.spectec:73:1-73:47:
def $intersect_set<K>



;; ../../../../examples/p4-concrete/0-aux.spectec:75:1-75:43:
def $union_set<K>



;; ../../../../examples/p4-concrete/0-aux.spectec:77:1-77:37:
def $unions_set<K>



;; ../../../../examples/p4-concrete/0-aux.spectec:79:1-79:42:
def $diff_set<K>



;; ../../../../examples/p4-concrete/0-aux.spectec:81:1-81:39:
def $sub_set<K>



;; ../../../../examples/p4-concrete/0-aux.spectec:83:1-83:38:
def $eq_set<K>



;; ../../../../examples/p4-concrete/0-aux.spectec:89:21-89:27:
syntax pair<K, V> = 
   | K : V

;; ../../../../examples/p4-concrete/0-aux.spectec:91:20-91:35:
syntax map<K, V> = set<pair<K, V>>

;; ../../../../examples/p4-concrete/0-aux.spectec:93:1-93:33:
def $empty_map<K, V>

1. Return ({ [] })

;; ../../../../examples/p4-concrete/0-aux.spectec:96:1-96:39:
def $dom_map<K, V>(({ (K : V)* }))

1. Return ({ K* })

;; ../../../../examples/p4-concrete/0-aux.spectec:99:1-99:39:
def $find_map<K, V>



;; ../../../../examples/p4-concrete/0-aux.spectec:101:1-101:41:
def $find_maps<K, V>



;; ../../../../examples/p4-concrete/0-aux.spectec:103:1-103:48:
def $add_map<K, V>



;; ../../../../examples/p4-concrete/0-aux.spectec:105:1-105:51:
def $adds_map<K, V>



;; ../../../../examples/p4-concrete/0-aux.spectec:107:1-107:51:
def $update_map<K, V>



;; ../../../../examples/p4-concrete/1-syntax.spectec:6:1-7:7:
syntax trailingCommaOpt = 
   | 
   | ,

;; ../../../../examples/p4-concrete/1-syntax.spectec:14:1-16:35:
syntax number = 
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)

;; ../../../../examples/p4-concrete/1-syntax.spectec:22:24-22:57:
syntax stringLiteral = 
   | " text " hint(print "#%#")

;; ../../../../examples/p4-concrete/1-syntax.spectec:35:21-35:29:
syntax identifier = 
   | text

;; ../../../../examples/p4-concrete/1-syntax.spectec:36:25-36:34:
syntax typeIdentifier = 
   | text

;; ../../../../examples/p4-concrete/1-syntax.spectec:43:1-45:30:
syntax nonTypeName = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority

;; ../../../../examples/p4-concrete/1-syntax.spectec:48:1-49:23:
syntax prefixedNonTypeName = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName

;; ../../../../examples/p4-concrete/1-syntax.spectec:55:19-55:33:
syntax typeName = typeIdentifier

;; ../../../../examples/p4-concrete/1-syntax.spectec:58:1-59:21:
syntax prefixedTypeName = 
   | text
   | . typeName

;; ../../../../examples/p4-concrete/1-syntax.spectec:66:1-68:36:
syntax tableCustomName = 
   | text
   | text
   | apply
   | state
   | type
   | priority

;; ../../../../examples/p4-concrete/1-syntax.spectec:75:1-77:9:
syntax name = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list

;; ../../../../examples/p4-concrete/1-syntax.spectec:80:1-81:21:
syntax nameList = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list
   | nameList , name

;; ../../../../examples/p4-concrete/1-syntax.spectec:83:1-83:40:
def $flatten_nameList(nameList'')

1. If ((nameList'' has type name)), then

  1. (Let name be (nameList'' as name))

  2. Return [name]

1. Else Phantom#0

2. If ((nameList'' matches pattern `%,%`)), then

  1. (Let (nameList'' , name) be nameList'')

  2. Return $flatten_nameList(nameList'') ++ [name]

2. Else Phantom#1

;; ../../../../examples/p4-concrete/1-syntax.spectec:88:17-88:21:
syntax member = name

;; ../../../../examples/p4-concrete/1-syntax.spectec:94:20-94:45:
syntax direction = 
   | 
   | in
   | out
   | inout

;; ../../../../examples/p4-concrete/1-syntax.spectec:107:1-118:32:
syntax baseType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>

;; ../../../../examples/p4-concrete/1-syntax.spectec:126:26-126:64:
syntax specializedType = 
   | prefixedTypeName < typeArgumentList >

;; ../../../../examples/p4-concrete/1-syntax.spectec:129:1-130:20:
syntax namedType = 
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../examples/p4-concrete/1-syntax.spectec:136:26-136:51:
syntax headerStackType = 
   | namedType [ expression ]

;; ../../../../examples/p4-concrete/1-syntax.spectec:144:19-144:41:
syntax listType = 
   | list< typeArgument >

;; ../../../../examples/p4-concrete/1-syntax.spectec:150:20-150:47:
syntax tupleType = 
   | tuple< typeArgumentList >

;; ../../../../examples/p4-concrete/1-syntax.spectec:157:1-161:14:
syntax type = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >

;; ../../../../examples/p4-concrete/1-syntax.spectec:164:1-166:15:
syntax typeOrVoid = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | text

;; ../../../../examples/p4-concrete/1-syntax.spectec:172:24-172:28:
syntax typeParameter = name

;; ../../../../examples/p4-concrete/1-syntax.spectec:175:1-176:39:
syntax typeParameterList = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list
   | typeParameterList , typeParameter

;; ../../../../examples/p4-concrete/1-syntax.spectec:178:1-178:67:
def $flatten_typeParameterList(typeParameterList'')

1. If ((typeParameterList'' has type typeParameter)), then

  1. (Let typeParameter be (typeParameterList'' as typeParameter))

  2. Return [typeParameter]

1. Else Phantom#2

2. If ((typeParameterList'' matches pattern `%,%`)), then

  1. (Let (typeParameterList'' , typeParameter) be typeParameterList'')

  2. Return $flatten_typeParameterList(typeParameterList'') ++ [typeParameter]

2. Else Phantom#3

;; ../../../../examples/p4-concrete/1-syntax.spectec:184:1-185:27:
syntax typeParameterListOpt = 
   | 
   | < typeParameterList >

;; ../../../../examples/p4-concrete/1-syntax.spectec:187:1-187:73:
def $flatten_typeParameterListOpt(typeParameterListOpt)

1. Case analysis on typeParameterListOpt

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `<%>`)

    1. (Let (< typeParameterList >) be typeParameterListOpt)

    2. Return $flatten_typeParameterList(typeParameterList)

;; ../../../../examples/p4-concrete/1-syntax.spectec:199:3-199:52:
syntax parameter = 
   | annotationList direction type name initializerOpt

;; ../../../../examples/p4-concrete/1-syntax.spectec:202:1-203:39:
syntax nonEmptyParameterList = 
   | annotationList direction type name initializerOpt
   | nonEmptyParameterList , parameter

;; ../../../../examples/p4-concrete/1-syntax.spectec:206:1-207:26:
syntax parameterList = 
   | 
   | annotationList direction type name initializerOpt
   | nonEmptyParameterList , parameter

;; ../../../../examples/p4-concrete/1-syntax.spectec:209:1-209:55:
def $flatten_parameterList(parameterList)

1. If ((parameterList matches pattern ``EMPTY`)), then

  1. Return []

1. Else Phantom#4

2. If ((parameterList has type parameter)), then

  1. (Let parameter be (parameterList as parameter))

  2. Return [parameter]

2. Else Phantom#5

3. If ((parameterList has type nonEmptyParameterList)), then

  1. (Let nonEmptyParameterList' be (parameterList as nonEmptyParameterList))

  2. If ((nonEmptyParameterList' matches pattern `%,%`)), then

    1. (Let (nonEmptyParameterList , parameter) be nonEmptyParameterList')

    2. Return $flatten_parameterList((nonEmptyParameterList as parameterList)) ++ [parameter]

  2. Else Phantom#6

3. Else Phantom#7

;; ../../../../examples/p4-concrete/1-syntax.spectec:219:31-219:40:
syntax constructorParameter = parameter

;; ../../../../examples/p4-concrete/1-syntax.spectec:221:35-221:48:
syntax constructorParameterList = parameterList

;; ../../../../examples/p4-concrete/1-syntax.spectec:224:1-225:23:
syntax constructorParameterListOpt = 
   | 
   | ( parameterList )

;; ../../../../examples/p4-concrete/1-syntax.spectec:227:1-228:26:
def $flatten_constructorParameterListOpt(constructorParameterListOpt)

1. Case analysis on constructorParameterListOpt

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `(%)`)

    1. (Let (( parameterList )) be constructorParameterListOpt)

    2. Return $flatten_parameterList(parameterList)

;; ../../../../examples/p4-concrete/1-syntax.spectec:238:26-238:44:
syntax namedExpression = 
   | name = expression

;; ../../../../examples/p4-concrete/1-syntax.spectec:241:1-242:43:
syntax namedExpressionList = 
   | name = expression
   | namedExpressionList , namedExpression

;; ../../../../examples/p4-concrete/1-syntax.spectec:244:1-244:73:
def $flatten_namedExpressionList(namedExpressionList'')

1. If ((namedExpressionList'' has type namedExpression)), then

  1. (Let namedExpression be (namedExpressionList'' as namedExpression))

  2. Return [namedExpression]

1. Else Phantom#8

2. If ((namedExpressionList'' matches pattern `%,%`)), then

  1. (Let (namedExpressionList'' , namedExpression) be namedExpressionList'')

  2. Return $flatten_namedExpressionList(namedExpressionList'') ++ [namedExpression]

2. Else Phantom#9

;; ../../../../examples/p4-concrete/1-syntax.spectec:258:1-260:18:
syntax literalExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")

;; ../../../../examples/p4-concrete/1-syntax.spectec:267:1-268:9:
syntax referenceExpression = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this

;; ../../../../examples/p4-concrete/1-syntax.spectec:274:28-274:32:
syntax defaultExpression = 
   | ...

;; ../../../../examples/p4-concrete/1-syntax.spectec:282:15-282:32:
syntax unop = 
   | !
   | ~
   | -
   | +

;; ../../../../examples/p4-concrete/1-syntax.spectec:284:26-284:41:
syntax unaryExpression = 
   | unop expression

;; ../../../../examples/p4-concrete/1-syntax.spectec:287:1-289:35:
syntax binop = 
   | *
   | /
   | %
   | +
   | -
   | |+|
   | |-|
   | <<
   | >>
   | <=
   | >=
   | <
   | >
   | !=
   | ==
   | &
   | ^
   | |
   | ++
   | &&
   | ||

;; ../../../../examples/p4-concrete/1-syntax.spectec:291:27-291:54:
syntax binaryExpression = 
   | expression binop expression

;; ../../../../examples/p4-concrete/1-syntax.spectec:294:3-294:38:
syntax binaryExpressionNonBrace = 
   | expressionNonBrace binop expression

;; ../../../../examples/p4-concrete/1-syntax.spectec:297:3-297:41:
syntax ternaryExpression = 
   | expression ? expression : expression

;; ../../../../examples/p4-concrete/1-syntax.spectec:300:3-300:49:
syntax ternaryExpressionNonBrace = 
   | expressionNonBrace ? expression : expression

;; ../../../../examples/p4-concrete/1-syntax.spectec:306:25-306:45:
syntax castExpression = 
   | ( type ) expression

;; ../../../../examples/p4-concrete/1-syntax.spectec:315:1-316:48:
syntax dataExpression = 
   | {#}
   | { dataElementExpression trailingCommaOpt }

;; ../../../../examples/p4-concrete/1-syntax.spectec:325:3-325:18:
syntax errorAccessExpression = 
   | error. member

;; ../../../../examples/p4-concrete/1-syntax.spectec:328:3-328:29:
syntax memberAccessExpression = 
   | memberAccessBase . member

;; ../../../../examples/p4-concrete/1-syntax.spectec:331:1-332:45:
syntax indexAccessExpression = 
   | expression [ expression ]
   | expression [ expression : expression ]

;; ../../../../examples/p4-concrete/1-syntax.spectec:335:1-337:26:
syntax accessExpression = 
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]

;; ../../../../examples/p4-concrete/1-syntax.spectec:340:3-340:37:
syntax memberAccessExpressionNonBrace = 
   | memberAccessBaseNonBrace . member

;; ../../../../examples/p4-concrete/1-syntax.spectec:343:1-344:53:
syntax indexAccessExpressionNonBrace = 
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]

;; ../../../../examples/p4-concrete/1-syntax.spectec:347:1-349:34:
syntax accessExpressionNonBrace = 
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]

;; ../../../../examples/p4-concrete/1-syntax.spectec:363:1-364:62:
syntax callExpression = 
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )

;; ../../../../examples/p4-concrete/1-syntax.spectec:367:1-368:70:
syntax callExpressionNonBrace = 
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )

;; ../../../../examples/p4-concrete/1-syntax.spectec:374:34-374:49:
syntax parenthesizedExpression = 
   | ( expression )

;; ../../../../examples/p4-concrete/1-syntax.spectec:381:1-391:28:
syntax expression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../examples/p4-concrete/1-syntax.spectec:395:1-397:33:
syntax expressionList = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expressionList , expression

;; ../../../../examples/p4-concrete/1-syntax.spectec:399:1-399:58:
def $flatten_expressionList(expressionList'')

1. Case analysis on expressionList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%,%`)

    1. (Let (expressionList'' , expression) be expressionList'')

    2. Return $flatten_expressionList(expressionList'') ++ [expression]

1. Else Phantom#10

2. If ((expressionList'' has type expression)), then

  1. (Let expression be (expressionList'' as expression))

  2. Return [expression]

2. Else Phantom#11

;; ../../../../examples/p4-concrete/1-syntax.spectec:406:1-407:15:
syntax memberAccessBase = 
   | text
   | . typeName
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../examples/p4-concrete/1-syntax.spectec:409:36-409:50:
syntax sequenceElementExpression = expressionList

;; ../../../../examples/p4-concrete/1-syntax.spectec:412:1-415:54:
syntax recordElementExpression = 
   | name = expression
   | name = expression ,...
   | name = expression , namedExpressionList
   | name = expression , namedExpressionList ,...

;; ../../../../examples/p4-concrete/1-syntax.spectec:418:1-419:28:
syntax dataElementExpression = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expressionList , expression
   | name = expression
   | name = expression ,...
   | name = expression , namedExpressionList
   | name = expression , namedExpressionList ,...

;; ../../../../examples/p4-concrete/1-syntax.spectec:421:24-421:34:
syntax routineTarget = expression

;; ../../../../examples/p4-concrete/1-syntax.spectec:422:28-422:37:
syntax constructorTarget = namedType

;; ../../../../examples/p4-concrete/1-syntax.spectec:425:1-426:22:
syntax callTarget = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../examples/p4-concrete/1-syntax.spectec:433:1-441:28:
syntax expressionNonBrace = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../examples/p4-concrete/1-syntax.spectec:444:1-445:23:
syntax memberAccessBaseNonBrace = 
   | text
   | . typeName
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../examples/p4-concrete/1-syntax.spectec:447:32-447:50:
syntax routineTargetNonBrace = expressionNonBrace

;; ../../../../examples/p4-concrete/1-syntax.spectec:450:1-451:22:
syntax callTargetNonBrace = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../examples/p4-concrete/1-syntax.spectec:453:1-453:57:
def $expressionNonBrace(expressionNonBrace'')

1. Case analysis on expressionNonBrace''

  1. Case (% has type literalExpression)

    1. (Let literalExpression be (expressionNonBrace'' as literalExpression))

    2. Return (literalExpression as expression)

  2. Case (% has type referenceExpression)

    1. (Let referenceExpression be (expressionNonBrace'' as referenceExpression))

    2. Return (referenceExpression as expression)

  3. Case (% has type unaryExpression)

    1. (Let unaryExpression be (expressionNonBrace'' as unaryExpression))

    2. Return (unaryExpression as expression)

  4. Case (% has type binaryExpressionNonBrace)

    1. (Let (expressionNonBrace_l binop expression_r) be (expressionNonBrace'' as binaryExpressionNonBrace))

    2. (Let expression_l be $expressionNonBrace(expressionNonBrace_l))

    3. Return ((expression_l binop expression_r) as expression)

  5. Case (% has type ternaryExpressionNonBrace)

    1. (Let (expressionNonBrace_cond ? expression_true : expression_false) be (expressionNonBrace'' as ternaryExpressionNonBrace))

    2. (Let expression_cond be $expressionNonBrace(expressionNonBrace_cond))

    3. Return ((expression_cond ? expression_true : expression_false) as expression)

  6. Case (% has type castExpression)

    1. (Let castExpression be (expressionNonBrace'' as castExpression))

    2. Return (castExpression as expression)

  7. Case (% has type errorAccessExpression)

    1. (Let errorAccessExpression be (expressionNonBrace'' as errorAccessExpression))

    2. Return (errorAccessExpression as expression)

  8. Case (% has type memberAccessExpressionNonBrace)

    1. (Let (memberAccessBaseNonBrace . member) be (expressionNonBrace'' as memberAccessExpressionNonBrace))

    2. Case analysis on memberAccessBaseNonBrace

      1. Case (% has type prefixedTypeName)

        1. (Let prefixedTypeName be (memberAccessBaseNonBrace as prefixedTypeName))

        2. Return (((prefixedTypeName as memberAccessBase) . member) as expression)

      2. Case (% has type expressionNonBrace)

        1. (Let expressionNonBrace_base be (memberAccessBaseNonBrace as expressionNonBrace))

        2. (Let expression_base be $expressionNonBrace(expressionNonBrace_base))

        3. Return (((expression_base as memberAccessBase) . member) as expression)

  9. Case (% has type indexAccessExpressionNonBrace)

    1. (Let indexAccessExpressionNonBrace be (expressionNonBrace'' as indexAccessExpressionNonBrace))

    2. Case analysis on indexAccessExpressionNonBrace

      1. Case (% matches pattern `%[%]`)

        1. (Let (expressionNonBrace_base [ expression_index ]) be indexAccessExpressionNonBrace)

        2. (Let expression_base be $expressionNonBrace(expressionNonBrace_base))

        3. Return ((expression_base [ expression_index ]) as expression)

      2. Case (% matches pattern `%[%:%]`)

        1. (Let (expressionNonBrace_base [ expression_hi : expression_lo ]) be indexAccessExpressionNonBrace)

        2. (Let expression_base be $expressionNonBrace(expressionNonBrace_base))

        3. Return ((expression_base [ expression_hi : expression_lo ]) as expression)

  10. Case (% has type callExpressionNonBrace)

    1. (Let callExpressionNonBrace be (expressionNonBrace'' as callExpressionNonBrace))

    2. Case analysis on callExpressionNonBrace

      1. Case (% matches pattern `%(%)`)

        1. (Let (callTargetNonBrace ( argumentList )) be callExpressionNonBrace)

        2. Case analysis on callTargetNonBrace

          1. Case (% has type expressionNonBrace)

            1. (Let expressionNonBrace'' be (callTargetNonBrace as expressionNonBrace))

            2. (Let expression be $expressionNonBrace(expressionNonBrace''))

            3. Return (((expression as callTarget) ( argumentList )) as expression)

          2. Case (% has type constructorTarget)

            1. (Let constructorTarget be (callTargetNonBrace as constructorTarget))

            2. Return (((constructorTarget as callTarget) ( argumentList )) as expression)

      2. Case (% matches pattern `%<%>(%)`)

        1. (Let (expressionNonBrace'' < realTypeArgumentList >( argumentList )) be callExpressionNonBrace)

        2. (Let expression be $expressionNonBrace(expressionNonBrace''))

        3. Return ((expression < realTypeArgumentList >( argumentList )) as expression)

  11. Case (% has type parenthesizedExpression)

    1. (Let parenthesizedExpression be (expressionNonBrace'' as parenthesizedExpression))

    2. Return (parenthesizedExpression as expression)

;; ../../../../examples/p4-concrete/1-syntax.spectec:505:1-509:7:
syntax simpleKeysetExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _

;; ../../../../examples/p4-concrete/1-syntax.spectec:512:1-513:57:
syntax simpleKeysetExpressionList = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _
   | simpleKeysetExpressionList , simpleKeysetExpression

;; ../../../../examples/p4-concrete/1-syntax.spectec:515:1-516:28:
def $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList'')

1. If ((simpleKeysetExpressionList'' has type simpleKeysetExpression)), then

  1. (Let simpleKeysetExpression be (simpleKeysetExpressionList'' as simpleKeysetExpression))

  2. Return [simpleKeysetExpression]

1. Else Phantom#12

2. If ((simpleKeysetExpressionList'' matches pattern `%,%`)), then

  1. (Let (simpleKeysetExpressionList'' , simpleKeysetExpression) be simpleKeysetExpressionList'')

  2. Return $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList'') ++ [simpleKeysetExpression]

2. Else Phantom#13

;; ../../../../examples/p4-concrete/1-syntax.spectec:526:1-530:62:
syntax tupleKeysetExpression = 
   | ( expression &&& expression )
   | ( expression .. expression )
   | (default)
   | (_)
   | ( simpleKeysetExpression , simpleKeysetExpressionList )

;; ../../../../examples/p4-concrete/1-syntax.spectec:533:1-534:26:
syntax keysetExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _
   | ( expression &&& expression )
   | ( expression .. expression )
   | (default)
   | (_)
   | ( simpleKeysetExpression , simpleKeysetExpressionList )

;; ../../../../examples/p4-concrete/1-syntax.spectec:541:1-543:7:
syntax realTypeArgument = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _

;; ../../../../examples/p4-concrete/1-syntax.spectec:546:1-547:45:
syntax realTypeArgumentList = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | realTypeArgumentList , realTypeArgument

;; ../../../../examples/p4-concrete/1-syntax.spectec:549:1-549:76:
def $flatten_realTypeArgumentList(realTypeArgumentList'')

1. If ((realTypeArgumentList'' has type realTypeArgument)), then

  1. (Let realTypeArgument be (realTypeArgumentList'' as realTypeArgument))

  2. Return [realTypeArgument]

1. Else Phantom#14

2. If ((realTypeArgumentList'' matches pattern `%,%`)), then

  1. (Let (realTypeArgumentList'' , realTypeArgument) be realTypeArgumentList'')

  2. Return $flatten_realTypeArgumentList(realTypeArgumentList'') ++ [realTypeArgument]

2. Else Phantom#15

;; ../../../../examples/p4-concrete/1-syntax.spectec:555:1-556:16:
syntax typeArgument = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority

;; ../../../../examples/p4-concrete/1-syntax.spectec:560:1-562:37:
syntax typeArgumentList = 
   | 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | typeArgumentList , typeArgument

;; ../../../../examples/p4-concrete/1-syntax.spectec:564:1-564:64:
def $flatten_typeArgumentList(typeArgumentList'')

1. Case analysis on typeArgumentList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%,%`)

    1. (Let (typeArgumentList'' , typeArgument) be typeArgumentList'')

    2. Return $flatten_typeArgumentList(typeArgumentList'') ++ [typeArgument]

1. Else Phantom#16

2. If ((typeArgumentList'' has type typeArgument)), then

  1. (Let typeArgument be (typeArgumentList'' as typeArgument))

  2. Return [typeArgument]

2. Else Phantom#17

;; ../../../../examples/p4-concrete/1-syntax.spectec:575:1-578:7:
syntax argument = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _

;; ../../../../examples/p4-concrete/1-syntax.spectec:581:1-582:37:
syntax argumentListNonEmpty = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _
   | argumentListNonEmpty , argument

;; ../../../../examples/p4-concrete/1-syntax.spectec:585:1-586:25:
syntax argumentList = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _
   | argumentListNonEmpty , argument

;; ../../../../examples/p4-concrete/1-syntax.spectec:588:1-588:52:
def $flatten_argumentList(argumentList)

1. If ((argumentList matches pattern ``EMPTY`)), then

  1. Return []

1. Else Phantom#18

2. If ((argumentList has type argument)), then

  1. (Let argument be (argumentList as argument))

  2. Return [argument]

2. Else Phantom#19

3. If ((argumentList has type argumentListNonEmpty)), then

  1. (Let argumentListNonEmpty' be (argumentList as argumentListNonEmpty))

  2. If ((argumentListNonEmpty' matches pattern `%,%`)), then

    1. (Let (argumentListNonEmpty , argument) be argumentListNonEmpty')

    2. Return $flatten_argumentList((argumentListNonEmpty as argumentList)) ++ [argument]

  2. Else Phantom#20

3. Else Phantom#21

;; ../../../../examples/p4-concrete/1-syntax.spectec:599:1-603:16:
syntax lvalue = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | lvalue . member
   | lvalue [ expression ]
   | lvalue [ expression : expression ]
   | ( lvalue )

;; ../../../../examples/p4-concrete/1-syntax.spectec:613:25-613:27:
syntax emptyStatement = 
   | ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:620:1-622:34:
syntax assignop = 
   | =
   | +=
   | -=
   | |+|=
   | |-|=
   | *=
   | /=
   | %=
   | <<=
   | >>=
   | &=
   | ^=
   | |=

;; ../../../../examples/p4-concrete/1-syntax.spectec:624:30-624:59:
syntax assignmentStatement = 
   | lvalue assignop expression ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:631:1-632:54:
syntax callStatement = 
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );

;; ../../../../examples/p4-concrete/1-syntax.spectec:638:37-638:76:
syntax directApplicationStatement = 
   | namedType .apply( argumentList );

;; ../../../../examples/p4-concrete/1-syntax.spectec:645:1-646:25:
syntax returnStatement = 
   | return;
   | return expression ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:652:24-652:31:
syntax exitStatement = 
   | exit;

;; ../../../../examples/p4-concrete/1-syntax.spectec:660:25-660:70:
syntax blockStatement = 
   | annotationList { blockElementStatementList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:669:1-670:48:
syntax conditionalStatement = 
   | if( expression ) statement
   | if( expression ) statement else statement

;; ../../../../examples/p4-concrete/1-syntax.spectec:679:1-682:31:
syntax forInitStatement = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression

;; ../../../../examples/p4-concrete/1-syntax.spectec:685:1-686:53:
syntax forInitStatementListNonEmpty = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forInitStatementListNonEmpty , forInitStatement

;; ../../../../examples/p4-concrete/1-syntax.spectec:689:1-690:33:
syntax forInitStatementList = 
   | 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forInitStatementListNonEmpty , forInitStatement

;; ../../../../examples/p4-concrete/1-syntax.spectec:692:29-692:45:
syntax forUpdateStatement = forInitStatement

;; ../../../../examples/p4-concrete/1-syntax.spectec:695:1-696:57:
syntax forUpdateStatementListNonEmpty = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forUpdateStatementListNonEmpty , forUpdateStatement

;; ../../../../examples/p4-concrete/1-syntax.spectec:699:1-700:35:
syntax forUpdateStatementList = 
   | 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forUpdateStatementListNonEmpty , forUpdateStatement

;; ../../../../examples/p4-concrete/1-syntax.spectec:703:1-704:30:
syntax forCollectionExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression .. expression

;; ../../../../examples/p4-concrete/1-syntax.spectec:707:1-712:81:
syntax forStatement = 
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement

;; ../../../../examples/p4-concrete/1-syntax.spectec:719:1-720:23:
syntax switchLabel = 
   | default
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../examples/p4-concrete/1-syntax.spectec:723:1-724:19:
syntax switchCase = 
   | switchLabel : blockStatement
   | switchLabel :

;; ../../../../examples/p4-concrete/1-syntax.spectec:727:1-728:30:
syntax switchCaseList = 
   | 
   | switchCaseList switchCase

;; ../../../../examples/p4-concrete/1-syntax.spectec:730:1-730:58:
def $flatten_switchCaseList(switchCaseList'')

1. Case analysis on switchCaseList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (switchCaseList'' switchCase) be switchCaseList'')

    2. Return $flatten_switchCaseList(switchCaseList'') ++ [switchCase]

;; ../../../../examples/p4-concrete/1-syntax.spectec:735:26-735:68:
syntax switchStatement = 
   | switch( expression ){ switchCaseList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:741:25-741:33:
syntax breakStatement = 
   | break;

;; ../../../../examples/p4-concrete/1-syntax.spectec:743:28-743:39:
syntax continueStatement = 
   | continue;

;; ../../../../examples/p4-concrete/1-syntax.spectec:750:1-761:20:
syntax statement = 
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | return;
   | return expression ;
   | exit;
   | annotationList { blockElementStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement
   | break;
   | continue;
   | switch( expression ){ switchCaseList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:771:22-771:35:
syntax initializer = 
   | = expression

;; ../../../../examples/p4-concrete/1-syntax.spectec:774:3-774:48:
syntax constantDeclaration = 
   | annotationList const type name initializer ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:777:1-778:16:
syntax initializerOpt = 
   | 
   | = expression

;; ../../../../examples/p4-concrete/1-syntax.spectec:781:3-781:45:
syntax variableDeclaration = 
   | annotationList type name initializerOpt ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:784:1-786:14:
syntax blockElementStatement = 
   | annotationList const type name initializer ;
   | annotationList type name initializerOpt ;
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | return;
   | return expression ;
   | exit;
   | annotationList { blockElementStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement
   | break;
   | continue;
   | switch( expression ){ switchCaseList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:789:1-790:52:
syntax blockElementStatementList = 
   | 
   | blockElementStatementList blockElementStatement

;; ../../../../examples/p4-concrete/1-syntax.spectec:792:1-793:27:
def $flatten_blockElementStatementList(blockElementStatementList'')

1. Case analysis on blockElementStatementList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (blockElementStatementList'' blockElementStatement) be blockElementStatementList'')

    2. Return $flatten_blockElementStatementList(blockElementStatementList'') ++ [blockElementStatement]

;; ../../../../examples/p4-concrete/1-syntax.spectec:806:3-806:58:
syntax functionPrototype = 
   | typeOrVoid name typeParameterListOpt ( parameterList )

;; ../../../../examples/p4-concrete/1-syntax.spectec:809:3-809:50:
syntax functionDeclaration = 
   | annotationList functionPrototype blockStatement

;; ../../../../examples/p4-concrete/1-syntax.spectec:816:3-816:63:
syntax actionDeclaration = 
   | annotationList action name ( parameterList ) blockStatement

;; ../../../../examples/p4-concrete/1-syntax.spectec:824:28-824:57:
syntax objectInitializer = 
   | ={ objectDeclarationList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:828:1-829:68:
syntax instantiation = 
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:832:1-833:18:
syntax objectDeclaration = 
   | annotationList functionPrototype blockStatement
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:836:1-837:44:
syntax objectDeclarationList = 
   | 
   | objectDeclarationList objectDeclaration

;; ../../../../examples/p4-concrete/1-syntax.spectec:839:1-839:79:
def $flatten_objectDeclarationList(objectDeclarationList'')

1. Case analysis on objectDeclarationList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (objectDeclarationList'' objectDeclaration) be objectDeclarationList'')

    2. Return $flatten_objectDeclarationList(objectDeclarationList'') ++ [objectDeclaration]

;; ../../../../examples/p4-concrete/1-syntax.spectec:851:27-851:46:
syntax errorDeclaration = 
   | error{ nameList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:857:31-857:72:
syntax matchKindDeclaration = 
   | match_kind{ nameList trailingCommaOpt }

;; ../../../../examples/p4-concrete/1-syntax.spectec:868:1-869:76:
syntax enumTypeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }

;; ../../../../examples/p4-concrete/1-syntax.spectec:875:20-875:47:
syntax typeField = 
   | annotationList type name ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:878:1-879:28:
syntax typeFieldList = 
   | 
   | typeFieldList typeField

;; ../../../../examples/p4-concrete/1-syntax.spectec:881:1-881:55:
def $flatten_typeFieldList(typeFieldList'')

1. Case analysis on typeFieldList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (typeFieldList'' typeField) be typeFieldList'')

    2. Return $flatten_typeFieldList(typeFieldList'') ++ [typeField]

;; ../../../../examples/p4-concrete/1-syntax.spectec:887:3-887:69:
syntax structTypeDeclaration = 
   | annotationList struct name typeParameterListOpt { typeFieldList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:890:3-890:69:
syntax headerTypeDeclaration = 
   | annotationList header name typeParameterListOpt { typeFieldList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:893:3-893:75:
syntax headerUnionTypeDeclaration = 
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:896:1-899:31:
syntax derivedTypeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:906:1-907:27:
syntax typedefType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:910:1-911:37:
syntax typedefDeclaration = 
   | annotationList typedef typedefType name ;
   | annotationList type type name ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:918:3-918:45:
syntax externFunctionDeclaration = 
   | annotationList extern functionPrototype ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:921:1-923:49:
syntax methodPrototype = 
   | annotationList typeIdentifier ( parameterList );
   | annotationList functionPrototype ;
   | annotationList abstract functionPrototype ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:926:1-927:40:
syntax methodPrototypeList = 
   | 
   | methodPrototypeList methodPrototype

;; ../../../../examples/p4-concrete/1-syntax.spectec:929:1-929:73:
def $flatten_methodPrototypeList(methodPrototypeList'')

1. Case analysis on methodPrototypeList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (methodPrototypeList'' methodPrototype) be methodPrototypeList'')

    2. Return $flatten_methodPrototypeList(methodPrototypeList'') ++ [methodPrototype]

;; ../../../../examples/p4-concrete/1-syntax.spectec:937:3-937:82:
syntax externObjectDeclaration = 
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:940:1-941:28:
syntax externDeclaration = 
   | annotationList extern functionPrototype ;
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:951:21-951:48:
syntax selectCase = 
   | keysetExpression : name ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:954:1-955:30:
syntax selectCaseList = 
   | 
   | selectCaseList selectCase

;; ../../../../examples/p4-concrete/1-syntax.spectec:957:1-957:58:
def $flatten_selectCaseList(selectCaseList'')

1. Case analysis on selectCaseList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (selectCaseList'' selectCase) be selectCaseList'')

    2. Return $flatten_selectCaseList(selectCaseList'') ++ [selectCase]

;; ../../../../examples/p4-concrete/1-syntax.spectec:962:27-962:73:
syntax selectExpression = 
   | select( expressionList ){ selectCaseList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:969:1-970:21:
syntax stateExpression = 
   | name ;
   | select( expressionList ){ selectCaseList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:973:1-974:31:
syntax transitionStatement = 
   | 
   | transition stateExpression

;; ../../../../examples/p4-concrete/1-syntax.spectec:981:1-983:21:
syntax valueSetType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | tuple< typeArgumentList >
   | text
   | . typeName

;; ../../../../examples/p4-concrete/1-syntax.spectec:986:3-986:69:
syntax valueSetDeclaration = 
   | annotationList value_set< valueSetType >( expression ) name ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:993:3-993:72:
syntax parserTypeDeclaration = 
   | annotationList parser name typeParameterListOpt ( parameterList );

;; ../../../../examples/p4-concrete/1-syntax.spectec:1001:31-1001:70:
syntax parserBlockStatement = 
   | annotationList { parserStatementList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:1004:1-1011:25:
syntax parserStatement = 
   | annotationList const type name initializer ;
   | annotationList type name initializerOpt ;
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | annotationList { parserStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement

;; ../../../../examples/p4-concrete/1-syntax.spectec:1014:1-1015:40:
syntax parserStatementList = 
   | 
   | parserStatementList parserStatement

;; ../../../../examples/p4-concrete/1-syntax.spectec:1017:1-1017:73:
def $flatten_parserStatementList(parserStatementList'')

1. Case analysis on parserStatementList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (parserStatementList'' parserStatement) be parserStatementList'')

    2. Return $flatten_parserStatementList(parserStatementList'') ++ [parserStatement]

;; ../../../../examples/p4-concrete/1-syntax.spectec:1023:3-1023:73:
syntax parserState = 
   | annotationList state name { parserStatementList transitionStatement }

;; ../../../../examples/p4-concrete/1-syntax.spectec:1026:1-1027:32:
syntax parserStateList = 
   | annotationList state name { parserStatementList transitionStatement }
   | parserStateList parserState

;; ../../../../examples/p4-concrete/1-syntax.spectec:1029:1-1029:61:
def $flatten_parserStateList(parserStateList'')

1. If ((parserStateList'' has type parserState)), then

  1. (Let parserState be (parserStateList'' as parserState))

  2. Return [parserState]

1. Else Phantom#22

2. If ((parserStateList'' matches pattern `%%`)), then

  1. (Let (parserStateList'' parserState) be parserStateList'')

  2. Return $flatten_parserStateList(parserStateList'') ++ [parserState]

2. Else Phantom#23

;; ../../../../examples/p4-concrete/1-syntax.spectec:1035:1-1038:24:
syntax parserLocalDeclaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList type name initializerOpt ;
   | annotationList value_set< valueSetType >( expression ) name ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:1041:1-1042:54:
syntax parserLocalDeclarationList = 
   | 
   | parserLocalDeclarationList parserLocalDeclaration

;; ../../../../examples/p4-concrete/1-syntax.spectec:1044:1-1045:28:
def $flatten_parserLocalDeclarationList(parserLocalDeclarationList'')

1. Case analysis on parserLocalDeclarationList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (parserLocalDeclarationList'' parserLocalDeclaration) be parserLocalDeclarationList'')

    2. Return $flatten_parserLocalDeclarationList(parserLocalDeclarationList'') ++ [parserLocalDeclaration]

;; ../../../../examples/p4-concrete/1-syntax.spectec:1054:3-1056:52:
syntax parserDeclaration = 
   | annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:1066:16-1066:21:
syntax const = 
   | const

;; ../../../../examples/p4-concrete/1-syntax.spectec:1069:1-1070:10:
syntax constOpt = 
   | 
   | const

;; ../../../../examples/p4-concrete/1-syntax.spectec:1072:1-1072:41:
def $flatten_constOpt(constOpt)

1. If ((constOpt matches pattern ``EMPTY`)), then

  1. Return ?()

1. Else Phantom#24

2. If ((constOpt has type const)), then

  1. (Let const be (constOpt as const))

  2. Return ?(const)

2. Else Phantom#25

;; ../../../../examples/p4-concrete/1-syntax.spectec:1080:19-1080:55:
syntax tableKey = 
   | expression : name annotationList ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:1083:1-1084:26:
syntax tableKeyList = 
   | 
   | tableKeyList tableKey

;; ../../../../examples/p4-concrete/1-syntax.spectec:1086:1-1086:52:
def $flatten_tableKeyList(tableKeyList'')

1. Case analysis on tableKeyList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (tableKeyList'' tableKey) be tableKeyList'')

    2. Return $flatten_tableKeyList(tableKeyList'') ++ [tableKey]

;; ../../../../examples/p4-concrete/1-syntax.spectec:1096:1-1097:42:
syntax tableActionReference = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | prefixedNonTypeName ( argumentList )

;; ../../../../examples/p4-concrete/1-syntax.spectec:1099:22-1099:60:
syntax tableAction = 
   | annotationList tableActionReference ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:1102:1-1103:32:
syntax tableActionList = 
   | 
   | tableActionList tableAction

;; ../../../../examples/p4-concrete/1-syntax.spectec:1105:1-1105:61:
def $flatten_tableActionList(tableActionList'')

1. Case analysis on tableActionList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (tableActionList'' tableAction) be tableActionList'')

    2. Return $flatten_tableActionList(tableActionList'') ++ [tableAction]

;; ../../../../examples/p4-concrete/1-syntax.spectec:1115:1-1116:35:
syntax tableEntryPriority = 
   | priority= number :
   | priority=( expression ):

;; ../../../../examples/p4-concrete/1-syntax.spectec:1119:1-1120:72:
syntax tableEntry = 
   | constOpt tableEntryPriority keysetExpression : tableActionReference annotationList ;
   | constOpt keysetExpression : tableActionReference annotationList ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:1123:1-1124:30:
syntax tableEntryList = 
   | 
   | tableEntryList tableEntry

;; ../../../../examples/p4-concrete/1-syntax.spectec:1126:1-1126:58:
def $flatten_tableEntryList(tableEntryList'')

1. Case analysis on tableEntryList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (tableEntryList'' tableEntry) be tableEntryList'')

    2. Return $flatten_tableEntryList(tableEntryList'') ++ [tableEntry]

;; ../../../../examples/p4-concrete/1-syntax.spectec:1136:1-1139:59:
syntax tableProperty = 
   | key={ tableKeyList }
   | actions={ tableActionList }
   | annotationList constOpt entries={ tableEntryList }
   | annotationList constOpt tableCustomName initializer ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:1142:1-1143:36:
syntax tablePropertyList = 
   | 
   | tablePropertyList tableProperty

;; ../../../../examples/p4-concrete/1-syntax.spectec:1145:1-1145:67:
def $flatten_tablePropertyList(tablePropertyList'')

1. Case analysis on tablePropertyList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (tablePropertyList'' tableProperty) be tablePropertyList'')

    2. Return $flatten_tablePropertyList(tablePropertyList'') ++ [tableProperty]

;; ../../../../examples/p4-concrete/1-syntax.spectec:1151:3-1151:51:
syntax tableDeclaration = 
   | annotationList table name { tablePropertyList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:1158:3-1158:73:
syntax controlTypeDeclaration = 
   | annotationList control name typeParameterListOpt ( parameterList );

;; ../../../../examples/p4-concrete/1-syntax.spectec:1164:22-1164:36:
syntax controlBody = blockStatement

;; ../../../../examples/p4-concrete/1-syntax.spectec:1167:1-1171:21:
syntax controlLocalDeclaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList type name initializerOpt ;
   | annotationList action name ( parameterList ) blockStatement
   | annotationList table name { tablePropertyList }

;; ../../../../examples/p4-concrete/1-syntax.spectec:1174:1-1175:56:
syntax controlLocalDeclarationList = 
   | 
   | controlLocalDeclarationList controlLocalDeclaration

;; ../../../../examples/p4-concrete/1-syntax.spectec:1177:1-1178:29:
def $flatten_controlLocalDeclarationList(controlLocalDeclarationList'')

1. Case analysis on controlLocalDeclarationList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (controlLocalDeclarationList'' controlLocalDeclaration) be controlLocalDeclarationList'')

    2. Return $flatten_controlLocalDeclarationList(controlLocalDeclarationList'') ++ [controlLocalDeclaration]

;; ../../../../examples/p4-concrete/1-syntax.spectec:1188:3-1190:55:
syntax controlDeclaration = 
   | annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody }

;; ../../../../examples/p4-concrete/1-syntax.spectec:1197:3-1197:73:
syntax packageTypeDeclaration = 
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../examples/p4-concrete/1-syntax.spectec:1204:1-1208:27:
syntax typeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }
   | annotationList typedef typedefType name ;
   | annotationList type type name ;
   | annotationList parser name typeParameterListOpt ( parameterList );
   | annotationList control name typeParameterListOpt ( parameterList );
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../examples/p4-concrete/1-syntax.spectec:1215:1-1224:20:
syntax declaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList functionPrototype blockStatement
   | annotationList action name ( parameterList ) blockStatement
   | error{ nameList }
   | match_kind{ nameList trailingCommaOpt }
   | annotationList extern functionPrototype ;
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }
   | annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList }
   | annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody }
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }
   | annotationList typedef typedefType name ;
   | annotationList type type name ;
   | annotationList parser name typeParameterListOpt ( parameterList );
   | annotationList control name typeParameterListOpt ( parameterList );
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../examples/p4-concrete/1-syntax.spectec:1231:1-1248:27:
syntax annotationToken = 
   | unexpected_token
   | abstract
   | action
   | actions
   | apply
   | bool
   | bit
   | break
   | const
   | continue
   | control
   | default
   | else
   | entries
   | enum
   | error
   | exit
   | extern
   | false
   | for
   | header
   | header_union
   | if
   | in
   | inout
   | int
   | key
   | match_kind
   | type
   | out
   | parser
   | package
   | pragma
   | return
   | select
   | state
   | string
   | struct
   | switch
   | table
   | this
   | transition
   | true
   | tuple
   | typedef
   | varbit
   | value_set
   | list
   | void
   | _
   | text
   | text
   | " text " hint(print "#%#")
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | &&&
   | ..
   | <<
   | &&
   | ||
   | ==
   | !=
   | >=
   | <=
   | ++
   | +
   | |+|
   | -
   | |-|
   | *
   | /
   | %
   | |
   | &
   | ^
   | ~
   | [
   | ]
   | {
   | }
   | <
   | >
   | !
   | :
   | ,
   | ?
   | .
   | =
   | ;
   | @

;; ../../../../examples/p4-concrete/1-syntax.spectec:1251:1-1253:35:
syntax annotationBody = 
   | 
   | annotationBody ( annotationBody )
   | annotationBody annotationToken

;; ../../../../examples/p4-concrete/1-syntax.spectec:1256:3-1256:41:
syntax structuredAnnotationBody = 
   | dataElementExpression trailingCommaOpt

;; ../../../../examples/p4-concrete/1-syntax.spectec:1259:1-1261:42:
syntax annotation = 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]

;; ../../../../examples/p4-concrete/1-syntax.spectec:1264:1-1265:38:
syntax annotationListNonEmpty = 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]
   | annotationListNonEmpty annotation

;; ../../../../examples/p4-concrete/1-syntax.spectec:1268:1-1269:27:
syntax annotationList = 
   | 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]
   | annotationListNonEmpty annotation

;; ../../../../examples/p4-concrete/1-syntax.spectec:1276:1-1278:17:
syntax p4program = 
   | 
   | p4program declaration
   | p4program ;

;; ../../../../examples/p4-concrete/1-syntax.spectec:1280:1-1280:49:
def $flatten_p4program(p4program'')

1. Case analysis on p4program''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (p4program'' declaration) be p4program'')

    2. Return $flatten_p4program(p4program'') ++ [declaration]

  3. Case (% matches pattern `%;`)

    1. (Let (p4program'' ;) be p4program'')

    2. Return $flatten_p4program(p4program'')

;; ../../../../examples/p4-concrete/2.0-domain.spectec:5:17-5:21:
syntax nameIR = text

;; ../../../../examples/p4-concrete/2.0-domain.spectec:7:1-7:25:
def $name(name)

1. Case analysis on name

  1. Case (% has type identifier)

    1. (Let (t) be (name as identifier))

    2. Return t

  2. Case (% has type typeIdentifier)

    1. (Let (t) be (name as typeIdentifier))

    2. Return t

1. Else Phantom#26

2. If ((name has type nonTypeName)), then

  1. (Let nonTypeName be (name as nonTypeName))

  2. Case analysis on nonTypeName

    1. Case (% matches pattern `APPLY`)

      1. Return "apply"

    2. Case (% matches pattern `KEY`)

      1. Return "key"

    3. Case (% matches pattern `ACTIONS`)

      1. Return "actions"

    4. Case (% matches pattern `STATE`)

      1. Return "state"

    5. Case (% matches pattern `ENTRIES`)

      1. Return "entries"

    6. Case (% matches pattern `TYPE`)

      1. Return "type"

    7. Case (% matches pattern `PRIORITY`)

      1. Return "priority"

  2. Else Phantom#27

2. Else Phantom#28

3. If ((name matches pattern `LIST`)), then

  1. Return "list"

3. Else Phantom#29

;; ../../../../examples/p4-concrete/2.0-domain.spectec:20:1-20:47:
def $tableCustomName(tableCustomName)

1. Case analysis on tableCustomName

  1. Case (% has type identifier)

    1. (Let (t) be (tableCustomName as identifier))

    2. Return t

  2. Case (% has type typeIdentifier)

    1. (Let (t) be (tableCustomName as typeIdentifier))

    2. Return t

1. Else Phantom#30

2. Case analysis on tableCustomName

  1. Case (% matches pattern `APPLY`)

    1. Return "apply"

  2. Case (% matches pattern `STATE`)

    1. Return "state"

  3. Case (% matches pattern `TYPE`)

    1. Return "type"

  4. Case (% matches pattern `PRIORITY`)

    1. Return "priority"

2. Else Phantom#31

;; ../../../../examples/p4-concrete/2.0-domain.spectec:33:13-33:17:
syntax id = text

;; ../../../../examples/p4-concrete/2.0-domain.spectec:39:14-39:16:
syntax tid = id

;; ../../../../examples/p4-concrete/2.0-domain.spectec:41:1-41:23:
def $fresh_tid



;; ../../../../examples/p4-concrete/2.0-domain.spectec:42:1-42:28:
def $fresh_tids(nat')

1. If ((nat' = 0)), then

  1. Return []

2. Otherwise

  1. Return $fresh_tid :: $fresh_tids((nat' - 1))

;; ../../../../examples/p4-concrete/2.0-domain.spectec:56:14-56:24:
syntax pid = 
   | id # bool

;; ../../../../examples/p4-concrete/2.0-domain.spectec:57:14-57:26:
syntax rid = 
   | id ( pid* )

;; ../../../../examples/p4-concrete/2.0-domain.spectec:59:1-59:36:
def $rid(name, parameterList)

1. Return ($name(name) ( $pids(parameterList) ))

;; ../../../../examples/p4-concrete/2.0-domain.spectec:60:1-60:32:
def $pids(parameterList)

1. If ((parameterList matches pattern ``EMPTY`)), then

  1. Return []

1. Else Phantom#32

2. If ((parameterList has type parameter)), then

  1. (Let parameter be (parameterList as parameter))

  2. Return [$pid(parameter)]

2. Else Phantom#33

3. If ((parameterList has type nonEmptyParameterList)), then

  1. (Let nonEmptyParameterList' be (parameterList as nonEmptyParameterList))

  2. If ((nonEmptyParameterList' matches pattern `%,%`)), then

    1. (Let (nonEmptyParameterList , parameter) be nonEmptyParameterList')

    2. Return $pids((nonEmptyParameterList as parameterList)) ++ [$pid(parameter)]

  2. Else Phantom#34

3. Else Phantom#35

;; ../../../../examples/p4-concrete/2.0-domain.spectec:61:1-61:26:
def $pid((_annotationList _direction _type name initializerOpt))

1. If ((initializerOpt matches pattern ``EMPTY`)), then

  1. Return ($name(name) # false)

1. Else Phantom#36

2. If ((initializerOpt has type initializer)), then

  1. (Let initializer be (initializerOpt as initializer))

  2. Return ($name(name) # true)

2. Else Phantom#37

;; ../../../../examples/p4-concrete/2.0-domain.spectec:78:14-78:17:
syntax cid = rid

;; ../../../../examples/p4-concrete/2.0-domain.spectec:80:1-80:50:
def $cid(name, constructorParameterListOpt)

1. Case analysis on constructorParameterListOpt

  1. Case (% matches pattern ``EMPTY`)

    1. Return ($name(name) ( [] ))

  2. Case (% matches pattern `(%)`)

    1. (Let (( parameterList )) be constructorParameterListOpt)

    2. Return ($name(name) ( $pids(parameterList) ))

;; ../../../../examples/p4-concrete/2.0-domain.spectec:88:1-88:48:
def $expression_as_lvalue(expression'')

1. Case analysis on expression''

  1. Case (% has type referenceExpression)

    1. (Let referenceExpression be (expression'' as referenceExpression))

    2. Return ?((referenceExpression as lvalue))

  2. Case (% has type memberAccessExpression)

    1. (Let (memberAccessBase . member) be (expression'' as memberAccessExpression))

    2. If ((memberAccessBase has type expression)), then

      1. (Let expression'' be (memberAccessBase as expression))

      2. (Let lvalue'? be $expression_as_lvalue(expression''))

      3. If ((lvalue'? matches pattern (_))), then

        1. (Let ?(lvalue) be lvalue'?)

        2. Return ?((lvalue . member))

      3. Else Phantom#38

    2. Else Phantom#39

  3. Case (% has type parenthesizedExpression)

    1. (Let (( expression'' )) be (expression'' as parenthesizedExpression))

    2. (Let lvalue'? be $expression_as_lvalue(expression''))

    3. If ((lvalue'? matches pattern (_))), then

      1. (Let ?(lvalue) be lvalue'?)

      2. Return ?((( lvalue )))

    3. Else Phantom#40

1. Else Phantom#41

;; ../../../../examples/p4-concrete/2.0-domain.spectec:99:14-99:17:
syntax oid = id*

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:14:1-17:15:
syntax primitiveValue = 
   | b bool
   | error. id
   | match_kind. id
   | " text "

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:24:1-25:21:
syntax numberValue = 
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:27:20-27:50:
syntax baseValue = 
   | b bool
   | error. id
   | match_kind. id
   | " text "
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:35:20-35:31:
syntax listValue = 
   | [ value* ]

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:36:21-36:32:
syntax tupleValue = 
   | ( value* )

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:37:27-37:55:
syntax headerStackValue = 
   | [ value* #( nat ; nat )]

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:39:21-39:32:
syntax fieldValue = 
   | value id ;

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:41:22-41:49:
syntax structValue = 
   | struct tid { fieldValue* }

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:42:22-42:49:
syntax headerValue = 
   | header tid { fieldValue* }

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:43:27-43:60:
syntax headerUnionValue = 
   | header_union tid { fieldValue* }

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:46:1-47:23:
syntax enumValue = 
   | tid . id
   | tid . id # value

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:50:1-56:14:
syntax dataValue = 
   | [ value* ]
   | ( value* )
   | [ value* #( nat ; nat )]
   | struct tid { fieldValue* }
   | header tid { fieldValue* }
   | header_union tid { fieldValue* }
   | tid . id
   | tid . id # value

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:62:23-62:30:
syntax defaultValue = 
   | default

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:64:29-64:33:
syntax invalidHeaderValue = 
   | {#}

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:67:1-68:28:
syntax sequenceValue = 
   | seq( value* )
   | seq( value* ,...)

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:71:1-72:36:
syntax recordValue = 
   | record{ fieldValue* }
   | record{ fieldValue* ,...}

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:75:1-77:29:
syntax setValue = 
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:80:1-81:38:
syntax tableValue = 
   | table_enum tid . id
   | table_struct tid { fieldValue* }

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:84:1-89:15:
syntax synthesizedValue = 
   | default
   | {#}
   | seq( value* )
   | seq( value* ,...)
   | record{ fieldValue* }
   | record{ fieldValue* ,...}
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }
   | table_enum tid . id
   | table_struct tid { fieldValue* }

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:95:31-95:37:
syntax objectReferenceValue = 
   | ! oid

;; ../../../../examples/p4-concrete/2.1.1-value.spectec:102:1-105:25:
syntax value = 
   | b bool
   | error. id
   | match_kind. id
   | " text "
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat
   | [ value* ]
   | ( value* )
   | [ value* #( nat ; nat )]
   | struct tid { fieldValue* }
   | header tid { fieldValue* }
   | header_union tid { fieldValue* }
   | tid . id
   | tid . id # value
   | default
   | {#}
   | seq( value* )
   | seq( value* ,...)
   | record{ fieldValue* }
   | record{ fieldValue* ,...}
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }
   | table_enum tid . id
   | table_struct tid { fieldValue* }
   | ! oid

;; ../../../../examples/p4-concrete/2.1.2-value-aux.spectec:5:1-5:28:
def $to_int



;; ../../../../examples/p4-concrete/2.1.2-value-aux.spectec:12:1-12:31:
def $to_bitstr



;; ../../../../examples/p4-concrete/2.1.2-value-aux.spectec:18:1-18:28:
def $to_number(value)

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. Case analysis on number

    1. Case (% matches pattern `D%`)

      1. (Let (d i) be number)

      2. Return i

    2. Case (% matches pattern `%S%`)

      1. (Let (w s i) be number)

      2. Return $to_int((w as int), i)

    3. Case (% matches pattern `%W%`)

      1. (Let (w w i) be number)

      2. Return i

1. Else Phantom#42

2. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. If ((numberValue matches pattern `%V%#%`)), then

    1. (Let (w v i # _nat) be numberValue)

    2. Return i

  2. Else Phantom#43

2. Else Phantom#44

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:14:1-18:11:
syntax primitiveTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:25:1-28:20:
syntax numberTypeIR = 
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:30:21-30:51:
syntax baseTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:40:1-41:31:
syntax namedTypeIR = 
   | tid tid
   | polyTypeDefIR < typeIR* >

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:52:1-53:20:
syntax aliasTypeIR = 
   | typedef tid typeIR
   | type tid typeIR

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:59:21-59:37:
syntax listTypeIR = 
   | list< typeIR >

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:60:22-60:40:
syntax tupleTypeIR = 
   | tuple< typeIR* >

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:61:28-61:43:
syntax headerStackTypeIR = 
   | typeIR [ nat ]

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:63:22-63:34:
syntax fieldTypeIR = 
   | typeIR id ;

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:65:23-65:51:
syntax structTypeIR = 
   | struct tid { fieldTypeIR* }

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:66:23-66:51:
syntax headerTypeIR = 
   | header tid { fieldTypeIR* }

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:67:28-67:62:
syntax headerUnionTypeIR = 
   | header_union tid { fieldTypeIR* }

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:69:23-69:37:
syntax valueFieldIR = 
   | id = value ;

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:72:1-73:42:
syntax enumTypeIR = 
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:76:1-82:15:
syntax dataTypeIR = 
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:92:3-92:40:
syntax externObjectTypeIR = 
   | extern tid map<rid, routineTypeDefIR>

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:93:29-93:57:
syntax parserObjectTypeIR = 
   | parser( parameterTypeIR* )

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:94:30-94:59:
syntax controlObjectTypeIR = 
   | control( parameterTypeIR* )

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:95:30-95:50:
syntax packageObjectTypeIR = 
   | package< typeIR* >

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:96:28-96:47:
syntax tableObjectTypeIR = 
   | table tid # typeIR

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:99:1-103:22:
syntax objectTypeIR = 
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:106:1-108:17:
syntax definedTypeIR = 
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:114:24-114:31:
syntax defaultTypeIR = 
   | default

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:116:30-116:44:
syntax invalidHeaderTypeIR = 
   | header_invalid

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:119:1-120:29:
syntax sequenceTypeIR = 
   | seq< typeIR* >
   | seq< typeIR* ,...>

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:123:1-124:37:
syntax recordTypeIR = 
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:126:20-126:36:
syntax setTypeIR = 
   | set< typeIR* >

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:129:1-130:39:
syntax tableTypeIR = 
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:133:1-138:16:
syntax synthesizedTypeIR = 
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:145:1-148:22:
syntax typeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:154:24-154:30:
syntax monoTypeDefIR = typeIR

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:156:24-156:48:
syntax polyTypeDefIR = 
   | typeIR < tid* , tid* >

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:158:20-158:49:
syntax typeDefIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }
   | typeIR < tid* , tid* >

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:164:26-164:52:
syntax parameterTypeIR = 
   | direction typeIR id value?

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:171:1-174:33:
syntax functionTypeIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:177:1-182:27:
syntax methodTypeIR = 
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:185:1-186:17:
syntax routineTypeIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:192:31-192:44:
syntax monoRoutineTypeDefIR = routineTypeIR

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:194:31-194:62:
syntax polyRoutineTypeDefIR = 
   | routineTypeIR < tid* , tid* >

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:197:1-198:25:
syntax routineTypeDefIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR
   | routineTypeIR < tid* , tid* >

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:204:37-204:52:
syntax constructorParameterTypeIR = parameterTypeIR

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:211:3-211:58:
syntax constructorTypeIR = 
   | constructor( constructorParameterTypeIR* )-> typeIR

;; ../../../../examples/p4-concrete/2.2.1-type.spectec:217:31-217:66:
syntax constructorTypeDefIR = 
   | constructorTypeIR < tid* , tid* >

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:9:1-9:34:
def $is_baseTypeIR(typeIR)

1. If ((typeIR has type baseTypeIR)), then

  1. (Let baseTypeIR be (typeIR as baseTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:16:1-16:39:
def $is_primitiveTypeIR(typeIR)

1. If ((typeIR has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:21:1-21:35:
def $is_void_typeIR(typeIR)

1. If ((typeIR has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

  2. If ((primitiveTypeIR matches pattern `VOID`)), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:26:1-26:35:
def $is_bool_typeIR(typeIR)

1. If ((typeIR has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

  2. If ((primitiveTypeIR matches pattern `BOOL`)), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:31:1-31:36:
def $is_error_typeIR(typeIR)

1. If ((typeIR has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

  2. If ((primitiveTypeIR matches pattern `ERROR`)), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:36:1-36:40:
def $is_matchkind_typeIR(typeIR)

1. If ((typeIR has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

  2. If ((primitiveTypeIR matches pattern `MATCH_KIND`)), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:41:1-41:37:
def $is_string_typeIR(typeIR)

1. If ((typeIR has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

  2. If ((primitiveTypeIR matches pattern `STRING`)), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:48:1-48:36:
def $is_numberTypeIR(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:53:1-53:44:
def $is_arbitrary_int_typeIR(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT`)), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:58:1-58:40:
def $is_fixed_int_typeIR(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:63:1-63:40:
def $is_fixed_bit_typeIR(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:76:1-76:34:
def $is_dataTypeIR(typeIR)

1. If ((typeIR has type dataTypeIR)), then

  1. (Let dataTypeIR be (typeIR as dataTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:81:1-81:41:
def $is_headerStackTypeIR(typeIR)

1. If ((typeIR has type headerStackTypeIR)), then

  1. (Let headerStackTypeIR be (typeIR as headerStackTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:88:1-88:36:
def $is_objectTypeIR(typeIR)

1. If ((typeIR has type objectTypeIR)), then

  1. (Let objectTypeIR be (typeIR as objectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:93:1-93:44:
def $is_extern_object_typeIR(typeIR)

1. If ((typeIR has type externObjectTypeIR)), then

  1. (Let externObjectTypeIR be (typeIR as externObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:98:1-98:44:
def $is_parser_object_typeIR(typeIR)

1. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let parserObjectTypeIR be (typeIR as parserObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:103:1-103:45:
def $is_control_object_typeIR(typeIR)

1. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let controlObjectTypeIR be (typeIR as controlObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:108:1-108:45:
def $is_package_object_typeIR(typeIR)

1. If ((typeIR has type packageObjectTypeIR)), then

  1. (Let packageObjectTypeIR be (typeIR as packageObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:113:1-113:43:
def $is_table_object_typeIR(typeIR)

1. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let controlObjectTypeIR be (typeIR as controlObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:120:1-120:41:
def $is_synthesizedTypeIR(typeIR)

1. If ((typeIR has type tableObjectTypeIR)), then

  1. (Let tableObjectTypeIR be (typeIR as tableObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.2-type-aux.spectec:125:1-125:34:
def $is_set_typeIR(typeIR)

1. If ((typeIR has type setTypeIR)), then

  1. (Let (set< _typeIR* >) be (typeIR as setTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:5:16-5:24:
syntax bound = set<tid>

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:6:16-6:32:
syntax theta = map<tid, typeIR>

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:8:1-8:31:
def $free_type(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type baseTypeIR)

    1. (Let baseTypeIR be (typeIR'' as baseTypeIR))

    2. Return ({ [] })

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. Case analysis on namedTypeIR

      1. Case (% matches pattern `TID%`)

        1. (Let (tid tid) be namedTypeIR)

        2. Return ({ [tid] })

      2. Case (% matches pattern `%<%>`)

        1. (Let (polyTypeDefIR < typeIR''* >) be namedTypeIR)

        2. (Let bound_base be $free_typeDef((polyTypeDefIR as typeDefIR)))

        3. (Let bound_args be $unions_set<tid>($free_type(typeIR'')*))

        4. Return $union_set<tid>(bound_base, bound_args)

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. Case analysis on aliasTypeIR

      1. Case (% matches pattern `TYPEDEF%%`)

        1. (Let (typedef _tid typeIR'') be aliasTypeIR)

        2. Return $free_type(typeIR'')

      2. Case (% matches pattern `TYPE%%`)

        1. (Let (type _tid typeIR'') be aliasTypeIR)

        2. Return $free_type(typeIR'')

  4. Case (% has type listTypeIR)

    1. (Let (list< typeIR'' >) be (typeIR'' as listTypeIR))

    2. Return $free_type(typeIR'')

  5. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR'')*)

  6. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'' [ _nat ]) be (typeIR'' as headerStackTypeIR))

    2. Return $free_type(typeIR'')

  7. Case (% has type headerTypeIR)

    1. (Let (header _tid { (typeIR'' _id ;)* }) be (typeIR'' as headerTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR'')*)

  8. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { (typeIR'' _id ;)* }) be (typeIR'' as headerUnionTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR'')*)

  9. Case (% has type structTypeIR)

    1. (Let (struct _tid { (typeIR'' _id ;)* }) be (typeIR'' as structTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR'')*)

  10. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return ({ [] })

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # typeIR'' { _valueFieldIR* }) be enumTypeIR)

        2. Return $free_type(typeIR'')

  11. Case (% has type externObjectTypeIR)

    1. (Let (extern _tid ({ (_rid : routineTypeDefIR)* })) be (typeIR'' as externObjectTypeIR))

    2. Return $unions_set<tid>($free_routineTypeDef(routineTypeDefIR)*)

  12. Case (% has type parserObjectTypeIR)

    1. (Let (parser( parameterTypeIR* )) be (typeIR'' as parserObjectTypeIR))

    2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

    3. Return bound_params

  13. Case (% has type controlObjectTypeIR)

    1. (Let (control( parameterTypeIR* )) be (typeIR'' as controlObjectTypeIR))

    2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

    3. Return bound_params

  14. Case (% has type packageObjectTypeIR)

    1. (Let (package< typeIR''* >) be (typeIR'' as packageObjectTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR'')*)

  15. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # typeIR'') be (typeIR'' as tableObjectTypeIR))

    2. Return $free_type(typeIR'')

  16. Case (% has type defaultTypeIR)

    1. (Let defaultTypeIR be (typeIR'' as defaultTypeIR))

    2. If ((defaultTypeIR matches pattern `DEFAULT`)), then

      1. Return ({ [] })

    2. Else Phantom#45

  17. Case (% has type invalidHeaderTypeIR)

    1. (Let invalidHeaderTypeIR be (typeIR'' as invalidHeaderTypeIR))

    2. If ((invalidHeaderTypeIR matches pattern `HEADER_INVALID`)), then

      1. Return ({ [] })

    2. Else Phantom#46

  18. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR'' as sequenceTypeIR))

    2. Case analysis on sequenceTypeIR

      1. Case (% matches pattern `SEQ<%>`)

        1. (Let (seq< typeIR''* >) be sequenceTypeIR)

        2. Return $unions_set<tid>($free_type(typeIR'')*)

      2. Case (% matches pattern `SEQ<%,...>`)

        1. (Let (seq< typeIR''* ,...>) be sequenceTypeIR)

        2. Return $unions_set<tid>($free_type(typeIR'')*)

  19. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR'' as recordTypeIR))

    2. Case analysis on recordTypeIR

      1. Case (% matches pattern `RECORD{%}`)

        1. (Let (record{ (typeIR'' _id ;)* }) be recordTypeIR)

        2. Return $unions_set<tid>($free_type(typeIR'')*)

      2. Case (% matches pattern `RECORD{%,...}`)

        1. (Let (record{ (typeIR'' _id ;)* ,...}) be recordTypeIR)

        2. Return $unions_set<tid>($free_type(typeIR'')*)

  20. Case (% has type setTypeIR)

    1. (Let (set< typeIR''* >) be (typeIR'' as setTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR'')*)

  21. Case (% has type tableTypeIR)

    1. (Let tableTypeIR be (typeIR'' as tableTypeIR))

    2. Case analysis on tableTypeIR

      1. Case (% matches pattern `TABLE_ENUM%{%}`)

        1. (Let (table_enum _tid { _id* }) be tableTypeIR)

        2. Return ({ [] })

      2. Case (% matches pattern `TABLE_STRUCT%{%}`)

        1. (Let (table_struct _tid { _fieldTypeIR* }) be tableTypeIR)

        2. Return ({ [] })

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:9:1-9:37:
def $free_typeDef(typeDefIR)

1. Case analysis on typeDefIR

  1. Case (% has type typeIR)

    1. (Let typeIR be (typeDefIR as typeIR))

    2. Return $free_type(typeIR)

  2. Case (% has type polyTypeDefIR)

    1. (Let (typeIR_base < tid* , tid_hidden* >) be (typeDefIR as polyTypeDefIR))

    2. (Let bound_base be $free_typeDef((typeIR_base as typeDefIR)))

    3. (Let bound_tparams be ({ tid* ++ tid_hidden* }))

    4. Return $diff_set<tid>(bound_base, bound_tparams)

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:10:1-10:49:
def $free_parameterType((_direction typeIR _id _value?))

1. Return $free_type(typeIR)

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:11:1-11:45:
def $free_routineType(routineTypeIR)

1. Case analysis on routineTypeIR

  1. Case (% has type functionTypeIR)

    1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

    2. Case analysis on functionTypeIR

      1. Case (% matches pattern `BUILTIN_FUNCTION(%)->%`)

        1. (Let (builtin_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      2. Case (% matches pattern `FUNCTION(%)->%`)

        1. (Let (function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      3. Case (% matches pattern `EXTERN_FUNCTION(%)->%`)

        1. (Let (extern_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      4. Case (% matches pattern `ACTION(%)`)

        1. (Let (action( parameterTypeIR* )) be functionTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. Return bound_params

  2. Case (% has type methodTypeIR)

    1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

    2. Case analysis on methodTypeIR

      1. Case (% matches pattern `BUILTIN_METHOD(%)->%`)

        1. (Let (builtin_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      2. Case (% matches pattern `EXTERN_METHOD(%)->%`)

        1. (Let (extern_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      3. Case (% matches pattern `EXTERN_METHODABSTRACT(%)->%`)

        1. (Let (extern_methodabstract( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      4. Case (% matches pattern `PARSER_APPLY(%)`)

        1. (Let (parser_apply( parameterTypeIR* )) be methodTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. Return bound_params

      5. Case (% matches pattern `CONTROL_APPLY(%)`)

        1. (Let (control_apply( parameterTypeIR* )) be methodTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. Return bound_params

      6. Case (% matches pattern `TABLE_APPLY->%`)

        1. (Let (table_apply-> typeIR_ret) be methodTypeIR)

        2. (Let bound_ret be $free_type(typeIR_ret))

        3. Return bound_ret

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:12:1-12:51:
def $free_routineTypeDef(routineTypeDefIR)

1. Case analysis on routineTypeDefIR

  1. Case (% has type routineTypeIR)

    1. (Let routineTypeIR be (routineTypeDefIR as routineTypeIR))

    2. Return $free_routineType(routineTypeIR)

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (routineTypeIR < tid* , tid_hidden* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. (Let bound_base be $free_routineTypeDef((routineTypeIR as routineTypeDefIR)))

    3. (Let bound_tparams be ({ tid* ++ tid_hidden* }))

    4. Return $diff_set<tid>(bound_base, bound_tparams)

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:14:1-14:40:
def $subst_type(set<pair<tid, typeIR>>', typeIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return typeIR

2. Otherwise

  1. Return $subst_type'(set<pair<tid, typeIR>>', typeIR)

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:15:1-15:41:
def $subst_type'(theta, typeIR''')

1. Case analysis on typeIR'''

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR''' as namedTypeIR))

    2. Case analysis on namedTypeIR

      1. Case (% matches pattern `TID%`)

        1. (Let (tid tid) be namedTypeIR)

        2. (Let typeIR''? be $find_map<tid, typeIR>(theta, tid))

        3. If ((typeIR''? matches pattern (_))), then

          1. (Let ?(typeIR) be typeIR''?)

          2. Return typeIR

      2. Case (% matches pattern `%<%>`)

        1. (Let (polyTypeDefIR < typeIR* >) be namedTypeIR)

        2. (Let typeDefIR be $subst_typeDef'(theta, (polyTypeDefIR as typeDefIR)))

        3. If ((typeDefIR has type polyTypeDefIR)), then

          1. (Let polyTypeDefIR_subst be (typeDefIR as polyTypeDefIR))

          2. (Let typeIR_subst be $subst_type'(theta, typeIR))*

          3. Return ((polyTypeDefIR_subst < typeIR_subst* >) as typeIR)

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR''' as aliasTypeIR))

    2. Case analysis on aliasTypeIR

      1. Case (% matches pattern `TYPEDEF%%`)

        1. (Let (typedef tid typeIR) be aliasTypeIR)

        2. (Let typeIR_subst be $subst_type'(theta, typeIR))

        3. Return ((typedef tid typeIR_subst) as typeIR)

      2. Case (% matches pattern `TYPE%%`)

        1. (Let (type tid typeIR) be aliasTypeIR)

        2. (Let typeIR_subst be $subst_type'(theta, typeIR))

        3. Return ((type tid typeIR_subst) as typeIR)

  3. Case (% has type listTypeIR)

    1. (Let (list< typeIR >) be (typeIR''' as listTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))

    3. Return ((list< typeIR_subst >) as typeIR)

  4. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR* >) be (typeIR''' as tupleTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))*

    3. Return ((tuple< typeIR_subst* >) as typeIR)

  5. Case (% has type headerStackTypeIR)

    1. (Let (typeIR [ n ]) be (typeIR''' as headerStackTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))

    3. Return ((typeIR_subst [ n ]) as typeIR)

  6. Case (% has type structTypeIR)

    1. (Let (struct tid { (typeIR_f id_f ;)* }) be (typeIR''' as structTypeIR))

    2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*

    3. Return ((struct tid { (typeIR_f_subst id_f ;)* }) as typeIR)

  7. Case (% has type headerTypeIR)

    1. (Let (header tid { (typeIR_f id_f ;)* }) be (typeIR''' as headerTypeIR))

    2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*

    3. Return ((header tid { (typeIR_f_subst id_f ;)* }) as typeIR)

  8. Case (% has type headerUnionTypeIR)

    1. (Let (header_union tid { (typeIR_f id_f ;)* }) be (typeIR''' as headerUnionTypeIR))

    2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*

    3. Return ((header_union tid { (typeIR_f_subst id_f ;)* }) as typeIR)

  9. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR''' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum tid # typeIR''' { valueFieldIR* }) be enumTypeIR)

      2. (Let typeIR_subst be $subst_type'(theta, typeIR'''))

      3. Return ((enum tid # typeIR_subst { valueFieldIR* }) as typeIR)

  10. Case (% has type externObjectTypeIR)

    1. (Let (extern tid ({ (rid : routineTypeDefIR)* })) be (typeIR''' as externObjectTypeIR))

    2. (Let routineTypeDefIR_subst be $subst_routineTypeDef'(theta, routineTypeDefIR))*

    3. Return ((extern tid ({ (rid : routineTypeDefIR_subst)* })) as typeIR)

  11. Case (% has type parserObjectTypeIR)

    1. (Let (parser( parameterTypeIR* )) be (typeIR''' as parserObjectTypeIR))

    2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

    3. Return ((parser( parameterTypeIR_subst* )) as typeIR)

  12. Case (% has type controlObjectTypeIR)

    1. (Let (control( parameterTypeIR* )) be (typeIR''' as controlObjectTypeIR))

    2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

    3. Return ((control( parameterTypeIR_subst* )) as typeIR)

  13. Case (% has type packageObjectTypeIR)

    1. (Let (package< typeIR'''* >) be (typeIR''' as packageObjectTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR'''))*

    3. Return ((package< typeIR_subst* >) as typeIR)

  14. Case (% has type tableObjectTypeIR)

    1. (Let (table tid # typeIR''') be (typeIR''' as tableObjectTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR'''))

    3. Return ((table tid # typeIR_subst) as typeIR)

  15. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR''' as sequenceTypeIR))

    2. Case analysis on sequenceTypeIR

      1. Case (% matches pattern `SEQ<%>`)

        1. (Let (seq< typeIR'''* >) be sequenceTypeIR)

        2. (Let typeIR_subst be $subst_type'(theta, typeIR'''))*

        3. Return ((seq< typeIR_subst* >) as typeIR)

      2. Case (% matches pattern `SEQ<%,...>`)

        1. (Let (seq< typeIR'''* ,...>) be sequenceTypeIR)

        2. (Let typeIR_subst be $subst_type'(theta, typeIR'''))*

        3. Return ((seq< typeIR_subst* ,...>) as typeIR)

  16. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR''' as recordTypeIR))

    2. Case analysis on recordTypeIR

      1. Case (% matches pattern `RECORD{%}`)

        1. (Let (record{ (typeIR_f id_f ;)* }) be recordTypeIR)

        2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*

        3. Return ((record{ (typeIR_f_subst id_f ;)* }) as typeIR)

      2. Case (% matches pattern `RECORD{%,...}`)

        1. (Let (record{ (typeIR_f id_f ;)* ,...}) be recordTypeIR)

        2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*

        3. Return ((record{ (typeIR_f_subst id_f ;)* ,...}) as typeIR)

  17. Case (% has type setTypeIR)

    1. (Let (set< typeIR'''* >) be (typeIR''' as setTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR'''))*

    3. Return ((set< typeIR_subst* >) as typeIR)

2. Otherwise

  1. Return typeIR'''

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:16:1-16:49:
def $subst_typeDef(set<pair<tid, typeIR>>', typeDefIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return typeDefIR

2. Otherwise

  1. Return $subst_typeDef'(set<pair<tid, typeIR>>', typeDefIR)

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:17:1-17:50:
def $subst_typeDef'(theta, typeDefIR)

1. Case analysis on typeDefIR

  1. Case (% has type typeIR)

    1. (Let typeIR be (typeDefIR as typeIR))

    2. Return ($subst_type'(theta, typeIR) as typeDefIR)

  2. Case (% has type polyTypeDefIR)

    1. (Let (typeIR_base < tid* , tid_hidden* >) be (typeDefIR as polyTypeDefIR))

    2. (Let ({ tid_free* }) be $diff_set<tid>($free_type(typeIR_base), ({ tid* ++ tid_hidden* })))

    3. (Let typeIR? be $find_map<tid, typeIR>(theta, tid_free))*

    4. If ((typeIR? matches pattern (_)))*, then

      1. (Let ?(typeIR_free) be typeIR?)*

      2. (Let bound_capture be $unions_set<tid>($free_type(typeIR_free)*))

      3. (Let tid_fresh* be $fresh_tids(|tid* ++ tid_hidden*|))

      4. If (~$in_set<tid>(tid_fresh, bound_capture))*, then

        1. (Let tid_fresh_spec* be tid_fresh*[0 : |tid*|])

        2. (Let tid_fresh_hidden* be tid_fresh*[|tid*| : |tid_hidden*|])

        3. (Let theta' be $adds_map<tid, typeIR>(theta, tid*, ((tid tid_fresh_spec) as typeIR)*))

        4. (Let theta'' be $adds_map<tid, typeIR>(theta', tid_hidden*, ((tid tid_fresh_hidden) as typeIR)*))

        5. (Let typeIR_base_subst be $subst_type(theta'', typeIR_base))

        6. Return ((typeIR_base_subst < tid_fresh_spec* , tid_fresh_hidden* >) as typeDefIR)

      4. Else Phantom#47

    4. Else Phantom#48

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:18:1-18:67:
def $subst_parameterType(set<pair<tid, typeIR>>', parameterTypeIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return parameterTypeIR

2. Otherwise

  1. Return $subst_parameterType'(set<pair<tid, typeIR>>', parameterTypeIR)

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:19:1-19:68:
def $subst_parameterType'(theta, (direction typeIR id value?))

1. (Let typeIR_subst be $subst_type'(theta, typeIR))

2. Return (direction typeIR_subst id value?)

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:20:1-20:61:
def $subst_routineType(set<pair<tid, typeIR>>', routineTypeIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return routineTypeIR

2. Otherwise

  1. Return $subst_routineType'(set<pair<tid, typeIR>>', routineTypeIR)

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:21:1-21:62:
def $subst_routineType'(theta, routineTypeIR)

1. Case analysis on routineTypeIR

  1. Case (% has type functionTypeIR)

    1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

    2. Case analysis on functionTypeIR

      1. Case (% matches pattern `BUILTIN_FUNCTION(%)->%`)

        1. (Let (builtin_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((builtin_function( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      2. Case (% matches pattern `FUNCTION(%)->%`)

        1. (Let (function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((function( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      3. Case (% matches pattern `EXTERN_FUNCTION(%)->%`)

        1. (Let (extern_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((extern_function( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      4. Case (% matches pattern `ACTION(%)`)

        1. (Let (action( parameterTypeIR* )) be functionTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. Return ((action( parameterTypeIR_subst* )) as routineTypeIR)

  2. Case (% has type methodTypeIR)

    1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

    2. Case analysis on methodTypeIR

      1. Case (% matches pattern `BUILTIN_METHOD(%)->%`)

        1. (Let (builtin_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((builtin_method( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      2. Case (% matches pattern `EXTERN_METHOD(%)->%`)

        1. (Let (extern_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((extern_method( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      3. Case (% matches pattern `EXTERN_METHODABSTRACT(%)->%`)

        1. (Let (extern_methodabstract( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((extern_methodabstract( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      4. Case (% matches pattern `PARSER_APPLY(%)`)

        1. (Let (parser_apply( parameterTypeIR* )) be methodTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. Return ((parser_apply( parameterTypeIR_subst* )) as routineTypeIR)

      5. Case (% matches pattern `CONTROL_APPLY(%)`)

        1. (Let (control_apply( parameterTypeIR* )) be methodTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. Return ((control_apply( parameterTypeIR_subst* )) as routineTypeIR)

      6. Case (% matches pattern `TABLE_APPLY->%`)

        1. (Let (table_apply-> typeIR_ret) be methodTypeIR)

        2. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        3. Return ((table_apply-> typeIR_ret_subst) as routineTypeIR)

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:22:1-22:70:
def $subst_routineTypeDef(set<pair<tid, typeIR>>', routineTypeDefIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return routineTypeDefIR

2. Otherwise

  1. Return $subst_routineTypeDef'(set<pair<tid, typeIR>>', routineTypeDefIR)

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:23:1-23:71:
def $subst_routineTypeDef'(theta, routineTypeDefIR)

1. Case analysis on routineTypeDefIR

  1. Case (% has type routineTypeIR)

    1. (Let routineTypeIR be (routineTypeDefIR as routineTypeIR))

    2. Return ($subst_routineType'(theta, routineTypeIR) as routineTypeDefIR)

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (routineTypeIR < tid* , tid_hidden* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. (Let ({ tid_free* }) be $diff_set<tid>($free_routineType(routineTypeIR), ({ tid* ++ tid_hidden* })))

    3. (Let typeIR? be $find_map<tid, typeIR>(theta, tid_free))*

    4. If ((typeIR? matches pattern (_)))*, then

      1. (Let ?(typeIR_free) be typeIR?)*

      2. (Let bound_capture be $unions_set<tid>($free_type(typeIR_free)*))

      3. (Let tid_fresh* be $fresh_tids(|tid* ++ tid_hidden*|))

      4. If (~$in_set<tid>(tid_fresh, bound_capture))*, then

        1. (Let tid_fresh_spec* be tid_fresh*[0 : |tid*|])

        2. (Let tid_fresh_hidden* be tid_fresh*[|tid*| : |tid_hidden*|])

        3. (Let theta' be $adds_map<tid, typeIR>(theta, tid*, ((tid tid_fresh_spec) as typeIR)*))

        4. (Let theta'' be $adds_map<tid, typeIR>(theta', tid_hidden*, ((tid tid_fresh_hidden) as typeIR)*))

        5. (Let routineTypeIR_subst be $subst_routineType(theta'', routineTypeIR))

        6. Return ((routineTypeIR_subst < tid_fresh_spec* , tid_fresh_hidden* >) as routineTypeDefIR)

      4. Else Phantom#49

    4. Else Phantom#50

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:24:1-24:73:
def $subst_constructorType(set<pair<tid, typeIR>>', constructorTypeIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return constructorTypeIR

2. Otherwise

  1. Return $subst_constructorType'(set<pair<tid, typeIR>>', constructorTypeIR)

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:25:1-25:74:
def $subst_constructorType'(theta, (constructor( parameterTypeIR* )-> typeIR_obj))

1. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

2. (Let typeIR_obj_subst be $subst_type'(theta, typeIR_obj))

3. Return (constructor( parameterTypeIR_subst* )-> typeIR_obj_subst)

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:561:1-561:53:
def $specialize_typeDef(typeDefIR, typeIR''*)

1. Case analysis on typeDefIR

  1. Case (% has type typeIR)

    1. (Let typeIR be (typeDefIR as typeIR))

    2. If ((typeIR''* matches pattern [])), then

      1. Return typeIR

    2. Else Phantom#51

  2. Case (% has type polyTypeDefIR)

    1. (Let (typeIR_base < tid* , tid_hidden* >) be (typeDefIR as polyTypeDefIR))

    2. (Let tid_tparam* be tid* ++ tid_hidden*)

    3. (Let theta be ({ (tid_tparam : typeIR'')* }))

    4. Return $subst_type(theta, typeIR_base)

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:574:1-575:29:
def $specialize_routineTypeDef(routineTypeDefIR, typeIR'*)

1. Case analysis on routineTypeDefIR

  1. Case (% has type routineTypeIR)

    1. (Let routineTypeIR be (routineTypeDefIR as routineTypeIR))

    2. If ((typeIR'* matches pattern [])), then

      1. Return ((routineTypeIR as routineTypeDefIR), [])

    2. Else Phantom#52

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (routineTypeIR < tid* , tid_hidden* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. (Let tid_tparam* be tid* ++ tid_hidden*)

    3. If ((|tid_tparam*| = |typeIR'*|)), then

      1. (Let theta be ({ (tid_tparam : typeIR')* }))

      2. Return (($subst_routineType(theta, routineTypeIR) as routineTypeDefIR), [])

    3. Else Phantom#53

    4. If (((|tid_tparam*| > 0) /\ (|typeIR'*| = 0))), then

      1. (Let tid_fresh* be $fresh_tids(|tid_tparam*|))

      2. (Let theta be ({ (tid_tparam : ((tid tid_fresh) as typeIR))* }))

      3. Return (($subst_routineType(theta, routineTypeIR), tid_fresh*) as (routineTypeDefIR, tid*))

    4. Else Phantom#54

    5. If ((((|tid_hidden*| > 0) /\ (|tid*| = |typeIR'*|)) /\ (|typeIR'*| > 0))), then

      1. (Let tid_fresh* be $fresh_tids(|tid_hidden*|))

      2. (Let typeIR_arg_new* be typeIR'* ++ ((tid tid_fresh) as typeIR)*)

      3. (Let theta be ({ (tid_tparam : typeIR_arg_new)* }))

      4. Return (($subst_routineType(theta, routineTypeIR), tid_fresh*) as (routineTypeDefIR, tid*))

    5. Else Phantom#55

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:616:1-617:30:
def $specialize_constructorTypeDef((constructorTypeIR < tid* , tid_hidden* >), typeIR_arg*)

1. (Let tid_tparam* be tid* ++ tid_hidden*)

2. If ((|tid_tparam*| = |typeIR_arg*|)), then

  1. (Let theta be ({ (tid_tparam : typeIR_arg)* }))

  2. (Let constructorTypeIR_subst be $subst_constructorType(theta, constructorTypeIR))

  3. Return (constructorTypeIR_subst, [])

2. Else Phantom#56

3. If (((|tid_tparam*| > 0) /\ (|typeIR_arg*| = 0))), then

  1. (Let tid_fresh* be $fresh_tids(|tid_tparam*|))

  2. (Let theta be ({ (tid_tparam : ((tid tid_fresh) as typeIR))* }))

  3. (Let constructorTypeIR_subst be $subst_constructorType(theta, constructorTypeIR))

  4. Return (constructorTypeIR_subst, tid_fresh*)

3. Else Phantom#57

4. If ((((|tid_hidden*| > 0) /\ (|tid*| = |typeIR_arg*|)) /\ (|typeIR_arg*| > 0))), then

  1. (Let tid_fresh* be $fresh_tids(|tid_hidden*|))

  2. (Let typeIR_arg_new* be typeIR_arg* ++ ((tid tid_fresh) as typeIR)*)

  3. (Let theta be ({ (tid_tparam : typeIR_arg_new)* }))

  4. (Let constructorTypeIR_subst be $subst_constructorType(theta, constructorTypeIR))

  5. Return (constructorTypeIR_subst, tid_fresh*)

4. Else Phantom#58

;; ../../../../examples/p4-concrete/2.2.3-type-subst.spectec:662:1-662:28:
def $canon(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `%<%>`)), then

      1. (Let (polyTypeDefIR < typeIR_arg* >) be namedTypeIR)

      2. (Let typeIR be $specialize_typeDef((polyTypeDefIR as typeDefIR), typeIR_arg*))

      3. Return $canon(typeIR)

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPEDEF%%`)), then

      1. (Let (typedef _tid typeIR) be aliasTypeIR)

      2. Return $canon(typeIR)

2. Otherwise

  1. Return typeIR''

;; ../../../../examples/p4-concrete/2.2.4-type-util.spectec:7:1-7:38:
def $is_nominal_typeIR(typeIR)

1. Return $is_nominal_typeIR'($canon(typeIR))

;; ../../../../examples/p4-concrete/2.2.4-type-util.spectec:8:1-8:39:
def $is_nominal_typeIR'(typeIR)

1. Case analysis on typeIR

  1. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  2. Case (% has type structTypeIR)

    1. (Let (struct _tid { _fieldTypeIR* }) be (typeIR as structTypeIR))

    2. Return true

  3. Case (% has type headerTypeIR)

    1. (Let (header _tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

    2. Return true

  4. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR as headerUnionTypeIR))

    2. Return true

  5. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

  6. Case (% has type externObjectTypeIR)

    1. (Let (extern _tid _map<rid, routineTypeDefIR>) be (typeIR as externObjectTypeIR))

    2. Return true

  7. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR as tableObjectTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.4-type-util.spectec:25:1-25:42:
def $is_defaultable_typeIR(typeIR)

1. Return $is_defaultable_typeIR'($canon(typeIR))

;; ../../../../examples/p4-concrete/2.2.4-type-util.spectec:26:1-26:43:
def $is_defaultable_typeIR'(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `BOOL`)

        1. Return true

      2. Case (% matches pattern `ERROR`)

        1. Return true

      3. Case (% matches pattern `STRING`)

        1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR'') be aliasTypeIR)

      2. Return $is_defaultable_typeIR(typeIR'')

  4. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. If ($is_defaultable_typeIR(typeIR''))*, then

      1. Return true

  5. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'' [ _nat ]) be (typeIR'' as headerStackTypeIR))

    2. Return $is_defaultable_typeIR(typeIR'')

  6. Case (% has type structTypeIR)

    1. (Let (struct _tid { (typeIR'' _id ;)* }) be (typeIR'' as structTypeIR))

    2. If ($is_defaultable_typeIR(typeIR''))*, then

      1. Return true

  7. Case (% has type headerTypeIR)

    1. (Let (header _tid { (typeIR'' _id ;)* }) be (typeIR'' as headerTypeIR))

    2. If ($is_defaultable_typeIR(typeIR''))*, then

      1. Return true

  8. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { (typeIR'' _id ;)* }) be (typeIR'' as headerUnionTypeIR))

    2. If ($is_defaultable_typeIR(typeIR''))*, then

      1. Return true

  9. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # typeIR'' { _valueFieldIR* }) be enumTypeIR)

        2. Return $is_defaultable_typeIR(typeIR'')

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/2.2.4-type-util.spectec:54:1-54:40:
def $is_equalable_typeIR(typeIR)

1. Return $is_equalable_typeIR'($canon(typeIR))

;; ../../../../examples/p4-concrete/2.2.4-type-util.spectec:55:1-55:41:
def $is_equalable_typeIR'(typeIR)

1. Case analysis on typeIR

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `VOID`)), then

      1. Return false

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid tid) be namedTypeIR)

      2. Return false

  3. Case (% has type externObjectTypeIR)

    1. (Let (extern _tid _map<rid, routineTypeDefIR>) be (typeIR as externObjectTypeIR))

    2. Return false

  4. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

    2. Return false

  5. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

    2. Return false

  6. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR as packageObjectTypeIR))

    2. Return false

  7. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR as tableObjectTypeIR))

    2. Return false

  8. Case (% has type defaultTypeIR)

    1. (Let defaultTypeIR be (typeIR as defaultTypeIR))

    2. If ((defaultTypeIR matches pattern `DEFAULT`)), then

      1. Return false

  9. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR as sequenceTypeIR))

    2. If ((sequenceTypeIR matches pattern `SEQ<%,...>`)), then

      1. (Let (seq< _typeIR* ,...>) be sequenceTypeIR)

      2. Return false

  10. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR as recordTypeIR))

    2. If ((recordTypeIR matches pattern `RECORD{%,...}`)), then

      1. (Let (record{ _fieldTypeIR* ,...}) be recordTypeIR)

      2. Return false

  11. Case (% has type invalidHeaderTypeIR)

    1. (Let invalidHeaderTypeIR be (typeIR as invalidHeaderTypeIR))

    2. If ((invalidHeaderTypeIR matches pattern `HEADER_INVALID`)), then

      1. Return false

  12. Case (% has type setTypeIR)

    1. (Let (set< _typeIR* >) be (typeIR as setTypeIR))

    2. Return false

  13. Case (% has type tableTypeIR)

    1. (Let tableTypeIR be (typeIR as tableTypeIR))

    2. Case analysis on tableTypeIR

      1. Case (% matches pattern `TABLE_ENUM%{%}`)

        1. (Let (table_enum _tid { _id* }) be tableTypeIR)

        2. Return false

      2. Case (% matches pattern `TABLE_STRUCT%{%}`)

        1. (Let (table_struct _tid { _fieldTypeIR* }) be tableTypeIR)

        2. Return false

2. Otherwise

  1. Return true

;; ../../../../examples/p4-concrete/2.2.4-type-util.spectec:78:1-78:41:
def $is_assignable_typeIR(typeIR)

1. Return $is_assignable_typeIR'($canon(typeIR))

;; ../../../../examples/p4-concrete/2.2.4-type-util.spectec:79:1-79:42:
def $is_assignable_typeIR'(typeIR)

1. Case analysis on typeIR

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `VOID`)

        1. Return false

      2. Case (% matches pattern `STRING`)

        1. Return false

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR as numberTypeIR))

    2. If ((numberTypeIR matches pattern `INT`)), then

      1. Return false

  3. Case (% has type objectTypeIR)

    1. (Let objectTypeIR be (typeIR as objectTypeIR))

    2. Return false

  4. Case (% has type synthesizedTypeIR)

    1. (Let synthesizedTypeIR be (typeIR as synthesizedTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../examples/p4-concrete/2.2.5-type-alpha.spectec:5:1-7:20:
relation Type_alpha: typeIR'''', typeIR'''''

1. Case analysis on typeIR''''

  1. Case (% has type baseTypeIR)

    1. (Let baseTypeIR be (typeIR'''' as baseTypeIR))

    2. If ((typeIR''''' has type baseTypeIR)), then

      1. (Let baseTypeIR' be (typeIR''''' as baseTypeIR))

      2. If ((baseTypeIR = baseTypeIR')), then

        1. The relation holds

      2. Else Phantom#59

    2. Else Phantom#60

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'''' as namedTypeIR))

    2. Case analysis on namedTypeIR

      1. Case (% matches pattern `TID%`)

        1. (Let (tid tid) be namedTypeIR)

        2. If ((typeIR''''' has type namedTypeIR)), then

          1. (Let namedTypeIR' be (typeIR''''' as namedTypeIR))

          2. If ((namedTypeIR' matches pattern `TID%`)), then

            1. (Let (tid tid') be namedTypeIR')

            2. If ((tid = tid')), then

              1. The relation holds

            2. Else Phantom#61

          2. Else Phantom#62

        2. Else Phantom#63

      2. Case (% matches pattern `%<%>`)

        1. (Let (polyTypeDefIR_a < typeIR_a* >) be namedTypeIR)

        2. If ((typeIR''''' has type namedTypeIR)), then

          1. (Let namedTypeIR' be (typeIR''''' as namedTypeIR))

          2. If ((namedTypeIR' matches pattern `%<%>`)), then

            1. (Let (polyTypeDefIR_b < typeIR_b* >) be namedTypeIR')

            2. (Let typeIR_a_spec be $specialize_typeDef((polyTypeDefIR_a as typeDefIR), typeIR_a*))

            3. (Let typeIR_b_spec be $specialize_typeDef((polyTypeDefIR_b as typeDefIR), typeIR_b*))

            4. If ((Type_alpha: typeIR_a_spec ~~ typeIR_b_spec holds)), then

              1. If (($is_nominal_typeIR(typeIR_a_spec) /\ $is_nominal_typeIR(typeIR_b_spec))), then

                1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*, then

                  1. The relation holds

                1. Else Phantom#64

              1. Else Phantom#65

              2. If ((~$is_nominal_typeIR(typeIR_a_spec) /\ ~$is_nominal_typeIR(typeIR_b_spec))), then

                1. The relation holds

              2. Else Phantom#66

            4. Else Phantom#67

          2. Else Phantom#68

        2. Else Phantom#69

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'''' as aliasTypeIR))

    2. Case analysis on aliasTypeIR

      1. Case (% matches pattern `TYPEDEF%%`)

        1. (Let (typedef _tid typeIR_a) be aliasTypeIR)

        2. If ((Type_alpha: typeIR_a ~~ typeIR''''' holds)), then

          1. The relation holds

        2. Else Phantom#70

      2. Case (% matches pattern `TYPE%%`)

        1. (Let (type tid typeIR'''') be aliasTypeIR)

        2. If ((typeIR''''' has type aliasTypeIR)), then

          1. (Let aliasTypeIR' be (typeIR''''' as aliasTypeIR))

          2. If ((aliasTypeIR' matches pattern `TYPE%%`)), then

            1. (Let (type tid' typeIR''''') be aliasTypeIR')

            2. If ((tid = tid')), then

              1. If ((Type_alpha: typeIR'''' ~~ typeIR''''' holds)), then

                1. The relation holds

              1. Else Phantom#71

            2. Else Phantom#72

          2. Else Phantom#73

        2. Else Phantom#74

  4. Case (% has type listTypeIR)

    1. (Let (list< typeIR'''' >) be (typeIR'''' as listTypeIR))

    2. If ((typeIR''''' has type listTypeIR)), then

      1. (Let (list< typeIR''''' >) be (typeIR''''' as listTypeIR))

      2. If ((Type_alpha: typeIR'''' ~~ typeIR''''' holds)), then

        1. The relation holds

      2. Else Phantom#75

    2. Else Phantom#76

  5. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''''* >) be (typeIR'''' as tupleTypeIR))

    2. If ((typeIR''''' has type tupleTypeIR)), then

      1. (Let (tuple< typeIR'''''* >) be (typeIR''''' as tupleTypeIR))

      2. If ((Type_alpha: typeIR'''' ~~ typeIR''''' holds))*, then

        1. The relation holds

      2. Else Phantom#77

    2. Else Phantom#78

  6. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'''' [ n_s ]) be (typeIR'''' as headerStackTypeIR))

    2. If ((typeIR''''' has type headerStackTypeIR)), then

      1. (Let (typeIR''''' [ n_s' ]) be (typeIR''''' as headerStackTypeIR))

      2. If ((n_s = n_s')), then

        1. If ((Type_alpha: typeIR'''' ~~ typeIR''''' holds)), then

          1. The relation holds

        1. Else Phantom#79

      2. Else Phantom#80

    2. Else Phantom#81

  7. Case (% has type structTypeIR)

    1. (Let (struct tid { (typeIR_f_a id_f ;)* }) be (typeIR'''' as structTypeIR))

    2. If ((typeIR''''' has type structTypeIR)), then

      1. (Let (struct tid' { (typeIR_f_b id_f' ;)* }) be (typeIR''''' as structTypeIR))

      2. If ((id_f = id_f'))*, then

        1. If ((tid = tid')), then

          1. If ((Type_alpha: typeIR_f_a ~~ typeIR_f_b holds))*, then

            1. The relation holds

          1. Else Phantom#82

        1. Else Phantom#83

      2. Else Phantom#84

    2. Else Phantom#85

  8. Case (% has type headerTypeIR)

    1. (Let (header tid { (typeIR_f_a id_f ;)* }) be (typeIR'''' as headerTypeIR))

    2. If ((typeIR''''' has type headerTypeIR)), then

      1. (Let (header tid' { (typeIR_f_b id_f' ;)* }) be (typeIR''''' as headerTypeIR))

      2. If ((id_f = id_f'))*, then

        1. If ((tid = tid')), then

          1. If ((Type_alpha: typeIR_f_a ~~ typeIR_f_b holds))*, then

            1. The relation holds

          1. Else Phantom#86

        1. Else Phantom#87

      2. Else Phantom#88

    2. Else Phantom#89

  9. Case (% has type headerUnionTypeIR)

    1. (Let (header_union tid { (typeIR_f_a id_f ;)* }) be (typeIR'''' as headerUnionTypeIR))

    2. If ((typeIR''''' has type headerUnionTypeIR)), then

      1. (Let (header_union tid' { (typeIR_f_b id_f' ;)* }) be (typeIR''''' as headerUnionTypeIR))

      2. If ((id_f = id_f'))*, then

        1. If ((tid = tid')), then

          1. If ((Type_alpha: typeIR_f_a ~~ typeIR_f_b holds))*, then

            1. The relation holds

          1. Else Phantom#90

        1. Else Phantom#91

      2. Else Phantom#92

    2. Else Phantom#93

  10. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'''' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum tid { id_f* }) be enumTypeIR)

        2. If ((typeIR''''' has type enumTypeIR)), then

          1. (Let enumTypeIR' be (typeIR''''' as enumTypeIR))

          2. If ((enumTypeIR' matches pattern `ENUM%{%}`)), then

            1. (Let (enum tid' { id_f'* }) be enumTypeIR')

            2. If ((id_f = id_f'))*, then

              1. If ((tid = tid')), then

                1. The relation holds

              1. Else Phantom#94

            2. Else Phantom#95

          2. Else Phantom#96

        2. Else Phantom#97

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum tid # typeIR'''' { (id_f = value_f ;)* }) be enumTypeIR)

        2. If ((typeIR''''' has type enumTypeIR)), then

          1. (Let enumTypeIR' be (typeIR''''' as enumTypeIR))

          2. If ((enumTypeIR' matches pattern `ENUM%#%{%}`)), then

            1. (Let (enum tid' # typeIR''''' { (id_f' = value_f' ;)* }) be enumTypeIR')

            2. If ((id_f = id_f'))*, then

              1. If ((tid = tid')), then

                1. If ((value_f = value_f'))*, then

                  1. If ((Type_alpha: typeIR'''' ~~ typeIR''''' holds)), then

                    1. The relation holds

                  1. Else Phantom#98

                1. Else Phantom#99

              1. Else Phantom#100

            2. Else Phantom#101

          2. Else Phantom#102

        2. Else Phantom#103

  11. Case (% has type externObjectTypeIR)

    1. (Let (extern tid ({ (rid_a : routineTypeDefIR_a)* })) be (typeIR'''' as externObjectTypeIR))

    2. If ((typeIR''''' has type externObjectTypeIR)), then

      1. (Let (extern tid' ({ (rid_b : routineTypeDefIR_b)* })) be (typeIR''''' as externObjectTypeIR))

      2. If ((tid = tid')), then

        1. If ($eq_set<rid>(({ rid_a* }), ({ rid_b* }))), then

          1. (Let routineTypeDefIR? be $find_map<rid, routineTypeDefIR>(({ (rid_a : routineTypeDefIR_a)* }), rid_a))*

          2. If ((routineTypeDefIR? matches pattern (_)))*, then

            1. (Let ?(routineTypeDefIR_a') be routineTypeDefIR?)*

            2. (Let routineTypeDefIR'? be $find_map<rid, routineTypeDefIR>(({ (rid_b : routineTypeDefIR_b)* }), rid_a))*

            3. If ((routineTypeDefIR'? matches pattern (_)))*, then

              1. (Let ?(routineTypeDefIR_b') be routineTypeDefIR'?)*

              2. If ((RoutineTypeDef_alpha: routineTypeDefIR_a' ~~ routineTypeDefIR_b' holds))*, then

                1. The relation holds

              2. Else Phantom#104

            3. Else Phantom#105

          2. Else Phantom#106

        1. Else Phantom#107

      2. Else Phantom#108

    2. Else Phantom#109

  12. Case (% has type parserObjectTypeIR)

    1. (Let (parser( parameterTypeIR_a* )) be (typeIR'''' as parserObjectTypeIR))

    2. If ((typeIR''''' has type parserObjectTypeIR)), then

      1. (Let (parser( parameterTypeIR_b* )) be (typeIR''''' as parserObjectTypeIR))

      2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

        1. The relation holds

      2. Else Phantom#110

    2. Else Phantom#111

  13. Case (% has type controlObjectTypeIR)

    1. (Let (control( parameterTypeIR_a* )) be (typeIR'''' as controlObjectTypeIR))

    2. If ((typeIR''''' has type controlObjectTypeIR)), then

      1. (Let (control( parameterTypeIR_b* )) be (typeIR''''' as controlObjectTypeIR))

      2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

        1. The relation holds

      2. Else Phantom#112

    2. Else Phantom#113

  14. Case (% has type packageObjectTypeIR)

    1. (Let (package< typeIR''''* >) be (typeIR'''' as packageObjectTypeIR))

    2. If ((typeIR''''' has type packageObjectTypeIR)), then

      1. (Let (package< typeIR'''''* >) be (typeIR''''' as packageObjectTypeIR))

      2. If ((Type_alpha: typeIR'''' ~~ typeIR''''' holds))*, then

        1. The relation holds

      2. Else Phantom#114

    2. Else Phantom#115

  15. Case (% has type tableObjectTypeIR)

    1. (Let (table tid # typeIR'''') be (typeIR'''' as tableObjectTypeIR))

    2. If ((typeIR''''' has type tableObjectTypeIR)), then

      1. (Let (table tid' # typeIR''''') be (typeIR''''' as tableObjectTypeIR))

      2. If ((tid = tid')), then

        1. If ((Type_alpha: typeIR'''' ~~ typeIR''''' holds)), then

          1. The relation holds

        1. Else Phantom#116

      2. Else Phantom#117

    2. Else Phantom#118

  16. Case (% has type defaultTypeIR)

    1. (Let defaultTypeIR be (typeIR'''' as defaultTypeIR))

    2. If ((defaultTypeIR matches pattern `DEFAULT`)), then

      1. If ((typeIR''''' has type defaultTypeIR)), then

        1. (Let defaultTypeIR' be (typeIR''''' as defaultTypeIR))

        2. If ((defaultTypeIR' matches pattern `DEFAULT`)), then

          1. The relation holds

        2. Else Phantom#119

      1. Else Phantom#120

    2. Else Phantom#121

  17. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR'''' as sequenceTypeIR))

    2. Case analysis on sequenceTypeIR

      1. Case (% matches pattern `SEQ<%>`)

        1. (Let (seq< typeIR''''* >) be sequenceTypeIR)

        2. If ((typeIR''''' has type sequenceTypeIR)), then

          1. (Let sequenceTypeIR' be (typeIR''''' as sequenceTypeIR))

          2. If ((sequenceTypeIR' matches pattern `SEQ<%>`)), then

            1. (Let (seq< typeIR'''''* >) be sequenceTypeIR')

            2. If ((Type_alpha: typeIR'''' ~~ typeIR''''' holds))*, then

              1. The relation holds

            2. Else Phantom#122

          2. Else Phantom#123

        2. Else Phantom#124

      2. Case (% matches pattern `SEQ<%,...>`)

        1. (Let (seq< typeIR''''* ,...>) be sequenceTypeIR)

        2. If ((typeIR''''' has type sequenceTypeIR)), then

          1. (Let sequenceTypeIR' be (typeIR''''' as sequenceTypeIR))

          2. If ((sequenceTypeIR' matches pattern `SEQ<%,...>`)), then

            1. (Let (seq< typeIR'''''* ,...>) be sequenceTypeIR')

            2. If ((Type_alpha: typeIR'''' ~~ typeIR''''' holds))*, then

              1. The relation holds

            2. Else Phantom#125

          2. Else Phantom#126

        2. Else Phantom#127

  18. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR'''' as recordTypeIR))

    2. Case analysis on recordTypeIR

      1. Case (% matches pattern `RECORD{%}`)

        1. (Let (record{ (typeIR'''' id ;)* }) be recordTypeIR)

        2. If ((typeIR''''' has type recordTypeIR)), then

          1. (Let recordTypeIR' be (typeIR''''' as recordTypeIR))

          2. If ((recordTypeIR' matches pattern `RECORD{%}`)), then

            1. (Let (record{ (typeIR''''' id' ;)* }) be recordTypeIR')

            2. If ((id = id'))*, then

              1. If ((Type_alpha: typeIR'''' ~~ typeIR''''' holds))*, then

                1. The relation holds

              1. Else Phantom#128

            2. Else Phantom#129

          2. Else Phantom#130

        2. Else Phantom#131

      2. Case (% matches pattern `RECORD{%,...}`)

        1. (Let (record{ (typeIR'''' id ;)* ,...}) be recordTypeIR)

        2. If ((typeIR''''' has type recordTypeIR)), then

          1. (Let recordTypeIR' be (typeIR''''' as recordTypeIR))

          2. If ((recordTypeIR' matches pattern `RECORD{%,...}`)), then

            1. (Let (record{ (typeIR''''' id' ;)* ,...}) be recordTypeIR')

            2. If ((id = id'))*, then

              1. If ((Type_alpha: typeIR'''' ~~ typeIR''''' holds))*, then

                1. The relation holds

              1. Else Phantom#132

            2. Else Phantom#133

          2. Else Phantom#134

        2. Else Phantom#135

  19. Case (% has type invalidHeaderTypeIR)

    1. (Let invalidHeaderTypeIR be (typeIR'''' as invalidHeaderTypeIR))

    2. If ((invalidHeaderTypeIR matches pattern `HEADER_INVALID`)), then

      1. If ((typeIR''''' has type invalidHeaderTypeIR)), then

        1. (Let invalidHeaderTypeIR' be (typeIR''''' as invalidHeaderTypeIR))

        2. If ((invalidHeaderTypeIR' matches pattern `HEADER_INVALID`)), then

          1. The relation holds

        2. Else Phantom#136

      1. Else Phantom#137

    2. Else Phantom#138

  20. Case (% has type setTypeIR)

    1. (Let (set< typeIR''''* >) be (typeIR'''' as setTypeIR))

    2. If ((typeIR''''* matches pattern [ _/1 ])), then

      1. (Let [typeIR''''] be typeIR''''*)

      2. If ((typeIR''''' has type setTypeIR)), then

        1. (Let (set< typeIR''* >) be (typeIR''''' as setTypeIR))

        2. If ((typeIR''* matches pattern [ _/1 ])), then

          1. (Let [typeIR'''''] be typeIR''*)

          2. If ((Type_alpha: typeIR'''' ~~ typeIR''''' holds)), then

            1. The relation holds

          2. Else Phantom#139

        2. Else Phantom#140

      2. Else Phantom#141

    2. Else Phantom#142

  21. Case (% has type tableTypeIR)

    1. (Let tableTypeIR be (typeIR'''' as tableTypeIR))

    2. Case analysis on tableTypeIR

      1. Case (% matches pattern `TABLE_ENUM%{%}`)

        1. (Let (table_enum tid { id_f* }) be tableTypeIR)

        2. If ((typeIR''''' has type tableTypeIR)), then

          1. (Let tableTypeIR' be (typeIR''''' as tableTypeIR))

          2. If ((tableTypeIR' matches pattern `TABLE_ENUM%{%}`)), then

            1. (Let (table_enum tid' { id_f'* }) be tableTypeIR')

            2. If ((id_f = id_f'))*, then

              1. If ((tid = tid')), then

                1. The relation holds

              1. Else Phantom#143

            2. Else Phantom#144

          2. Else Phantom#145

        2. Else Phantom#146

      2. Case (% matches pattern `TABLE_STRUCT%{%}`)

        1. (Let (table_struct tid { (typeIR_f_a id_f ;)* }) be tableTypeIR)

        2. If ((typeIR''''' has type tableTypeIR)), then

          1. (Let tableTypeIR' be (typeIR''''' as tableTypeIR))

          2. If ((tableTypeIR' matches pattern `TABLE_STRUCT%{%}`)), then

            1. (Let (table_struct tid' { (typeIR_f_b id_f' ;)* }) be tableTypeIR')

            2. If ((id_f = id_f'))*, then

              1. If ((tid = tid')), then

                1. If ((Type_alpha: typeIR_f_a ~~ typeIR_f_b holds))*, then

                  1. The relation holds

                1. Else Phantom#147

              1. Else Phantom#148

            2. Else Phantom#149

          2. Else Phantom#150

        2. Else Phantom#151

2. If ((typeIR''''' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR''''' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPEDEF%%`)), then

    1. (Let (typedef _tid typeIR''''') be aliasTypeIR)

    2. If ((Type_alpha: typeIR'''' ~~ typeIR''''' holds)), then

      1. The relation holds

    2. Else Phantom#152

  2. Else Phantom#153

2. Else Phantom#154

;; ../../../../examples/p4-concrete/2.2.5-type-alpha.spectec:9:1-11:20:
relation ParameterType_alpha: (_direction typeIR_a _id _value?), (_direction' typeIR_b _id' _value'?)

1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

  1. The relation holds

1. Else Phantom#155

;; ../../../../examples/p4-concrete/2.2.5-type-alpha.spectec:13:1-15:20:
relation RoutineType_alpha: routineTypeIR, routineTypeIR'

1. Case analysis on routineTypeIR

  1. Case (% has type functionTypeIR)

    1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

    2. Case analysis on functionTypeIR

      1. Case (% matches pattern `BUILTIN_FUNCTION(%)->%`)

        1. (Let (builtin_function( parameterTypeIR_a* )-> typeIR_ret_a) be functionTypeIR)

        2. If ((routineTypeIR' has type functionTypeIR)), then

          1. (Let functionTypeIR' be (routineTypeIR' as functionTypeIR))

          2. If ((functionTypeIR' matches pattern `BUILTIN_FUNCTION(%)->%`)), then

            1. (Let (builtin_function( parameterTypeIR_b* )-> typeIR_ret_b) be functionTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

                1. The relation holds

              1. Else Phantom#156

            2. Else Phantom#157

          2. Else Phantom#158

        2. Else Phantom#159

      2. Case (% matches pattern `FUNCTION(%)->%`)

        1. (Let (function( parameterTypeIR_a* )-> typeIR_ret_a) be functionTypeIR)

        2. If ((routineTypeIR' has type functionTypeIR)), then

          1. (Let functionTypeIR' be (routineTypeIR' as functionTypeIR))

          2. If ((functionTypeIR' matches pattern `FUNCTION(%)->%`)), then

            1. (Let (function( parameterTypeIR_b* )-> typeIR_ret_b) be functionTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

                1. The relation holds

              1. Else Phantom#160

            2. Else Phantom#161

          2. Else Phantom#162

        2. Else Phantom#163

      3. Case (% matches pattern `ACTION(%)`)

        1. (Let (action( parameterTypeIR_a* )) be functionTypeIR)

        2. If ((routineTypeIR' has type functionTypeIR)), then

          1. (Let functionTypeIR' be (routineTypeIR' as functionTypeIR))

          2. If ((functionTypeIR' matches pattern `ACTION(%)`)), then

            1. (Let (action( parameterTypeIR_b* )) be functionTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. The relation holds

            2. Else Phantom#164

          2. Else Phantom#165

        2. Else Phantom#166

      4. Case (% matches pattern `EXTERN_FUNCTION(%)->%`)

        1. (Let (extern_function( parameterTypeIR_a* )-> typeIR_ret_a) be functionTypeIR)

        2. If ((routineTypeIR' has type functionTypeIR)), then

          1. (Let functionTypeIR' be (routineTypeIR' as functionTypeIR))

          2. If ((functionTypeIR' matches pattern `EXTERN_FUNCTION(%)->%`)), then

            1. (Let (extern_function( parameterTypeIR_b* )-> typeIR_ret_b) be functionTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

                1. The relation holds

              1. Else Phantom#167

            2. Else Phantom#168

          2. Else Phantom#169

        2. Else Phantom#170

  2. Case (% has type methodTypeIR)

    1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

    2. Case analysis on methodTypeIR

      1. Case (% matches pattern `BUILTIN_METHOD(%)->%`)

        1. (Let (builtin_method( parameterTypeIR_a* )-> typeIR_ret_a) be methodTypeIR)

        2. If ((routineTypeIR' has type methodTypeIR)), then

          1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

          2. If ((methodTypeIR' matches pattern `BUILTIN_METHOD(%)->%`)), then

            1. (Let (builtin_method( parameterTypeIR_b* )-> typeIR_ret_b) be methodTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

                1. The relation holds

              1. Else Phantom#171

            2. Else Phantom#172

          2. Else Phantom#173

        2. Else Phantom#174

      2. Case (% matches pattern `EXTERN_METHOD(%)->%`)

        1. (Let (extern_method( parameterTypeIR_a* )-> typeIR_ret_a) be methodTypeIR)

        2. If ((routineTypeIR' has type methodTypeIR)), then

          1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

          2. If ((methodTypeIR' matches pattern `EXTERN_METHOD(%)->%`)), then

            1. (Let (extern_method( parameterTypeIR_b* )-> typeIR_ret_b) be methodTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

                1. The relation holds

              1. Else Phantom#175

            2. Else Phantom#176

          2. Else Phantom#177

        2. Else Phantom#178

      3. Case (% matches pattern `EXTERN_METHODABSTRACT(%)->%`)

        1. (Let (extern_methodabstract( parameterTypeIR_a* )-> typeIR_ret_a) be methodTypeIR)

        2. If ((routineTypeIR' has type methodTypeIR)), then

          1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

          2. If ((methodTypeIR' matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

            1. (Let (extern_methodabstract( parameterTypeIR_b* )-> typeIR_ret_b) be methodTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

                1. The relation holds

              1. Else Phantom#179

            2. Else Phantom#180

          2. Else Phantom#181

        2. Else Phantom#182

      4. Case (% matches pattern `PARSER_APPLY(%)`)

        1. (Let (parser_apply( parameterTypeIR_a* )) be methodTypeIR)

        2. If ((routineTypeIR' has type methodTypeIR)), then

          1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

          2. If ((methodTypeIR' matches pattern `PARSER_APPLY(%)`)), then

            1. (Let (parser_apply( parameterTypeIR_b* )) be methodTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. The relation holds

            2. Else Phantom#183

          2. Else Phantom#184

        2. Else Phantom#185

      5. Case (% matches pattern `CONTROL_APPLY(%)`)

        1. (Let (control_apply( parameterTypeIR_a* )) be methodTypeIR)

        2. If ((routineTypeIR' has type methodTypeIR)), then

          1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

          2. If ((methodTypeIR' matches pattern `CONTROL_APPLY(%)`)), then

            1. (Let (control_apply( parameterTypeIR_b* )) be methodTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. The relation holds

            2. Else Phantom#186

          2. Else Phantom#187

        2. Else Phantom#188

      6. Case (% matches pattern `TABLE_APPLY->%`)

        1. (Let (table_apply-> typeIR_ret_a) be methodTypeIR)

        2. If ((routineTypeIR' has type methodTypeIR)), then

          1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

          2. If ((methodTypeIR' matches pattern `TABLE_APPLY->%`)), then

            1. (Let (table_apply-> typeIR_ret_b) be methodTypeIR')

            2. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

              1. The relation holds

            2. Else Phantom#189

          2. Else Phantom#190

        2. Else Phantom#191

;; ../../../../examples/p4-concrete/2.2.5-type-alpha.spectec:17:1-19:20:
relation RoutineTypeDef_alpha: routineTypeDefIR, routineTypeDefIR'

1. Case analysis on routineTypeDefIR

  1. Case (% has type routineTypeIR)

    1. (Let routineTypeIR_a be (routineTypeDefIR as routineTypeIR))

    2. If ((routineTypeDefIR' has type routineTypeIR)), then

      1. (Let routineTypeIR_b be (routineTypeDefIR' as routineTypeIR))

      2. If ((RoutineType_alpha: routineTypeIR_a ~~ routineTypeIR_b holds)), then

        1. The relation holds

      2. Else Phantom#192

    2. Else Phantom#193

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (routineTypeIR_a < tid_a* , tid_hidden_a* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. If ((routineTypeDefIR' has type polyRoutineTypeDefIR)), then

      1. (Let (routineTypeIR_b < tid_b* , tid_hidden_b* >) be (routineTypeDefIR' as polyRoutineTypeDefIR))

      2. If ((|tid_a*| = |tid_b*|)), then

        1. If ((|tid_hidden_a*| = |tid_hidden_b*|)), then

          1. (Let tid_fresh* be $fresh_tids((|tid_a*| + |tid_hidden_a*|)))

          2. (Let tid_a'* be tid_a* ++ tid_hidden_a*)

          3. (Let theta_a be ({ (tid_a' : ((tid tid_fresh) as typeIR))* }))

          4. (Let routineTypeIR_a_subst be $subst_routineType(theta_a, routineTypeIR_a))

          5. (Let tid_b'* be tid_b* ++ tid_hidden_b*)

          6. (Let theta_b be ({ (tid_b' : ((tid tid_fresh) as typeIR))* }))

          7. (Let routineTypeIR_b_subst be $subst_routineType(theta_b, routineTypeIR_b))

          8. If ((RoutineType_alpha: routineTypeIR_a_subst ~~ routineTypeIR_b_subst holds)), then

            1. The relation holds

          8. Else Phantom#194

        1. Else Phantom#195

      2. Else Phantom#196

    2. Else Phantom#197

;; ../../../../examples/p4-concrete/2.3-compile-time-known.spectec:5:14-5:30:
syntax ctk = 
   | lctk
   | ctk
   | dyn

;; ../../../../examples/p4-concrete/2.3-compile-time-known.spectec:7:1-7:30:
def $join_ctk(ctk'', ctk''')

1. Case analysis on ctk''

  1. Case (% matches pattern `LCTK`)

    1. Case analysis on ctk'''

      1. Case (% matches pattern `LCTK`)

        1. Return (lctk)

      2. Case (% matches pattern `CTK`)

        1. Return (ctk)

  2. Case (% matches pattern `CTK`)

    1. Case analysis on ctk'''

      1. Case (% matches pattern `LCTK`)

        1. Return (ctk)

      2. Case (% matches pattern `CTK`)

        1. Return (ctk)

2. Otherwise

  1. Return (dyn)

;; ../../../../examples/p4-concrete/2.3-compile-time-known.spectec:16:1-16:27:
def $joins_ctk(ctk''*)

1. Case analysis on ctk''*

  1. Case (% matches pattern [])

    1. Return (dyn)

  2. Case (% matches pattern [ _/1 ])

    1. (Let [ctk''] be ctk''*)

    2. Return ctk''

  3. Case (% matches pattern _ :: _)

    1. (Let ctk_a :: ctk''* be ctk''*)

    2. Case analysis on ctk''*

      1. Case (% matches pattern [ _/1 ])

        1. (Let [ctk_b] be ctk''*)

        2. Return $join_ctk(ctk_a, ctk_b)

      2. Case (% matches pattern _ :: _)

        1. (Let ctk_b :: ctk_c* be ctk''*)

        2. (Let ctk_d be $join_ctk(ctk_a, ctk_b))

        3. Return $joins_ctk(ctk_d :: ctk_c*)

    2. Else Phantom#198

1. Else Phantom#199

;; ../../../../examples/p4-concrete/3-numerics.spectec:5:1-5:21:
def $pow2



;; ../../../../examples/p4-concrete/3-numerics.spectec:7:1-7:25:
def $shl



;; ../../../../examples/p4-concrete/3-numerics.spectec:8:1-8:25:
def $shr



;; ../../../../examples/p4-concrete/3-numerics.spectec:9:1-9:36:
def $shr_arith



;; ../../../../examples/p4-concrete/3-numerics.spectec:11:1-11:21:
def $bneg



;; ../../../../examples/p4-concrete/3-numerics.spectec:12:1-12:26:
def $band



;; ../../../../examples/p4-concrete/3-numerics.spectec:13:1-13:26:
def $bxor



;; ../../../../examples/p4-concrete/3-numerics.spectec:14:1-14:25:
def $bor



;; ../../../../examples/p4-concrete/3-numerics.spectec:16:1-16:33:
def $bitacc



;; ../../../../examples/p4-concrete/3-numerics.spectec:24:1-24:28:
def $un_bnot(value)

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. If ((number matches pattern `%W%`)), then

    1. (Let (w w i) be number)

    2. (Let i' be $bneg(i))

    3. Return ((w w i') as value)

  2. Else Phantom#200

1. Else Phantom#201

;; ../../../../examples/p4-concrete/3-numerics.spectec:31:1-31:28:
def $un_lnot(value)

1. If ((value has type primitiveValue)), then

  1. (Let primitiveValue be (value as primitiveValue))

  2. If ((primitiveValue matches pattern `B%`)), then

    1. (Let (b b) be primitiveValue)

    2. Return ((b ~b) as value)

  2. Else Phantom#202

1. Else Phantom#203

;; ../../../../examples/p4-concrete/3-numerics.spectec:37:1-37:28:
def $un_plus(value)

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. Case analysis on number

    1. Case (% matches pattern `D%`)

      1. (Let (d i) be number)

      2. Return ((d i) as value)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i) be number)

      2. Return ((w w i) as value)

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i) be number)

      2. Return ((w s i) as value)

1. Else Phantom#204

;; ../../../../examples/p4-concrete/3-numerics.spectec:45:1-45:29:
def $un_minus(value)

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. Case analysis on number

    1. Case (% matches pattern `D%`)

      1. (Let (d i) be number)

      2. Return ((d -i) as value)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i) be number)

      2. (Let i' be ($pow2(w) - i))

      3. Return ((w w i') as value)

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i) be number)

      2. (Let i' be $to_bitstr((w as int), $to_int((w as int), -i)))

      3. Return ((w s i') as value)

1. Else Phantom#205

;; ../../../../examples/p4-concrete/3-numerics.spectec:59:1-59:36:
def $bin_plus(value, value')

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. Case analysis on number

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `D%`)), then

          1. (Let (d i_r) be number')

          2. Return ((d (i_l + i_r)) as value)

        2. Else Phantom#206

      2. Else Phantom#207

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be number')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), (i_l' + i_r')))

            4. Return ((w w i') as value)

          2. Else Phantom#208

        2. Else Phantom#209

      2. Else Phantom#210

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be number')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), (i_l' + i_r')))

            4. Return ((w s i') as value)

            5. (Let i' be $to_bitstr((w as int), (i_l' - i_r')))

            6. Return ((w s i') as value)

            7. (Let i' be $to_bitstr((w as int), (i_l' * i_r')))

            8. Return ((w s i') as value)

          2. Else Phantom#211

        2. Else Phantom#212

      2. Else Phantom#213

1. Else Phantom#214

;; ../../../../examples/p4-concrete/3-numerics.spectec:73:1-73:39:
def $bin_satplus



;; ../../../../examples/p4-concrete/3-numerics.spectec:77:1-77:37:
def $bin_minus(value, value')

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. Case analysis on number

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `D%`)), then

          1. (Let (d i_r) be number')

          2. Return ((d (i_l - i_r)) as value)

        2. Else Phantom#215

      2. Else Phantom#216

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be number')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), (i_l' - i_r')))

            4. Return ((w w i') as value)

            5. (Let i' be $to_bitstr((w as int), (i_l' * i_r')))

            6. Return ((w w i') as value)

          2. Else Phantom#217

        2. Else Phantom#218

      2. Else Phantom#219

  2. Else Phantom#220

1. Else Phantom#221

;; ../../../../examples/p4-concrete/3-numerics.spectec:91:1-91:40:
def $bin_satminus



;; ../../../../examples/p4-concrete/3-numerics.spectec:95:1-95:35:
def $bin_mul(value, value')

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. If ((number matches pattern `D%`)), then

    1. (Let (d i_l) be number)

    2. If ((value' has type number)), then

      1. (Let number' be (value' as number))

      2. If ((number' matches pattern `D%`)), then

        1. (Let (d i_r) be number')

        2. Return ((d (i_l * i_r)) as value)

      2. Else Phantom#222

    2. Else Phantom#223

  2. Else Phantom#224

1. Else Phantom#225

;; ../../../../examples/p4-concrete/3-numerics.spectec:109:1-109:35:
def $bin_div(value, value')

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. If ((number matches pattern `D%`)), then

    1. (Let (d i_l) be number)

    2. If ((value' has type number)), then

      1. (Let number' be (value' as number))

      2. If ((number' matches pattern `D%`)), then

        1. (Let (d i_r) be number')

        2. Return ((d (i_l / i_r)) as value)

      2. Else Phantom#226

    2. Else Phantom#227

  2. Else Phantom#228

1. Else Phantom#229

;; ../../../../examples/p4-concrete/3-numerics.spectec:115:1-115:35:
def $bin_mod(value, value')

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. If ((number matches pattern `D%`)), then

    1. (Let (d i_l) be number)

    2. If ((value' has type number)), then

      1. (Let number' be (value' as number))

      2. If ((number' matches pattern `D%`)), then

        1. (Let (d i_r) be number')

        2. Return ((d (i_l \ i_r)) as value)

      2. Else Phantom#230

    2. Else Phantom#231

  2. Else Phantom#232

1. Else Phantom#233

;; ../../../../examples/p4-concrete/3-numerics.spectec:121:1-121:35:
def $bin_shl(value, value')

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. Case analysis on number

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. Case analysis on number'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be number')

            2. Return ((d $shl(i_l, i_r)) as value)

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be number')

            2. Return ((d $shl(i_l, i_r)) as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be number')

            2. (Let i_r' be $to_int((w_r as int), i_r))

            3. Return ((d $shl(i_l, i_r')) as value)

      2. Else Phantom#234

    2. Case (% matches pattern `%W%`)

      1. (Let (w_l w i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. Case analysis on number'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be number')

            2. Return $bin_shl(((w_l w i_l) as value), ((w_l w $to_int((w_l as int), i_r)) as value))

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be number')

            2. (Let i' be $to_bitstr((w_l as int), $shl(i_l, i_r)))

            3. Return ((w_l w i') as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be number')

            2. (Let i_r' be $to_int((w_r as int), i_r))

            3. (Let i' be $to_bitstr((w_l as int), $shl(i_l, i_r')))

            4. Return ((w_l w i') as value)

      2. Else Phantom#235

    3. Case (% matches pattern `%S%`)

      1. (Let (w_l s i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. Case analysis on number'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be number')

            2. Return $bin_shl(((w_l s i_l) as value), ((w_l s $to_int((w_l as int), i_r)) as value))

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be number')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i' be $to_bitstr((w_l as int), $shl(i_l', i_r)))

            4. Return ((w_l s i') as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be number')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i_r' be $to_int((w_r as int), i_r))

            4. (Let i' be $to_bitstr((w_l as int), $shl(i_l', i_r')))

            5. Return ((w_l s i') as value)

      2. Else Phantom#236

1. Else Phantom#237

;; ../../../../examples/p4-concrete/3-numerics.spectec:148:1-148:35:
def $bin_shr(value, value')

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. Case analysis on number

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. Case analysis on number'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be number')

            2. Return ((d $shr(i_l, i_r)) as value)

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be number')

            2. Return ((d $shr(i_l, i_r)) as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be number')

            2. (Let i_r' be $to_int((w_r as int), i_r))

            3. Return ((d $shr(i_l, i_r')) as value)

      2. Else Phantom#238

    2. Case (% matches pattern `%W%`)

      1. (Let (w_l w i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. Case analysis on number'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be number')

            2. Return $bin_shr(((w_l w i_l) as value), ((w_l w $to_int((w_l as int), i_r)) as value))

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be number')

            2. (Let i' be $to_bitstr((w_l as int), $shr(i_l, i_r)))

            3. Return ((w_l w i') as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be number')

            2. (Let i_r' be $to_int((w_r as int), i_r))

            3. (Let i' be $to_bitstr((w_l as int), $shr(i_l, i_r')))

            4. Return ((w_l w i') as value)

      2. Else Phantom#239

    3. Case (% matches pattern `%S%`)

      1. (Let (w_l s i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. Case analysis on number'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be number')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. If ((i_l' < (0 as int))), then

              1. (Let i' be $shr_arith(i_l, i_r, ($pow2(w_l) - (1 as int))))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

            3. Else Phantom#240

            4. If ((i_l' >= (0 as int))), then

              1. (Let i' be $shr(i_l, i_r))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

            4. Else Phantom#241

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be number')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. If ((i_l' < (0 as int))), then

              1. (Let i' be $shr_arith(i_l, i_r, ($pow2(w_l) - (1 as int))))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

            3. Else Phantom#242

            4. If ((i_l' >= (0 as int))), then

              1. (Let i' be $shr(i_l, i_r))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

            4. Else Phantom#243

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be number')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i_r' be $to_int((w_r as int), i_r))

            4. If ((i_l' < (0 as int))), then

              1. (Let i' be $shr_arith(i_l, i_r, ($pow2(w_l) - (1 as int))))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

            4. Else Phantom#244

            5. If ((i_l' >= (0 as int))), then

              1. (Let i' be $shr(i_l, i_r))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

            5. Else Phantom#245

      2. Else Phantom#246

1. Else Phantom#247

;; ../../../../examples/p4-concrete/3-numerics.spectec:198:1-198:33:
def $bin_le(value, value')

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. Case analysis on number

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `D%`)), then

          1. (Let (d i_r) be number')

          2. Return (i_l <= i_r)

        2. Else Phantom#248

      2. Else Phantom#249

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be number')

          2. If ((w = w')), then

            1. Return (i_l <= i_r)

          2. Else Phantom#250

        2. Else Phantom#251

      2. Else Phantom#252

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be number')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. Return (i_l' <= i_r')

          2. Else Phantom#253

        2. Else Phantom#254

      2. Else Phantom#255

1. Else Phantom#256

;; ../../../../examples/p4-concrete/3-numerics.spectec:208:1-208:33:
def $bin_ge(value, value')

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. Case analysis on number

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `D%`)), then

          1. (Let (d i_r) be number')

          2. Return (i_l >= i_r)

        2. Else Phantom#257

      2. Else Phantom#258

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be number')

          2. If ((w = w')), then

            1. Return (i_l >= i_r)

          2. Else Phantom#259

        2. Else Phantom#260

      2. Else Phantom#261

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be number')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. Return (i_l' >= i_r')

          2. Else Phantom#262

        2. Else Phantom#263

      2. Else Phantom#264

1. Else Phantom#265

;; ../../../../examples/p4-concrete/3-numerics.spectec:218:1-218:33:
def $bin_lt(value, value')

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. Case analysis on number

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `D%`)), then

          1. (Let (d i_r) be number')

          2. Return (i_l < i_r)

        2. Else Phantom#266

      2. Else Phantom#267

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be number')

          2. If ((w = w')), then

            1. Return (i_l < i_r)

          2. Else Phantom#268

        2. Else Phantom#269

      2. Else Phantom#270

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be number')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. Return (i_l' < i_r')

          2. Else Phantom#271

        2. Else Phantom#272

      2. Else Phantom#273

1. Else Phantom#274

;; ../../../../examples/p4-concrete/3-numerics.spectec:228:1-228:33:
def $bin_gt(value, value')

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. Case analysis on number

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `D%`)), then

          1. (Let (d i_r) be number')

          2. Return (i_l > i_r)

        2. Else Phantom#275

      2. Else Phantom#276

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be number')

          2. If ((w = w')), then

            1. Return (i_l > i_r)

          2. Else Phantom#277

        2. Else Phantom#278

      2. Else Phantom#279

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be number')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. Return (i_l' > i_r')

          2. Else Phantom#280

        2. Else Phantom#281

      2. Else Phantom#282

1. Else Phantom#283

;; ../../../../examples/p4-concrete/3-numerics.spectec:238:1-238:33:
def $bin_eq(value, value')

1. Case analysis on value

  1. Case (% has type primitiveValue)

    1. (Let primitiveValue_a be (value as primitiveValue))

    2. If ((value' has type primitiveValue)), then

      1. (Let primitiveValue_b be (value' as primitiveValue))

      2. Return (primitiveValue_a = primitiveValue_b)

    2. Else Phantom#284

  2. Case (% has type number)

    1. (Let number be (value as number))

    2. Case analysis on number

      1. Case (% matches pattern `D%`)

        1. (Let (d i_a) be number)

        2. If ((value' has type number)), then

          1. (Let number' be (value' as number))

          2. If ((number' matches pattern `D%`)), then

            1. (Let (d i_b) be number')

            2. Return (i_a = i_b)

          2. Else Phantom#285

        2. Else Phantom#286

      2. Case (% matches pattern `%W%`)

        1. (Let (w_a w i_a) be number)

        2. If ((value' has type number)), then

          1. (Let number' be (value' as number))

          2. If ((number' matches pattern `%W%`)), then

            1. (Let (w_b w i_b) be number')

            2. Return ((w_a = w_b) /\ (i_a = i_b))

          2. Else Phantom#287

        2. Else Phantom#288

      3. Case (% matches pattern `%S%`)

        1. (Let (w_a s i_a) be number)

        2. If ((value' has type number)), then

          1. (Let number' be (value' as number))

          2. If ((number' matches pattern `%S%`)), then

            1. (Let (w_b s i_b) be number')

            2. Return ((w_a = w_b) /\ (i_a = i_b))

          2. Else Phantom#289

        2. Else Phantom#290

  3. Case (% has type listValue)

    1. (Let ([ value_a* ]) be (value as listValue))

    2. If ((value' has type listValue)), then

      1. (Let ([ value_b* ]) be (value' as listValue))

      2. Return $bin_eqs(value_a*, value_b*)

    2. Else Phantom#291

  4. Case (% has type tupleValue)

    1. (Let (( value_a* )) be (value as tupleValue))

    2. If ((value' has type tupleValue)), then

      1. (Let (( value_b* )) be (value' as tupleValue))

      2. Return $bin_eqs(value_a*, value_b*)

    2. Else Phantom#292

  5. Case (% has type headerStackValue)

    1. (Let ([ value_a* #( _nat ; n_s_a )]) be (value as headerStackValue))

    2. If ((value' has type headerStackValue)), then

      1. (Let ([ value_b* #( _nat' ; n_s_b )]) be (value' as headerStackValue))

      2. Return ($bin_eqs(value_a*, value_b*) /\ (n_s_a = n_s_b))

    2. Else Phantom#293

  6. Case (% has type structValue)

    1. (Let (struct tid_a { (value_f_a id_f_a ;)* }) be (value as structValue))

    2. If ((value' has type structValue)), then

      1. (Let (struct tid_b { (value_f_b id_f_b ;)* }) be (value' as structValue))

      2. Return ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*, (value_f_b, id_f_b)*))

    2. Else Phantom#294

  7. Case (% has type headerValue)

    1. (Let (header tid_a { (value_f_a id_f_a ;)* }) be (value as headerValue))

    2. If ((value' has type headerValue)), then

      1. (Let (header tid_b { (value_f_b id_f_b ;)* }) be (value' as headerValue))

      2. Return ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*, (value_f_b, id_f_b)*))

    2. Else Phantom#295

  8. Case (% has type headerUnionValue)

    1. (Let (header_union tid_a { (value_f_a id_f_a ;)* }) be (value as headerUnionValue))

    2. If ((value' has type headerUnionValue)), then

      1. (Let (header_union tid_b { (value_f_b id_f_b ;)* }) be (value' as headerUnionValue))

      2. Return ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*, (value_f_b, id_f_b)*))

    2. Else Phantom#296

  9. Case (% has type enumValue)

    1. (Let enumValue be (value as enumValue))

    2. Case analysis on enumValue

      1. Case (% matches pattern `%.%`)

        1. (Let (tid_a . id_f_a) be enumValue)

        2. If ((value' has type enumValue)), then

          1. (Let enumValue' be (value' as enumValue))

          2. If ((enumValue' matches pattern `%.%`)), then

            1. (Let (tid_b . id_f_b) be enumValue')

            2. Return ((tid_a = tid_b) /\ (id_f_a = id_f_b))

          2. Else Phantom#297

        2. Else Phantom#298

      2. Case (% matches pattern `%.%#%`)

        1. (Let (tid_a . id_f_a # value_f_a) be enumValue)

        2. If ((value' has type enumValue)), then

          1. (Let enumValue' be (value' as enumValue))

          2. If ((enumValue' matches pattern `%.%#%`)), then

            1. (Let (tid_b . id_f_b # value_f_b) be enumValue')

            2. Return (((tid_a = tid_b) /\ (id_f_a = id_f_b)) /\ $bin_eq(value_f_a, value_f_b))

          2. Else Phantom#299

        2. Else Phantom#300

  10. Case (% has type invalidHeaderValue)

    1. (Let invalidHeaderValue be (value as invalidHeaderValue))

    2. If ((invalidHeaderValue matches pattern `{#}`)), then

      1. If ((value' has type invalidHeaderValue)), then

        1. (Let invalidHeaderValue' be (value' as invalidHeaderValue))

        2. If ((invalidHeaderValue' matches pattern `{#}`)), then

          1. Return true

        2. Else Phantom#301

      1. Else Phantom#302

    2. Else Phantom#303

1. Else Phantom#304

2. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. If ((numberValue matches pattern `%V%#%`)), then

    1. (Let (w_a v i_a # _nat) be numberValue)

    2. If ((value' has type numberValue)), then

      1. (Let numberValue' be (value' as numberValue))

      2. If ((numberValue' matches pattern `%V%#%`)), then

        1. (Let (w_b v i_b # _nat') be numberValue')

        2. Return ((w_a = w_b) /\ (i_a = i_b))

      2. Else Phantom#305

    2. Else Phantom#306

  2. Else Phantom#307

2. Else Phantom#308

;; ../../../../examples/p4-concrete/3-numerics.spectec:239:1-239:36:
def $bin_eqs(value*, value'*)

1. Case analysis on value*

  1. Case (% matches pattern [])

    1. Case analysis on value'*

      1. Case (% matches pattern [])

        1. Return true

      2. Case (% matches pattern _ :: _)

        1. (Let _value :: _value'* be value'*)

        2. Return false

  2. Case (% matches pattern _ :: _)

    1. (Let _value :: _value'* be value*)

    2. If ((value'* matches pattern [])), then

      1. Return false

    2. Else Phantom#309

    3. (Let value_a_h :: value_a_t* be value*)

    4. If ((value'* matches pattern _ :: _)), then

      1. (Let value_b_h :: value_b_t* be value'*)

      2. Return ($bin_eq(value_a_h, value_b_h) /\ $bin_eqs(value_a_t*, value_b_t*))

    4. Else Phantom#310

;; ../../../../examples/p4-concrete/3-numerics.spectec:240:1-240:55:
def $bin_eqs_fields((value, id)*, (value, id)'*)

1. Case analysis on (value, id)*

  1. Case (% matches pattern [])

    1. Case analysis on (value, id)'*

      1. Case (% matches pattern [])

        1. Return true

      2. Case (% matches pattern _ :: _)

        1. (Let _(value, id) :: _(value, id)'* be (value, id)'*)

        2. Return false

  2. Case (% matches pattern _ :: _)

    1. (Let _(value, id) :: _(value, id)'* be (value, id)*)

    2. If (((value, id)'* matches pattern [])), then

      1. Return false

    2. Else Phantom#311

    3. (Let (value_a_h, id_a_h) :: (value_a_t, id_a_t)* be (value, id)*)

    4. If (((value, id)'* matches pattern _ :: _)), then

      1. (Let (value_b_h, id_b_h) :: (value_b_t, id_b_t)* be (value, id)'*)

      2. Return (((id_a_h = id_b_h) /\ $bin_eq(value_a_h, value_b_h)) /\ $bin_eqs_fields((value_a_t, id_a_t)*, (value_b_t, id_b_t)*))

    4. Else Phantom#312

;; ../../../../examples/p4-concrete/3-numerics.spectec:297:1-297:33:
def $bin_ne(value_l, value_r)

1. Return ~$bin_eq(value_l, value_r)

;; ../../../../examples/p4-concrete/3-numerics.spectec:303:1-303:36:
def $bin_band(value, value')

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. Case analysis on number

    1. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be number')

          2. If ((w = w')), then

            1. (Let i' be $to_bitstr((w as int), $band(i_l, i_r)))

            2. Return ((w w i') as value)

          2. Else Phantom#313

        2. Else Phantom#314

      2. Else Phantom#315

    2. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be number')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), $band(i_l', i_r')))

            4. Return ((w s i') as value)

          2. Else Phantom#316

        2. Else Phantom#317

      2. Else Phantom#318

  2. Else Phantom#319

1. Else Phantom#320

;; ../../../../examples/p4-concrete/3-numerics.spectec:315:1-315:36:
def $bin_bxor(value, value')

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. Case analysis on number

    1. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be number')

          2. If ((w = w')), then

            1. (Let i' be $to_bitstr((w as int), $bxor(i_l, i_r)))

            2. Return ((w w i') as value)

          2. Else Phantom#321

        2. Else Phantom#322

      2. Else Phantom#323

    2. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be number')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), $bxor(i_l', i_r')))

            4. Return ((w s i') as value)

          2. Else Phantom#324

        2. Else Phantom#325

      2. Else Phantom#326

  2. Else Phantom#327

1. Else Phantom#328

;; ../../../../examples/p4-concrete/3-numerics.spectec:327:1-327:35:
def $bin_bor(value, value')

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. Case analysis on number

    1. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be number')

          2. If ((w = w')), then

            1. (Let i' be $to_bitstr((w as int), $bor(i_l, i_r)))

            2. Return ((w w i') as value)

          2. Else Phantom#329

        2. Else Phantom#330

      2. Else Phantom#331

    2. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. If ((number' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be number')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), $bor(i_l', i_r')))

            4. Return ((w s i') as value)

          2. Else Phantom#332

        2. Else Phantom#333

      2. Else Phantom#334

  2. Else Phantom#335

1. Else Phantom#336

;; ../../../../examples/p4-concrete/3-numerics.spectec:339:1-339:38:
def $bin_concat(value, value')

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. Case analysis on number

    1. Case (% matches pattern `%W%`)

      1. (Let (w_l w i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. Case analysis on number'

          1. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be number')

            2. (Let i_l' be $shl(i_l, (w_r as int)))

            3. (Let i_l'' be (i_l' + i_r))

            4. (Let w be (w_l + w_r))

            5. (Let i'' be $to_bitstr((w as int), i_l''))

            6. Return ((w w i'') as value)

          2. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be number')

            2. (Let i_l' be $shl(i_l, (w_r as int)))

            3. (Let i_l'' be (i_l' + i_r))

            4. (Let w be (w_l + w_r))

            5. (Let i'' be $to_bitstr((w as int), i_l''))

            6. Return ((w w i'') as value)

        2. Else Phantom#337

      2. Else Phantom#338

    2. Case (% matches pattern `%S%`)

      1. (Let (w_l s i_l) be number)

      2. If ((value' has type number)), then

        1. (Let number' be (value' as number))

        2. Case analysis on number'

          1. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be number')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i_l'' be $shl(i_l', (w_r as int)))

            4. (Let i_l''' be (i_l'' + i_r))

            5. (Let w be (w_l + w_r))

            6. (Let i''' be $to_bitstr((w as int), i_l'''))

            7. Return ((w s i''') as value)

          2. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be number')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i_l'' be $shl(i_l', (w_r as int)))

            4. (Let i_l''' be (i_l'' + i_r))

            5. (Let w be (w_l + w_r))

            6. (Let i''' be $to_bitstr((w as int), i_l'''))

            7. Return ((w s i''') as value)

        2. Else Phantom#339

      2. Else Phantom#340

  2. Else Phantom#341

1. Else Phantom#342

;; ../../../../examples/p4-concrete/3-numerics.spectec:367:1-367:36:
def $bin_land(value, value')

1. If ((value has type primitiveValue)), then

  1. (Let primitiveValue be (value as primitiveValue))

  2. If ((primitiveValue matches pattern `B%`)), then

    1. (Let (b b_l) be primitiveValue)

    2. If ((value' has type primitiveValue)), then

      1. (Let primitiveValue' be (value' as primitiveValue))

      2. If ((primitiveValue' matches pattern `B%`)), then

        1. (Let (b b_r) be primitiveValue')

        2. Return ((b (b_l /\ b_r)) as value)

      2. Else Phantom#343

    2. Else Phantom#344

  2. Else Phantom#345

1. Else Phantom#346

;; ../../../../examples/p4-concrete/3-numerics.spectec:373:1-373:35:
def $bin_lor(value, value')

1. If ((value has type primitiveValue)), then

  1. (Let primitiveValue be (value as primitiveValue))

  2. If ((primitiveValue matches pattern `B%`)), then

    1. (Let (b b_l) be primitiveValue)

    2. If ((value' has type primitiveValue)), then

      1. (Let primitiveValue' be (value' as primitiveValue))

      2. If ((primitiveValue' matches pattern `B%`)), then

        1. (Let (b b_r) be primitiveValue')

        2. Return ((b (b_l \/ b_r)) as value)

      2. Else Phantom#347

    2. Else Phantom#348

  2. Else Phantom#349

1. Else Phantom#350

;; ../../../../examples/p4-concrete/3-numerics.spectec:381:1-381:36:
def $cast_op(typeIR, value'')

1. Case analysis on value''

  1. Case (% has type primitiveValue)

    1. (Let primitiveValue be (value'' as primitiveValue))

    2. If ((primitiveValue matches pattern `B%`)), then

      1. (Let (b b) be primitiveValue)

      2. Return $cast_bool(typeIR, b)

    2. Else Phantom#351

  2. Case (% has type number)

    1. (Let number be (value'' as number))

    2. Case analysis on number

      1. Case (% matches pattern `D%`)

        1. (Let (d i) be number)

        2. Return $cast_arbint(typeIR, i)

      2. Case (% matches pattern `%W%`)

        1. (Let (w w i) be number)

        2. Return $cast_fixbit(typeIR, w, i)

      3. Case (% matches pattern `%S%`)

        1. (Let (w s i) be number)

        2. Return $cast_fixint(typeIR, w, i)

  3. Case (% has type structValue)

    1. (Let (struct tid { (value_f id_f ;)* }) be (value'' as structValue))

    2. Return $cast_struct(typeIR, tid, (value_f, id_f)*)

  4. Case (% has type headerValue)

    1. (Let (header tid { (value_f id_f ;)* }) be (value'' as headerValue))

    2. Return $cast_header(typeIR, tid, (value_f, id_f)*)

  5. Case (% has type enumValue)

    1. (Let enumValue be (value'' as enumValue))

    2. If ((enumValue matches pattern `%.%#%`)), then

      1. (Let (_tid . _id # value'') be enumValue)

      2. Return $cast_op(typeIR, value'')

    2. Else Phantom#352

  6. Case (% has type sequenceValue)

    1. (Let sequenceValue be (value'' as sequenceValue))

    2. If ((sequenceValue matches pattern `SEQ(%)`)), then

      1. (Let (seq( value''* )) be sequenceValue)

      2. Return $cast_sequence(typeIR, value''*)

    2. Else Phantom#353

  7. Case (% has type recordValue)

    1. (Let recordValue be (value'' as recordValue))

    2. If ((recordValue matches pattern `RECORD{%}`)), then

      1. (Let (record{ (value'' id ;)* }) be recordValue)

      2. Return $cast_record(typeIR, (value'', id)*)

    2. Else Phantom#354

  8. Case (% has type defaultValue)

    1. (Let defaultValue be (value'' as defaultValue))

    2. If ((defaultValue matches pattern `DEFAULT`)), then

      1. Return $default(typeIR)

    2. Else Phantom#355

  9. Case (% has type setValue)

    1. (Let setValue be (value'' as setValue))

    2. Case analysis on setValue

      1. Case (% matches pattern `SET{%}`)

        1. (Let (set{ value'' }) be setValue)

        2. Return $cast_set_singleton(typeIR, value'')

      2. Case (% matches pattern `SET{%&&&%}`)

        1. (Let (set{ value_b &&& value_m }) be setValue)

        2. Return $cast_set_mask(typeIR, value_b, value_m)

      3. Case (% matches pattern `SET{%..%}`)

        1. (Let (set{ value_l .. value_u }) be setValue)

        2. Return $cast_set_range(typeIR, value_l, value_u)

1. Else Phantom#356

;; ../../../../examples/p4-concrete/3-numerics.spectec:383:1-383:29:
def $default(typeIR)

1. Return $default'($canon(typeIR))

;; ../../../../examples/p4-concrete/3-numerics.spectec:384:1-384:30:
def $default'(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `BOOL`)

        1. Return ((b false) as value)

      2. Case (% matches pattern `ERROR`)

        1. Return ((error. "NoError") as value)

      3. Case (% matches pattern `STRING`)

        1. (Let text_empty be "")

        2. Return ((" text_empty ") as value)

    2. Else Phantom#357

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT`)

        1. Return ((d (0 as int)) as value)

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< w >) be numberTypeIR)

        2. Return ((w w (0 as int)) as value)

      3. Case (% matches pattern `INT<%>`)

        1. (Let (int< w >) be numberTypeIR)

        2. Return ((w s (0 as int)) as value)

      4. Case (% matches pattern `VARBIT<%>`)

        1. (Let (varbit< w >) be numberTypeIR)

        2. Return ((w v (0 as int) # 0) as value)

  3. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. Return (([ $default(typeIR'')* ]) as value)

  4. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'' [ n_s ]) be (typeIR'' as headerStackTypeIR))

    2. (Let value* be $repeat_<value>($default(typeIR''), n_s))

    3. Return (([ value* #( 0 ; n_s )]) as value)

  5. Case (% has type structTypeIR)

    1. (Let (struct tid { (typeIR_f id_f ;)* }) be (typeIR'' as structTypeIR))

    2. Return ((struct tid { ($default(typeIR_f) id_f ;)* }) as value)

  6. Case (% has type headerTypeIR)

    1. (Let (header tid { (typeIR_f id_f ;)* }) be (typeIR'' as headerTypeIR))

    2. Return ((header tid { ($default(typeIR_f) id_f ;)* }) as value)

  7. Case (% has type headerUnionTypeIR)

    1. (Let (header_union tid { (typeIR_f id_f ;)* }) be (typeIR'' as headerUnionTypeIR))

    2. Return ((header_union tid { ($default(typeIR_f) id_f ;)* }) as value)

  8. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum tid { id* }) be enumTypeIR)

        2. If ((id* matches pattern _ :: _)), then

          1. (Let id_f_h :: _id* be id*)

          2. Return ((tid . id_f_h) as value)

        2. Else Phantom#358

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum tid # typeIR'' { (id_f = value_f ;)* }) be enumTypeIR)

        2. (Let value_zero be $cast_arbint(typeIR'', (0 as int)))

        3. (Let id? be $assoc_<value, id>(value_zero, (value_f, id_f)*))

        4. If ((id? matches pattern (_))), then

          1. (Let ?(id_zero) be id?)

          2. Return ((tid . id_zero # value_zero) as value)

        4. Else Phantom#359

        5. If ((?() = $assoc_<value, id>(value_zero, (value_f, id_f)*))), then

          1. (Let id_zero be "__UNSPECIFIED")

          2. Return ((tid . id_zero # value_zero) as value)

        5. Else Phantom#360

1. Else Phantom#361

;; ../../../../examples/p4-concrete/3-numerics.spectec:388:1-388:37:
def $cast_bool(typeIR, b)

1. Return $cast_bool'($canon(typeIR), b)

;; ../../../../examples/p4-concrete/3-numerics.spectec:389:1-389:38:
def $cast_bool'(typeIR'', b')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BOOL`)), then

      1. Return ((b b') as value)

    2. Else Phantom#362

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `BIT<%>`)), then

      1. (Let (bit< w >) be numberTypeIR)

      2. Case analysis on b'

        1. Case (% = true)

          1. Return ((w w (1 as int)) as value)

        2. Case (% = false)

          1. Return ((w w (0 as int)) as value)

      2. Else Phantom#363

    2. Else Phantom#364

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR'') be aliasTypeIR)

      2. Return $cast_bool(typeIR'', b')

    2. Else Phantom#365

1. Else Phantom#366

;; ../../../../examples/p4-concrete/3-numerics.spectec:402:1-402:38:
def $cast_arbint(typeIR, i)

1. Return $cast_arbint'($canon(typeIR), i)

;; ../../../../examples/p4-concrete/3-numerics.spectec:403:1-403:39:
def $cast_arbint'(typeIR''', i)

1. Case analysis on typeIR'''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR''' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BOOL`)), then

      1. Return ((b (i = (0 as int))) as value)

    2. Else Phantom#367

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR''' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT`)

        1. Return ((d i) as value)

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< w >) be numberTypeIR)

        2. Return ((w w $to_bitstr((w as int), i)) as value)

      3. Case (% matches pattern `INT<%>`)

        1. (Let (int< w >) be numberTypeIR)

        2. Return ((w s $to_bitstr((w as int), i)) as value)

    2. Else Phantom#368

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR''' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR''') be aliasTypeIR)

      2. Return $cast_arbint(typeIR''', i)

    2. Else Phantom#369

  4. Case (% has type setTypeIR)

    1. (Let (set< typeIR'''* >) be (typeIR''' as setTypeIR))

    2. If ((typeIR'''* matches pattern [ _/1 ])), then

      1. (Let [typeIR'''] be typeIR'''*)

      2. Return ((set{ $cast_arbint(typeIR''', i) }) as value)

    2. Else Phantom#370

1. Else Phantom#371

;; ../../../../examples/p4-concrete/3-numerics.spectec:418:1-418:43:
def $cast_fixbit(typeIR, w, i)

1. Return $cast_fixbit'($canon(typeIR), w, i)

;; ../../../../examples/p4-concrete/3-numerics.spectec:419:1-419:44:
def $cast_fixbit'(typeIR''', w', i)

1. Case analysis on typeIR'''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR''' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BOOL`)), then

      1. Return ((b (i = (1 as int))) as value)

    2. Else Phantom#372

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR''' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT`)

        1. Return ((d i) as value)

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< w_to >) be numberTypeIR)

        2. (Let i' be $to_bitstr((w_to as int), i))

        3. Return ((w_to w i') as value)

      3. Case (% matches pattern `INT<%>`)

        1. (Let (int< w_to >) be numberTypeIR)

        2. (Let i' be $to_bitstr((w_to as int), i))

        3. Return ((w_to s i') as value)

    2. Else Phantom#373

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR''' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR''') be aliasTypeIR)

      2. Return $cast_fixbit(typeIR''', w', i)

    2. Else Phantom#374

  4. Case (% has type setTypeIR)

    1. (Let (set< typeIR'''* >) be (typeIR''' as setTypeIR))

    2. If ((typeIR'''* matches pattern [ _/1 ])), then

      1. (Let [typeIR'''] be typeIR'''*)

      2. Return ((set{ $cast_fixbit(typeIR''', w', i) }) as value)

    2. Else Phantom#375

1. Else Phantom#376

;; ../../../../examples/p4-concrete/3-numerics.spectec:436:1-436:43:
def $cast_fixint(typeIR, w, i)

1. Return $cast_fixint'($canon(typeIR), w, i)

;; ../../../../examples/p4-concrete/3-numerics.spectec:437:1-437:44:
def $cast_fixint'(typeIR''', w', i)

1. Case analysis on typeIR'''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR''' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT`)

        1. Return ((d $to_int((w' as int), i)) as value)

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< w_to >) be numberTypeIR)

        2. (Let i' be $to_bitstr((w_to as int), $to_int((w' as int), i)))

        3. Return ((w_to w i') as value)

      3. Case (% matches pattern `INT<%>`)

        1. (Let (int< w_to >) be numberTypeIR)

        2. (Let i' be $to_bitstr((w_to as int), $to_int((w' as int), i)))

        3. Return ((w_to s i') as value)

    2. Else Phantom#377

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR''' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR''') be aliasTypeIR)

      2. Return $cast_fixint(typeIR''', w', i)

    2. Else Phantom#378

  3. Case (% has type setTypeIR)

    1. (Let (set< typeIR'''* >) be (typeIR''' as setTypeIR))

    2. If ((typeIR'''* matches pattern [ _/1 ])), then

      1. (Let [typeIR'''] be typeIR'''*)

      2. Return ((set{ $cast_fixint(typeIR''', w', i) }) as value)

    2. Else Phantom#379

1. Else Phantom#380

;; ../../../../examples/p4-concrete/3-numerics.spectec:453:1-453:52:
def $cast_struct(typeIR, tid, (value_f, id_f)*)

1. Return $cast_struct'($canon(typeIR), tid, (value_f, id_f)*)

;; ../../../../examples/p4-concrete/3-numerics.spectec:454:1-454:53:
def $cast_struct'(typeIR, tid', (value_f, id_f)*)

1. If ((typeIR has type structTypeIR)), then

  1. (Let (struct tid { _fieldTypeIR* }) be (typeIR as structTypeIR))

  2. If ((tid = tid')), then

    1. Return ((struct tid { (value_f id_f ;)* }) as value)

  2. Else Phantom#381

1. Else Phantom#382

;; ../../../../examples/p4-concrete/3-numerics.spectec:467:1-467:52:
def $cast_header(typeIR, tid, (value_f, id_f)*)

1. Return $cast_header'($canon(typeIR), tid, (value_f, id_f)*)

;; ../../../../examples/p4-concrete/3-numerics.spectec:468:1-468:53:
def $cast_header'(typeIR, tid', (value_f, id_f)*)

1. If ((typeIR has type headerTypeIR)), then

  1. (Let (header tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

  2. If ((tid = tid')), then

    1. Return ((header tid { (value_f id_f ;)* }) as value)

  2. Else Phantom#383

1. Else Phantom#384

;; ../../../../examples/p4-concrete/3-numerics.spectec:485:1-485:43:
def $cast_sequence(typeIR, value*)

1. Return $cast_sequence'($canon(typeIR), value*)

;; ../../../../examples/p4-concrete/3-numerics.spectec:486:1-486:44:
def $cast_sequence'(typeIR'', value*)

1. Case analysis on typeIR''

  1. Case (% has type listTypeIR)

    1. (Let (list< typeIR >) be (typeIR'' as listTypeIR))

    2. Return (([ $cast_op(typeIR, value)* ]) as value)

  2. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR* >) be (typeIR'' as tupleTypeIR))

    2. Return ((( $cast_op(typeIR, value)* )) as value)

  3. Case (% has type headerStackTypeIR)

    1. (Let (typeIR [ n_s ]) be (typeIR'' as headerStackTypeIR))

    2. (Let value_cast be $cast_op(typeIR, value))*

    3. (Let n_idx be |value*|)

    4. Return (([ value_cast* #( n_idx ; n_s )]) as value)

  4. Case (% has type structTypeIR)

    1. (Let (struct tid { (typeIR_f id_f ;)* }) be (typeIR'' as structTypeIR))

    2. (Let value_cast be $cast_op(typeIR_f, value))*

    3. Return ((struct tid { (value_cast id_f ;)* }) as value)

  5. Case (% has type headerTypeIR)

    1. (Let (header tid { (typeIR_f id_f ;)* }) be (typeIR'' as headerTypeIR))

    2. (Let value_cast be $cast_op(typeIR_f, value))*

    3. Return ((header tid { (value_cast id_f ;)* }) as value)

1. Else Phantom#385

;; ../../../../examples/p4-concrete/3-numerics.spectec:516:1-516:47:
def $cast_record(typeIR, (value, id)*)

1. Return $cast_record'($canon(typeIR), (value, id)*)

;; ../../../../examples/p4-concrete/3-numerics.spectec:517:1-517:48:
def $cast_record'(typeIR, (value_f, id_f)*)

1. Case analysis on typeIR

  1. Case (% has type structTypeIR)

    1. (Let (struct tid { (typeIR_t_f id_t_f ;)* }) be (typeIR as structTypeIR))

    2. (Let value? be $find_map<id, value>(({ (id_f : value_f)* }), id_t_f))*

    3. If ((value? matches pattern (_)))*, then

      1. (Let ?(value_f') be value?)*

      2. (Let value_f_cast be $cast_op(typeIR_t_f, value_f'))*

      3. Return ((struct tid { (value_f_cast id_f ;)* }) as value)

    3. Else Phantom#386

  2. Case (% has type headerTypeIR)

    1. (Let (header tid { (typeIR_t_f id_t_f ;)* }) be (typeIR as headerTypeIR))

    2. (Let value? be $find_map<id, value>(({ (id_f : value_f)* }), id_t_f))*

    3. If ((value? matches pattern (_)))*, then

      1. (Let ?(value_f') be value?)*

      2. (Let value_f_cast be $cast_op(typeIR_t_f, value_f'))*

      3. Return ((header tid { (value_f_cast id_f ;)* }) as value)

    3. Else Phantom#387

1. Else Phantom#388

;; ../../../../examples/p4-concrete/3-numerics.spectec:551:1-551:47:
def $cast_set_singleton(typeIR, value)

1. Return $cast_set_singleton'($canon(typeIR), value)

;; ../../../../examples/p4-concrete/3-numerics.spectec:552:1-552:48:
def $cast_set_singleton'(typeIR'', value)

1. If ((typeIR'' has type setTypeIR)), then

  1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

  2. If ((typeIR'* matches pattern [ _/1 ])), then

    1. (Let [typeIR] be typeIR'*)

    2. Return ((set{ $cast_op(typeIR, value) }) as value)

  2. Else Phantom#389

1. Else Phantom#390

;; ../../../../examples/p4-concrete/3-numerics.spectec:560:1-560:49:
def $cast_set_mask(typeIR, value_b, value_m)

1. Return $cast_set_mask'($canon(typeIR), value_b, value_m)

;; ../../../../examples/p4-concrete/3-numerics.spectec:561:1-561:50:
def $cast_set_mask'(typeIR'', value_b, value_m)

1. If ((typeIR'' has type setTypeIR)), then

  1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

  2. If ((typeIR'* matches pattern [ _/1 ])), then

    1. (Let [typeIR] be typeIR'*)

    2. (Let value_b_cast be $cast_op(typeIR, value_b))

    3. (Let value_m_cast be $cast_op(typeIR, value_m))

    4. Return ((set{ value_b_cast &&& value_m_cast }) as value)

  2. Else Phantom#391

1. Else Phantom#392

;; ../../../../examples/p4-concrete/3-numerics.spectec:571:1-571:50:
def $cast_set_range(typeIR, value_l, value_u)

1. Return $cast_set_range'($canon(typeIR), value_l, value_u)

;; ../../../../examples/p4-concrete/3-numerics.spectec:572:1-572:51:
def $cast_set_range'(typeIR'', value_l, value_u)

1. If ((typeIR'' has type setTypeIR)), then

  1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

  2. If ((typeIR'* matches pattern [ _/1 ])), then

    1. (Let [typeIR] be typeIR'*)

    2. (Let value_l_cast be $cast_op(typeIR, value_l))

    3. (Let value_u_cast be $cast_op(typeIR, value_u))

    4. Return ((set{ value_l_cast .. value_u_cast }) as value)

  2. Else Phantom#393

1. Else Phantom#394

;; ../../../../examples/p4-concrete/3-numerics.spectec:637:1-637:44:
def $bitacc_op(value_b, value_h, value_l)

1. (Let i_b be $to_number(value_b))

2. (Let i_h be $to_number(value_h))

3. (Let i_l be $to_number(value_l))

4. (Let int be ((i_h + (1 as int)) - i_l))

5. If ((int has type nat)), then

  1. (Let w be (int as nat))

  2. (Let i be $bitacc(i_b, i_h, i_l))

  3. Return ((w w i) as value)

5. Else Phantom#395

;; ../../../../examples/p4-concrete/3-numerics.spectec:650:1-650:32:
def $sizeof(typeIR, text)

1. Case analysis on text

  1. Case (% = "minSizeInBits")

    1. Return $sizeof_minSizeInBits(typeIR)

  2. Case (% = "minSizeInBytes")

    1. Return $sizeof_minSizeInBytes(typeIR)

  3. Case (% = "maxSizeInBits")

    1. Return $sizeof_maxSizeInBits(typeIR)

  4. Case (% = "maxSizeInBytes")

    1. Return $sizeof_maxSizeInBytes(typeIR)

1. Else Phantom#396

;; ../../../../examples/p4-concrete/3-numerics.spectec:652:1-652:42:
def $sizeof_minSizeInBits(typeIR)

1. Return ((d ($sizeof_minSizeInBits'(typeIR) as int)) as value)

;; ../../../../examples/p4-concrete/3-numerics.spectec:653:1-653:41:
def $sizeof_minSizeInBits'(typeIR)

1. Return $sizeof_minSizeInBits''($canon(typeIR))

;; ../../../../examples/p4-concrete/3-numerics.spectec:654:1-654:42:
def $sizeof_minSizeInBits''(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BOOL`)), then

      1. Return 1

    2. Else Phantom#397

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< w >) be numberTypeIR)

        2. Return w

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< w >) be numberTypeIR)

        2. Return w

      3. Case (% matches pattern `VARBIT<%>`)

        1. (Let (varbit< _nat >) be numberTypeIR)

        2. Return 0

    2. Else Phantom#398

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR'') be aliasTypeIR)

      2. Return $sizeof_minSizeInBits'(typeIR'')

    2. Else Phantom#399

  4. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum _tid # typeIR'' { _valueFieldIR* }) be enumTypeIR)

      2. Return $sizeof_minSizeInBits'(typeIR'')

    2. Else Phantom#400

  5. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. Return $sum($sizeof_minSizeInBits'(typeIR'')*)

  6. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'' [ n_size ]) be (typeIR'' as headerStackTypeIR))

    2. Return ($sizeof_minSizeInBits'(typeIR'') * n_size)

  7. Case (% has type structTypeIR)

    1. (Let (struct _tid { (typeIR'' _id ;)* }) be (typeIR'' as structTypeIR))

    2. Return $sum($sizeof_minSizeInBits'(typeIR'')*)

  8. Case (% has type headerTypeIR)

    1. (Let (header _tid { (typeIR'' _id ;)* }) be (typeIR'' as headerTypeIR))

    2. Return $sum($sizeof_minSizeInBits'(typeIR'')*)

  9. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { (typeIR'' _id ;)* }) be (typeIR'' as headerUnionTypeIR))

    2. Return $min($sizeof_minSizeInBits'(typeIR'')*)

1. Else Phantom#401

;; ../../../../examples/p4-concrete/3-numerics.spectec:656:1-656:43:
def $sizeof_minSizeInBytes(typeIR)

1. (Let n_size be $sizeof_minSizeInBits'(typeIR))

2. Return ((d ((n_size / 8) as int)) as value)

;; ../../../../examples/p4-concrete/3-numerics.spectec:658:1-658:42:
def $sizeof_maxSizeInBits(typeIR)

1. Return ((d ($sizeof_maxSizeInBits'(typeIR) as int)) as value)

;; ../../../../examples/p4-concrete/3-numerics.spectec:659:1-659:41:
def $sizeof_maxSizeInBits'(typeIR)

1. Return $sizeof_maxSizeInBits''($canon(typeIR))

;; ../../../../examples/p4-concrete/3-numerics.spectec:660:1-660:42:
def $sizeof_maxSizeInBits''(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BOOL`)), then

      1. Return 1

    2. Else Phantom#402

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< w >) be numberTypeIR)

        2. Return w

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< w >) be numberTypeIR)

        2. Return w

      3. Case (% matches pattern `VARBIT<%>`)

        1. (Let (varbit< w >) be numberTypeIR)

        2. Return w

    2. Else Phantom#403

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR'') be aliasTypeIR)

      2. Return $sizeof_maxSizeInBits'(typeIR'')

    2. Else Phantom#404

  4. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum _tid # typeIR'' { _valueFieldIR* }) be enumTypeIR)

      2. Return $sizeof_maxSizeInBits'(typeIR'')

    2. Else Phantom#405

  5. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. Return $sum($sizeof_maxSizeInBits'(typeIR'')*)

  6. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'' [ n_size ]) be (typeIR'' as headerStackTypeIR))

    2. Return ($sizeof_maxSizeInBits'(typeIR'') * n_size)

  7. Case (% has type structTypeIR)

    1. (Let (struct _tid { (typeIR'' _id ;)* }) be (typeIR'' as structTypeIR))

    2. Return $sum($sizeof_maxSizeInBits'(typeIR'')*)

  8. Case (% has type headerTypeIR)

    1. (Let (header _tid { (typeIR'' _id ;)* }) be (typeIR'' as headerTypeIR))

    2. Return $sum($sizeof_maxSizeInBits'(typeIR'')*)

  9. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { (typeIR'' _id ;)* }) be (typeIR'' as headerUnionTypeIR))

    2. Return $max($sizeof_maxSizeInBits'(typeIR'')*)

1. Else Phantom#406

;; ../../../../examples/p4-concrete/3-numerics.spectec:662:1-662:43:
def $sizeof_maxSizeInBytes(typeIR)

1. (Let n_size be $sizeof_maxSizeInBits'(typeIR))

2. Return ((d ((n_size / 8) as int)) as value)

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:6:1-7:14:
syntax prefixedNameIR = 
   | ` nameIR
   | . nameIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:9:1-9:63:
def $prefixedNonTypeName(prefixedNonTypeName)

1. If ((prefixedNonTypeName has type nonTypeName)), then

  1. (Let nonTypeName be (prefixedNonTypeName as nonTypeName))

  2. Return (` $name((nonTypeName as name)))

1. Else Phantom#407

2. If ((prefixedNonTypeName matches pattern ``ID.%`)), then

  1. (Let (. nonTypeName) be prefixedNonTypeName)

  2. Return (. $name((nonTypeName as name)))

2. Else Phantom#408

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:13:1-13:57:
def $prefixedTypeName(prefixedTypeName)

1. If ((prefixedTypeName has type typeName)), then

  1. (Let typeName be (prefixedTypeName as typeName))

  2. Return (` $name((typeName as name)))

1. Else Phantom#409

2. If ((prefixedTypeName matches pattern ``TID.%`)), then

  1. (Let (. typeName) be prefixedTypeName)

  2. Return (. $name((typeName as name)))

2. Else Phantom#410

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:17:1-17:53:
def $flatten_prefixedNameIR(prefixedNameIR)

1. Case analysis on prefixedNameIR

  1. Case (% matches pattern ``%`)

    1. (Let (` nameIR) be prefixedNameIR)

    2. Return nameIR

  2. Case (% matches pattern `.%`)

    1. (Let (. nameIR) be prefixedNameIR)

    2. Return "." ++ nameIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:21:21-21:28:
syntax nameListIR = nameIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:27:26-27:29:
syntax typeParameterIR = tid

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:29:30-29:46:
syntax typeParameterListIR = typeParameterIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:38:3-38:66:
syntax parameterIR = 
   | annotationList direction typeIR nameIR constantInitializerOptIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:40:26-40:38:
syntax parameterListIR = parameterIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:46:33-46:44:
syntax constructorParameterIR = parameterIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:48:37-48:49:
syntax constructorParameterListIR = parameterIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:56:28-56:55:
syntax namedExpressionIR = 
   | nameIR = typedExpressionIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:58:32-58:50:
syntax namedExpressionListIR = namedExpressionIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:68:30-68:47:
syntax literalExpressionIR = literalExpression

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:74:32-74:46:
syntax referenceExpressionIR = prefixedNameIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:80:30-80:47:
syntax defaultExpressionIR = defaultExpression

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:86:28-86:50:
syntax unaryExpressionIR = 
   | unop typedExpressionIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:89:3-89:44:
syntax binaryExpressionIR = 
   | typedExpressionIR binop typedExpressionIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:92:3-92:62:
syntax ternaryExpressionIR = 
   | typedExpressionIR ? typedExpressionIR : typedExpressionIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:98:27-98:56:
syntax castExpressionIR = 
   | ( typeIR ) typedExpressionIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:107:1-111:46:
syntax dataExpressionIR = 
   | {#}
   | seq{ typedExpressionListIR }
   | seq{ typedExpressionListIR ,...}
   | record{ namedExpressionListIR }
   | record{ namedExpressionListIR ,...}

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:120:3-120:18:
syntax errorAccessExpressionIR = 
   | error. nameIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:123:3-123:31:
syntax memberAccessExpressionIR = 
   | memberAccessBaseIR . nameIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:126:1-127:66:
syntax indexAccessExpressionIR = 
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:130:1-132:28:
syntax accessExpressionIR = 
   | error. nameIR
   | memberAccessBaseIR . nameIR
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:143:1-146:25:
syntax routineTargetIR = 
   | ` nameIR
   | . nameIR
   | typedExpressionIR . nameIR
   | type prefixedNameIR . nameIR
   | ( routineTargetIR )

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:148:30-148:68:
syntax constructorTargetIR = 
   | prefixedNameIR < typeArgumentListIR >

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:151:1-152:64:
syntax callExpressionIR = 
   | constructorTargetIR ( argumentListIR )
   | routineTargetIR < typeArgumentListIR >( argumentListIR )

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:158:36-158:58:
syntax parenthesizedExpressionIR = 
   | ( typedExpressionIR )

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:165:1-175:30:
syntax expressionIR = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | ` nameIR
   | . nameIR
   | ...
   | unop typedExpressionIR
   | typedExpressionIR binop typedExpressionIR
   | typedExpressionIR ? typedExpressionIR : typedExpressionIR
   | ( typeIR ) typedExpressionIR
   | {#}
   | seq{ typedExpressionListIR }
   | seq{ typedExpressionListIR ,...}
   | record{ namedExpressionListIR }
   | record{ namedExpressionListIR ,...}
   | error. nameIR
   | memberAccessBaseIR . nameIR
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]
   | constructorTargetIR ( argumentListIR )
   | routineTargetIR < typeArgumentListIR >( argumentListIR )
   | ( typedExpressionIR )

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:177:27-177:42:
syntax expressionNoteIR = 
   | ( typeIR ctk )

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:180:3-180:35:
syntax typedExpressionIR = 
   | expressionIR # expressionNoteIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:182:32-182:50:
syntax typedExpressionListIR = typedExpressionIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:185:1-186:22:
syntax memberAccessBaseIR = 
   | type prefixedNameIR
   | expressionIR # expressionNoteIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:193:1-197:7:
syntax simpleKeysetExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR &&& typedExpressionIR
   | typedExpressionIR .. typedExpressionIR
   | default
   | _

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:199:39-199:64:
syntax simpleKeysetExpressionListIR = simpleKeysetExpressionIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:201:34-201:67:
syntax tupleKeysetExpressionIR = 
   | ( simpleKeysetExpressionListIR )

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:204:1-205:28:
syntax keysetExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR &&& typedExpressionIR
   | typedExpressionIR .. typedExpressionIR
   | default
   | _
   | ( simpleKeysetExpressionListIR )

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:211:25-211:31:
syntax typeArgumentIR = typeIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:213:29-213:44:
syntax typeArgumentListIR = typeArgumentIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:220:1-223:7:
syntax argumentIR = 
   | expressionIR # expressionNoteIR
   | nameIR = typedExpressionIR
   | nameIR =_
   | _

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:225:25-225:36:
syntax argumentListIR = argumentIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:232:1-236:23:
syntax lvalueIR = 
   | ` nameIR
   | . nameIR
   | typedLvalueIR . nameIR
   | typedLvalueIR [ typedExpressionIR ]
   | typedLvalueIR [ typedExpressionIR : typedExpressionIR ]
   | ( typedLvalueIR )

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:238:24-238:47:
syntax typedLvalueIR = 
   | lvalueIR #( typeIR )

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:248:27-248:41:
syntax emptyStatementIR = emptyStatement

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:255:3-255:46:
syntax assignmentStatementIR = 
   | typedLvalueIR assignop typedExpressionIR ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:262:3-262:65:
syntax callStatementIR = 
   | routineTargetIR < typeArgumentListIR >( argumentListIR );

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:269:3-269:49:
syntax directApplicationStatementIR = 
   | prefixedNameIR .apply( argumentListIR );

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:276:1-277:32:
syntax returnStatementIR = 
   | return;
   | return typedExpressionIR ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:283:26-283:39:
syntax exitStatementIR = exitStatement

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:292:3-292:50:
syntax blockStatementIR = 
   | annotationList { blockElementStatementListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:301:1-302:59:
syntax conditionalStatementIR = 
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:311:1-314:35:
syntax forInitStatementIR = 
   | annotationList typeIR nameIR initializerOptIR
   | lvalueIR ( argumentListIR )
   | lvalueIR < typeArgumentListIR >( argumentListIR )
   | lvalueIR assignop expressionIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:316:33-316:52:
syntax forInitStatementListIR = forInitStatementIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:318:31-318:49:
syntax forUpdateStatementIR = forInitStatementIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:320:35-320:56:
syntax forUpdateStatementListIR = forUpdateStatementIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:323:1-324:44:
syntax forCollectionExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR .. typedExpressionIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:327:1-335:18:
syntax forStatementIR = 
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:342:1-343:22:
syntax switchLabelIR = 
   | default
   | expressionIR # expressionNoteIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:346:1-347:21:
syntax switchCaseIR = 
   | switchLabelIR : blockStatementIR
   | switchLabelIR :

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:349:27-349:40:
syntax switchCaseListIR = switchCaseIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:352:3-352:54:
syntax switchStatementIR = 
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:358:27-358:41:
syntax breakStatementIR = breakStatement

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:360:30-360:47:
syntax continueStatementIR = continueStatement

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:367:1-378:22:
syntax statementIR = 
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | return;
   | return typedExpressionIR ;
   | exit;
   | annotationList { blockElementStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR
   | break;
   | continue;
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:388:32-388:40:
syntax constantInitializerIR = 
   | = value

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:390:35-390:57:
syntax constantInitializerOptIR = constantInitializerIR?

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:393:3-393:62:
syntax constantDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:395:24-395:44:
syntax initializerIR = 
   | = typedExpressionIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:397:27-397:41:
syntax initializerOptIR = initializerIR?

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:400:3-400:51:
syntax variableDeclarationIR = 
   | annotationList typeIR nameIR initializerOptIR ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:403:1-405:16:
syntax blockElementStatementIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | return;
   | return typedExpressionIR ;
   | exit;
   | annotationList { blockElementStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR
   | break;
   | continue;
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:407:38-407:62:
syntax blockElementStatementListIR = blockElementStatementIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:414:3-415:73:
syntax functionPrototypeIR = 
   | typeIR nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR )

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:418:3-418:54:
syntax functionDeclarationIR = 
   | annotationList functionPrototypeIR blockStatementIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:425:3-425:69:
syntax actionDeclarationIR = 
   | annotationList action nameIR ( parameterListIR ) blockStatementIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:433:30-433:61:
syntax objectInitializerIR = 
   | ={ objectDeclarationListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:435:33-435:53:
syntax objectInitializerOptIR = objectInitializerIR?

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:438:3-440:30:
syntax instantiationIR = 
   | annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:443:1-444:20:
syntax objectDeclarationIR = 
   | annotationList functionPrototypeIR blockStatementIR
   | annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:446:34-446:54:
syntax objectDeclarationListIR = objectDeclarationIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:452:29-452:50:
syntax errorDeclarationIR = 
   | error{ nameListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:458:33-458:59:
syntax matchKindDeclarationIR = 
   | match_kind{ nameListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:469:1-470:65:
syntax enumTypeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:476:22-476:53:
syntax typeFieldIR = 
   | annotationList typeIR nameIR ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:478:26-478:38:
syntax typeFieldListIR = typeFieldIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:481:3-482:73:
syntax structTypeDeclarationIR = 
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:485:3-486:73:
syntax headerTypeDeclarationIR = 
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:489:3-490:73:
syntax headerUnionTypeDeclarationIR = 
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:493:1-496:33:
syntax derivedTypeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:503:1-504:29:
syntax typedefTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:507:1-508:41:
syntax typedefDeclarationIR = 
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:515:3-515:47:
syntax externFunctionDeclarationIR = 
   | annotationList extern functionPrototypeIR ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:518:1-520:51:
syntax methodPrototypeIR = 
   | annotationList nameIR <, typeParameterListIR >( parameterListIR );
   | annotationList functionPrototypeIR ;
   | annotationList abstract functionPrototypeIR ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:522:32-522:50:
syntax methodPrototypeListIR = methodPrototypeIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:525:3-527:31:
syntax externObjectDeclarationIR = 
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:530:1-531:30:
syntax externDeclarationIR = 
   | annotationList extern functionPrototypeIR ;
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:541:23-541:54:
syntax selectCaseIR = 
   | keysetExpressionIR : nameIR ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:543:27-543:40:
syntax selectCaseListIR = selectCaseIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:546:3-546:58:
syntax selectExpressionIR = 
   | select( typedExpressionListIR ){ selectCaseListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:553:1-554:23:
syntax stateExpressionIR = 
   | nameIR ;
   | select( typedExpressionListIR ){ selectCaseListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:556:32-556:60:
syntax transitionStatementIR = 
   | transition stateExpressionIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:563:3-563:72:
syntax valueSetDeclarationIR = 
   | annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:570:3-571:76:
syntax parserTypeDeclarationIR = 
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:580:3-580:44:
syntax parserBlockStatementIR = 
   | annotationList { parserStatementListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:583:1-590:27:
syntax parserStatementIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | annotationList { parserStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:592:32-592:50:
syntax parserStatementListIR = parserStatementIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:595:3-596:53:
syntax parserStateIR = 
   | annotationList state nameIR { parserStatementListIR transitionStatementIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:598:28-598:42:
syntax parserStateListIR = parserStateIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:601:1-604:26:
syntax parserLocalDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:607:3-607:28:
syntax parserLocalDeclarationListIR = parserLocalDeclarationIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:610:3-613:56:
syntax parserDeclarationIR = 
   | annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:623:18-623:23:
syntax constIR = const

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:625:21-625:29:
syntax constOptIR = constIR?

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:631:21-631:66:
syntax tableKeyIR = 
   | typedExpressionIR : nameIR annotationList ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:633:25-633:36:
syntax tableKeyListIR = tableKeyIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:639:33-639:67:
syntax tableActionReferenceIR = 
   | prefixedNameIR ( argumentListIR )

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:641:24-641:64:
syntax tableActionIR = 
   | annotationList tableActionReferenceIR ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:643:28-643:42:
syntax tableActionListIR = tableActionIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:650:1-651:42:
syntax tableEntryPriorityIR = 
   | priority= number :
   | priority=( typedExpressionIR ):

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:653:34-653:55:
syntax tableEntryPriorityOptIR = tableEntryPriorityIR?

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:656:3-657:67:
syntax tableEntryIR = 
   | constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:659:27-659:40:
syntax tableEntryListIR = tableEntryIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:666:1-672:75:
syntax tablePropertyIR = 
   | key={ tableKeyListIR }
   | actions={ tableActionListIR }
   | annotationList constOptIR entries={ tableEntryListIR }
   | annotationList constOptIR default_action= tableActionReferenceIR ;
   | annotationList constOptIR custom nameIR initializerIR ;
   | annotationList constOptIR custom_const nameIR constantInitializerIR ;

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:674:30-674:46:
syntax tablePropertyListIR = tablePropertyIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:677:3-677:62:
syntax tableDeclarationIR = 
   | annotationList table typeIR nameIR { tablePropertyListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:684:3-686:28:
syntax controlTypeDeclarationIR = 
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:692:24-692:40:
syntax controlBodyIR = blockStatementIR

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:695:1-699:23:
syntax controlLocalDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | annotationList action nameIR ( parameterListIR ) blockStatementIR
   | annotationList table typeIR nameIR { tablePropertyListIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:702:3-702:29:
syntax controlLocalDeclarationListIR = controlLocalDeclarationIR*

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:705:3-708:59:
syntax controlDeclarationIR = 
   | annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:715:3-717:28:
syntax packageTypeDeclarationIR = 
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:724:1-728:29:
syntax typeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:735:1-744:22:
syntax declarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList functionPrototypeIR blockStatementIR
   | annotationList action nameIR ( parameterListIR ) blockStatementIR
   | error{ nameListIR }
   | match_kind{ nameListIR }
   | annotationList extern functionPrototypeIR ;
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }
   | annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }
   | annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../examples/p4-concrete/4-ir-syntax.spectec:750:22-750:39:
syntax p4programIR = 
   | declarationIR* ;

;; ../../../../examples/p4-concrete/5.0-flow.spectec:5:15-5:25:
syntax flow = 
   | cont
   | ret

;; ../../../../examples/p4-concrete/5.0-flow.spectec:9:1-9:34:
def $join_flow(flow'', flow''')

1. If ((flow'' matches pattern `RET`)), then

  1. If ((flow''' matches pattern `RET`)), then

    1. Return (ret)

2. Otherwise

  1. Return (cont)

;; ../../../../examples/p4-concrete/5.01-env.spectec:5:20-5:47:
syntax varTypeIR = 
   | direction typeIR ctk value?

;; ../../../../examples/p4-concrete/5.01-env.spectec:12:16-12:34:
syntax frame = map<id, varTypeIR>

;; ../../../../examples/p4-concrete/5.01-env.spectec:14:1-14:27:
def $empty_frame

1. Return $empty_map<id, varTypeIR>

;; ../../../../examples/p4-concrete/5.01-env.spectec:18:16-18:35:
syntax tdenv = map<tid, typeDefIR>

;; ../../../../examples/p4-concrete/5.01-env.spectec:20:1-20:27:
def $empty_tdenv

1. Return $empty_map<tid, typeDefIR>

;; ../../../../examples/p4-concrete/5.01-env.spectec:24:16-24:42:
syntax rdenv = map<rid, routineTypeDefIR>

;; ../../../../examples/p4-concrete/5.01-env.spectec:26:1-26:27:
def $empty_rdenv

1. Return $empty_map<rid, routineTypeDefIR>

;; ../../../../examples/p4-concrete/5.01-env.spectec:30:16-30:46:
syntax cdenv = map<cid, constructorTypeDefIR>

;; ../../../../examples/p4-concrete/5.01-env.spectec:32:1-32:27:
def $empty_cdenv

1. Return $empty_map<cid, constructorTypeDefIR>

;; ../../../../examples/p4-concrete/5.01-env.spectec:39:1-39:39:
def $check_routine_name(id_l, id_r)

1. Return (id_l = id_r)

;; ../../../../examples/p4-concrete/5.01-env.spectec:42:1-42:37:
def $check_arity(id_arg?*, id_param*)

1. Return (|id_arg?*| = |id_param*|)

;; ../../../../examples/p4-concrete/5.01-env.spectec:45:1-45:42:
def $check_arity_more(id_arg?*, id_param*)

1. Return (|id_arg?*| > |id_param*|)

;; ../../../../examples/p4-concrete/5.01-env.spectec:48:1-48:42:
def $check_arity_less(id_arg?*, id_param*)

1. Return (|id_arg?*| < |id_param*|)

;; ../../../../examples/p4-concrete/5.01-env.spectec:51:1-51:44:
def $get_missing_parameters(id*, id_arg*)

1. Case analysis on id*

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let id_param_h :: id_param_t* be id*)

    2. If (~$in_set<id>(id_param_h, ({ id_arg* }))), then

      1. Return id_param_h :: $get_missing_parameters(id_param_t*, id_arg*)

    2. Else Phantom#411

    3. Otherwise

      1. Return $get_missing_parameters(id_param_t*, id_arg*)

;; ../../../../examples/p4-concrete/5.01-env.spectec:68:1-68:61:
def $find_match_named<V>(rid, V, id_arg*, pid'*)

1. (Let (id_param # bool_param) be pid')*

2. If ($eq_set<id>(({ id_arg* }), ({ id_param* }))), then

  1. Return ?((rid, V, []))

3. Otherwise

  1. Return ?()

;; ../../../../examples/p4-concrete/5.01-env.spectec:77:1-77:69:
def $find_match_named_default<V>(rid, V, id_arg*, pid'*)

1. (Let (id_param # bool_param) be pid')*

2. (Let id_default* be $get_missing_parameters(id_param*, id_arg*))

3. If (($find_match_named<V>(rid, V, id_arg* ++ id_default*, (id_param # bool_param)*) =/= ?())), then

  1. Return ?((rid, V, id_default*))

4. Otherwise

  1. Return ?()

;; ../../../../examples/p4-concrete/5.01-env.spectec:91:1-91:74:
def $find_match_unnamed_default<V>(rid, V, id_arg?*, pid*)

1. (Let (_pid*, (id_default # bool)*) be $partition_<pid>(pid*, |id_arg?*|))

2. If ((bool = true))*, then

  1. Return ?((rid, V, id_default*))

3. Otherwise

  1. Return ?()

;; ../../../../examples/p4-concrete/5.01-env.spectec:100:1-100:64:
def $find_matching<V>(id_r, id_arg?*, id_arg''*, (id_r' ( pid_r''* )), V)

1. If (~$check_routine_name(id_r, id_r')), then

  1. Return ?()

1. Else Phantom#412

2. (Let (id_param' # bool_param') be pid_r'')*

3. If ($check_routine_name(id_r, id_r')), then

  1. If ($check_arity_more(id_arg?*, id_param'*)), then

    1. Return ?()

  1. Else Phantom#413

3. Else Phantom#414

4. If ((|id_arg''*| > 0)), then

  1. If ($check_routine_name(id_r, id_r')), then

    1. If ($check_arity(id_arg?*, id_param'*)), then

      1. Return $find_match_named<V>((id_r' ( (id_param' # bool_param')* )), V, id_arg''*, (id_param' # bool_param')*)

    1. Else Phantom#415

    2. If ($check_arity_less(id_arg?*, id_param'*)), then

      1. Return $find_match_named_default<V>((id_r' ( (id_param' # bool_param')* )), V, id_arg''*, (id_param' # bool_param')*)

    2. Else Phantom#416

  1. Else Phantom#417

4. Else Phantom#418

5. If ((id_arg''* matches pattern [])), then

  1. If ($check_routine_name(id_r, id_r')), then

    1. If ($check_arity(id_arg?*, id_param'*)), then

      1. Return ?(((id_r' ( (id_param' # bool_param')* )), V, []))

    1. Else Phantom#419

    2. If ($check_arity_less(id_arg?*, id_param'*)), then

      1. Return $find_match_unnamed_default<V>((id_r' ( (id_param' # bool_param')* )), V, id_arg?*, (id_param' # bool_param')*)

    2. Else Phantom#420

  1. Else Phantom#421

5. Else Phantom#422

;; ../../../../examples/p4-concrete/5.01-env.spectec:159:1-159:67:
def $find_matchings<V>(id_r, id_arg?*, id_arg'*, rid''*, V''*)

1. Case analysis on rid''*

  1. Case (% matches pattern [])

    1. If ((V''* matches pattern [])), then

      1. Return []

    1. Else Phantom#423

  2. Case (% matches pattern _ :: _)

    1. (Let rid_h :: rid_t* be rid''*)

    2. If ((V''* matches pattern _ :: _)), then

      1. (Let V_h :: V_t* be V''*)

      2. If (($find_matching<V>(id_r, id_arg?*, id_arg'*, rid_h, V_h) = ?())), then

        1. Return $find_matchings<V>(id_r, id_arg?*, id_arg'*, rid_t*, V_t*)

      2. Else Phantom#424

      3. (Let (rid, V, id*)? be $find_matching<V>(id_r, id_arg?*, id_arg'*, rid_h, V_h))

      4. If (((rid, V, id*)? matches pattern (_))), then

        1. (Let ?((rid'', V'', id_default*)) be (rid, V, id*)?)

        2. Return (rid'', V'', id_default*) :: $find_matchings<V>(id_r, id_arg?*, id_arg'*, rid_t*, V_t*)

      4. Else Phantom#425

    2. Else Phantom#426

;; ../../../../examples/p4-concrete/5.01-env.spectec:181:1-181:66:
def $find_overloaded<V>(({ (rid : V)* }), id_r, id_arg?*)

1. If ((|id_arg?*| > 0)), then

  1. (Let id? be id_arg?)*

  2. If ((id? matches pattern (_)))*, then

    1. (Let ?(id_arg') be id?)*

    2. If (($find_matchings<V>(id_r, id_arg?*, id_arg'*, rid*, V*) = [])), then

      1. Return ?()

    2. Else Phantom#427

    3. (Let (rid, V, id*)* be $find_matchings<V>(id_r, id_arg?*, id_arg'*, rid*, V*))

    4. If (((rid, V, id*)* matches pattern [ _/1 ])), then

      1. (Let [(rid', V', id_default*)] be (rid, V, id*)*)

      2. Return ?((rid', V', id_default*))

    4. Else Phantom#428

  2. Else Phantom#429

1. Else Phantom#430

2. If ((id_arg? = ?()))*, then

  1. If (($find_matchings<V>(id_r, id_arg?*, [], rid*, V*) = [])), then

    1. Return ?()

  1. Else Phantom#431

  2. (Let (rid, V, id*)* be $find_matchings<V>(id_r, id_arg?*, [], rid*, V*))

  3. If (((rid, V, id*)* matches pattern [ _/1 ])), then

    1. (Let [(rid', V', id_default*)] be (rid, V, id*)*)

    2. Return ?((rid', V', id_default*))

  3. Else Phantom#432

2. Else Phantom#433

;; ../../../../examples/p4-concrete/5.01-env.spectec:218:1-218:50:
def $find_non_overloaded<V>(({ (rid : V)* }), id)

1. (Let V''* be $find_non_overloaded'<V>(({ (rid : V)* }), id))

2. If ((V''* matches pattern [ _/1 ])), then

  1. (Let [V'] be V''*)

  2. Return ?(V')

3. Otherwise

  1. Return ?()

;; ../../../../examples/p4-concrete/5.01-env.spectec:219:1-219:51:
def $find_non_overloaded'<V>(set<pair<rid, V>>', id)

1. If ((set<pair<rid, V>>' = ({ [] }))), then

  1. Return []

1. Else Phantom#434

2. (Let ({ pair<rid, V>* }) be set<pair<rid, V>>')

3. If ((pair<rid, V>* matches pattern _ :: _)), then

  1. (Let (rid_h : V_h) :: (rid_t : V_t)* be pair<rid, V>*)

  2. (Let (id' ( _pid* )) be rid_h)

  3. Case analysis on id'

    1. Case (% = id)

      1. (Let V_t_found* be $find_non_overloaded'<V>(({ (rid_t : V_t)* }), id))

      2. Return V_h :: V_t_found*

    2. Case (% =/= id)

      1. (Let V_t_found* be $find_non_overloaded'<V>(({ (rid_t : V_t)* }), id))

      2. Return V_t_found*

3. Else Phantom#435

;; ../../../../examples/p4-concrete/5.02-context.spectec:5:17-5:39:
syntax cursor = 
   | global
   | block
   | local

;; ../../../../examples/p4-concrete/5.02-context.spectec:16:3-19:18:
syntax globalTypingLayer = {cdenv cdenv, tdenv tdenv, rdenv rdenv, frame frame}

;; ../../../../examples/p4-concrete/5.02-context.spectec:24:1-28:12:
syntax blockKind = 
   | 
   | extern
   | parser
   | control
   | package

;; ../../../../examples/p4-concrete/5.02-context.spectec:30:1-30:43:
def $is_extern_blockKind(blockKind)

1. Return (blockKind = (extern))

;; ../../../../examples/p4-concrete/5.02-context.spectec:33:1-33:43:
def $is_parser_blockKind(blockKind)

1. Return (blockKind = (parser))

;; ../../../../examples/p4-concrete/5.02-context.spectec:36:1-36:44:
def $is_control_blockKind(blockKind)

1. Return (blockKind = (control))

;; ../../../../examples/p4-concrete/5.02-context.spectec:39:1-39:44:
def $is_package_blockKind(blockKind)

1. Return (blockKind = (package))

;; ../../../../examples/p4-concrete/5.02-context.spectec:43:3-47:18:
syntax blockTypingLayer = {id id, kind blockKind, tdenv tdenv, rdenv rdenv, frame frame}

;; ../../../../examples/p4-concrete/5.02-context.spectec:52:1-60:23:
syntax localKind = 
   | 
   | function-> typeIR
   | extern_function-> typeIR
   | action
   | extern_method-> typeIR
   | extern_methodabstract-> typeIR
   | parser_state
   | control_apply_method
   | table_apply_method

;; ../../../../examples/p4-concrete/5.02-context.spectec:62:1-62:45:
def $is_function_localKind(localKind')

1. If ((localKind' matches pattern `FUNCTION->%`)), then

  1. (Let (function-> _typeIR) be localKind')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.02-context.spectec:67:1-67:52:
def $is_extern_function_localKind(localKind')

1. If ((localKind' matches pattern `EXTERN_FUNCTION->%`)), then

  1. (Let (extern_function-> _typeIR) be localKind')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.02-context.spectec:74:1-74:43:
def $is_action_localKind(localKind')

1. If ((localKind' matches pattern `ACTION`)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.02-context.spectec:79:1-79:50:
def $is_extern_method_localKind(localKind')

1. If ((localKind' matches pattern `EXTERN_METHOD->%`)), then

  1. (Let (extern_method-> _typeIR) be localKind')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.02-context.spectec:86:1-86:59:
def $is_extern_abstract_method_localKind(localKind')

1. If ((localKind' matches pattern `EXTERN_METHODABSTRACT->%`)), then

  1. (Let (extern_methodabstract-> _typeIR) be localKind')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.02-context.spectec:93:1-93:49:
def $is_parser_state_localKind(localKind')

1. If ((localKind' matches pattern `PARSER_STATE`)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.02-context.spectec:98:1-98:57:
def $is_control_apply_method_localKind(localKind')

1. If ((localKind' matches pattern `CONTROL_APPLY_METHOD`)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.02-context.spectec:105:1-105:55:
def $is_table_apply_method_localKind(localKind')

1. If ((localKind' matches pattern `TABLE_APPLY_METHOD`)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.02-context.spectec:113:3-116:20:
syntax localTypingLayer = {id id, kind localKind, tdenv tdenv, frames frame*}

;; ../../../../examples/p4-concrete/5.02-context.spectec:123:3-125:29:
syntax typingContext = {global globalTypingLayer, block blockTypingLayer, local localTypingLayer}

;; ../../../../examples/p4-concrete/5.02-context.spectec:133:1-133:41:
def $empty_typingContext

1. (Let globalTypingLayer be {cdenv $empty_cdenv, tdenv $empty_tdenv, rdenv $empty_rdenv, frame $empty_frame})

2. (Let blockTypingLayer be {id "", kind (), tdenv $empty_tdenv, rdenv $empty_rdenv, frame $empty_frame})

3. (Let localTypingLayer be {id "", kind (), tdenv $empty_tdenv, frames [$empty_frame]})

4. (Let TC be {global globalTypingLayer, block blockTypingLayer, local localTypingLayer})

5. Return TC

;; ../../../../examples/p4-concrete/5.02-context.spectec:161:1-161:42:
def $bound(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return ({ [] })

  2. Case (% matches pattern `BLOCK`)

    1. Return $dom_map<tid, typeDefIR>(TC.block.tdenv)

  3. Case (% matches pattern `LOCAL`)

    1. (Let bound_block be $bound((block), TC))

    2. (Let bound_local be $dom_map<tid, typeDefIR>(TC.local.tdenv))

    3. Return $union_set<tid>(bound_block, bound_local)

;; ../../../../examples/p4-concrete/5.02-context.spectec:173:1-173:42:
def $enter(TC)

1. Return TC[local.frames = $empty_frame :: TC.local.frames]

;; ../../../../examples/p4-concrete/5.02-context.spectec:177:1-177:41:
def $exit(TC)

1. (Let frame* be TC.local.frames)

2. If ((frame* matches pattern _ :: _)), then

  1. (Let frame_h :: frame_t* be frame*)

  2. Return TC[local.frames = frame_t*]

2. Else Phantom#436

;; ../../../../examples/p4-concrete/5.02-context.spectec:188:1-188:67:
def $add_var(cursor, TC, id, varTypeIR)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let frame be TC.global.frame)

    2. If (~$in_set<id>(id, $dom_map<id, varTypeIR>(frame))), then

      1. (Let (_direction typeIR _ctk _value?) be varTypeIR)

      2. If (((id = "main") => $is_package_object_typeIR($canon(typeIR)))), then

        1. (Let frame_update be $add_map<id, varTypeIR>(frame, id, varTypeIR))

        2. (Let TC' be TC[global.frame = frame_update])

        3. Return TC'

      2. Else Phantom#437

    2. Else Phantom#438

  2. Case (% matches pattern `BLOCK`)

    1. (Let frame be TC.block.frame)

    2. If (~$in_set<id>(id, $dom_map<id, varTypeIR>(frame))), then

      1. If ((id =/= "main")), then

        1. (Let frame_update be $add_map<id, varTypeIR>(TC.block.frame, id, varTypeIR))

        2. (Let TC' be TC[block.frame = frame_update])

        3. Return TC'

      1. Else Phantom#439

    2. Else Phantom#440

  3. Case (% matches pattern `LOCAL`)

    1. (Let frame'* be TC.local.frames)

    2. If ((frame'* matches pattern _ :: _)), then

      1. (Let frame_h :: frame_t* be frame'*)

      2. If (~$in_set<id>(id, $dom_map<id, varTypeIR>(frame_h))), then

        1. If ((id =/= "main")), then

          1. (Let frame_h_update be $add_map<id, varTypeIR>(frame_h, id, varTypeIR))

          2. (Let frame* be frame_h_update :: frame_t*)

          3. (Let TC' be TC[local.frames = frame*])

          4. Return TC'

        1. Else Phantom#441

      2. Else Phantom#442

    2. Else Phantom#443

;; ../../../../examples/p4-concrete/5.02-context.spectec:189:1-189:70:
def $add_vars(p, TC, id*, varTypeIR*)

1. Case analysis on id*

  1. Case (% matches pattern [])

    1. If ((varTypeIR* matches pattern [])), then

      1. Return TC

    1. Else Phantom#444

  2. Case (% matches pattern _ :: _)

    1. (Let id_h :: id_t* be id*)

    2. If ((varTypeIR* matches pattern _ :: _)), then

      1. (Let varTypeIR_h :: varTypeIR_t* be varTypeIR*)

      2. (Let TC' be $add_var(p, TC, id_h, varTypeIR_h))

      3. (Let TC'' be $add_vars(p, TC', id_t*, varTypeIR_t*))

      4. Return TC''

    2. Else Phantom#445

;; ../../../../examples/p4-concrete/5.02-context.spectec:219:1-219:75:
def $add_parameter(cursor, TC, (direction typeIR id value?))

1. Case analysis on direction

  1. Case (% matches pattern ``EMPTY`)

    1. (Let varTypeIR be (() typeIR (ctk) value?))

    2. (Let TC' be $add_var(cursor, TC, id, varTypeIR))

    3. Return TC'

  2. Case (% matches pattern `IN`)

    1. (Let varTypeIR be (direction typeIR (dyn) value?))

    2. (Let TC' be $add_var(cursor, TC, id, varTypeIR))

    3. Return TC'

  3. Case (% matches pattern `OUT`)

    1. (Let varTypeIR be (direction typeIR (dyn) value?))

    2. (Let TC' be $add_var(cursor, TC, id, varTypeIR))

    3. Return TC'

  4. Case (% matches pattern `INOUT`)

    1. (Let varTypeIR be (direction typeIR (dyn) value?))

    2. (Let TC' be $add_var(cursor, TC, id, varTypeIR))

    3. Return TC'

;; ../../../../examples/p4-concrete/5.02-context.spectec:220:1-220:77:
def $add_parameters(cursor, TC, parameterTypeIR*)

1. Case analysis on parameterTypeIR*

  1. Case (% matches pattern [])

    1. Return TC

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t* be parameterTypeIR*)

    2. (Let TC' be $add_parameter(cursor, TC, parameterTypeIR_h))

    3. (Let TC'' be $add_parameters(cursor, TC', parameterTypeIR_t*))

    4. Return TC''

;; ../../../../examples/p4-concrete/5.02-context.spectec:237:1-237:78:
def $add_constructorParameter(TC, (direction typeIR id value''?))

1. Case analysis on value''?

  1. Case (% matches pattern ())

    1. (Let varTypeIR be (direction typeIR (ctk) ?()))

    2. (Let TC' be $add_var((block), TC, id, varTypeIR))

    3. Return TC'

  2. Case (% matches pattern (_))

    1. (Let ?(value'') be value''?)

    2. (Let varTypeIR be (direction typeIR (ctk) ?(value'')))

    3. (Let TC' be $add_var((block), TC, id, varTypeIR))

    4. Return TC'

;; ../../../../examples/p4-concrete/5.02-context.spectec:238:1-238:80:
def $add_constructorParameters(TC, parameterTypeIR*)

1. Case analysis on parameterTypeIR*

  1. Case (% matches pattern [])

    1. Return TC

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t* be parameterTypeIR*)

    2. (Let TC' be $add_constructorParameter(TC, parameterTypeIR_h))

    3. (Let TC'' be $add_constructorParameters(TC', parameterTypeIR_t*))

    4. Return TC''

;; ../../../../examples/p4-concrete/5.02-context.spectec:254:1-254:69:
def $add_type(cursor, TC, tid, typeDefIR)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let tdenv be TC.global.tdenv)

    2. If (~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))), then

      1. (Let tdenv_update be $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR))

      2. (Let TC' be TC[global.tdenv = tdenv_update])

      3. Return TC'

    2. Else Phantom#446

  2. Case (% matches pattern `BLOCK`)

    1. (Let tdenv be TC.block.tdenv)

    2. If (~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))), then

      1. (Let tdenv_update be $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR))

      2. (Let TC' be TC[block.tdenv = tdenv_update])

      3. Return TC'

    2. Else Phantom#447

  3. Case (% matches pattern `LOCAL`)

    1. (Let tdenv be TC.local.tdenv)

    2. If (~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))), then

      1. (Let tdenv_update be $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR))

      2. (Let TC' be TC[local.tdenv = tdenv_update])

      3. Return TC'

    2. Else Phantom#448

;; ../../../../examples/p4-concrete/5.02-context.spectec:274:1-274:72:
def $add_types(p, TC, tid*, typeDefIR*)

1. Case analysis on tid*

  1. Case (% matches pattern [])

    1. If ((typeDefIR* matches pattern [])), then

      1. Return TC

    1. Else Phantom#449

  2. Case (% matches pattern _ :: _)

    1. (Let tid_h :: tid_t* be tid*)

    2. If ((typeDefIR* matches pattern _ :: _)), then

      1. (Let typeDefIR_h :: typeDefIR_t* be typeDefIR*)

      2. (Let TC' be $add_type(p, TC, tid_h, typeDefIR_h))

      3. (Let TC'' be $add_types(p, TC', tid_t*, typeDefIR_t*))

      4. Return TC''

    2. Else Phantom#450

;; ../../../../examples/p4-concrete/5.02-context.spectec:282:1-282:88:
def $add_routine_overload(cursor, TC, rid, routineTypeDefIR)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let rdenv be TC.global.rdenv)

    2. If (~$in_set<rid>(rid, $dom_map<rid, routineTypeDefIR>(rdenv))), then

      1. (Let rdenv_update be $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

      2. (Let TC' be TC[global.rdenv = rdenv_update])

      3. Return TC'

    2. Else Phantom#451

  2. Case (% matches pattern `BLOCK`)

    1. (Let rdenv be TC.block.rdenv)

    2. If (~$in_set<rid>(rid, $dom_map<rid, routineTypeDefIR>(rdenv))), then

      1. (Let rdenv_update be $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

      2. (Let TC' be TC[block.rdenv = rdenv_update])

      3. Return TC'

    2. Else Phantom#452

1. Else Phantom#453

;; ../../../../examples/p4-concrete/5.02-context.spectec:297:1-297:92:
def $add_routine_non_overload(cursor, TC, rid, routineTypeDefIR)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let rdenv be TC.global.rdenv)

    2. (Let (id ( _pid* )) be rid)

    3. (Let ({ (id_k ( _pid'* ))* }) be $dom_map<rid, routineTypeDefIR>(rdenv))

    4. If (~$in_set<id>(id, ({ id_k* }))), then

      1. (Let rdenv_update be $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

      2. (Let TC' be TC[global.rdenv = rdenv_update])

      3. Return TC'

    4. Else Phantom#454

  2. Case (% matches pattern `BLOCK`)

    1. (Let rdenv be TC.block.rdenv)

    2. (Let (id ( _pid* )) be rid)

    3. (Let ({ (id_k ( _pid'* ))* }) be $dom_map<rid, routineTypeDefIR>(rdenv))

    4. If (~$in_set<id>(id, ({ id_k* }))), then

      1. (Let rdenv_update be $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

      2. (Let TC' be TC[block.rdenv = rdenv_update])

      3. Return TC'

    4. Else Phantom#455

1. Else Phantom#456

;; ../../../../examples/p4-concrete/5.02-context.spectec:318:1-318:79:
def $add_constructor(TC, cid, constructorTypeDefIR)

1. (Let cdenv be TC.global.cdenv)

2. If (~$in_set<cid>(cid, $dom_map<cid, constructorTypeDefIR>(cdenv))), then

  1. (Let cdenv_update be $add_map<cid, constructorTypeDefIR>(cdenv, cid, constructorTypeDefIR))

  2. (Let TC' be TC[global.cdenv = cdenv_update])

  3. Return TC'

2. Else Phantom#457

;; ../../../../examples/p4-concrete/5.02-context.spectec:333:1-333:66:
def $find_var(p', TC, prefixedNameIR)

1. If ((prefixedNameIR matches pattern `.%`)), then

  1. (Let (. id) be prefixedNameIR)

  2. (Let frame be TC.global.frame)

  3. Return $find_map<id, varTypeIR>(frame, id)

1. Else Phantom#458

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let frame be TC.global.frame)

      3. Return $find_map<id, varTypeIR>(frame, id)

    1. Else Phantom#459

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let frame be TC.block.frame)

      3. (Let varTypeIR'? be $find_map<id, varTypeIR>(frame, id))

      4. If ((varTypeIR'? matches pattern (_))), then

        1. (Let ?(varTypeIR) be varTypeIR'?)

        2. Return ?(varTypeIR)

      4. Else Phantom#460

      5. If ((?() = $find_map<id, varTypeIR>(frame, id))), then

        1. Return $find_var((global), TC, (` id))

      5. Else Phantom#461

    1. Else Phantom#462

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let frame* be TC.local.frames)

      3. (Let varTypeIR'? be $find_maps<id, varTypeIR>(frame*, id))

      4. If ((varTypeIR'? matches pattern (_))), then

        1. (Let ?(varTypeIR) be varTypeIR'?)

        2. Return ?(varTypeIR)

      4. Else Phantom#463

      5. If ((?() = $find_maps<id, varTypeIR>(frame*, id))), then

        1. Return $find_var((block), TC, (` id))

      5. Else Phantom#464

    1. Else Phantom#465

;; ../../../../examples/p4-concrete/5.02-context.spectec:354:1-354:63:
def $find_value(p', TC, prefixedNameIR)

1. If ((prefixedNameIR matches pattern `.%`)), then

  1. (Let (. id) be prefixedNameIR)

  2. (Let frame be TC.global.frame)

  3. (Let varTypeIR? be $find_map<id, varTypeIR>(frame, id))

  4. If ((varTypeIR? matches pattern (_))), then

    1. (Let ?((_direction _typeIR _ctk value'?)) be varTypeIR?)

    2. If ((value'? matches pattern (_))), then

      1. (Let ?(value) be value'?)

      2. Return value

    2. Else Phantom#466

  4. Else Phantom#467

1. Else Phantom#468

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let frame be TC.global.frame)

      3. (Let varTypeIR? be $find_map<id, varTypeIR>(frame, id))

      4. If ((varTypeIR? matches pattern (_))), then

        1. (Let ?((_direction _typeIR _ctk value'?)) be varTypeIR?)

        2. If ((value'? matches pattern (_))), then

          1. (Let ?(value) be value'?)

          2. Return value

        2. Else Phantom#469

      4. Else Phantom#470

    1. Else Phantom#471

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let frame be TC.block.frame)

      3. (Let varTypeIR? be $find_map<id, varTypeIR>(frame, id))

      4. If ((varTypeIR? matches pattern (_))), then

        1. (Let ?((_direction _typeIR _ctk value'?)) be varTypeIR?)

        2. If ((value'? matches pattern (_))), then

          1. (Let ?(value) be value'?)

          2. Return value

        2. Else Phantom#472

      4. Else Phantom#473

      5. If ((?() = $find_map<id, varTypeIR>(frame, id))), then

        1. Return $find_value((global), TC, (` id))

      5. Else Phantom#474

    1. Else Phantom#475

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let frame* be TC.local.frames)

      3. (Let varTypeIR? be $find_maps<id, varTypeIR>(frame*, id))

      4. If ((varTypeIR? matches pattern (_))), then

        1. (Let ?((_direction _typeIR _ctk value'?)) be varTypeIR?)

        2. If ((value'? matches pattern (_))), then

          1. (Let ?(value) be value'?)

          2. Return value

        2. Else Phantom#476

      4. Else Phantom#477

      5. If ((?() = $find_maps<id, varTypeIR>(frame*, id))), then

        1. Return $find_value((block), TC, (` id))

      5. Else Phantom#478

    1. Else Phantom#479

;; ../../../../examples/p4-concrete/5.02-context.spectec:377:1-377:67:
def $find_type(p', TC, prefixedNameIR)

1. If ((prefixedNameIR matches pattern `.%`)), then

  1. (Let (. tid) be prefixedNameIR)

  2. (Let tdenv be TC.global.tdenv)

  3. Return $find_map<tid, typeDefIR>(tdenv, tid)

1. Else Phantom#480

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` tid) be prefixedNameIR)

      2. (Let tdenv be TC.global.tdenv)

      3. Return $find_map<tid, typeDefIR>(tdenv, tid)

    1. Else Phantom#481

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` tid) be prefixedNameIR)

      2. (Let tdenv be TC.block.tdenv)

      3. (Let typeDefIR'? be $find_map<tid, typeDefIR>(tdenv, tid))

      4. If ((typeDefIR'? matches pattern (_))), then

        1. (Let ?(typeDefIR) be typeDefIR'?)

        2. Return ?(typeDefIR)

      4. Else Phantom#482

      5. If ((?() = $find_map<tid, typeDefIR>(tdenv, tid))), then

        1. Return $find_type((global), TC, (` tid))

      5. Else Phantom#483

    1. Else Phantom#484

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` tid) be prefixedNameIR)

      2. (Let tdenv* be [TC.local.tdenv])

      3. (Let typeDefIR'? be $find_maps<tid, typeDefIR>(tdenv*, tid))

      4. If ((typeDefIR'? matches pattern (_))), then

        1. (Let ?(typeDefIR) be typeDefIR'?)

        2. Return ?(typeDefIR)

      4. Else Phantom#485

      5. If ((?() = $find_maps<tid, typeDefIR>(tdenv*, tid))), then

        1. Return $find_type((block), TC, (` tid))

      5. Else Phantom#486

    1. Else Phantom#487

;; ../../../../examples/p4-concrete/5.02-context.spectec:400:1-400:41:
def $ids_arguments(argumentIR*)

1. Return $id_argument(argumentIR)*

;; ../../../../examples/p4-concrete/5.02-context.spectec:401:1-401:35:
def $id_argument(argumentIR)

1. If ((argumentIR has type typedExpressionIR)), then

  1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

  2. Return ?()

1. Else Phantom#488

2. Case analysis on argumentIR

  1. Case (% matches pattern `%=%`)

    1. (Let (nameIR = _typedExpressionIR) be argumentIR)

    2. Return ?(nameIR)

  2. Case (% matches pattern `%=_`)

    1. (Let (nameIR =_) be argumentIR)

    2. Return ?(nameIR)

  3. Case (% matches pattern `_`)

    1. Return ?()

2. Else Phantom#489

;; ../../../../examples/p4-concrete/5.02-context.spectec:409:1-410:34:
def $find_routine_overloaded(cursor, TC, prefixedNameIR, argumentIR*)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Case analysis on prefixedNameIR

      1. Case (% matches pattern `.%`)

        1. (Let (. id) be prefixedNameIR)

        2. (Let rdenv be TC.global.rdenv)

        3. (Let id_arg?* be $ids_arguments(argumentIR*))

        4. Return $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?*)

      2. Case (% matches pattern ``%`)

        1. (Let (` id) be prefixedNameIR)

        2. (Let rdenv be TC.global.rdenv)

        3. (Let id_arg?* be $ids_arguments(argumentIR*))

        4. Return $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?*)

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let rdenv be TC.block.rdenv)

      3. (Let id_arg?* be $ids_arguments(argumentIR*))

      4. (Let (rid, routineTypeDefIR, id*)? be $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?*))

      5. If (((rid, routineTypeDefIR, id*)? matches pattern (_))), then

        1. (Let ?((rid, routineTypeDefIR, id_default*)) be (rid, routineTypeDefIR, id*)?)

        2. Return ?((rid, routineTypeDefIR, id_default*))

      5. Else Phantom#490

      6. If ((?() = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?*))), then

        1. Return $find_routine_overloaded((global), TC, (` id), argumentIR*)

      6. Else Phantom#491

    1. Else Phantom#492

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. Return $find_routine_overloaded((block), TC, (` id), argumentIR*)

    1. Else Phantom#493

;; ../../../../examples/p4-concrete/5.02-context.spectec:435:1-436:22:
def $find_routine_non_overloaded(p', TC, prefixedNameIR)

1. If ((prefixedNameIR matches pattern `.%`)), then

  1. (Let (. id) be prefixedNameIR)

  2. Return $find_non_overloaded<routineTypeDefIR>(TC.global.rdenv, id)

1. Else Phantom#494

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. Return $find_non_overloaded<routineTypeDefIR>(TC.global.rdenv, id)

    1. Else Phantom#495

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let routineTypeDefIR'? be $find_non_overloaded<routineTypeDefIR>(TC.block.rdenv, id))

      3. If ((routineTypeDefIR'? matches pattern (_))), then

        1. (Let ?(routineTypeDefIR) be routineTypeDefIR'?)

        2. Return ?(routineTypeDefIR)

      3. Else Phantom#496

      4. If ((?() = $find_non_overloaded<routineTypeDefIR>(TC.block.rdenv, id))), then

        1. Return $find_routine_non_overloaded((global), TC, (` id))

      4. Else Phantom#497

    1. Else Phantom#498

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. Return $find_routine_non_overloaded((block), TC, (` id))

    1. Else Phantom#499

;; ../../../../examples/p4-concrete/5.02-context.spectec:454:1-455:38:
def $find_constructor_overloaded(TC, prefixedNameIR, argumentIR*)

1. Case analysis on prefixedNameIR

  1. Case (% matches pattern `.%`)

    1. (Let (. id) be prefixedNameIR)

    2. (Let cdenv be TC.global.cdenv)

    3. (Let id_arg?* be $ids_arguments(argumentIR*))

    4. Return $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?*)

  2. Case (% matches pattern ``%`)

    1. (Let (` id) be prefixedNameIR)

    2. (Let cdenv be TC.global.cdenv)

    3. (Let id_arg?* be $ids_arguments(argumentIR*))

    4. Return $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?*)

;; ../../../../examples/p4-concrete/5.02-context.spectec:468:1-468:47:
def $find_return_type(TC)

1. (Let localKind be TC.local.kind)

2. Case analysis on localKind

  1. Case (% matches pattern `FUNCTION->%`)

    1. (Let (function-> typeIR_ret) be localKind)

    2. Return ?(typeIR_ret)

  2. Case (% matches pattern `EXTERN_FUNCTION->%`)

    1. (Let (extern_function-> typeIR_ret) be localKind)

    2. Return ?(typeIR_ret)

  3. Case (% matches pattern `EXTERN_METHOD->%`)

    1. (Let (extern_method-> typeIR_ret) be localKind)

    2. Return ?(typeIR_ret)

  4. Case (% matches pattern `EXTERN_METHODABSTRACT->%`)

    1. (Let (extern_methodabstract-> typeIR_ret) be localKind)

    2. Return ?(typeIR_ret)

3. If (((action) = TC.local.kind)), then

  1. Return ?(((void) as typeIR))

4. If (((control_apply_method) = TC.local.kind)), then

  1. Return ?(((void) as typeIR))

5. Otherwise

  1. Return ?()

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:5:19-5:31:
syntax matchKey = (typeIR, id)

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:7:22-7:72:
syntax matchAction = (prefixedNameIR, parameterTypeIR*, argumentListIR)

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:10:3-13:24:
syntax matchPriority = {values nat*, init bool, delta nat, largest_wins bool}

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:16:3-17:17:
syntax matchEntry = {size nat, const bool}

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:21:1-27:11:
syntax matchMode = 
   | nopri
   | noprilpm nat
   | pri
   | prilpm

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:30:3-34:21:
syntax tableContext = {keys matchKey*, actions matchAction*, priorities matchPriority, entries matchEntry, mode matchMode}

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:44:1-46:10:
syntax tableEntryState = 
   | lpm nat
   | nolpm

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:54:1-54:38:
def $empty_tableContext

1. (Let matchPriority be {values [], init false, delta 1, largest_wins true})

2. (Let matchEntry be {size 0, const true})

3. Return {keys [], actions [], priorities matchPriority, entries matchEntry, mode (nopri)}

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:76:1-76:54:
def $add_key(TBLC, id, typeIR)

1. (Let matchKey be (typeIR, id))

2. Return TBLC[keys = TBLC.keys ++ [matchKey]]

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:84:1-84:95:
def $add_action(TBLC, prefixedNameIR, parameterTypeIR*, argumentListIR)

1. (Let matchAction be (prefixedNameIR, parameterTypeIR*, argumentListIR))

2. Return TBLC[actions = TBLC.actions ++ [matchAction]]

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:92:1-92:58:
def $add_table_priority(TBLC, n)

1. Return TBLC[priorities.values = TBLC.priorities.values ++ [n]]

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:103:1-103:58:
def $update_mode(TBLC, id, typeIR)

1. Return $update_mode'(TBLC, id, $canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:104:1-104:59:
def $update_mode'(TBLC, text', typeIR'')

1. Case analysis on text'

  1. Case (% = "lpm")

    1. Case analysis on typeIR''

      1. Case (% has type numberTypeIR)

        1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

        2. Case analysis on numberTypeIR

          1. Case (% matches pattern `INT<%>`)

            1. (Let (int< n >) be numberTypeIR)

            2. If ((TBLC.mode matches pattern `NOPRI`)), then

              1. Return TBLC[mode = (noprilpm n)]

          2. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< n >) be numberTypeIR)

            2. If ((TBLC.mode matches pattern `NOPRI`)), then

              1. Return TBLC[mode = (noprilpm n)]

          3. Case (% matches pattern `VARBIT<%>`)

            1. (Let (varbit< n >) be numberTypeIR)

            2. If ((TBLC.mode matches pattern `NOPRI`)), then

              1. Return TBLC[mode = (noprilpm n)]

      2. Case (% has type aliasTypeIR)

        1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

        2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

          1. (Let (type _tid typeIR'') be aliasTypeIR)

          2. Return $update_mode(TBLC, "lpm", typeIR'')

    2. If ((TBLC.mode matches pattern `PRI`)), then

      1. Return TBLC[mode = (prilpm)]

  2. Case (% = "range")

    1. If ((TBLC.mode matches pattern `NOPRI`)), then

      1. Return TBLC[mode = (pri)]

    2. (Let matchMode be TBLC.mode)

    3. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (noprilpm _nat) be matchMode)

      2. Return TBLC[mode = (prilpm)]

  3. Case (% = "ternary")

    1. If ((TBLC.mode matches pattern `NOPRI`)), then

      1. Return TBLC[mode = (pri)]

    2. (Let matchMode be TBLC.mode)

    3. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (noprilpm _nat) be matchMode)

      2. Return TBLC[mode = (prilpm)]

  4. Case (% = "optional")

    1. If ((TBLC.mode matches pattern `NOPRI`)), then

      1. Return TBLC[mode = (pri)]

    2. (Let matchMode be TBLC.mode)

    3. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (noprilpm _nat) be matchMode)

      2. Return TBLC[mode = (prilpm)]

2. Otherwise

  1. Return TBLC

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:138:1-138:85:
def $find_action(TBLC, prefixedNameIR)

1. Return $find_action'(TBLC.actions, prefixedNameIR)

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:139:1-139:86:
def $find_action'(matchAction*, prefixedNameIR)

1. Case analysis on matchAction*

  1. Case (% matches pattern [])

    1. Return ?()

  2. Case (% matches pattern _ :: _)

    1. (Let matchAction_h :: matchAction_t* be matchAction*)

    2. (Let (prefixedNameIR', parameterTypeIR*, argumentListIR) be matchAction_h)

    3. Case analysis on prefixedNameIR'

      1. Case (% = prefixedNameIR)

        1. Return ?((parameterTypeIR*, argumentListIR))

      2. Case (% =/= prefixedNameIR)

        1. Return $find_action'(matchAction_t*, prefixedNameIR)

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:156:1-156:50:
def $find_table_priority_last(TBLC)

1. (Let n* be TBLC.priorities.values)

2. Return n*[(|n*| - 1)]

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:165:1-165:78:
def $join_tableEntryState(tableEntryState, tableEntryState')

1. Case analysis on tableEntryState

  1. Case (% matches pattern `NOLPM`)

    1. Case analysis on tableEntryState'

      1. Case (% matches pattern `LPM%`)

        1. (Let (lpm n) be tableEntryState')

        2. Return (lpm n)

      2. Case (% matches pattern `NOLPM`)

        1. Return (nolpm)

  2. Case (% matches pattern `LPM%`)

    1. (Let (lpm n) be tableEntryState)

    2. If ((tableEntryState' matches pattern `NOLPM`)), then

      1. Return (lpm n)

    2. Else Phantom#500

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:171:1-171:40:
def $tableEntry_lpm_prefix(value)

1. Return $tableEntry_lpm_prefix'(value, 0)

;; ../../../../examples/p4-concrete/5.03-table-context.spectec:172:1-172:46:
def $tableEntry_lpm_prefix'(value, n_prefix')

1. If ((value has type number)), then

  1. (Let number be (value as number))

  2. If ((number matches pattern `%W%`)), then

    1. (Let (nat w _int) be number)

    2. If ((nat = 0)), then

      1. Return n_prefix'

    2. Else Phantom#501

    3. If ((_int has type nat)), then

      1. (Let n be (_int as nat))

      2. If ((nat > 0)), then

        1. If (((n \ 2) =/= 0)), then

          1. (Let value' be (((nat - 1) w (((n - 1) / 2) as int)) as value))

          2. Return $tableEntry_lpm_prefix'(value', (n_prefix' + 1))

        1. Else Phantom#502

      2. Else Phantom#503

      3. If ((n_prefix' = 0)), then

        1. If ((nat > 0)), then

          1. If (((n \ 2) = 0)), then

            1. (Let value' be (((nat - 1) w ((n / 2) as int)) as value))

            2. Return $tableEntry_lpm_prefix'(value', 0)

          1. Else Phantom#504

        1. Else Phantom#505

      3. Else Phantom#506

    3. Else Phantom#507

  2. Else Phantom#508

1. Else Phantom#509

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:5:1-7:20:
relation Type_wf: bound, typeIR'''

1. Case analysis on typeIR'''

  1. Case (% has type baseTypeIR)

    1. (Let baseTypeIR be (typeIR''' as baseTypeIR))

    2. The relation holds

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR''' as namedTypeIR))

    2. Case analysis on namedTypeIR

      1. Case (% matches pattern `TID%`)

        1. (Let (tid tid) be namedTypeIR)

        2. If ($in_set<tid>(tid, bound)), then

          1. The relation holds

        2. Else Phantom#510

      2. Case (% matches pattern `%<%>`)

        1. (Let (polyTypeDefIR < typeIR_arg* >) be namedTypeIR)

        2. (Let typeIR''' be $specialize_typeDef((polyTypeDefIR as typeDefIR), typeIR_arg*))

        3. If ((Type_wf: bound |- typeIR''' holds)), then

          1. The relation holds

        3. Else Phantom#511

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR''' as aliasTypeIR))

    2. Case analysis on aliasTypeIR

      1. Case (% matches pattern `TYPEDEF%%`)

        1. (Let (typedef _tid typeIR''') be aliasTypeIR)

        2. If ($nestable_typedef(typeIR''')), then

          1. If ((Type_wf: bound |- typeIR''' holds)), then

            1. The relation holds

          1. Else Phantom#512

        2. Else Phantom#513

      2. Case (% matches pattern `TYPE%%`)

        1. (Let (type _tid typeIR''') be aliasTypeIR)

        2. If ($nestable_new(typeIR''')), then

          1. If ((Type_wf: bound |- typeIR''' holds)), then

            1. The relation holds

          1. Else Phantom#514

        2. Else Phantom#515

  4. Case (% has type listTypeIR)

    1. (Let (list< typeIR''' >) be (typeIR''' as listTypeIR))

    2. If ($nestable_list(typeIR''')), then

      1. If ((Type_wf: bound |- typeIR''' holds)), then

        1. The relation holds

      1. Else Phantom#516

    2. Else Phantom#517

  5. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR'''* >) be (typeIR''' as tupleTypeIR))

    2. If ($nestable_tuple(typeIR'''))*, then

      1. If ((Type_wf: bound |- typeIR''' holds))*, then

        1. The relation holds

      1. Else Phantom#518

    2. Else Phantom#519

  6. Case (% has type headerStackTypeIR)

    1. (Let (typeIR''' [ _nat ]) be (typeIR''' as headerStackTypeIR))

    2. If ($nestable_stack(typeIR''')), then

      1. If ((Type_wf: bound |- typeIR''' holds)), then

        1. The relation holds

      1. Else Phantom#520

    2. Else Phantom#521

  7. Case (% has type structTypeIR)

    1. (Let (struct _tid { (typeIR''' id ;)* }) be (typeIR''' as structTypeIR))

    2. If ($distinct_<id>(id*)), then

      1. If ($nestable_struct(typeIR'''))*, then

        1. If ((Type_wf: bound |- typeIR''' holds))*, then

          1. The relation holds

        1. Else Phantom#522

      1. Else Phantom#523

    2. Else Phantom#524

  8. Case (% has type headerTypeIR)

    1. (Let (header _tid { (typeIR''' id ;)* }) be (typeIR''' as headerTypeIR))

    2. If ($distinct_<id>(id*)), then

      1. If ($nestable_header(typeIR'''))*, then

        1. If ((Type_wf: bound |- typeIR''' holds))*, then

          1. The relation holds

        1. Else Phantom#525

      1. Else Phantom#526

    2. Else Phantom#527

  9. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { (typeIR''' id ;)* }) be (typeIR''' as headerUnionTypeIR))

    2. If ($distinct_<id>(id*)), then

      1. If ($nestable_headerunion(typeIR'''))*, then

        1. If ((Type_wf: bound |- typeIR''' holds))*, then

          1. The relation holds

        1. Else Phantom#528

      1. Else Phantom#529

    2. Else Phantom#530

  10. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR''' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { id* }) be enumTypeIR)

        2. If ($distinct_<id>(id*)), then

          1. The relation holds

        2. Else Phantom#531

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # typeIR''' { (id = _value ;)* }) be enumTypeIR)

        2. If ($distinct_<id>(id*)), then

          1. If ($nestable_serenum(typeIR''')), then

            1. If ((Type_wf: bound |- typeIR''' holds)), then

              1. The relation holds

            1. Else Phantom#532

          1. Else Phantom#533

        2. Else Phantom#534

  11. Case (% has type externObjectTypeIR)

    1. (Let (extern _tid ({ (_rid : routineTypeDefIR)* })) be (typeIR''' as externObjectTypeIR))

    2. If ((RoutineTypeDef_wf: bound |- routineTypeDefIR holds))*, then

      1. The relation holds

    2. Else Phantom#535

  12. Case (% has type parserObjectTypeIR)

    1. (Let (parser( parameterTypeIR* )) be (typeIR''' as parserObjectTypeIR))

    2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. The relation holds

    2. Else Phantom#536

  13. Case (% has type controlObjectTypeIR)

    1. (Let (control( parameterTypeIR* )) be (typeIR''' as controlObjectTypeIR))

    2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. The relation holds

    2. Else Phantom#537

  14. Case (% has type packageObjectTypeIR)

    1. (Let (package< typeIR'''* >) be (typeIR''' as packageObjectTypeIR))

    2. If ((Type_wf: bound |- typeIR''' holds))*, then

      1. The relation holds

    2. Else Phantom#538

  15. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # typeIR''') be (typeIR''' as tableObjectTypeIR))

    2. (Let typeIR'' be $canon(typeIR'''))

    3. If ((typeIR'' has type tableTypeIR)), then

      1. (Let tableTypeIR be (typeIR'' as tableTypeIR))

      2. If ((tableTypeIR matches pattern `TABLE_STRUCT%{%}`)), then

        1. (Let (table_struct _tid' { _fieldTypeIR* }) be tableTypeIR)

        2. If ((Type_wf: bound |- typeIR''' holds)), then

          1. The relation holds

        2. Else Phantom#539

      2. Else Phantom#540

    3. Else Phantom#541

  16. Case (% has type defaultTypeIR)

    1. (Let defaultTypeIR be (typeIR''' as defaultTypeIR))

    2. If ((defaultTypeIR matches pattern `DEFAULT`)), then

      1. The relation holds

    2. Else Phantom#542

  17. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR''' as sequenceTypeIR))

    2. Case analysis on sequenceTypeIR

      1. Case (% matches pattern `SEQ<%>`)

        1. (Let (seq< typeIR'''* >) be sequenceTypeIR)

        2. If ((Type_wf: bound |- typeIR''' holds))*, then

          1. The relation holds

        2. Else Phantom#543

      2. Case (% matches pattern `SEQ<%,...>`)

        1. (Let (seq< typeIR'''* ,...>) be sequenceTypeIR)

        2. If ((Type_wf: bound |- typeIR''' holds))*, then

          1. The relation holds

        2. Else Phantom#544

  18. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR''' as recordTypeIR))

    2. Case analysis on recordTypeIR

      1. Case (% matches pattern `RECORD{%}`)

        1. (Let (record{ (typeIR''' id ;)* }) be recordTypeIR)

        2. If ($distinct_<id>(id*)), then

          1. If ((Type_wf: bound |- typeIR''' holds))*, then

            1. The relation holds

          1. Else Phantom#545

        2. Else Phantom#546

      2. Case (% matches pattern `RECORD{%,...}`)

        1. (Let (record{ (typeIR''' id ;)* ,...}) be recordTypeIR)

        2. If ($distinct_<id>(id*)), then

          1. If ((Type_wf: bound |- typeIR''' holds))*, then

            1. The relation holds

          1. Else Phantom#547

        2. Else Phantom#548

  19. Case (% has type invalidHeaderTypeIR)

    1. (Let invalidHeaderTypeIR be (typeIR''' as invalidHeaderTypeIR))

    2. If ((invalidHeaderTypeIR matches pattern `HEADER_INVALID`)), then

      1. The relation holds

    2. Else Phantom#549

  20. Case (% has type setTypeIR)

    1. (Let (set< typeIR'''* >) be (typeIR''' as setTypeIR))

    2. If ((typeIR'''* matches pattern [ _/1 ])), then

      1. (Let [typeIR'''] be typeIR'''*)

      2. If ($nestable_set(typeIR''')), then

        1. If ((Type_wf: bound |- typeIR''' holds)), then

          1. The relation holds

        1. Else Phantom#550

      2. Else Phantom#551

    2. Else Phantom#552

  21. Case (% has type tableTypeIR)

    1. (Let tableTypeIR be (typeIR''' as tableTypeIR))

    2. Case analysis on tableTypeIR

      1. Case (% matches pattern `TABLE_ENUM%{%}`)

        1. (Let (table_enum _tid { id* }) be tableTypeIR)

        2. If ($distinct_<id>(id*)), then

          1. The relation holds

        2. Else Phantom#553

      2. Case (% matches pattern `TABLE_STRUCT%{%}`)

        1. (Let (table_struct _tid { _fieldTypeIR* }) be tableTypeIR)

        2. The relation holds

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:9:1-11:20:
relation TypeDef_wf: bound, typeDefIR

1. Case analysis on typeDefIR

  1. Case (% has type typeIR)

    1. (Let typeIR be (typeDefIR as typeIR))

    2. If ($definable_type_mono(typeIR)), then

      1. If ((Type_wf: bound |- typeIR holds)), then

        1. The relation holds

      1. Else Phantom#554

    2. Else Phantom#555

  2. Case (% has type polyTypeDefIR)

    1. (Let (typeIR < tid_expl* , tid_impl* >) be (typeDefIR as polyTypeDefIR))

    2. If ($definable_type_poly(typeIR)), then

      1. If ($distinct_<tid>(tid_expl* ++ tid_impl*)), then

        1. (Let bound_inner be $union_set<tid>(bound, ({ tid_expl* ++ tid_impl* })))

        2. If ((Type_wf: bound_inner |- typeIR holds)), then

          1. The relation holds

        2. Else Phantom#556

      1. Else Phantom#557

    2. Else Phantom#558

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:13:1-15:20:
relation ParameterType_wf: bound, (direction typeIR _id value''?)

1. If ((direction matches pattern ``EMPTY`)), then

  1. Case analysis on value''?

    1. Case (% matches pattern ())

      1. If ((Type_wf: bound |- typeIR holds)), then

        1. If ($is_extern_object_typeIR($canon(typeIR))), then

          1. The relation holds

        1. Else Phantom#559

      1. Else Phantom#560

    2. Case (% matches pattern (_))

      1. (Let ?(value'') be value''?)

      2. If ((Type_wf: bound |- typeIR holds)), then

        1. If ($is_extern_object_typeIR($canon(typeIR))), then

          1. The relation holds

        1. Else Phantom#561

      2. Else Phantom#562

1. Else Phantom#563

2. Case analysis on value''?

  1. Case (% matches pattern ())

    1. If ((Type_wf: bound |- typeIR holds)), then

      1. If (~$is_extern_object_typeIR($canon(typeIR))), then

        1. The relation holds

      1. Else Phantom#564

    1. Else Phantom#565

  2. Case (% matches pattern (_))

    1. (Let ?(value'') be value''?)

    2. If ((Type_wf: bound |- typeIR holds)), then

      1. If (~$is_extern_object_typeIR($canon(typeIR))), then

        1. If (((direction = (in)) \/ (direction = ()))), then

          1. The relation holds

        1. Else Phantom#566

      1. Else Phantom#567

    2. Else Phantom#568

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:17:1-19:20:
relation ParameterTypes_wf: bound, parameterTypeIR*

1. (Let (_direction _typeIR id _value?) be parameterTypeIR)*

2. If ($distinct_<id>(id*)), then

  1. If ((ParameterType_wf: bound |- parameterTypeIR holds))*, then

    1. The relation holds

  1. Else Phantom#569

2. Else Phantom#570

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:21:1-23:20:
relation RoutineType_wf: bound, routineTypeIR

1. Case analysis on routineTypeIR

  1. Case (% has type functionTypeIR)

    1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

    2. Case analysis on functionTypeIR

      1. Case (% matches pattern `BUILTIN_FUNCTION(%)->%`)

        1. (Let (builtin_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. If ((Type_wf: bound |- typeIR_ret holds)), then

            1. The relation holds

          1. Else Phantom#571

        2. Else Phantom#572

      2. Case (% matches pattern `FUNCTION(%)->%`)

        1. (Let (function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

          2. If ($nestable_function(direction, typeIR))*, then

            1. If ((Type_wf: bound |- typeIR_ret holds)), then

              1. The relation holds

            1. Else Phantom#573

          2. Else Phantom#574

        2. Else Phantom#575

      3. Case (% matches pattern `ACTION(%)`)

        1. (Let (action( parameterTypeIR* )) be functionTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

          2. If ($directionless_trailing(direction*)), then

            1. If ($nestable_action(direction, typeIR))*, then

              1. The relation holds

            1. Else Phantom#576

          2. Else Phantom#577

        2. Else Phantom#578

      4. Case (% matches pattern `EXTERN_FUNCTION(%)->%`)

        1. (Let (extern_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

          2. If ($nestable_externfunction(direction, typeIR))*, then

            1. If ((Type_wf: bound |- typeIR_ret holds)), then

              1. The relation holds

            1. Else Phantom#579

          2. Else Phantom#580

        2. Else Phantom#581

  2. Case (% has type methodTypeIR)

    1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

    2. Case analysis on methodTypeIR

      1. Case (% matches pattern `BUILTIN_METHOD(%)->%`)

        1. (Let (builtin_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. If ((Type_wf: bound |- typeIR_ret holds)), then

            1. The relation holds

          1. Else Phantom#582

        2. Else Phantom#583

      2. Case (% matches pattern `EXTERN_METHOD(%)->%`)

        1. (Let (extern_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

          2. If ($nestable_externmethod(direction, typeIR))*, then

            1. If ((Type_wf: bound |- typeIR_ret holds)), then

              1. The relation holds

            1. Else Phantom#584

          2. Else Phantom#585

        2. Else Phantom#586

      3. Case (% matches pattern `EXTERN_METHODABSTRACT(%)->%`)

        1. (Let (extern_methodabstract( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

          2. If ($nestable_externabstractmethod(direction, typeIR))*, then

            1. If ((Type_wf: bound |- typeIR_ret holds)), then

              1. The relation holds

            1. Else Phantom#587

          2. Else Phantom#588

        2. Else Phantom#589

      4. Case (% matches pattern `PARSER_APPLY(%)`)

        1. (Let (parser_apply( parameterTypeIR* )) be methodTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

          2. If ($nestable_parserapplymethod(direction, typeIR))*, then

            1. The relation holds

          2. Else Phantom#590

        2. Else Phantom#591

      5. Case (% matches pattern `CONTROL_APPLY(%)`)

        1. (Let (control_apply( parameterTypeIR* )) be methodTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

          2. If ($nestable_controlapplymethod(direction, typeIR))*, then

            1. The relation holds

          2. Else Phantom#592

        2. Else Phantom#593

      6. Case (% matches pattern `TABLE_APPLY->%`)

        1. (Let (table_apply-> typeIR) be methodTypeIR)

        2. If ((typeIR has type tableTypeIR)), then

          1. (Let tableTypeIR be (typeIR as tableTypeIR))

          2. If ((tableTypeIR matches pattern `TABLE_STRUCT%{%}`)), then

            1. (Let (table_struct _tid { _fieldTypeIR* }) be tableTypeIR)

            2. The relation holds

          2. Else Phantom#594

        2. Else Phantom#595

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:25:1-27:20:
relation RoutineTypeDef_wf: bound, routineTypeDefIR

1. Case analysis on routineTypeDefIR

  1. Case (% has type routineTypeIR)

    1. (Let routineTypeIR be (routineTypeDefIR as routineTypeIR))

    2. If ($definable_routine_mono(routineTypeIR)), then

      1. If ((RoutineType_wf: bound |- routineTypeIR holds)), then

        1. The relation holds

      1. Else Phantom#596

    2. Else Phantom#597

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (routineTypeIR < tid_expl* , tid_impl* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. If ($definable_routine_poly(routineTypeIR)), then

      1. If ($distinct_<tid>(tid_expl* ++ tid_impl*)), then

        1. (Let bound_inner be $union_set<tid>(bound, ({ tid_expl* ++ tid_impl* })))

        2. If ((RoutineType_wf: bound_inner |- routineTypeIR holds)), then

          1. The relation holds

        2. Else Phantom#598

      1. Else Phantom#599

    2. Else Phantom#600

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:29:1-31:20:
relation ConstructorParameterType_wf: bound, (direction typeIR _id _value?)

1. If ((direction matches pattern ``EMPTY`)), then

  1. If ((Type_wf: bound |- typeIR holds)), then

    1. The relation holds

  1. Else Phantom#601

1. Else Phantom#602

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:33:1-35:20:
relation ConstructorParameterTypes_wf: bound, parameterTypeIR*

1. (Let (_direction _typeIR id _value?) be parameterTypeIR)*

2. If ($distinct_<id>(id*)), then

  1. If ((ConstructorParameterType_wf: bound |- parameterTypeIR holds))*, then

    1. The relation holds

  1. Else Phantom#603

2. Else Phantom#604

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:37:1-39:20:
relation ConstructorType_wf: bound, (constructor( parameterTypeIR* )-> typeIR_object)

1. If ((ConstructorParameterTypes_wf: bound |- parameterTypeIR* holds)), then

  1. If ((Type_wf: bound |- typeIR_object holds)), then

    1. (Let typeIR' be $canon(typeIR_object))

    2. Case analysis on typeIR'

      1. Case (% has type externObjectTypeIR)

        1. (Let (extern _tid _map<rid, routineTypeDefIR>) be (typeIR' as externObjectTypeIR))

        2. (Let (_direction typeIR _id _value?) be parameterTypeIR)*

        3. If ($nestable_constructor_extern(typeIR))*, then

          1. The relation holds

        3. Else Phantom#605

      2. Case (% has type parserObjectTypeIR)

        1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

        2. (Let (_direction typeIR _id _value?) be parameterTypeIR)*

        3. If ($nestable_constructor_parser(typeIR))*, then

          1. The relation holds

        3. Else Phantom#606

      3. Case (% has type controlObjectTypeIR)

        1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

        2. (Let (_direction typeIR _id _value?) be parameterTypeIR)*

        3. If ($nestable_constructor_control(typeIR))*, then

          1. The relation holds

        3. Else Phantom#607

      4. Case (% has type packageObjectTypeIR)

        1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

        2. (Let (_direction typeIR _id _value?) be parameterTypeIR)*

        3. If ($nestable_constructor_package(typeIR))*, then

          1. The relation holds

        3. Else Phantom#608

    2. Else Phantom#609

  1. Else Phantom#610

1. Else Phantom#611

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:41:1-43:20:
relation ConstructorTypeDef_wf: bound, (constructorTypeIR < tid_expl* , tid_impl* >)

1. (Let (constructor( _constructorParameterTypeIR* )-> typeIR_object) be constructorTypeIR)

2. If ($definable_constructor(typeIR_object)), then

  1. If ($distinct_<tid>(tid_expl* ++ tid_impl*)), then

    1. (Let bound_inner be $union_set<tid>(bound, ({ tid_expl* ++ tid_impl* })))

    2. If ((ConstructorType_wf: bound_inner |- constructorTypeIR holds)), then

      1. The relation holds

    2. Else Phantom#612

  1. Else Phantom#613

2. Else Phantom#614

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:98:1-98:37:
def $nestable_typedef(typeIR)

1. Return $nestable'_typedef($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:99:1-99:38:
def $nestable'_typedef(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `BOOL`)

        1. Return true

      2. Case (% matches pattern `ERROR`)

        1. Return true

      3. Case (% matches pattern `STRING`)

        1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type dataTypeIR)

    1. (Let dataTypeIR be (typeIR' as dataTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:117:1-117:33:
def $nestable_new(typeIR)

1. Return $nestable'_new($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:118:1-118:34:
def $nestable'_new(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BOOL`)), then

      1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:136:1-136:34:
def $nestable_list(typeIR)

1. Return $nestable'_list($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:137:1-137:35:
def $nestable'_list(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `BOOL`)

        1. Return true

      2. Case (% matches pattern `ERROR`)

        1. Return true

      3. Case (% matches pattern `MATCH_KIND`)

        1. Return true

      4. Case (% matches pattern `STRING`)

        1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type dataTypeIR)

    1. (Let dataTypeIR be (typeIR' as dataTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:156:1-156:35:
def $nestable_tuple(typeIR)

1. Return $nestable'_tuple($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:157:1-157:36:
def $nestable'_tuple(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `BOOL`)

        1. Return true

      2. Case (% matches pattern `ERROR`)

        1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      3. Case (% matches pattern `VARBIT<%>`)

        1. (Let (varbit< _nat >) be numberTypeIR)

        2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type tupleTypeIR)

    1. (Let (tuple< _typeIR* >) be (typeIR'' as tupleTypeIR))

    2. Return true

  6. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'' [ _nat ]) be (typeIR'' as headerStackTypeIR))

    2. Return true

  7. Case (% has type headerTypeIR)

    1. (Let (header _tid { _fieldTypeIR* }) be (typeIR'' as headerTypeIR))

    2. Return true

  8. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR'' as headerUnionTypeIR))

    2. Return true

  9. Case (% has type structTypeIR)

    1. (Let (struct _tid { _fieldTypeIR* }) be (typeIR'' as structTypeIR))

    2. Return true

  10. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:182:1-182:35:
def $nestable_stack(typeIR)

1. Return $nestable'_stack($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:183:1-183:36:
def $nestable'_stack(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  2. Case (% has type headerTypeIR)

    1. (Let (header _tid { _fieldTypeIR* }) be (typeIR' as headerTypeIR))

    2. Return true

  3. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR' as headerUnionTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:197:1-197:36:
def $nestable_struct(typeIR)

1. Return $nestable'_struct($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:198:1-198:37:
def $nestable'_struct(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `BOOL`)

        1. Return true

      2. Case (% matches pattern `ERROR`)

        1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

      3. Case (% matches pattern `VARBIT<%>`)

        1. (Let (varbit< _nat >) be numberTypeIR)

        2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type tupleTypeIR)

    1. (Let (tuple< _typeIR* >) be (typeIR'' as tupleTypeIR))

    2. Return true

  6. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'' [ _nat ]) be (typeIR'' as headerStackTypeIR))

    2. Return true

  7. Case (% has type structTypeIR)

    1. (Let (struct _tid { _fieldTypeIR* }) be (typeIR'' as structTypeIR))

    2. Return true

  8. Case (% has type headerTypeIR)

    1. (Let (header _tid { _fieldTypeIR* }) be (typeIR'' as headerTypeIR))

    2. Return true

  9. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR'' as headerUnionTypeIR))

    2. Return true

  10. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:224:1-224:36:
def $nestable_header(typeIR)

1. Return $nestable'_header($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:225:1-225:37:
def $nestable'_header(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BOOL`)), then

      1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

      3. Case (% matches pattern `VARBIT<%>`)

        1. (Let (varbit< _nat >) be numberTypeIR)

        2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

      2. Return true

  6. Case (% has type structTypeIR)

    1. (Let (struct _tid { (typeIR'' _id ;)* }) be (typeIR'' as structTypeIR))

    2. If ($nestable_struct_in_header(typeIR''))*, then

      1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:226:1-226:46:
def $nestable_struct_in_header(typeIR)

1. Return $nestable'_struct_in_header($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:227:1-227:47:
def $nestable'_struct_in_header(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BOOL`)), then

      1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

      2. Return true

  6. Case (% has type structTypeIR)

    1. (Let (struct _tid { (typeIR'' _id ;)* }) be (typeIR'' as structTypeIR))

    2. If ($nestable_struct_in_header(typeIR''))*, then

      1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:261:1-261:41:
def $nestable_headerunion(typeIR)

1. Return $nestable'_headerunion($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:262:1-262:42:
def $nestable'_headerunion(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  3. Case (% has type headerTypeIR)

    1. (Let (header _tid { _fieldTypeIR* }) be (typeIR' as headerTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:282:1-282:37:
def $nestable_serenum(typeIR)

1. Return $nestable'_serenum($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:283:1-283:38:
def $nestable'_serenum(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR'') be aliasTypeIR)

      2. Return $nestable_new_in_serenum(typeIR'')

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:284:1-284:44:
def $nestable_new_in_serenum(typeIR)

1. Return $nestable_new_in_serenum'($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:285:1-285:45:
def $nestable_new_in_serenum'(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:361:1-361:33:
def $nestable_set(typeIR)

1. Return $nestable'_set($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:362:1-362:34:
def $nestable'_set(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `BOOL`)

        1. Return true

      2. Case (% matches pattern `ERROR`)

        1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. If ($nestable_tuple_in_set(typeIR''))*, then

      1. Return true

  6. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

  7. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR'' as sequenceTypeIR))

    2. If ((sequenceTypeIR matches pattern `SEQ<%>`)), then

      1. (Let (seq< typeIR''* >) be sequenceTypeIR)

      2. If ($nestable_sequence_in_set(typeIR''))*, then

        1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:363:1-363:42:
def $nestable_tuple_in_set(typeIR)

1. Return $nestable'_tuple_in_set($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:364:1-364:43:
def $nestable'_tuple_in_set(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BOOL`)), then

      1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. If ($nestable_tuple_in_set(typeIR''))*, then

      1. Return true

  6. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:365:1-365:45:
def $nestable_sequence_in_set(typeIR)

1. Return $nestable'_sequence_in_set($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:366:1-366:46:
def $nestable'_sequence_in_set(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BOOL`)), then

      1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. If ($nestable_sequence_in_set(typeIR''))*, then

      1. Return true

  6. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

  7. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR'' as sequenceTypeIR))

    2. If ((sequenceTypeIR matches pattern `SEQ<%>`)), then

      1. (Let (seq< typeIR''* >) be sequenceTypeIR)

      2. If ($nestable_sequence_in_set(typeIR''))*, then

        1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:430:1-430:40:
def $definable_type_mono(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. Return true

  3. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

  4. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:445:1-445:40:
def $definable_type_poly(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type tupleTypeIR)

    1. (Let (tuple< _typeIR* >) be (typeIR' as tupleTypeIR))

    2. Return true

  2. Case (% has type headerStackTypeIR)

    1. (Let (_typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

    2. Return true

  3. Case (% has type headerTypeIR)

    1. (Let (header _tid { _fieldTypeIR* }) be (typeIR' as headerTypeIR))

    2. Return true

  4. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR' as headerUnionTypeIR))

    2. Return true

  5. Case (% has type structTypeIR)

    1. (Let (struct _tid { _fieldTypeIR* }) be (typeIR' as structTypeIR))

    2. Return true

  6. Case (% has type externObjectTypeIR)

    1. (Let (extern _tid _map<rid, routineTypeDefIR>) be (typeIR' as externObjectTypeIR))

    2. Return true

  7. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

    2. Return true

  8. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

    2. Return true

  9. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:478:1-478:49:
def $nestable_function(direction, typeIR)

1. Return $nestable_function'(direction, $canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:479:1-479:50:
def $nestable_function'(direction', typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `STRING`)), then

      1. If (~(direction' matches pattern ``EMPTY`)), then

        1. Return false

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `INT`)), then

      1. If (~(direction' matches pattern ``EMPTY`)), then

        1. Return false

  3. Case (% has type objectTypeIR)

    1. (Let objectTypeIR be (typeIR' as objectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:498:1-498:47:
def $directionless_trailing(direction*)

1. Return $directionless_trailing'(true, $rev_<direction>(direction*))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:499:1-499:54:
def $directionless_trailing'(_bool', direction''*)

1. Case analysis on direction''*

  1. Case (% matches pattern [])

    1. Return true

  2. Case (% matches pattern _ :: _)

    1. (Let direction_h :: direction_t* be direction''*)

    2. If (~(direction_h matches pattern ``EMPTY`)), then

      1. Return $directionless_trailing'(false, direction_t*)

    2. Else Phantom#615

2. Case analysis on _bool'

  1. Case (% = true)

    1. If ((direction''* matches pattern _ :: _)), then

      1. (Let direction'' :: direction_t* be direction''*)

      2. If ((direction'' matches pattern ``EMPTY`)), then

        1. Return $directionless_trailing'(true, direction_t*)

      2. Else Phantom#616

    1. Else Phantom#617

  2. Case (% = false)

    1. If ((direction''* matches pattern _ :: _)), then

      1. (Let direction'' :: direction_t* be direction''*)

      2. If ((direction'' matches pattern ``EMPTY`)), then

        1. Return false

      2. Else Phantom#618

    1. Else Phantom#619

2. Else Phantom#620

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:512:1-512:47:
def $nestable_action(direction, typeIR)

1. Return $nestable_action'(direction, $canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:513:1-513:48:
def $nestable_action'(direction', typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `STRING`)), then

      1. If (~(direction' matches pattern ``EMPTY`)), then

        1. Return false

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `INT`)), then

      1. Return false

  3. Case (% has type objectTypeIR)

    1. (Let objectTypeIR be (typeIR' as objectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:531:1-531:55:
def $nestable_externfunction(direction, typeIR)

1. Return $nestable_externfunction'(direction, $canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:532:1-532:56:
def $nestable_externfunction'(direction', typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `STRING`)), then

      1. If (~(direction' matches pattern ``EMPTY`)), then

        1. Return false

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `INT`)), then

      1. If (~(direction' matches pattern ``EMPTY`)), then

        1. Return false

  3. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

    2. Return false

  4. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

    2. Return false

  5. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return false

  6. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:561:1-561:53:
def $nestable_externmethod(direction, typeIR)

1. Return $nestable_externmethod'(direction, $canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:562:1-562:54:
def $nestable_externmethod'(direction', typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `STRING`)), then

      1. If (~(direction' matches pattern ``EMPTY`)), then

        1. Return false

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `INT`)), then

      1. If (~(direction' matches pattern ``EMPTY`)), then

        1. Return false

  3. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

    2. Return false

  4. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

    2. Return false

  5. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return false

  6. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:584:1-584:61:
def $nestable_externabstractmethod(direction, typeIR)

1. Return $nestable_externabstractmethod'(direction, $canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:585:1-585:62:
def $nestable_externabstractmethod'(direction', typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `STRING`)), then

      1. If (~(direction' matches pattern ``EMPTY`)), then

        1. Return false

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `INT`)), then

      1. If (~(direction' matches pattern ``EMPTY`)), then

        1. Return false

  3. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

    2. Return false

  4. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

    2. Return false

  5. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return false

  6. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:607:1-607:58:
def $nestable_parserapplymethod(direction, typeIR)

1. Return $nestable_parserapplymethod'(direction, $canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:608:1-608:59:
def $nestable_parserapplymethod'(direction', typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `STRING`)), then

      1. If (~(direction' matches pattern ``EMPTY`)), then

        1. Return false

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `INT`)), then

      1. If (~(direction' matches pattern ``EMPTY`)), then

        1. Return false

  3. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

    2. Return false

  4. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

    2. Return false

  5. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return false

  6. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:629:1-629:59:
def $nestable_controlapplymethod(direction, typeIR)

1. Return $nestable_controlapplymethod'(direction, $canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:630:1-630:60:
def $nestable_controlapplymethod'(direction', typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `STRING`)), then

      1. If (~(direction' matches pattern ``EMPTY`)), then

        1. Return false

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `INT`)), then

      1. If (~(direction' matches pattern ``EMPTY`)), then

        1. Return false

  3. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

    2. Return false

  4. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return false

  5. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:657:1-657:50:
def $definable_routine_mono(routineTypeIR')

1. Case analysis on routineTypeIR'

  1. Case (% has type functionTypeIR)

    1. (Let functionTypeIR be (routineTypeIR' as functionTypeIR))

    2. Case analysis on functionTypeIR

      1. Case (% matches pattern `BUILTIN_FUNCTION(%)->%`)

        1. (Let (builtin_function( _parameterTypeIR* )-> _typeIR) be functionTypeIR)

        2. Return true

      2. Case (% matches pattern `ACTION(%)`)

        1. (Let (action( _parameterTypeIR* )) be functionTypeIR)

        2. Return true

  2. Case (% has type methodTypeIR)

    1. (Let methodTypeIR be (routineTypeIR' as methodTypeIR))

    2. Case analysis on methodTypeIR

      1. Case (% matches pattern `BUILTIN_METHOD(%)->%`)

        1. (Let (builtin_method( _parameterTypeIR* )-> _typeIR) be methodTypeIR)

        2. Return true

      2. Case (% matches pattern `PARSER_APPLY(%)`)

        1. (Let (parser_apply( _parameterTypeIR* )) be methodTypeIR)

        2. Return true

      3. Case (% matches pattern `CONTROL_APPLY(%)`)

        1. (Let (control_apply( _parameterTypeIR* )) be methodTypeIR)

        2. Return true

      4. Case (% matches pattern `TABLE_APPLY->%`)

        1. (Let (table_apply-> _typeIR) be methodTypeIR)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:673:1-673:50:
def $definable_routine_poly(routineTypeIR')

1. Case analysis on routineTypeIR'

  1. Case (% has type functionTypeIR)

    1. (Let functionTypeIR be (routineTypeIR' as functionTypeIR))

    2. Case analysis on functionTypeIR

      1. Case (% matches pattern `FUNCTION(%)->%`)

        1. (Let (function( _parameterTypeIR* )-> _typeIR) be functionTypeIR)

        2. Return true

      2. Case (% matches pattern `EXTERN_FUNCTION(%)->%`)

        1. (Let (extern_function( _parameterTypeIR* )-> _typeIR) be functionTypeIR)

        2. Return true

  2. Case (% has type methodTypeIR)

    1. (Let methodTypeIR be (routineTypeIR' as methodTypeIR))

    2. Case analysis on methodTypeIR

      1. Case (% matches pattern `EXTERN_METHOD(%)->%`)

        1. (Let (extern_method( _parameterTypeIR* )-> _typeIR) be methodTypeIR)

        2. Return true

      2. Case (% matches pattern `EXTERN_METHODABSTRACT(%)->%`)

        1. (Let (extern_methodabstract( _parameterTypeIR* )-> _typeIR) be methodTypeIR)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:708:1-708:48:
def $nestable_constructor_extern(typeIR)

1. Return $nestable'_constructor_extern($canon(typeIR))

2. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

  2. Return false

2. Else Phantom#621

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:709:1-709:49:
def $nestable'_constructor_extern(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

    2. Return false

  2. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return false

  3. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:728:1-728:48:
def $nestable_constructor_parser(typeIR)

1. Return $nestable'_constructor_parser($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:729:1-729:49:
def $nestable'_constructor_parser(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

    2. Return false

  2. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return false

  3. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:747:1-747:49:
def $nestable_constructor_control(typeIR)

1. Return $nestable'_constructor_control($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:748:1-748:50:
def $nestable'_constructor_control(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

    2. Return false

  2. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return false

  3. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:766:1-766:49:
def $nestable_constructor_package(typeIR)

1. Return $nestable'_constructor_package($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:767:1-767:50:
def $nestable'_constructor_package(typeIR')

1. If ((typeIR' has type tableObjectTypeIR)), then

  1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

  2. Return false

2. Otherwise

  1. Return true

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:787:1-787:42:
def $definable_constructor(typeIR)

1. Return $definable'_constructor($canon(typeIR))

;; ../../../../examples/p4-concrete/5.03-wellformed.spectec:788:1-788:43:
def $definable'_constructor(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type externObjectTypeIR)

    1. (Let (extern _tid _map<rid, routineTypeDefIR>) be (typeIR' as externObjectTypeIR))

    2. Return true

  2. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

    2. Return true

  3. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

    2. Return true

  4. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:6:1-8:23:
relation Eval_static: p, TC, (expressionIR # (( _typeIR' _ctk'' )))

1. Case analysis on expressionIR

  1. Case (% has type literalExpression)

    1. (Let literalExpression be (expressionIR as literalExpression))

    2. Case analysis on literalExpression

      1. Case (% matches pattern `TRUE`)

        1. Result in ((b true) as value)

      2. Case (% matches pattern `FALSE`)

        1. Result in ((b false) as value)

    2. Else Phantom#622

  2. Case (% has type prefixedNameIR)

    1. (Let prefixedNameIR be (expressionIR as prefixedNameIR))

    2. (Let value be $find_value(p, TC, prefixedNameIR))

    3. Result in value

  3. Case (% has type defaultExpression)

    1. (Let defaultExpression be (expressionIR as defaultExpression))

    2. If ((defaultExpression matches pattern `...`)), then

      1. Result in ((default) as value)

    2. Else Phantom#623

  4. Case (% has type unaryExpressionIR)

    1. (Let (unop typedExpressionIR) be (expressionIR as unaryExpressionIR))

    2. Case analysis on unop

      1. Case (% matches pattern `~`)

        1. (Eval_static: p TC |- typedExpressionIR ~> value)

        2. Result in $un_bnot(value)

      2. Case (% matches pattern `!`)

        1. (Eval_static: p TC |- typedExpressionIR ~> value)

        2. Result in $un_lnot(value)

      3. Case (% matches pattern `+`)

        1. (Eval_static: p TC |- typedExpressionIR ~> value)

        2. Result in $un_plus(value)

      4. Case (% matches pattern `-`)

        1. (Eval_static: p TC |- typedExpressionIR ~> value)

        2. Result in $un_minus(value)

  5. Case (% has type binaryExpressionIR)

    1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

    2. Case analysis on binop

      1. Case (% matches pattern `+`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_plus(value_l, value_r)

      2. Case (% matches pattern `|+|`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_satplus(value_l, value_r)

      3. Case (% matches pattern `-`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_minus(value_l, value_r)

      4. Case (% matches pattern `|-|`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_satminus(value_l, value_r)

      5. Case (% matches pattern `*`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_mul(value_l, value_r)

      6. Case (% matches pattern `/`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_div(value_l, value_r)

      7. Case (% matches pattern `<<`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_shl(value_l, value_r)

      8. Case (% matches pattern `>>`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_shr(value_l, value_r)

      9. Case (% matches pattern `<=`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in ((b $bin_le(value_l, value_r)) as value)

      10. Case (% matches pattern `>=`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in ((b $bin_ge(value_l, value_r)) as value)

      11. Case (% matches pattern `<`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in ((b $bin_lt(value_l, value_r)) as value)

      12. Case (% matches pattern `>`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in ((b $bin_gt(value_l, value_r)) as value)

      13. Case (% matches pattern `==`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in ((b $bin_eq(value_l, value_r)) as value)

      14. Case (% matches pattern `!=`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in ((b $bin_ne(value_l, value_r)) as value)

      15. Case (% matches pattern `&`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_band(value_l, value_r)

      16. Case (% matches pattern `^`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_bxor(value_l, value_r)

      17. Case (% matches pattern `|`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_bor(value_l, value_r)

      18. Case (% matches pattern `++`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_concat(value_l, value_r)

      19. Case (% matches pattern `&&`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_land(value_l, value_r)

      20. Case (% matches pattern `||`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_lor(value_l, value_r)

    2. Else Phantom#624

  6. Case (% has type ternaryExpressionIR)

    1. (Let (typedExpressionIR_cond ? typedExpressionIR_true : typedExpressionIR_false) be (expressionIR as ternaryExpressionIR))

    2. (Eval_static: p TC |- typedExpressionIR_cond ~> value)

    3. If ((value = ((b true) as value))), then

      1. (Eval_static: p TC |- typedExpressionIR_true ~> value_true)

      2. Result in value_true

    3. Else Phantom#625

    4. If ((value = ((b false) as value))), then

      1. (Eval_static: p TC |- typedExpressionIR_false ~> value_false)

      2. Result in value_false

    4. Else Phantom#626

  7. Case (% has type castExpressionIR)

    1. (Let (( typeIR ) typedExpressionIR) be (expressionIR as castExpressionIR))

    2. (Eval_static: p TC |- typedExpressionIR ~> value)

    3. (Let value_cast be $cast_op(typeIR, value))

    4. Result in value_cast

  8. Case (% has type dataExpressionIR)

    1. (Let dataExpressionIR be (expressionIR as dataExpressionIR))

    2. Case analysis on dataExpressionIR

      1. Case (% matches pattern `{#}`)

        1. Result in (({#}) as value)

      2. Case (% matches pattern `SEQ{%}`)

        1. (Let (seq{ typedExpressionIR* }) be dataExpressionIR)

        2. (Eval_static: p TC |- typedExpressionIR ~> value)*

        3. Result in ((seq( value* )) as value)

      3. Case (% matches pattern `SEQ{%,...}`)

        1. (Let (seq{ typedExpressionIR* ,...}) be dataExpressionIR)

        2. (Eval_static: p TC |- typedExpressionIR ~> value)*

        3. Result in ((seq( value* ,...)) as value)

      4. Case (% matches pattern `RECORD{%}`)

        1. (Let (record{ (nameIR = typedExpressionIR)* }) be dataExpressionIR)

        2. (Eval_static: p TC |- typedExpressionIR ~> value)*

        3. Result in ((record{ (value nameIR ;)* }) as value)

      5. Case (% matches pattern `RECORD{%,...}`)

        1. (Let (record{ (nameIR = typedExpressionIR)* ,...}) be dataExpressionIR)

        2. (Eval_static: p TC |- typedExpressionIR ~> value)*

        3. Result in ((record{ (value nameIR ;)* ,...}) as value)

  9. Case (% has type errorAccessExpressionIR)

    1. (Let (error. nameIR) be (expressionIR as errorAccessExpressionIR))

    2. (Let nameIR_error be "error." ++ nameIR)

    3. (Let value_error be $find_value(p, TC, (` nameIR_error)))

    4. Result in value_error

  10. Case (% has type memberAccessExpressionIR)

    1. (Let (memberAccessBaseIR . nameIR) be (expressionIR as memberAccessExpressionIR))

    2. If ((memberAccessBaseIR matches pattern `TYPE%`)), then

      1. (Let (type prefixedNameIR) be memberAccessBaseIR)

      2. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

      3. If ((typeDefIR'? matches pattern (_))), then

        1. (Let ?(typeDefIR) be typeDefIR'?)

        2. If ((typeDefIR has type enumTypeIR)), then

          1. (Let enumTypeIR be (typeDefIR as enumTypeIR))

          2. Case analysis on enumTypeIR

            1. Case (% matches pattern `ENUM%{%}`)

              1. (Let (enum tid { id_member* }) be enumTypeIR)

              2. If (nameIR is in id_member*), then

                1. Result in ((tid . nameIR) as value)

              2. Else Phantom#627

            2. Case (% matches pattern `ENUM%#%{%}`)

              1. (Let (enum tid # typeIR { (id_member = value_member ;)* }) be enumTypeIR)

              2. (Let value'? be $assoc_<id, value>(nameIR, (id_member, value_member)*))

              3. If ((value'? matches pattern (_))), then

                1. (Let ?(value) be value'?)

                2. Result in ((tid . nameIR # value) as value)

              3. Else Phantom#628

        2. Else Phantom#629

      3. Else Phantom#630

    2. Else Phantom#631

    3. If ((memberAccessBaseIR has type typedExpressionIR)), then

      1. (Let typedExpressionIR_base be (memberAccessBaseIR as typedExpressionIR))

      2. If ((nameIR = "size")), then

        1. (Let typeIR be _typeIR')

        2. If ((typeIR has type headerStackTypeIR)), then

          1. (Let (_typeIR' [ n_size ]) be (typeIR as headerStackTypeIR))

          2. Result in ((d (n_size as int)) as value)

        2. Else Phantom#632

      2. Else Phantom#633

    3. Else Phantom#634

  11. Case (% has type indexAccessExpressionIR)

    1. (Let indexAccessExpressionIR be (expressionIR as indexAccessExpressionIR))

    2. If ((indexAccessExpressionIR matches pattern `%[%:%]`)), then

      1. (Let (typedExpressionIR_base [ typedExpressionIR_hi : typedExpressionIR_lo ]) be indexAccessExpressionIR)

      2. (Eval_static: p TC |- typedExpressionIR_base ~> value_base)

      3. (Eval_static: p TC |- typedExpressionIR_hi ~> value_hi)

      4. (Eval_static: p TC |- typedExpressionIR_lo ~> value_lo)

      5. Result in $bitacc_op(value_base, value_hi, value_lo)

    2. Else Phantom#635

  12. Case (% has type callExpressionIR)

    1. (Let callExpressionIR be (expressionIR as callExpressionIR))

    2. If ((callExpressionIR matches pattern `%<%>(%)`)), then

      1. (Let (routineTargetIR < typeArgumentIR* >( argumentIR* )) be callExpressionIR)

      2. Case analysis on routineTargetIR

        1. Case (% matches pattern `%.%`)

          1. (Let (typedExpressionIR_base . nameIR) be routineTargetIR)

          2. If ((typeArgumentIR* matches pattern [])), then

            1. If ((argumentIR* matches pattern [])), then

              1. (Let (_expressionIR # (( _typeIR' _ctk' ))) be typedExpressionIR_base)

              2. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

                1. Result in $sizeof(_typeIR', nameIR)

              2. Else Phantom#636

            1. Else Phantom#637

          2. Else Phantom#638

        2. Case (% matches pattern `TYPE%.%`)

          1. (Let (type prefixedNameIR . nameIR) be routineTargetIR)

          2. If ((typeArgumentIR* matches pattern [])), then

            1. If ((argumentIR* matches pattern [])), then

              1. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

              2. If ((typeDefIR'? matches pattern (_))), then

                1. (Let ?(typeDefIR) be typeDefIR'?)

                2. Case analysis on typeDefIR

                  1. Case (% has type typeIR)

                    1. (Let _typeIR' be (typeDefIR as typeIR))

                    2. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

                      1. Result in $sizeof(_typeIR', nameIR)

                    2. Else Phantom#639

                  2. Case (% has type polyTypeDefIR)

                    1. (Let (_typeIR' < tid* , tid'* >) be (typeDefIR as polyTypeDefIR))

                    2. If ((tid* matches pattern [])), then

                      1. If ((tid'* matches pattern [])), then

                        1. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

                          1. Result in $sizeof(_typeIR', nameIR)

                        1. Else Phantom#640

                      1. Else Phantom#641

                    2. Else Phantom#642

              2. Else Phantom#643

            1. Else Phantom#644

          2. Else Phantom#645

        3. Case (% matches pattern `(%)`)

          1. (Let (( routineTargetIR )) be routineTargetIR)

          2. (Eval_static: p TC |- (((routineTargetIR < typeArgumentIR* >( argumentIR* )) as expressionIR) # (( _typeIR' _ctk'' ))) ~> value)

          3. Result in value

      2. Else Phantom#646

    2. Else Phantom#647

  13. Case (% has type parenthesizedExpressionIR)

    1. (Let (( typedExpressionIR )) be (expressionIR as parenthesizedExpressionIR))

    2. (Eval_static: p TC |- typedExpressionIR ~> value)

    3. Result in value

2. Case analysis on expressionIR

  1. Case (% has type number)

    1. (Let number be (expressionIR as number))

    2. Case analysis on number

      1. Case (% matches pattern `D%`)

        1. (Let (d i) be number)

        2. Result in ((d i) as value)

      2. Case (% matches pattern `%W%`)

        1. (Let (n w i) be number)

        2. Result in ((n w i) as value)

      3. Case (% matches pattern `%S%`)

        1. (Let (n s i) be number)

        2. Result in ((n s i) as value)

  2. Case (% has type stringLiteral)

    1. (Let (" text ") be (expressionIR as stringLiteral))

    2. Result in ((" text ") as value)

2. Else Phantom#648

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:15:1-17:23:
relation Type_ok: p, TC, typeOrVoid

1. Case analysis on typeOrVoid

  1. Case (% has type baseType)

    1. (Let baseType be (typeOrVoid as baseType))

    2. Case analysis on baseType

      1. Case (% matches pattern `BOOL`)

        1. Result in ((bool) as typeIR), []

      2. Case (% matches pattern `ERROR`)

        1. Result in ((error) as typeIR), []

      3. Case (% matches pattern `MATCH_KIND`)

        1. Result in ((match_kind) as typeIR), []

      4. Case (% matches pattern `STRING`)

        1. Result in ((string) as typeIR), []

      5. Case (% matches pattern `INT`)

        1. Result in ((int) as typeIR), []

      6. Case (% matches pattern `INT<%>`)

        1. (Let (int< int >) be baseType)

        2. If ((int has type nat)), then

          1. (Let n be (int as nat))

          2. Result in ((int< n >) as typeIR), []

        2. Else Phantom#649

      7. Case (% matches pattern `INT<(%)>`)

        1. (Let (int<( expression )>) be baseType)

        2. (Expr_ok: p TC |- expression : typedExpressionIR)

        3. (Eval_static: p TC |- typedExpressionIR ~> value)

        4. (Let int be $to_number(value))

        5. If ((int has type nat)), then

          1. (Let n be (int as nat))

          2. Result in ((int< n >) as typeIR), []

        5. Else Phantom#650

      8. Case (% matches pattern `BIT`)

        1. Result in ((bit< 1 >) as typeIR), []

      9. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< int >) be baseType)

        2. If ((int has type nat)), then

          1. (Let n be (int as nat))

          2. Result in ((bit< n >) as typeIR), []

        2. Else Phantom#651

      10. Case (% matches pattern `BIT<(%)>`)

        1. (Let (bit<( expression )>) be baseType)

        2. (Expr_ok: p TC |- expression : typedExpressionIR)

        3. (Eval_static: p TC |- typedExpressionIR ~> value)

        4. (Let int be $to_number(value))

        5. If ((int has type nat)), then

          1. (Let n be (int as nat))

          2. Result in ((bit< n >) as typeIR), []

        5. Else Phantom#652

      11. Case (% matches pattern `VARBIT<%>`)

        1. (Let (varbit< int >) be baseType)

        2. If ((int has type nat)), then

          1. (Let n be (int as nat))

          2. Result in ((varbit< n >) as typeIR), []

        2. Else Phantom#653

      12. Case (% matches pattern `VARBIT<(%)>`)

        1. (Let (varbit<( expression )>) be baseType)

        2. (Expr_ok: p TC |- expression : typedExpressionIR)

        3. (Eval_static: p TC |- typedExpressionIR ~> value)

        4. (Let int be $to_number(value))

        5. If ((int has type nat)), then

          1. (Let n be (int as nat))

          2. Result in ((varbit< n >) as typeIR), []

        5. Else Phantom#654

  2. Case (% has type prefixedTypeName)

    1. (Let prefixedTypeName be (typeOrVoid as prefixedTypeName))

    2. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

    3. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

    4. If ((typeDefIR'? matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?)

      2. Case analysis on typeDefIR

        1. Case (% has type typeIR)

          1. (Let typeIR be (typeDefIR as typeIR))

          2. Result in typeIR, []

        2. Case (% has type polyTypeDefIR)

          1. (Let polyTypeDefIR be (typeDefIR as polyTypeDefIR))

          2. Result in ((polyTypeDefIR < [] >) as typeIR), []

    4. Else Phantom#655

  3. Case (% has type specializedType)

    1. (Let (prefixedTypeName < typeArgumentList >) be (typeOrVoid as specializedType))

    2. If ((typeArgumentList matches pattern ``EMPTY`)), then

      1. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

      2. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

      3. If ((typeDefIR'? matches pattern (_))), then

        1. (Let ?(typeDefIR) be typeDefIR'?)

        2. If ((typeDefIR has type typeIR)), then

          1. (Let typeIR be (typeDefIR as typeIR))

          2. Result in typeIR, []

        2. Else Phantom#656

      3. Else Phantom#657

    2. Else Phantom#658

    3. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

    4. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

    5. If ((typeDefIR'? matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?)

      2. If ((typeDefIR has type polyTypeDefIR)), then

        1. (Let polyTypeDefIR be (typeDefIR as polyTypeDefIR))

        2. (Let (typeIR < tid_expl* , tid_impl* >) be polyTypeDefIR)

        3. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

        4. (TypeArguments_ok: p TC |- typeArgument* : typeIR_arg* # tid_fresh*)

        5. Result in ((polyTypeDefIR < typeIR_arg* >) as typeIR), tid_fresh*

      2. Else Phantom#659

    5. Else Phantom#660

  4. Case (% has type headerStackType)

    1. (Let (namedType [ expression_size ]) be (typeOrVoid as headerStackType))

    2. Case analysis on namedType

      1. Case (% has type typeName)

        1. (Let typeName be (namedType as typeName))

        2. (Type_ok: p TC |- (typeName as typeOrVoid) : typeIR_base # tid*)

        3. If ((tid* matches pattern [])), then

          1. (Expr_ok: p TC |- expression_size : typedExpressionIR_size)

          2. (Eval_static: p TC |- typedExpressionIR_size ~> value_size)

          3. (Let int be $to_number(value_size))

          4. If ((int has type nat)), then

            1. (Let n_size be (int as nat))

            2. (Let typeIR_stack be ((((tid "T") as typeIR) [ n_size ]) as typeIR))

            3. (Let polyTypeDefIR_stack be (typeIR_stack < ["T"] , [] >))

            4. Result in ((polyTypeDefIR_stack < [typeIR_base] >) as typeIR), []

          4. Else Phantom#661

        3. Else Phantom#662

      2. Case (% has type specializedType)

        1. (Let specializedType be (namedType as specializedType))

        2. (Type_ok: p TC |- (specializedType as typeOrVoid) : typeIR_base # tid_fresh*)

        3. (Expr_ok: p TC |- expression_size : typedExpressionIR_size)

        4. (Eval_static: p TC |- typedExpressionIR_size ~> value_size)

        5. (Let int be $to_number(value_size))

        6. If ((int has type nat)), then

          1. (Let n_size be (int as nat))

          2. (Let typeIR_stack be ((((tid "T") as typeIR) [ n_size ]) as typeIR))

          3. (Let polyTypeDefIR_stack be (typeIR_stack < ["T"] , [] >))

          4. Result in ((polyTypeDefIR_stack < [typeIR_base] >) as typeIR), tid_fresh*

        6. Else Phantom#663

    2. Else Phantom#664

  5. Case (% has type listType)

    1. (Let (list< typeArgument >) be (typeOrVoid as listType))

    2. (TypeArgument_ok: p TC |- typeArgument : typeIR_arg # tid_fresh*)

    3. (Let typeIR_list be ((list< ((tid "T") as typeIR) >) as typeIR))

    4. (Let polyTypeDefIR_list be (typeIR_list < ["T"] , [] >))

    5. Result in ((polyTypeDefIR_list < [typeIR_arg] >) as typeIR), tid_fresh*

  6. Case (% has type tupleType)

    1. (Let (tuple< typeArgumentList >) be (typeOrVoid as tupleType))

    2. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

    3. (TypeArguments_ok: p TC |- typeArgument* : typeIR_arg* # tid_fresh*)

    4. (Let i_idx* be ($init_(|typeIR_arg*|) as int*))

    5. (Let tid_tparam be "T" ++ $int_to_text(i_idx))*

    6. (Let typeIR_tuple be ((tuple< ((tid tid_tparam) as typeIR)* >) as typeIR))

    7. (Let polyTypeDefIR_tuple be (typeIR_tuple < tid_tparam* , [] >))

    8. Result in ((polyTypeDefIR_tuple < typeIR_arg* >) as typeIR), tid_fresh*

1. Else Phantom#665

2. If ((typeOrVoid matches pattern `VOID`)), then

  1. Result in ((void) as typeIR), []

2. Else Phantom#666

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:19:1-21:23:
relation TypeArgument_ok: p, TC, typeArgument

1. Case analysis on typeArgument

  1. Case (% has type type)

    1. (Let type be (typeArgument as type))

    2. (Type_ok: p TC |- (type as typeOrVoid) : typeIR # tid_impl*)

    3. Result in typeIR, tid_impl*

  2. Case (% has type nonTypeName)

    1. (Let nonTypeName be (typeArgument as nonTypeName))

    2. (Let tid be $name((nonTypeName as name)))

    3. Result in ((tid tid) as typeArgumentIR), []

1. Else Phantom#667

2. If ((typeArgument has type realTypeArgument)), then

  1. (Let realTypeArgument be (typeArgument as realTypeArgument))

  2. Case analysis on realTypeArgument

    1. Case (% matches pattern `VOID`)

      1. Result in ((void) as typeArgumentIR), []

    2. Case (% matches pattern `_`)

      1. (Let tid_impl be $fresh_tid)

      2. Result in ((tid tid_impl) as typeArgumentIR), [tid_impl]

  2. Else Phantom#668

2. Else Phantom#669

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:23:1-25:23:
relation TypeArguments_ok: p, TC, typeArgument*

1. Case analysis on typeArgument*

  1. Case (% matches pattern [])

    1. Result in [], []

  2. Case (% matches pattern _ :: _)

    1. (Let typeArgument_h :: typeArgument_t* be typeArgument*)

    2. (TypeArgument_ok: p TC |- typeArgument_h : typeArgumentIR_h # tid_impl_h*)

    3. (TypeArguments_ok: p TC |- typeArgument_t* : typeArgumentIR_t* # tid_impl_t*)

    4. (Let tid_impl* be tid_impl_h* ++ tid_impl_t*)

    5. Result in typeArgumentIR_h :: typeArgumentIR_t*, tid_impl*

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:31:1-31:54:
relation Sub_expl: typeIR_a, typeIR_b

1. (Let typeIR_a_canon be $canon(typeIR_a))

2. (Let typeIR_b_canon be $canon(typeIR_b))

3. If ((Sub_expl_canon: typeIR_a_canon <: typeIR_b_canon holds)), then

  1. The relation holds

3. Else Phantom#670

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:32:1-32:60:
relation Sub_expl_canon: typeIR_a, typeIR_b

1. Case analysis on (Type_alpha: typeIR_a ~~ typeIR_b holds)

  1. Case true

    1. The relation holds

  2. Case false

    1. If ((Sub_expl_canon_neq: typeIR_a <: typeIR_b holds)), then

      1. The relation holds

    1. Else Phantom#671

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:33:1-33:64:
relation Sub_expl_canon_neq: typeIR''''', typeIR''''''

1. If ((typeIR''''' = ((bit< 1 >) as typeIR))), then

  1. If ((typeIR'''''' has type primitiveTypeIR)), then

    1. (Let primitiveTypeIR be (typeIR'''''' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BOOL`)), then

      1. The relation holds

    2. Else Phantom#672

  1. Else Phantom#673

1. Else Phantom#674

2. Case analysis on typeIR'''''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR''''' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BOOL`)), then

      1. If ((typeIR'''''' = ((bit< 1 >) as typeIR))), then

        1. The relation holds

      1. Else Phantom#675

    2. Else Phantom#676

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR''''' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT`)

        1. Case analysis on typeIR''''''

          1. Case (% has type primitiveTypeIR)

            1. (Let primitiveTypeIR be (typeIR'''''' as primitiveTypeIR))

            2. If ((primitiveTypeIR matches pattern `BOOL`)), then

              1. The relation holds

            2. Else Phantom#677

          2. Case (% has type numberTypeIR)

            1. (Let numberTypeIR' be (typeIR'''''' as numberTypeIR))

            2. Case analysis on numberTypeIR'

              1. Case (% matches pattern `INT<%>`)

                1. (Let (int< _nat >) be numberTypeIR')

                2. The relation holds

              2. Case (% matches pattern `BIT<%>`)

                1. (Let (bit< _nat >) be numberTypeIR')

                2. The relation holds

            2. Else Phantom#678

        1. Else Phantom#679

      2. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. If ((typeIR'''''' has type numberTypeIR)), then

          1. (Let numberTypeIR' be (typeIR'''''' as numberTypeIR))

          2. Case analysis on numberTypeIR'

            1. Case (% matches pattern `INT`)

              1. The relation holds

            2. Case (% matches pattern `INT<%>`)

              1. (Let (int< w_b >) be numberTypeIR')

              2. The relation holds

            3. Case (% matches pattern `BIT<%>`)

              1. (Let (bit< w' >) be numberTypeIR')

              2. If ((_nat = w')), then

                1. The relation holds

              2. Else Phantom#680

          2. Else Phantom#681

        2. Else Phantom#682

      3. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. If ((typeIR'''''' has type numberTypeIR)), then

          1. (Let numberTypeIR' be (typeIR'''''' as numberTypeIR))

          2. Case analysis on numberTypeIR'

            1. Case (% matches pattern `INT`)

              1. The relation holds

            2. Case (% matches pattern `INT<%>`)

              1. (Let (int< w' >) be numberTypeIR')

              2. If ((_nat = w')), then

                1. The relation holds

              2. Else Phantom#683

            3. Case (% matches pattern `BIT<%>`)

              1. (Let (bit< w_b >) be numberTypeIR')

              2. The relation holds

          2. Else Phantom#684

        2. Else Phantom#685

    2. Else Phantom#686

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR''''' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR_a) be aliasTypeIR)

      2. If ((Sub_impl: typeIR_a <: typeIR'''''' holds)), then

        1. The relation holds

      2. Else Phantom#687

    2. Else Phantom#688

  4. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR''''' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum _tid # typeIR''''' { _valueFieldIR* }) be enumTypeIR)

      2. If ((Sub_impl: typeIR''''' <: typeIR'''''' holds)), then

        1. The relation holds

      2. Else Phantom#689

    2. Else Phantom#690

  5. Case (% has type defaultTypeIR)

    1. (Let defaultTypeIR be (typeIR''''' as defaultTypeIR))

    2. If ((defaultTypeIR matches pattern `DEFAULT`)), then

      1. If ($is_defaultable_typeIR(typeIR'''''')), then

        1. The relation holds

      1. Else Phantom#691

    2. Else Phantom#692

  6. Case (% has type invalidHeaderTypeIR)

    1. (Let invalidHeaderTypeIR be (typeIR''''' as invalidHeaderTypeIR))

    2. If ((invalidHeaderTypeIR matches pattern `HEADER_INVALID`)), then

      1. Case analysis on typeIR''''''

        1. Case (% has type headerTypeIR)

          1. (Let (header _tid { _fieldTypeIR* }) be (typeIR'''''' as headerTypeIR))

          2. The relation holds

        2. Case (% has type headerUnionTypeIR)

          1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR'''''' as headerUnionTypeIR))

          2. The relation holds

      1. Else Phantom#693

    2. Else Phantom#694

  7. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR''''' as sequenceTypeIR))

    2. Case analysis on sequenceTypeIR

      1. Case (% matches pattern `SEQ<%>`)

        1. (Let (seq< typeIR'''''* >) be sequenceTypeIR)

        2. Case analysis on typeIR''''''

          1. Case (% has type listTypeIR)

            1. (Let (list< typeIR'''''' >) be (typeIR'''''' as listTypeIR))

            2. If ((Sub_expl: typeIR''''' <: typeIR'''''' holds))*, then

              1. The relation holds

            2. Else Phantom#695

          2. Case (% has type tupleTypeIR)

            1. (Let (tuple< typeIR''''''* >) be (typeIR'''''' as tupleTypeIR))

            2. If ((Sub_expl: typeIR''''' <: typeIR'''''' holds))*, then

              1. The relation holds

            2. Else Phantom#696

          3. Case (% has type headerStackTypeIR)

            1. (Let (typeIR'''''' [ n_size ]) be (typeIR'''''' as headerStackTypeIR))

            2. If ((|typeIR'''''*| <= n_size)), then

              1. If ((Sub_expl: typeIR''''' <: typeIR'''''' holds))*, then

                1. The relation holds

              1. Else Phantom#697

            2. Else Phantom#698

          4. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR'''''' _id ;)* }) be (typeIR'''''' as structTypeIR))

            2. If ((Sub_expl: typeIR''''' <: typeIR'''''' holds))*, then

              1. The relation holds

            2. Else Phantom#699

          5. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR'''''' _id ;)* }) be (typeIR'''''' as headerTypeIR))

            2. If ((Sub_expl: typeIR''''' <: typeIR'''''' holds))*, then

              1. The relation holds

            2. Else Phantom#700

        2. Else Phantom#701

      2. Case (% matches pattern `SEQ<%,...>`)

        1. (Let (seq< typeIR'''''* ,...>) be sequenceTypeIR)

        2. Case analysis on typeIR''''''

          1. Case (% has type tupleTypeIR)

            1. (Let (tuple< typeIR''''''* >) be (typeIR'''''' as tupleTypeIR))

            2. If ((|typeIR'''''*| < |typeIR''''''*|)), then

              1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR''''''*, |typeIR'''''*|))

              2. If ((Sub_expl: typeIR''''' <: typeIR_b_non_default holds))*, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                  1. The relation holds

                1. Else Phantom#702

              2. Else Phantom#703

            2. Else Phantom#704

          2. Case (% has type headerStackTypeIR)

            1. (Let (typeIR'''''' [ n_size ]) be (typeIR'''''' as headerStackTypeIR))

            2. If ((|typeIR'''''*| < n_size)), then

              1. If ((Sub_expl: typeIR''''' <: typeIR'''''' holds))*, then

                1. If ($is_defaultable_typeIR(typeIR'''''')), then

                  1. The relation holds

                1. Else Phantom#705

              1. Else Phantom#706

            2. Else Phantom#707

          3. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR'''''' _id ;)* }) be (typeIR'''''' as structTypeIR))

            2. If ((|typeIR'''''*| < |typeIR''''''*|)), then

              1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR''''''*, |typeIR'''''*|))

              2. If ((Sub_expl: typeIR''''' <: typeIR_b_non_default holds))*, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                  1. The relation holds

                1. Else Phantom#708

              2. Else Phantom#709

            2. Else Phantom#710

          4. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR'''''' _id ;)* }) be (typeIR'''''' as headerTypeIR))

            2. If ((|typeIR'''''*| < |typeIR''''''*|)), then

              1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR''''''*, |typeIR'''''*|))

              2. If ((Sub_expl: typeIR''''' <: typeIR_b_non_default holds))*, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                  1. The relation holds

                1. Else Phantom#711

              2. Else Phantom#712

            2. Else Phantom#713

        2. Else Phantom#714

  8. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR''''' as recordTypeIR))

    2. Case analysis on recordTypeIR

      1. Case (% matches pattern `RECORD{%}`)

        1. (Let (record{ (typeIR''''' id_a ;)* }) be recordTypeIR)

        2. Case analysis on typeIR''''''

          1. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR'''''' id_b ;)* }) be (typeIR'''''' as structTypeIR))

            2. If ($eq_set<id>(({ id_a* }), ({ id_b* }))), then

              1. (Let typeIR''? be $find_map<id, typeIR>(({ (id_a : typeIR''''')* }), id_a))*

              2. If ((typeIR''? matches pattern (_)))*, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?)*

                2. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_b : typeIR'''''')* }), id_a))*

                3. If ((typeIR'''? matches pattern (_)))*, then

                  1. (Let ?(typeIR_b_aligned) be typeIR'''?)*

                  2. If ((Sub_expl: typeIR_a_aligned <: typeIR_b_aligned holds))*, then

                    1. The relation holds

                  2. Else Phantom#715

                3. Else Phantom#716

              2. Else Phantom#717

            2. Else Phantom#718

          2. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR'''''' id_b ;)* }) be (typeIR'''''' as headerTypeIR))

            2. If ($eq_set<id>(({ id_a* }), ({ id_b* }))), then

              1. (Let typeIR''? be $find_map<id, typeIR>(({ (id_a : typeIR''''')* }), id_a))*

              2. If ((typeIR''? matches pattern (_)))*, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?)*

                2. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_b : typeIR'''''')* }), id_a))*

                3. If ((typeIR'''? matches pattern (_)))*, then

                  1. (Let ?(typeIR_b_aligned) be typeIR'''?)*

                  2. If ((Sub_expl: typeIR_a_aligned <: typeIR_b_aligned holds))*, then

                    1. The relation holds

                  2. Else Phantom#719

                3. Else Phantom#720

              2. Else Phantom#721

            2. Else Phantom#722

        2. Else Phantom#723

      2. Case (% matches pattern `RECORD{%,...}`)

        1. (Let (record{ (typeIR''''' id_a ;)* ,...}) be recordTypeIR)

        2. Case analysis on typeIR''''''

          1. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR'''''' id_b ;)* }) be (typeIR'''''' as structTypeIR))

            2. If ($sub_set<id>(({ id_a* }), ({ id_b* }))), then

              1. (Let typeIR''? be $find_map<id, typeIR>(({ (id_a : typeIR''''')* }), id_a))*

              2. If ((typeIR''? matches pattern (_)))*, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?)*

                2. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_b : typeIR'''''')* }), id_a))*

                3. If ((typeIR'''? matches pattern (_)))*, then

                  1. (Let ?(typeIR_b_non_default_aligned) be typeIR'''?)*

                  2. If ((Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds))*, then

                    1. (Let ({ id_default* }) be $diff_set<id>(({ id_b* }), ({ id_a* })))

                    2. (Let typeIR''''? be $find_map<id, typeIR>(({ (id_b : typeIR'''''')* }), id_default))*

                    3. If ((typeIR''''? matches pattern (_)))*, then

                      1. (Let ?(typeIR_b_default) be typeIR''''?)*

                      2. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                        1. The relation holds

                      2. Else Phantom#724

                    3. Else Phantom#725

                  2. Else Phantom#726

                3. Else Phantom#727

              2. Else Phantom#728

            2. Else Phantom#729

          2. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR'''''' id_b ;)* }) be (typeIR'''''' as headerTypeIR))

            2. If ($sub_set<id>(({ id_a* }), ({ id_b* }))), then

              1. (Let typeIR''? be $find_map<id, typeIR>(({ (id_a : typeIR''''')* }), id_a))*

              2. If ((typeIR''? matches pattern (_)))*, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?)*

                2. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_b : typeIR'''''')* }), id_a))*

                3. If ((typeIR'''? matches pattern (_)))*, then

                  1. (Let ?(typeIR_b_non_default_aligned) be typeIR'''?)*

                  2. If ((Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds))*, then

                    1. (Let ({ id_default* }) be $diff_set<id>(({ id_b* }), ({ id_a* })))

                    2. (Let typeIR''''? be $find_map<id, typeIR>(({ (id_b : typeIR'''''')* }), id_default))*

                    3. If ((typeIR''''? matches pattern (_)))*, then

                      1. (Let ?(typeIR_b_default) be typeIR''''?)*

                      2. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                        1. The relation holds

                      2. Else Phantom#730

                    3. Else Phantom#731

                  2. Else Phantom#732

                3. Else Phantom#733

              2. Else Phantom#734

            2. Else Phantom#735

        2. Else Phantom#736

  9. Case (% has type setTypeIR)

    1. (Let (set< typeIR'''''* >) be (typeIR''''' as setTypeIR))

    2. If ((typeIR'''''* matches pattern [ _/1 ])), then

      1. (Let [typeIR'''''] be typeIR'''''*)

      2. If ((typeIR'''''' has type setTypeIR)), then

        1. (Let (set< typeIR''* >) be (typeIR'''''' as setTypeIR))

        2. If ((typeIR''* matches pattern [ _/1 ])), then

          1. (Let [typeIR''''''] be typeIR''*)

          2. If ((Sub_expl: typeIR''''' <: typeIR'''''' holds)), then

            1. The relation holds

          2. Else Phantom#737

        2. Else Phantom#738

      2. Else Phantom#739

    2. Else Phantom#740

2. Else Phantom#741

3. Case analysis on typeIR''''''

  1. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'''''' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR'''''') be aliasTypeIR)

      2. If ((Sub_impl: typeIR''''' <: typeIR'''''' holds)), then

        1. The relation holds

      2. Else Phantom#742

    2. Else Phantom#743

  2. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'''''' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum _tid # typeIR'''''' { _valueFieldIR* }) be enumTypeIR)

      2. If ((Sub_impl: typeIR''''' <: typeIR'''''' holds)), then

        1. The relation holds

      2. Else Phantom#744

    2. Else Phantom#745

  3. Case (% has type setTypeIR)

    1. (Let (set< typeIR'''''* >) be (typeIR'''''' as setTypeIR))

    2. If ((typeIR'''''* matches pattern [ _/1 ])), then

      1. (Let [typeIR''''''] be typeIR'''''*)

      2. If (~$is_set_typeIR(typeIR''''')), then

        1. If ((Sub_expl: typeIR''''' <: typeIR'''''' holds)), then

          1. The relation holds

        1. Else Phantom#746

      2. Else Phantom#747

    2. Else Phantom#748

3. Else Phantom#749

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:35:1-35:54:
relation Sub_impl: typeIR_a, typeIR_b

1. (Let typeIR_a_canon be $canon(typeIR_a))

2. (Let typeIR_b_canon be $canon(typeIR_b))

3. If ((Sub_impl_canon: typeIR_a_canon <: typeIR_b_canon holds)), then

  1. The relation holds

3. Else Phantom#750

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:36:1-36:60:
relation Sub_impl_canon: typeIR_a, typeIR_b

1. Case analysis on (Type_alpha: typeIR_a ~~ typeIR_b holds)

  1. Case true

    1. The relation holds

  2. Case false

    1. If ((Sub_impl_canon_neq: typeIR_a <: typeIR_b holds)), then

      1. The relation holds

    1. Else Phantom#751

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:37:1-37:64:
relation Sub_impl_canon_neq: typeIR, typeIR'''''

1. Case analysis on typeIR

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR as numberTypeIR))

    2. If ((numberTypeIR matches pattern `INT`)), then

      1. If ((typeIR''''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `INT<%>`)

            1. (Let (int< _nat >) be numberTypeIR')

            2. The relation holds

          2. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< _nat >) be numberTypeIR')

            2. The relation holds

        2. Else Phantom#752

      1. Else Phantom#753

    2. Else Phantom#754

  2. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum _tid # typeIR_a { _valueFieldIR* }) be enumTypeIR)

      2. If ((Sub_impl: typeIR_a <: typeIR''''' holds)), then

        1. The relation holds

      2. Else Phantom#755

    2. Else Phantom#756

  3. Case (% has type defaultTypeIR)

    1. (Let defaultTypeIR be (typeIR as defaultTypeIR))

    2. If ((defaultTypeIR matches pattern `DEFAULT`)), then

      1. If ($is_defaultable_typeIR(typeIR''''')), then

        1. The relation holds

      1. Else Phantom#757

    2. Else Phantom#758

  4. Case (% has type invalidHeaderTypeIR)

    1. (Let invalidHeaderTypeIR be (typeIR as invalidHeaderTypeIR))

    2. If ((invalidHeaderTypeIR matches pattern `HEADER_INVALID`)), then

      1. Case analysis on typeIR'''''

        1. Case (% has type headerTypeIR)

          1. (Let (header _tid { _fieldTypeIR* }) be (typeIR''''' as headerTypeIR))

          2. The relation holds

        2. Case (% has type headerUnionTypeIR)

          1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR''''' as headerUnionTypeIR))

          2. The relation holds

      1. Else Phantom#759

    2. Else Phantom#760

  5. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR as sequenceTypeIR))

    2. Case analysis on sequenceTypeIR

      1. Case (% matches pattern `SEQ<%>`)

        1. (Let (seq< typeIR_a* >) be sequenceTypeIR)

        2. Case analysis on typeIR'''''

          1. Case (% has type listTypeIR)

            1. (Let (list< typeIR''''' >) be (typeIR''''' as listTypeIR))

            2. If ((Sub_impl: typeIR_a <: typeIR''''' holds))*, then

              1. The relation holds

            2. Else Phantom#761

          2. Case (% has type tupleTypeIR)

            1. (Let (tuple< typeIR'''''* >) be (typeIR''''' as tupleTypeIR))

            2. If ((Sub_impl: typeIR_a <: typeIR''''' holds))*, then

              1. The relation holds

            2. Else Phantom#762

          3. Case (% has type headerStackTypeIR)

            1. (Let (typeIR''''' [ n_size ]) be (typeIR''''' as headerStackTypeIR))

            2. If ((|typeIR_a*| <= n_size)), then

              1. If ((Sub_impl: typeIR_a <: typeIR''''' holds))*, then

                1. The relation holds

              1. Else Phantom#763

            2. Else Phantom#764

          4. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR''''' _id ;)* }) be (typeIR''''' as structTypeIR))

            2. If ((Sub_impl: typeIR_a <: typeIR''''' holds))*, then

              1. The relation holds

            2. Else Phantom#765

          5. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR''''' _id ;)* }) be (typeIR''''' as headerTypeIR))

            2. If ((Sub_impl: typeIR_a <: typeIR''''' holds))*, then

              1. The relation holds

            2. Else Phantom#766

          6. Case (% has type sequenceTypeIR)

            1. (Let sequenceTypeIR' be (typeIR''''' as sequenceTypeIR))

            2. If ((sequenceTypeIR' matches pattern `SEQ<%>`)), then

              1. (Let (seq< typeIR'''''* >) be sequenceTypeIR')

              2. If ((Sub_impl: typeIR_a <: typeIR''''' holds))*, then

                1. The relation holds

              2. Else Phantom#767

            2. Else Phantom#768

        2. Else Phantom#769

      2. Case (% matches pattern `SEQ<%,...>`)

        1. (Let (seq< typeIR_a* ,...>) be sequenceTypeIR)

        2. Case analysis on typeIR'''''

          1. Case (% has type tupleTypeIR)

            1. (Let (tuple< typeIR'''''* >) be (typeIR''''' as tupleTypeIR))

            2. If ((|typeIR_a*| < |typeIR'''''*|)), then

              1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR'''''*, |typeIR_a*|))

              2. If ((Sub_impl: typeIR_a <: typeIR_b_non_default holds))*, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                  1. The relation holds

                1. Else Phantom#770

              2. Else Phantom#771

            2. Else Phantom#772

          2. Case (% has type headerStackTypeIR)

            1. (Let (typeIR''''' [ n_size ]) be (typeIR''''' as headerStackTypeIR))

            2. If ((|typeIR_a*| < n_size)), then

              1. If ((Sub_impl: typeIR_a <: typeIR''''' holds))*, then

                1. If ($is_defaultable_typeIR(typeIR''''')), then

                  1. The relation holds

                1. Else Phantom#773

              1. Else Phantom#774

            2. Else Phantom#775

          3. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR''''' _id ;)* }) be (typeIR''''' as structTypeIR))

            2. If ((|typeIR_a*| < |typeIR'''''*|)), then

              1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR'''''*, |typeIR_a*|))

              2. If ((Sub_impl: typeIR_a <: typeIR_b_non_default holds))*, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                  1. The relation holds

                1. Else Phantom#776

              2. Else Phantom#777

            2. Else Phantom#778

          4. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR''''' _id ;)* }) be (typeIR''''' as headerTypeIR))

            2. If ((|typeIR_a*| < |typeIR'''''*|)), then

              1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR'''''*, |typeIR_a*|))

              2. If ((Sub_impl: typeIR_a <: typeIR_b_non_default holds))*, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                  1. The relation holds

                1. Else Phantom#779

              2. Else Phantom#780

            2. Else Phantom#781

        2. Else Phantom#782

  6. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR as recordTypeIR))

    2. Case analysis on recordTypeIR

      1. Case (% matches pattern `RECORD{%}`)

        1. (Let (record{ (typeIR_a id_a ;)* }) be recordTypeIR)

        2. Case analysis on typeIR'''''

          1. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR''''' id_b ;)* }) be (typeIR''''' as structTypeIR))

            2. If ($eq_set<id>(({ id_a* }), ({ id_b* }))), then

              1. (Let typeIR''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

              2. If ((typeIR''? matches pattern (_)))*, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?)*

                2. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_b : typeIR''''')* }), id_a))*

                3. If ((typeIR'''? matches pattern (_)))*, then

                  1. (Let ?(typeIR_b_aligned) be typeIR'''?)*

                  2. If ((Sub_impl: typeIR_a_aligned <: typeIR_b_aligned holds))*, then

                    1. The relation holds

                  2. Else Phantom#783

                3. Else Phantom#784

              2. Else Phantom#785

            2. Else Phantom#786

          2. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR''''' id_b ;)* }) be (typeIR''''' as headerTypeIR))

            2. If ($eq_set<id>(({ id_a* }), ({ id_b* }))), then

              1. (Let typeIR''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

              2. If ((typeIR''? matches pattern (_)))*, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?)*

                2. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_b : typeIR''''')* }), id_a))*

                3. If ((typeIR'''? matches pattern (_)))*, then

                  1. (Let ?(typeIR_b_aligned) be typeIR'''?)*

                  2. If ((Sub_impl: typeIR_a_aligned <: typeIR_b_aligned holds))*, then

                    1. The relation holds

                  2. Else Phantom#787

                3. Else Phantom#788

              2. Else Phantom#789

            2. Else Phantom#790

        2. Else Phantom#791

      2. Case (% matches pattern `RECORD{%,...}`)

        1. (Let (record{ (typeIR_a id_a ;)* ,...}) be recordTypeIR)

        2. Case analysis on typeIR'''''

          1. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR''''' id_b ;)* }) be (typeIR''''' as structTypeIR))

            2. If ($sub_set<id>(({ id_a* }), ({ id_b* }))), then

              1. (Let typeIR''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

              2. If ((typeIR''? matches pattern (_)))*, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?)*

                2. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_b : typeIR''''')* }), id_a))*

                3. If ((typeIR'''? matches pattern (_)))*, then

                  1. (Let ?(typeIR_b_non_default_aligned) be typeIR'''?)*

                  2. If ((Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds))*, then

                    1. (Let ({ id_default* }) be $diff_set<id>(({ id_b* }), ({ id_a* })))

                    2. (Let typeIR''''? be $find_map<id, typeIR>(({ (id_b : typeIR''''')* }), id_default))*

                    3. If ((typeIR''''? matches pattern (_)))*, then

                      1. (Let ?(typeIR_b_default) be typeIR''''?)*

                      2. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                        1. The relation holds

                      2. Else Phantom#792

                    3. Else Phantom#793

                  2. Else Phantom#794

                3. Else Phantom#795

              2. Else Phantom#796

            2. Else Phantom#797

          2. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR''''' id_b ;)* }) be (typeIR''''' as headerTypeIR))

            2. If ($sub_set<id>(({ id_a* }), ({ id_b* }))), then

              1. (Let typeIR''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

              2. If ((typeIR''? matches pattern (_)))*, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?)*

                2. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_b : typeIR''''')* }), id_a))*

                3. If ((typeIR'''? matches pattern (_)))*, then

                  1. (Let ?(typeIR_b_non_default_aligned) be typeIR'''?)*

                  2. If ((Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds))*, then

                    1. (Let ({ id_default* }) be $diff_set<id>(({ id_b* }), ({ id_a* })))

                    2. (Let typeIR''''? be $find_map<id, typeIR>(({ (id_b : typeIR''''')* }), id_default))*

                    3. If ((typeIR''''? matches pattern (_)))*, then

                      1. (Let ?(typeIR_b_default) be typeIR''''?)*

                      2. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                        1. The relation holds

                      2. Else Phantom#798

                    3. Else Phantom#799

                  2. Else Phantom#800

                3. Else Phantom#801

              2. Else Phantom#802

            2. Else Phantom#803

        2. Else Phantom#804

1. Else Phantom#805

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:43:1-45:23:
relation Expr_ok: p, TC, expression'''

1. Case analysis on expression'''

  1. Case (% has type literalExpression)

    1. (Let literalExpression be (expression''' as literalExpression))

    2. Case analysis on literalExpression

      1. Case (% matches pattern `TRUE`)

        1. (Let expressionNoteIR be (( ((bool) as typeIR) (lctk) )))

        2. Result in (((true) as expressionIR) # expressionNoteIR)

      2. Case (% matches pattern `FALSE`)

        1. (Let expressionNoteIR be (( ((bool) as typeIR) (lctk) )))

        2. Result in (((false) as expressionIR) # expressionNoteIR)

    2. Else Phantom#806

  2. Case (% has type prefixedNonTypeName)

    1. (Let prefixedNonTypeName be (expression''' as prefixedNonTypeName))

    2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

    3. (Let varTypeIR? be $find_var(p, TC, prefixedNameIR))

    4. If ((varTypeIR? matches pattern (_))), then

      1. (Let ?((_direction typeIR ctk _value?)) be varTypeIR?)

      2. (Let expressionNoteIR be (( typeIR ctk )))

      3. Result in ((prefixedNameIR as expressionIR) # expressionNoteIR)

    4. Else Phantom#807

  3. Case (% has type defaultExpression)

    1. (Let defaultExpression be (expression''' as defaultExpression))

    2. If ((defaultExpression matches pattern `...`)), then

      1. (Let expressionNoteIR be (( ((default) as typeIR) (lctk) )))

      2. Result in (((...) as expressionIR) # expressionNoteIR)

    2. Else Phantom#808

  4. Case (% has type unaryExpression)

    1. (Let (unop expression''') be (expression''' as unaryExpression))

    2. Case analysis on unop

      1. Case (% matches pattern `!`)

        1. (Expr_ok: p TC |- expression''' : typedExpressionIR)

        2. (Let typedExpressionIR'? be $reduce_serenum_unary(typedExpressionIR, $compat_lnot))

        3. If ((typedExpressionIR'? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_reduced) be typedExpressionIR'?)

          2. (Let (_expressionIR # expressionNoteIR) be typedExpressionIR_reduced)

          3. Result in ((((!) typedExpressionIR_reduced) as expressionIR) # expressionNoteIR)

        3. Else Phantom#809

      2. Case (% matches pattern `~`)

        1. (Expr_ok: p TC |- expression''' : typedExpressionIR)

        2. (Let typedExpressionIR'? be $reduce_serenum_unary(typedExpressionIR, $compat_bnot))

        3. If ((typedExpressionIR'? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_reduced) be typedExpressionIR'?)

          2. (Let (_expressionIR # expressionNoteIR) be typedExpressionIR_reduced)

          3. Result in ((((~) typedExpressionIR_reduced) as expressionIR) # expressionNoteIR)

        3. Else Phantom#810

    2. Else Phantom#811

    3. If (((unop = (+)) \/ (unop = (-)))), then

      1. (Expr_ok: p TC |- expression''' : typedExpressionIR)

      2. (Let typedExpressionIR'? be $reduce_serenum_unary(typedExpressionIR, $compat_uplusminus))

      3. If ((typedExpressionIR'? matches pattern (_))), then

        1. (Let ?(typedExpressionIR_reduced) be typedExpressionIR'?)

        2. (Let (_expressionIR # expressionNoteIR) be typedExpressionIR_reduced)

        3. Result in (((unop typedExpressionIR_reduced) as expressionIR) # expressionNoteIR)

      3. Else Phantom#812

    3. Else Phantom#813

  5. Case (% has type binaryExpression)

    1. (Let (expression_l binop expression_r) be (expression''' as binaryExpression))

    2. Case analysis on binop

      1. Case (% is in [(+), (-), (*)])

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_plusminusmult))

          3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

            2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            5. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

            6. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

          3. Else Phantom#814

        4. Else Phantom#815

      2. Case (% is in [(|+|), (|-|)])

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_satplusminus))

          3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

            2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            5. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

            6. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

          3. Else Phantom#816

        4. Else Phantom#817

      3. Case (% is in [(/), (%)])

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_divmod))

          3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

            2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. Case analysis on (ctk_r_reduced matches pattern `LCTK`)

              1. Case true

                1. (Eval_static: p TC |- typedExpressionIR_r_reduced ~> value_r)

                2. (Let int be $to_number(value_r))

                3. If ((int has type nat)), then

                  1. (Let n_r be (int as nat))

                  2. If ((n_r > 0)), then

                    1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

                    2. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

                    3. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

                  2. Else Phantom#818

                3. Else Phantom#819

              2. Case false

                1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

                2. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

                3. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

          3. Else Phantom#820

        4. Else Phantom#821

      4. Case (% is in [(<<), (>>)])

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_shift))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (_expressionIR # (( typeIR_l_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

          3. (Let (_expressionIR' # (( typeIR_r_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

          4. If ($is_fixed_bit_typeIR(typeIR_r_reduced)), then

            1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            2. (Let expressionNoteIR be (( typeIR_l_reduced ctk_reduced )))

            3. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

          4. Else Phantom#822

          5. If ((ctk_r_reduced matches pattern `LCTK`)), then

            1. If (($is_arbitrary_int_typeIR(typeIR_r_reduced) \/ $is_fixed_int_typeIR(typeIR_r_reduced))), then

              1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

              2. (Let expressionNoteIR be (( typeIR_l_reduced ctk_reduced )))

              3. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

            1. Else Phantom#823

          5. Else Phantom#824

        4. Else Phantom#825

      5. Case (% is in [(==), (!=)])

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (_expressionIR # (( typeIR_cast ctk_l_cast ))) be typedExpressionIR_l_cast)

          3. (Let (_expressionIR' # (( _typeIR ctk_r_cast ))) be typedExpressionIR_r_cast)

          4. If ($is_equalable_typeIR(typeIR_cast)), then

            1. (Let ctk_cast be $join_ctk(ctk_l_cast, ctk_r_cast))

            2. (Let expressionNoteIR be (( ((bool) as typeIR) ctk_cast )))

            3. Result in (((typedExpressionIR_l_cast binop typedExpressionIR_r_cast) as expressionIR) # expressionNoteIR)

          4. Else Phantom#826

        4. Else Phantom#827

      6. Case (% is in [(<=), (>=), (<), (>)])

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_compare))

          3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

            2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            5. (Let expressionNoteIR be (( ((bool) as typeIR) ctk_reduced )))

            6. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

          3. Else Phantom#828

        4. Else Phantom#829

      7. Case (% is in [(&), (^), (|)])

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_bitwise))

          3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

            2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            5. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

            6. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

          3. Else Phantom#830

        4. Else Phantom#831

      8. Case (% is in [(&&), (||)])

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_logical))

          3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

            2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            5. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

            6. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

          3. Else Phantom#832

        4. Else Phantom#833

    2. Else Phantom#834

    3. If ((binop matches pattern `++`)), then

      1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

      2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

      3. (Let (typedExpressionIR, typedExpressionIR)? be $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_concat))

      4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)?)

        2. (Let (_expressionIR # (( typeIR_l_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

        3. (Let (_expressionIR' # (( typeIR_r_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

        4. (Let typeIR? be $result_concat(typeIR_l_reduced, typeIR_r_reduced))

        5. If ((typeIR? matches pattern (_))), then

          1. (Let ?(typeIR_reduced) be typeIR?)

          2. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

          3. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

          4. Result in (((typedExpressionIR_l_reduced (++) typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

        5. Else Phantom#835

      4. Else Phantom#836

    3. Else Phantom#837

  6. Case (% has type ternaryExpression)

    1. (Let (expression_cond ? expression_true : expression_false) be (expression''' as ternaryExpression))

    2. (Expr_ok: p TC |- expression_cond : typedExpressionIR_cond)

    3. (Let (_expressionIR # (( typeIR ctk_cond ))) be typedExpressionIR_cond)

    4. If ((typeIR has type primitiveTypeIR)), then

      1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

      2. If ((primitiveTypeIR matches pattern `BOOL`)), then

        1. (Expr_ok: p TC |- expression_true : typedExpressionIR_true)

        2. (Expr_ok: p TC |- expression_false : typedExpressionIR_false)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_true, typedExpressionIR_false))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_true_cast, typedExpressionIR_false_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (_expressionIR' # (( typeIR_cast ctk_true_cast ))) be typedExpressionIR_true_cast)

          3. (Let (_expressionIR'' # (( _typeIR ctk_false_cast ))) be typedExpressionIR_false_cast)

          4. If (($is_arbitrary_int_typeIR(typeIR_cast) => (ctk_cond =/= (dyn)))), then

            1. (Let ctk be $joins_ctk([ctk_cond, ctk_true_cast, ctk_false_cast]))

            2. (Let expressionNoteIR be (( typeIR_cast ctk )))

            3. Result in (((typedExpressionIR_cond ? typedExpressionIR_true_cast : typedExpressionIR_false_cast) as expressionIR) # expressionNoteIR)

          4. Else Phantom#838

        4. Else Phantom#839

      2. Else Phantom#840

    4. Else Phantom#841

  7. Case (% has type castExpression)

    1. (Let (( type_t ) expression''') be (expression''' as castExpression))

    2. (Type_ok: p TC |- (type_t as typeOrVoid) : typeIR_t # tid*)

    3. If ((tid* matches pattern [])), then

      1. If ((Type_wf: $bound(p, TC) |- typeIR_t holds)), then

        1. (Expr_ok: p TC |- expression''' : typedExpressionIR)

        2. (Let (_expressionIR # (( typeIR ctk ))) be typedExpressionIR)

        3. If ((Sub_expl: typeIR <: typeIR_t holds)), then

          1. (Let expressionNoteIR be (( typeIR_t ctk )))

          2. Result in (((( typeIR_t ) typedExpressionIR) as expressionIR) # expressionNoteIR)

        3. Else Phantom#842

      1. Else Phantom#843

    3. Else Phantom#844

  8. Case (% has type dataExpression)

    1. (Let dataExpression be (expression''' as dataExpression))

    2. Case analysis on dataExpression

      1. Case (% matches pattern `{#}`)

        1. (Let expressionNoteIR be (( ((header_invalid) as typeIR) (lctk) )))

        2. Result in ((({#}) as expressionIR) # expressionNoteIR)

      2. Case (% matches pattern `{%%}`)

        1. (Let ({ dataElementExpression _trailingCommaOpt }) be dataExpression)

        2. Case analysis on dataElementExpression

          1. Case (% has type expressionList)

            1. (Let expressionList be (dataElementExpression as expressionList))

            2. (Let expression_e* be $flatten_expressionList(expressionList))

            3. Case analysis on ((...) as expression) is in expression_e*

              1. Case false

                1. If ((expression_e* = $flatten_expressionList(expressionList))), then

                  1. (Expr_ok: p TC |- expression_e : typedExpressionIR_e)*

                  2. (Let (_expressionIR # (( typeIR_e ctk_e ))) be typedExpressionIR_e)*

                  3. (Let typeIR be ((seq< typeIR_e* >) as typeIR))

                  4. (Let ctk be $joins_ctk(ctk_e*))

                  5. (Let expressionNoteIR be (( typeIR ctk )))

                  6. Result in (((seq{ typedExpressionIR_e* }) as expressionIR) # expressionNoteIR)

                1. Else Phantom#845

              2. Case true

                1. (Let expression''* be $rev_<expression>(expression_e*))

                2. If ((expression''* matches pattern _ :: _)), then

                  1. (Let expression''' :: expression_e_h_rev* be expression''*)

                  2. If ((expression''' has type defaultExpression)), then

                    1. (Let defaultExpression be (expression''' as defaultExpression))

                    2. If ((defaultExpression matches pattern `...`)), then

                      1. (Let expression_e_h* be $rev_<expression>(expression_e_h_rev*))

                      2. If (~((...) as expression) is in expression_e_h*), then

                        1. (Expr_ok: p TC |- expression_e_h : typedExpressionIR_e_h)*

                        2. (Let (_expressionIR # (( typeIR_e_h ctk_e_h ))) be typedExpressionIR_e_h)*

                        3. (Let typeIR be ((seq< typeIR_e_h* ,...>) as typeIR))

                        4. (Let ctk be $joins_ctk(ctk_e_h*))

                        5. (Let expressionNoteIR be (( typeIR ctk )))

                        6. Result in (((seq{ typedExpressionIR_e_h* ,...}) as expressionIR) # expressionNoteIR)

                      2. Else Phantom#846

                    2. Else Phantom#847

                  2. Else Phantom#848

                2. Else Phantom#849

          2. Case (% has type recordElementExpression)

            1. (Let recordElementExpression be (dataElementExpression as recordElementExpression))

            2. Case analysis on recordElementExpression

              1. Case (% matches pattern `%=%`)

                1. (Let (name_f = expression_f) be recordElementExpression)

                2. (Let nameIR_f be $name(name_f))

                3. (Expr_ok: p TC |- expression_f : typedExpressionIR_f)

                4. (Let (_expressionIR # (( typeIR_f ctk_f ))) be typedExpressionIR_f)

                5. (Let typeIR be ((record{ [(typeIR_f nameIR_f ;)] }) as typeIR))

                6. (Let expressionNoteIR be (( typeIR ctk_f )))

                7. Result in (((record{ [(nameIR_f = typedExpressionIR_f)] }) as expressionIR) # expressionNoteIR)

              2. Case (% matches pattern `%=%,...`)

                1. (Let (name_f = expression_f ,...) be recordElementExpression)

                2. (Let nameIR_f be $name(name_f))

                3. (Expr_ok: p TC |- expression_f : typedExpressionIR_f)

                4. (Let (_expressionIR # (( typeIR_f ctk_f ))) be typedExpressionIR_f)

                5. (Let typeIR be ((record{ [(typeIR_f nameIR_f ;)] ,...}) as typeIR))

                6. (Let expressionNoteIR be (( typeIR ctk_f )))

                7. Result in (((record{ [(nameIR_f = typedExpressionIR_f)] ,...}) as expressionIR) # expressionNoteIR)

              3. Case (% matches pattern `%=%,%`)

                1. (Let (name_f_h = expression_f_h , namedExpressionList_t) be recordElementExpression)

                2. (Let (name_f_t = expression_f_t)* be $flatten_namedExpressionList(namedExpressionList_t))

                3. (Let name_f* be name_f_h :: name_f_t*)

                4. (Let nameIR_f be $name(name_f))*

                5. (Let expression_f* be expression_f_h :: expression_f_t*)

                6. (Expr_ok: p TC |- expression_f : typedExpressionIR_f)*

                7. (Let (_expressionIR # (( typeIR_f ctk_f ))) be typedExpressionIR_f)*

                8. (Let typeIR be ((record{ (typeIR_f nameIR_f ;)* }) as typeIR))

                9. (Let ctk be $joins_ctk(ctk_f*))

                10. (Let expressionNoteIR be (( typeIR ctk )))

                11. Result in (((record{ (nameIR_f = typedExpressionIR_f)* }) as expressionIR) # expressionNoteIR)

              4. Case (% matches pattern `%=%,%,...`)

                1. (Let (name_f_h = expression_f_h , namedExpressionList_t ,...) be recordElementExpression)

                2. (Let (name_f_t = expression_f_t)* be $flatten_namedExpressionList(namedExpressionList_t))

                3. (Let name_f* be name_f_h :: name_f_t*)

                4. (Let nameIR_f be $name(name_f))*

                5. (Let expression_f* be expression_f_h :: expression_f_t*)

                6. (Expr_ok: p TC |- expression_f : typedExpressionIR_f)*

                7. (Let (_expressionIR # (( typeIR_f ctk_f ))) be typedExpressionIR_f)*

                8. (Let typeIR be ((record{ (typeIR_f nameIR_f ;)* ,...}) as typeIR))

                9. (Let ctk be $joins_ctk(ctk_f*))

                10. (Let expressionNoteIR be (( typeIR ctk )))

                11. Result in (((record{ (nameIR_f = typedExpressionIR_f)* ,...}) as expressionIR) # expressionNoteIR)

  9. Case (% has type errorAccessExpression)

    1. (Let (error. member) be (expression''' as errorAccessExpression))

    2. (Let nameIR be $name(member))

    3. (Let nameIR_error be "error." ++ nameIR)

    4. If ((((error. nameIR) as value) = $find_value(p, TC, (` nameIR_error)))), then

      1. (Let expressionNoteIR be (( ((error) as typeIR) (lctk) )))

      2. Result in (((error. nameIR) as expressionIR) # expressionNoteIR)

    4. Else Phantom#850

  10. Case (% has type memberAccessExpression)

    1. (Let (memberAccessBase . member) be (expression''' as memberAccessExpression))

    2. Case analysis on memberAccessBase

      1. Case (% has type prefixedTypeName)

        1. (Let prefixedTypeName_base be (memberAccessBase as prefixedTypeName))

        2. (Let prefixedNameIR_base be $prefixedTypeName(prefixedTypeName_base))

        3. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR_base))

        4. If ((typeDefIR'? matches pattern (_))), then

          1. (Let ?(typeDefIR) be typeDefIR'?)

          2. If ((typeDefIR has type typeIR)), then

            1. (Let typeIR_base be (typeDefIR as typeIR))

            2. (Let typeIR be $canon(typeIR_base))

            3. If ((typeIR has type enumTypeIR)), then

              1. (Let enumTypeIR be (typeIR as enumTypeIR))

              2. Case analysis on enumTypeIR

                1. Case (% matches pattern `ENUM%{%}`)

                  1. (Let (enum _tid { nameIR_f* }) be enumTypeIR)

                  2. (Let nameIR be $name(member))

                  3. If (nameIR is in nameIR_f*), then

                    1. (Let expressionNoteIR be (( typeIR_base (lctk) )))

                    2. Result in ((((type prefixedNameIR_base) . nameIR) as expressionIR) # expressionNoteIR)

                  3. Else Phantom#851

                2. Case (% matches pattern `ENUM%#%{%}`)

                  1. (Let (enum _tid # _typeIR { (nameIR_f = _value ;)* }) be enumTypeIR)

                  2. (Let nameIR be $name(member))

                  3. If (nameIR is in nameIR_f*), then

                    1. (Let expressionNoteIR be (( typeIR_base (lctk) )))

                    2. Result in ((((type prefixedNameIR_base) . nameIR) as expressionIR) # expressionNoteIR)

                  3. Else Phantom#852

            3. Else Phantom#853

          2. Else Phantom#854

        4. Else Phantom#855

      2. Case (% has type expression)

        1. (Let expression_base be (memberAccessBase as expression))

        2. If (("size" = $name(member))), then

          1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

          2. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

          3. (Let typeIR' be $canon(typeIR_base))

          4. If ((typeIR' has type headerStackTypeIR)), then

            1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

            2. (Let expressionNoteIR be (( ((bit< 32 >) as typeIR) (lctk) )))

            3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . "size") as expressionIR) # expressionNoteIR)

          4. Else Phantom#856

        2. Else Phantom#857

        3. If (("lastIndex" = $name(member))), then

          1. If ((((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind)))), then

            1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

            2. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

            3. (Let typeIR' be $canon(typeIR_base))

            4. If ((typeIR' has type headerStackTypeIR)), then

              1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

              2. (Let expressionNoteIR be (( ((bit< 32 >) as typeIR) (dyn) )))

              3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . "lastIndex") as expressionIR) # expressionNoteIR)

            4. Else Phantom#858

          1. Else Phantom#859

        3. Else Phantom#860

        4. If (("last" = $name(member))), then

          1. If ((((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind)))), then

            1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

            2. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

            3. (Let typeIR' be $canon(typeIR_base))

            4. If ((typeIR' has type headerStackTypeIR)), then

              1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

              2. (Let expressionNoteIR be (( typeIR (dyn) )))

              3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . "last") as expressionIR) # expressionNoteIR)

            4. Else Phantom#861

          1. Else Phantom#862

        4. Else Phantom#863

        5. If (("next" = $name(member))), then

          1. If ((((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind)))), then

            1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

            2. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

            3. (Let typeIR' be $canon(typeIR_base))

            4. If ((typeIR' has type headerStackTypeIR)), then

              1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

              2. (Let expressionNoteIR be (( typeIR (dyn) )))

              3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . "next") as expressionIR) # expressionNoteIR)

            4. Else Phantom#864

          1. Else Phantom#865

        5. Else Phantom#866

        6. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

        7. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

        8. (Let typeIR' be $canon(typeIR_base))

        9. Case analysis on typeIR'

          1. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as structTypeIR))

            2. (Let nameIR be $name(member))

            3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

            4. If ((typeIR''? matches pattern (_))), then

              1. (Let ?(typeIR) be typeIR''?)

              2. (Let expressionNoteIR be (( typeIR (dyn) )))

              3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . nameIR) as expressionIR) # expressionNoteIR)

            4. Else Phantom#867

          2. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as headerTypeIR))

            2. (Let nameIR be $name(member))

            3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

            4. If ((typeIR''? matches pattern (_))), then

              1. (Let ?(typeIR) be typeIR''?)

              2. (Let expressionNoteIR be (( typeIR (dyn) )))

              3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . nameIR) as expressionIR) # expressionNoteIR)

            4. Else Phantom#868

          3. Case (% has type headerUnionTypeIR)

            1. (Let (header_union _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as headerUnionTypeIR))

            2. (Let nameIR be $name(member))

            3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

            4. If ((typeIR''? matches pattern (_))), then

              1. (Let ?(typeIR) be typeIR''?)

              2. (Let expressionNoteIR be (( typeIR (dyn) )))

              3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . nameIR) as expressionIR) # expressionNoteIR)

            4. Else Phantom#869

          4. Case (% has type tableTypeIR)

            1. (Let tableTypeIR be (typeIR' as tableTypeIR))

            2. If ((tableTypeIR matches pattern `TABLE_STRUCT%{%}`)), then

              1. (Let (table_struct _tid { (typeIR_f nameIR_f ;)* }) be tableTypeIR)

              2. (Let nameIR be $name(member))

              3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

              4. If ((typeIR''? matches pattern (_))), then

                1. (Let ?(typeIR) be typeIR''?)

                2. (Let expressionNoteIR be (( typeIR (dyn) )))

                3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . nameIR) as expressionIR) # expressionNoteIR)

              4. Else Phantom#870

            2. Else Phantom#871

        9. Else Phantom#872

  11. Case (% has type indexAccessExpression)

    1. (Let indexAccessExpression be (expression''' as indexAccessExpression))

    2. Case analysis on indexAccessExpression

      1. Case (% matches pattern `%[%]`)

        1. (Let (expression_base [ expression_index ]) be indexAccessExpression)

        2. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

        3. (Expr_ok: p TC |- expression_index : typedExpressionIR_index)

        4. (Let (_expressionIR # (( typeIR_base ctk_base ))) be typedExpressionIR_base)

        5. (Let (_expressionIR' # (( typeIR_index ctk_index ))) be typedExpressionIR_index)

        6. (Let typedExpressionIR? be $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index))

        7. If ((typedExpressionIR? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_index_reduced) be typedExpressionIR?)

          2. (Let typeIR be $canon(typeIR_base))

          3. Case analysis on typeIR

            1. Case (% has type tupleTypeIR)

              1. (Let (tuple< typeIR_e* >) be (typeIR as tupleTypeIR))

              2. If ((ctk_index matches pattern `LCTK`)), then

                1. (Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index)

                2. (Let int be $to_number(value_index))

                3. If ((int has type nat)), then

                  1. (Let n_index be (int as nat))

                  2. If ((n_index < |typeIR_e*|)), then

                    1. (Let expressionNoteIR be (( typeIR_e*[n_index] (dyn) )))

                    2. Result in (((typedExpressionIR_base [ typedExpressionIR_index_reduced ]) as expressionIR) # expressionNoteIR)

                  2. Else Phantom#873

                3. Else Phantom#874

              2. Else Phantom#875

            2. Case (% has type headerStackTypeIR)

              1. (Let (typeIR [ n_size ]) be (typeIR as headerStackTypeIR))

              2. Case analysis on (ctk_index matches pattern `LCTK`)

                1. Case true

                  1. (Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index)

                  2. (Let int be $to_number(value_index))

                  3. If ((int has type nat)), then

                    1. (Let n_index be (int as nat))

                    2. If ((n_index < n_size)), then

                      1. (Let expressionNoteIR be (( typeIR (dyn) )))

                      2. Result in (((typedExpressionIR_base [ typedExpressionIR_index_reduced ]) as expressionIR) # expressionNoteIR)

                    2. Else Phantom#876

                  3. Else Phantom#877

                2. Case false

                  1. (Let expressionNoteIR be (( typeIR (dyn) )))

                  2. Result in (((typedExpressionIR_base [ typedExpressionIR_index_reduced ]) as expressionIR) # expressionNoteIR)

          3. Else Phantom#878

        7. Else Phantom#879

      2. Case (% matches pattern `%[%:%]`)

        1. (Let (expression_base [ expression_hi : expression_lo ]) be indexAccessExpression)

        2. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

        3. (Expr_ok: p TC |- expression_hi : typedExpressionIR_hi)

        4. (Expr_ok: p TC |- expression_lo : typedExpressionIR_lo)

        5. (Let typedExpressionIR? be $reduce_serenum_unary(typedExpressionIR_base, $compat_bitslice_base))

        6. If ((typedExpressionIR? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_base_reduced) be typedExpressionIR?)

          2. (Let (_expressionIR # (( typeIR_base_reduced ctk_base_reduced ))) be typedExpressionIR_base_reduced)

          3. (Let typedExpressionIR'? be $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index))

          4. If ((typedExpressionIR'? matches pattern (_))), then

            1. (Let ?(typedExpressionIR_hi_reduced) be typedExpressionIR'?)

            2. (Let typedExpressionIR''? be $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index))

            3. If ((typedExpressionIR''? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_lo_reduced) be typedExpressionIR''?)

              2. (Let (_expressionIR' # (( typeIR_hi_reduced ctk_hi_reduced ))) be typedExpressionIR_hi_reduced)

              3. (Let (_expressionIR'' # (( typeIR_lo_reduced ctk_lo_reduced ))) be typedExpressionIR_lo_reduced)

              4. If ((ctk_hi_reduced matches pattern `LCTK`)), then

                1. (Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi)

                2. (Let int be $to_number(value_hi))

                3. If ((int has type nat)), then

                  1. (Let n_hi be (int as nat))

                  2. If ((ctk_lo_reduced matches pattern `LCTK`)), then

                    1. (Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo)

                    2. (Let int' be $to_number(value_lo))

                    3. If ((int' has type nat)), then

                      1. (Let n_lo be (int' as nat))

                      2. If ($is_valid_bitslice(typeIR_base_reduced, n_lo, n_hi)), then

                        1. (Let typeIR be ((bit< ((n_hi - n_lo) + 1) >) as typeIR))

                        2. (Let expressionNoteIR be (( typeIR ctk_base_reduced )))

                        3. Result in (((typedExpressionIR_base [ typedExpressionIR_hi_reduced : typedExpressionIR_lo_reduced ]) as expressionIR) # expressionNoteIR)

                      2. Else Phantom#880

                    3. Else Phantom#881

                  2. Else Phantom#882

                3. Else Phantom#883

              4. Else Phantom#884

            3. Else Phantom#885

          4. Else Phantom#886

        6. Else Phantom#887

  12. Case (% has type callExpression)

    1. (Let callExpression be (expression''' as callExpression))

    2. Case analysis on callExpression

      1. Case (% matches pattern `%(%)`)

        1. (Let (callTarget ( argumentList )) be callExpression)

        2. Case analysis on callTarget

          1. Case (% has type routineTarget)

            1. (Let routineTarget be (callTarget as routineTarget))

            2. (RoutineTarget_ok: p TC |- routineTarget : routineTargetIR)

            3. (Let argument* be $flatten_argumentList(argumentList))

            4. (Argument_ok: p TC |- argument : argumentIR)*

            5. (RoutineType_ok: p TC |- routineTargetIR < [] >( argumentIR* ): routineTypeIR <# tid_inserted* >(# id_default* ))

            6. (Let tid_infer* be tid_inserted*)

            7. (Call_ok: p TC |- routineTypeIR < [] # tid_infer* >( argumentIR* # id_default* ): typeIR_ret < typeArgumentIR_inferred* >( argumentIR_cast* ))

            8. If ((typeIR_ret =/= ((void) as typeIR))), then

              1. (Let ctk be $is_static_routineTarget(routineTargetIR))

              2. (Let callExpressionIR be (routineTargetIR < typeArgumentIR_inferred* >( argumentIR_cast* )))

              3. (Let expressionNoteIR be (( typeIR_ret ctk )))

              4. Result in ((callExpressionIR as expressionIR) # expressionNoteIR)

            8. Else Phantom#888

          2. Case (% has type prefixedTypeName)

            1. (Let prefixedTypeName be (callTarget as prefixedTypeName))

            2. (Let argument* be $flatten_argumentList(argumentList))

            3. (Argument_ok: p TC |- argument : argumentIR)*

            4. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

            5. (ConstructorType_ok: p TC |- prefixedNameIR < [] >( argumentIR* ): constructorTypeIR <# tid_impl* >(# id_default* ))

            6. (Inst_ok: p TC (anon) |- constructorTypeIR < [] # tid_impl* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

            7. If ($is_concrete_extern_object(typeIR_object)), then

              1. (Let callExpressionIR be ((prefixedNameIR < typeArgumentIR_inferred* >) ( argumentIR_cast* )))

              2. (Let expressionNoteIR be (( typeIR_object (ctk) )))

              3. Result in ((callExpressionIR as expressionIR) # expressionNoteIR)

            7. Else Phantom#889

          3. Case (% has type specializedType)

            1. (Let (prefixedTypeName < typeArgumentList >) be (callTarget as specializedType))

            2. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

            3. (TypeArguments_ok: p TC |- typeArgument* : typeArgumentIR* # tid_impl*)

            4. (Let argument* be $flatten_argumentList(argumentList))

            5. (Argument_ok: p TC |- argument : argumentIR)*

            6. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

            7. (ConstructorType_ok: p TC |- prefixedNameIR < typeArgumentIR* >( argumentIR* ): constructorTypeIR <# tid_inserted* >(# id_default* ))

            8. (Let tid_infer* be tid_impl* ++ tid_inserted*)

            9. (Inst_ok: p TC (anon) |- constructorTypeIR < typeArgumentIR* # tid_infer* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

            10. If ($is_concrete_extern_object(typeIR_object)), then

              1. (Let callExpressionIR be ((prefixedNameIR < typeArgumentIR_inferred* >) ( argumentIR_cast* )))

              2. (Let expressionNoteIR be (( typeIR_object (ctk) )))

              3. Result in ((callExpressionIR as expressionIR) # expressionNoteIR)

            10. Else Phantom#890

      2. Case (% matches pattern `%<%>(%)`)

        1. (Let (routineTarget < realTypeArgumentList >( argumentList )) be callExpression)

        2. (RoutineTarget_ok: p TC |- routineTarget : routineTargetIR)

        3. (Let realTypeArgument* be $flatten_realTypeArgumentList(realTypeArgumentList))

        4. (TypeArguments_ok: p TC |- (realTypeArgument* as typeArgument*) : typeArgumentIR* # tid_impl*)

        5. (Let argument* be $flatten_argumentList(argumentList))

        6. (Argument_ok: p TC |- argument : argumentIR)*

        7. (RoutineType_ok: p TC |- routineTargetIR < typeArgumentIR* >( argumentIR* ): routineTypeIR <# tid_inserted* >(# id_default* ))

        8. (Let tid_infer* be tid_impl* ++ tid_inserted*)

        9. (Call_ok: p TC |- routineTypeIR < typeArgumentIR* # tid_infer* >( argumentIR* # id_default* ): typeIR_ret < typeArgumentIR_inferred* >( argumentIR_cast* ))

        10. If ((typeIR_ret =/= ((void) as typeIR))), then

          1. (Let ctk be $is_static_routineTarget(routineTargetIR))

          2. (Let callExpressionIR be (routineTargetIR < typeArgumentIR_inferred* >( argumentIR_cast* )))

          3. (Let expressionNoteIR be (( typeIR_ret ctk )))

          4. Result in ((callExpressionIR as expressionIR) # expressionNoteIR)

        10. Else Phantom#891

  13. Case (% has type parenthesizedExpression)

    1. (Let (( expression''' )) be (expression''' as parenthesizedExpression))

    2. (Expr_ok: p TC |- expression''' : typedExpressionIR)

    3. (Let (_expressionIR # expressionNoteIR) be typedExpressionIR)

    4. Result in (((( typedExpressionIR )) as expressionIR) # expressionNoteIR)

1. Else Phantom#892

2. Case analysis on expression'''

  1. Case (% has type number)

    1. (Let number be (expression''' as number))

    2. Case analysis on number

      1. Case (% matches pattern `D%`)

        1. (Let (d i) be number)

        2. (Let expressionNoteIR be (( ((int) as typeIR) (lctk) )))

        3. Result in (((d i) as expressionIR) # expressionNoteIR)

      2. Case (% matches pattern `%S%`)

        1. (Let (n s i) be number)

        2. (Let expressionNoteIR be (( ((int< n >) as typeIR) (lctk) )))

        3. Result in (((n s i) as expressionIR) # expressionNoteIR)

      3. Case (% matches pattern `%W%`)

        1. (Let (n w i) be number)

        2. (Let expressionNoteIR be (( ((bit< n >) as typeIR) (lctk) )))

        3. Result in (((n w i) as expressionIR) # expressionNoteIR)

  2. Case (% has type stringLiteral)

    1. (Let (" text ") be (expression''' as stringLiteral))

    2. (Let expressionNoteIR be (( ((string) as typeIR) (lctk) )))

    3. Result in (((" text ") as expressionIR) # expressionNoteIR)

  3. Case (% has type referenceExpression)

    1. (Let referenceExpression be (expression''' as referenceExpression))

    2. If ((referenceExpression matches pattern `THIS`)), then

      1. (Let prefixedNameIR be (` "this"))

      2. (Let varTypeIR? be $find_var(p, TC, prefixedNameIR))

      3. If ((varTypeIR? matches pattern (_))), then

        1. (Let ?((_direction typeIR ctk _value?)) be varTypeIR?)

        2. (Let expressionNoteIR be (( typeIR ctk )))

        3. Result in ((prefixedNameIR as expressionIR) # expressionNoteIR)

      3. Else Phantom#893

    2. Else Phantom#894

2. Else Phantom#895

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:51:1-53:23:
relation Argument_ok: p, TC, argument

1. If ((argument has type expression)), then

  1. (Let expression be (argument as expression))

  2. (Expr_ok: p TC |- expression : typedExpressionIR)

  3. Result in (typedExpressionIR as argumentIR)

1. Else Phantom#896

2. Case analysis on argument

  1. Case (% matches pattern `%=%`)

    1. (Let (name = expression) be argument)

    2. (Let nameIR be $name(name))

    3. (Expr_ok: p TC |- expression : typedExpressionIR)

    4. Result in (nameIR = typedExpressionIR)

  2. Case (% matches pattern `%=_`)

    1. (Let (name =_) be argument)

    2. (Let nameIR be $name(name))

    3. Result in (nameIR =_)

  3. Case (% matches pattern `_`)

    1. Result in (_)

2. Else Phantom#897

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:59:1-61:23:
relation Lvalue_ok: p, TC, lvalue

1. If ((lvalue has type prefixedNonTypeName)), then

  1. (Let prefixedNonTypeName be (lvalue as prefixedNonTypeName))

  2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

  3. (Let varTypeIR? be $find_var(p, TC, prefixedNameIR))

  4. If ((varTypeIR? matches pattern (_))), then

    1. (Let ?((direction typeIR ctk value?)) be varTypeIR?)

    2. If ((ctk matches pattern `DYN`)), then

      1. If ((value? matches pattern ())), then

        1. If (((direction = (out)) \/ (direction = (inout)))), then

          1. Result in ((prefixedNameIR as lvalueIR) #( typeIR ))

        1. Else Phantom#898

      1. Else Phantom#899

    2. Else Phantom#900

  4. Else Phantom#901

1. Else Phantom#902

2. Case analysis on lvalue

  1. Case (% matches pattern `%.%`)

    1. (Let (lvalue_base . member) be lvalue)

    2. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

    3. (Let (_lvalueIR #( typeIR_base )) be typedLvalueIR_base)

    4. (Let typeIR' be $canon(typeIR_base))

    5. Case analysis on typeIR'

      1. Case (% has type headerStackTypeIR)

        1. (Let (typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

        2. (Let nameIR be $name(member))

        3. If (((nameIR = "next") \/ (nameIR = "last"))), then

          1. If ((((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind)))), then

            1. (Let typedLvalueIR be ((typedLvalueIR_base . nameIR) #( typeIR )))

            2. Result in typedLvalueIR

          1. Else Phantom#903

        3. Else Phantom#904

      2. Case (% has type structTypeIR)

        1. (Let (struct _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as structTypeIR))

        2. (Let nameIR be $name(member))

        3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

        4. If ((typeIR''? matches pattern (_))), then

          1. (Let ?(typeIR) be typeIR''?)

          2. (Let typedLvalueIR be ((typedLvalueIR_base . nameIR) #( typeIR )))

          3. Result in typedLvalueIR

        4. Else Phantom#905

      3. Case (% has type headerTypeIR)

        1. (Let (header _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as headerTypeIR))

        2. (Let nameIR be $name(member))

        3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

        4. If ((typeIR''? matches pattern (_))), then

          1. (Let ?(typeIR) be typeIR''?)

          2. (Let typedLvalueIR be ((typedLvalueIR_base . nameIR) #( typeIR )))

          3. Result in typedLvalueIR

        4. Else Phantom#906

      4. Case (% has type headerUnionTypeIR)

        1. (Let (header_union _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as headerUnionTypeIR))

        2. (Let nameIR be $name(member))

        3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

        4. If ((typeIR''? matches pattern (_))), then

          1. (Let ?(typeIR) be typeIR''?)

          2. (Let typedLvalueIR be ((typedLvalueIR_base . nameIR) #( typeIR )))

          3. Result in typedLvalueIR

        4. Else Phantom#907

    5. Else Phantom#908

  2. Case (% matches pattern `%[%]`)

    1. (Let (lvalue_base [ expression_index ]) be lvalue)

    2. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

    3. (Let (_lvalueIR #( typeIR_base )) be typedLvalueIR_base)

    4. (Let typeIR' be $canon(typeIR_base))

    5. If ((typeIR' has type headerStackTypeIR)), then

      1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

      2. (Expr_ok: p TC |- expression_index : typedExpressionIR_index)

      3. (Let (_expressionIR # (( typeIR_index ctk_index ))) be typedExpressionIR_index)

      4. (Let typedExpressionIR? be $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index))

      5. If ((typedExpressionIR? matches pattern (_))), then

        1. (Let ?(typedExpressionIR_index_reduced) be typedExpressionIR?)

        2. Case analysis on (ctk_index matches pattern `LCTK`)

          1. Case true

            1. (Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index)

            2. (Let int be $to_number(value_index))

            3. If ((int has type nat)), then

              1. (Let n_index be (int as nat))

              2. If ((n_index < n_size)), then

                1. (Let typedLvalueIR be ((typedLvalueIR_base [ typedExpressionIR_index_reduced ]) #( typeIR )))

                2. Result in typedLvalueIR

              2. Else Phantom#909

            3. Else Phantom#910

          2. Case false

            1. (Let typedLvalueIR be ((typedLvalueIR_base [ typedExpressionIR_index_reduced ]) #( typeIR )))

            2. Result in typedLvalueIR

      5. Else Phantom#911

    5. Else Phantom#912

  3. Case (% matches pattern `%[%:%]`)

    1. (Let (lvalue_base [ expression_hi : expression_lo ]) be lvalue)

    2. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

    3. (Let (_lvalueIR #( typeIR_base )) be typedLvalueIR_base)

    4. If ($compat_bitslice_base(typeIR_base)), then

      1. (Expr_ok: p TC |- expression_hi : typedExpressionIR_hi)

      2. (Expr_ok: p TC |- expression_lo : typedExpressionIR_lo)

      3. (Let typedExpressionIR? be $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index))

      4. If ((typedExpressionIR? matches pattern (_))), then

        1. (Let ?(typedExpressionIR_hi_reduced) be typedExpressionIR?)

        2. (Let typedExpressionIR'? be $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index))

        3. If ((typedExpressionIR'? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_lo_reduced) be typedExpressionIR'?)

          2. (Let (_expressionIR # (( typeIR_hi_reduced ctk_hi_reduced ))) be typedExpressionIR_hi_reduced)

          3. (Let (_expressionIR' # (( typeIR_lo_reduced ctk_lo_reduced ))) be typedExpressionIR_lo_reduced)

          4. If ((ctk_hi_reduced matches pattern `LCTK`)), then

            1. (Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi)

            2. (Let int be $to_number(value_hi))

            3. If ((int has type nat)), then

              1. (Let n_hi be (int as nat))

              2. If ((ctk_lo_reduced matches pattern `LCTK`)), then

                1. (Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo)

                2. (Let int' be $to_number(value_lo))

                3. If ((int' has type nat)), then

                  1. (Let n_lo be (int' as nat))

                  2. If ($is_valid_bitslice(typeIR_base, n_lo, n_hi)), then

                    1. (Let typeIR be ((bit< ((n_hi - n_lo) + 1) >) as typeIR))

                    2. (Let typedLvalueIR be ((typedLvalueIR_base [ typedExpressionIR_hi_reduced : typedExpressionIR_lo_reduced ]) #( typeIR )))

                    3. Result in typedLvalueIR

                  2. Else Phantom#913

                3. Else Phantom#914

              2. Else Phantom#915

            3. Else Phantom#916

          4. Else Phantom#917

        3. Else Phantom#918

      4. Else Phantom#919

    4. Else Phantom#920

  4. Case (% matches pattern `(%)`)

    1. (Let (( lvalue_base )) be lvalue)

    2. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

    3. (Let (_lvalueIR #( typeIR_base )) be typedLvalueIR_base)

    4. (Let typedLvalueIR be ((( typedLvalueIR_base )) #( typeIR_base )))

    5. Result in typedLvalueIR

2. Else Phantom#921

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:67:1-69:26:
relation Stmt_ok: p', TC', f', statement

1. Case analysis on statement

  1. Case (% has type emptyStatement)

    1. (Let emptyStatement be (statement as emptyStatement))

    2. If ((emptyStatement matches pattern `;`)), then

      1. Result in TC', f', ((;) as statementIR)

    2. Else Phantom#922

  2. Case (% has type assignmentStatement)

    1. (Let (lvalue assignop expression ;) be (statement as assignmentStatement))

    2. If ((assignop matches pattern `=`)), then

      1. (Lvalue_ok: p' TC' |- lvalue : typedLvalueIR)

      2. (Expr_ok: p' TC' |- expression : typedExpressionIR)

      3. (Let (_lvalueIR #( typeIR_l )) be typedLvalueIR)

      4. (Let (_expressionIR # (( typeIR_r _ctk ))) be typedExpressionIR)

      5. (Let typedExpressionIR'? be $coerce_unary(typedExpressionIR, typeIR_l))

      6. If ((typedExpressionIR'? matches pattern (_))), then

        1. (Let ?(typedExpressionIR_cast) be typedExpressionIR'?)

        2. Result in TC', f', ((typedLvalueIR (=) typedExpressionIR_cast ;) as statementIR)

      6. Else Phantom#923

    2. Else Phantom#924

  3. Case (% has type callStatement)

    1. (Let callStatement be (statement as callStatement))

    2. Case analysis on callStatement

      1. Case (% matches pattern `%(%);`)

        1. (Let (lvalue_routine ( argumentList );) be callStatement)

        2. (RoutineTarget_lvalue_ok: p' TC' |- lvalue_routine : routineTargetIR)

        3. (Let argument* be $flatten_argumentList(argumentList))

        4. (Argument_ok: p' TC' |- argument : argumentIR)*

        5. (RoutineType_ok: p' TC' |- routineTargetIR < [] >( argumentIR* ): routineTypeIR <# tid_impl* >(# id_default* ))

        6. (Call_ok: p' TC' |- routineTypeIR < [] # tid_impl* >( argumentIR* # id_default* ): typeIR_ret < typeArgumentIR_inferred* >( argumentIR_cast* ))

        7. (Let callStatementIR be (routineTargetIR < typeArgumentIR_inferred* >( argumentIR_cast* );))

        8. Result in TC', f', (callStatementIR as statementIR)

      2. Case (% matches pattern `%<%>(%);`)

        1. (Let (lvalue_routine < typeArgumentList >( argumentList );) be callStatement)

        2. (RoutineTarget_lvalue_ok: p' TC' |- lvalue_routine : routineTargetIR)

        3. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

        4. (TypeArguments_ok: p' TC' |- typeArgument* : typeArgumentIR* # tid_impl*)

        5. (Let argument* be $flatten_argumentList(argumentList))

        6. (Argument_ok: p' TC' |- argument : argumentIR)*

        7. (RoutineType_ok: p' TC' |- routineTargetIR < typeArgumentIR* >( argumentIR* ): routineTypeIR <# tid_inserted* >(# id_default* ))

        8. (Let tid_infer* be tid_impl* ++ tid_inserted*)

        9. (Call_ok: p' TC' |- routineTypeIR < [] # tid_infer* >( argumentIR* # id_default* ): typeIR_ret < typeArgumentIR_inferred* >( argumentIR_cast* ))

        10. (Let callStatementIR be (routineTargetIR < typeArgumentIR_inferred* >( argumentIR_cast* );))

        11. Result in TC', f', (callStatementIR as statementIR)

  4. Case (% has type directApplicationStatement)

    1. (Let (namedType .apply( argumentList );) be (statement as directApplicationStatement))

    2. (Expr_ok: p' TC' |- (((namedType as callTarget) ( () )) as expression) : (expressionIR # (( typeIR_object _ctk ))))

    3. If ((expressionIR has type callExpressionIR)), then

      1. (Let callExpressionIR be (expressionIR as callExpressionIR))

      2. If ((callExpressionIR matches pattern `%(%)`)), then

        1. (Let ((prefixedNameIR < typeArgumentIR* >) ( argumentIR* )) be callExpressionIR)

        2. If ((typeArgumentIR* matches pattern [])), then

          1. If ((argumentIR* matches pattern [])), then

            1. If ($compat_direct_application(typeIR_object)), then

              1. (Let nameIR_object be "__direct_application")

              2. (Let TC_1 be $add_var(p', TC', nameIR_object, (() typeIR_object (ctk) ?())))

              3. (Let lvalue be (((nameIR_object) as lvalue) . (("apply") as member)))

              4. (Stmt_ok: p' TC_1 f' |- ((lvalue ( argumentList );) as statement) : _typingContext _flow statementIR)

              5. If ((statementIR has type callStatementIR)), then

                1. (Let callStatementIR be (statementIR as callStatementIR))

                2. (Let (routineTargetIR < typeArgumentIR'* >( argumentIR_cast* );) be callStatementIR)

                3. If ((routineTargetIR = ((((` nameIR_object) as expressionIR) # (( typeIR_object (ctk) ))) . "apply"))), then

                  1. If ((typeArgumentIR'* matches pattern [])), then

                    1. (Let directApplicationStatementIR be (prefixedNameIR .apply( argumentIR_cast* );))

                    2. Result in TC', f', (directApplicationStatementIR as statementIR)

                  1. Else Phantom#925

                3. Else Phantom#926

              5. Else Phantom#927

            1. Else Phantom#928

          1. Else Phantom#929

        2. Else Phantom#930

      2. Else Phantom#931

    3. Else Phantom#932

  5. Case (% has type exitStatement)

    1. (Let exitStatement be (statement as exitStatement))

    2. If ((exitStatement matches pattern `EXIT;`)), then

      1. Result in TC', f', ((exit;) as statementIR)

    2. Else Phantom#933

  6. Case (% has type conditionalStatement)

    1. (Let conditionalStatement be (statement as conditionalStatement))

    2. Case analysis on conditionalStatement

      1. Case (% matches pattern `IF(%)%`)

        1. (Let (if( expression_cond ) statement_then) be conditionalStatement)

        2. (Expr_ok: p' TC' |- expression_cond : typedExpressionIR_cond)

        3. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR_cond)

        4. If ((typeIR has type primitiveTypeIR)), then

          1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

          2. If ((primitiveTypeIR matches pattern `BOOL`)), then

            1. (Stmt_ok: p' TC' f' |- statement_then : TC_then f_then statementIR_then)

            2. Result in TC', f', ((if( typedExpressionIR_cond ) statementIR_then) as statementIR)

          2. Else Phantom#934

        4. Else Phantom#935

      2. Case (% matches pattern `IF(%)%ELSE%`)

        1. (Let (if( expression_cond ) statement_then else statement_else) be conditionalStatement)

        2. (Expr_ok: p' TC' |- expression_cond : typedExpressionIR_cond)

        3. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR_cond)

        4. If ((typeIR has type primitiveTypeIR)), then

          1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

          2. If ((primitiveTypeIR matches pattern `BOOL`)), then

            1. (Stmt_ok: p' TC' f' |- statement_then : TC_then f_then statementIR_then)

            2. (Stmt_ok: p' TC' f' |- statement_else : TC_else f_else statementIR_else)

            3. (Let f_post be $join_flow(f_then, f_else))

            4. Result in TC', f_post, ((if( typedExpressionIR_cond ) statementIR_then else statementIR_else) as statementIR)

          2. Else Phantom#936

        4. Else Phantom#937

1. Else Phantom#938

2. If ((p' matches pattern `LOCAL`)), then

  1. Case analysis on statement

    1. Case (% has type returnStatement)

      1. (Let returnStatement be (statement as returnStatement))

      2. Case analysis on returnStatement

        1. Case (% matches pattern `RETURN;`)

          1. If ((?(((void) as typeIR)) = $find_return_type(TC'))), then

            1. Result in TC', (ret), ((return;) as statementIR)

          1. Else Phantom#939

        2. Case (% matches pattern `RETURN%;`)

          1. (Let (return expression ;) be returnStatement)

          2. (Expr_ok: (local) TC' |- expression : typedExpressionIR)

          3. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

          4. (Let typeIR'? be $find_return_type(TC'))

          5. If ((typeIR'? matches pattern (_))), then

            1. (Let ?(typeIR_ret) be typeIR'?)

            2. (Let typedExpressionIR'? be $coerce_unary(typedExpressionIR, typeIR_ret))

            3. If ((typedExpressionIR'? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_cast) be typedExpressionIR'?)

              2. Result in TC', (ret), ((return typedExpressionIR_cast ;) as statementIR)

            3. Else Phantom#940

          5. Else Phantom#941

    2. Case (% has type blockStatement)

      1. (Let blockStatement be (statement as blockStatement))

      2. (Block_ok: TC' f' |- blockStatement : TC_1 f_1 blockStatementIR)

      3. Result in TC_1, f_1, (blockStatementIR as statementIR)

    3. Case (% has type switchStatement)

      1. (Let (switch( expression_switch ){ switchCaseList }) be (statement as switchStatement))

      2. (Expr_ok: (local) TC' |- expression_switch : typedExpressionIR_switch)

      3. (Let (_expressionIR # (( typeIR_switch _ctk ))) be typedExpressionIR_switch)

      4. (Let typeIR be $canon(typeIR_switch))

      5. If ((typeIR has type tableTypeIR)), then

        1. (Let tableTypeIR be (typeIR as tableTypeIR))

        2. If ((tableTypeIR matches pattern `TABLE_ENUM%{%}`)), then

          1. (Let (table_enum tid_table_enum { _id* }) be tableTypeIR)

          2. (Let tid_table be $strip_prefix($strip_suffix(tid_table_enum, ")"), "action_list("))

          3. (Let switchCase* be $flatten_switchCaseList(switchCaseList))

          4. (SwitchCases_table_ok: TC' f' tid_table |- switchCase* : f_post switchCaseIR* # switchLabel*)

          5. If ($distinct_<switchLabel>(switchLabel*)), then

            1. (Let switchStatementIR be (switch( typedExpressionIR_switch ){ switchCaseIR* }))

            2. Result in TC', f_post, (switchStatementIR as statementIR)

          5. Else Phantom#942

        2. Else Phantom#943

      5. Else Phantom#944

      6. If ($compat_switch(typeIR_switch)), then

        1. (Let switchCase* be $flatten_switchCaseList(switchCaseList))

        2. (SwitchCases_general_ok: TC' f' typeIR_switch |- switchCase* : f_post switchCaseIR* # switchLabel*)

        3. If ($distinct_<switchLabel>(switchLabel*)), then

          1. (Let switchStatementIR be (switch( typedExpressionIR_switch ){ switchCaseIR* }))

          2. Result in TC', f_post, (switchStatementIR as statementIR)

        3. Else Phantom#945

      6. Else Phantom#946

  1. Else Phantom#947

2. Else Phantom#948

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:71:1-73:26:
relation Stmts_ok: 



;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:75:1-78:23:
relation BlockElementStmt_ok: TC_0, f, blockElementStatement

1. Case analysis on blockElementStatement

  1. Case (% has type constantDeclaration)

    1. (Let constantDeclaration be (blockElementStatement as constantDeclaration))

    2. (Decl_ok: (local) TC_0 |- (constantDeclaration as declaration) : TC_1 declarationIR)

    3. If ((declarationIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (declarationIR as constantDeclarationIR))

      2. Result in TC_1, f, (constantDeclarationIR as blockElementStatementIR)

    3. Else Phantom#949

  2. Case (% has type variableDeclaration)

    1. (Let (annotationList type name initializerOpt ;) be (blockElementStatement as variableDeclaration))

    2. If ((initializerOpt matches pattern ``EMPTY`)), then

      1. (Type_ok: (local) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

      2. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((local), TC_0) |- typeIR holds)), then

          1. If ($is_assignable_typeIR(typeIR)), then

            1. (Let nameIR be $name(name))

            2. (Let TC_1 be $add_var((local), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

            3. (Let variableDeclarationIR be (annotationList typeIR nameIR ?() ;))

            4. Result in TC_1, f, (variableDeclarationIR as blockElementStatementIR)

          1. Else Phantom#950

        1. Else Phantom#951

      2. Else Phantom#952

    2. Else Phantom#953

    3. If ((initializerOpt has type initializer)), then

      1. (Let (= expression_init) be (initializerOpt as initializer))

      2. (Type_ok: (local) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

      3. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((local), TC_0) |- typeIR holds)), then

          1. If ($is_assignable_typeIR(typeIR)), then

            1. (Expr_ok: (local) TC_0 |- expression_init : typedExpressionIR_init)

            2. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_init, typeIR))

            3. If ((typedExpressionIR? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?)

              2. (Let nameIR be $name(name))

              3. (Let TC_1 be $add_var((local), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

              4. (Let variableDeclarationIR be (annotationList typeIR nameIR ?((= typedExpressionIR_init_cast)) ;))

              5. Result in TC_1, f, (variableDeclarationIR as blockElementStatementIR)

            3. Else Phantom#954

          1. Else Phantom#955

        1. Else Phantom#956

      3. Else Phantom#957

    3. Else Phantom#958

  3. Case (% has type statement)

    1. (Let statement be (blockElementStatement as statement))

    2. (Stmt_ok: (local) TC_0 f |- statement : TC_1 f_post statementIR)

    3. Result in TC_1, f_post, (statementIR as blockElementStatementIR)

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:80:1-83:23:
relation BlockElementStmts_ok: TC', f', blockElementStatement*

1. Case analysis on blockElementStatement*

  1. Case (% matches pattern [])

    1. Result in TC', f', []

  2. Case (% matches pattern _ :: _)

    1. (Let blockElementStatement_h :: blockElementStatement_t* be blockElementStatement*)

    2. (BlockElementStmt_ok: TC' f' |- blockElementStatement_h : TC_1 f_1 blockElementStatementIR_h)

    3. (BlockElementStmts_ok: TC_1 f_1 |- blockElementStatement_t* : TC_2 f_2 blockElementStatementIR_t*)

    4. Result in TC_2, f_2, blockElementStatementIR_h :: blockElementStatementIR_t*

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:85:1-88:23:
relation Block_ok: TC_0, f, (annotationList { blockElementStatementList })

1. (Let blockElementStatement* be $flatten_blockElementStatementList(blockElementStatementList))

2. (Let TC_1 be $enter(TC_0))

3. (BlockElementStmts_ok: TC_1 f |- blockElementStatement* : TC_2 f_post blockElementStatementIR*)

4. (Let TC_3 be $exit(TC_2))

5. (Let blockStatementIR be (annotationList { blockElementStatementIR* }))

6. Result in TC_3, f_post, blockStatementIR

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:95:1-97:23:
relation Parameter_ok: p, TC, (annotationList direction type name initializerOpt)

1. If ((initializerOpt matches pattern ``EMPTY`)), then

  1. (Type_ok: p TC |- (type as typeOrVoid) : typeIR # tid_fresh*)

  2. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_fresh* })))

  3. If ((Type_wf: bound |- typeIR holds)), then

    1. (Let nameIR be $name(name))

    2. Result in (annotationList direction typeIR nameIR ?()), tid_fresh*

  3. Else Phantom#959

1. Else Phantom#960

2. If ((initializerOpt has type initializer)), then

  1. (Let (= expression_init) be (initializerOpt as initializer))

  2. (Type_ok: p TC |- (type as typeOrVoid) : typeIR # tid_fresh*)

  3. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_fresh* })))

  4. If ((Type_wf: bound |- typeIR holds)), then

    1. (Expr_ok: p TC |- expression_init : typedExpressionIR_init)

    2. (Let (_expressionIR # (( typeIR_init ctk ))) be typedExpressionIR_init)

    3. If ((ctk matches pattern `LCTK`)), then

      1. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_init, typeIR))

      2. If ((typedExpressionIR? matches pattern (_))), then

        1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?)

        2. (Let nameIR be $name(name))

        3. (Eval_static: p TC |- typedExpressionIR_init_cast ~> value_init)

        4. Result in (annotationList direction typeIR nameIR ?((= value_init))), tid_fresh*

      2. Else Phantom#961

    3. Else Phantom#962

  4. Else Phantom#963

2. Else Phantom#964

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:99:1-101:23:
relation Parameters_ok: p, TC, parameter*

1. Case analysis on parameter*

  1. Case (% matches pattern [])

    1. Result in [], []

  2. Case (% matches pattern _ :: _)

    1. (Let parameter_h :: parameter_t* be parameter*)

    2. (Parameter_ok: p TC |- parameter_h : parameterIR_h # tid_fresh_h*)

    3. (Parameters_ok: p TC |- parameter_t* : parameterIR_t* # tid_fresh_t*)

    4. Result in parameterIR_h :: parameterIR_t*, tid_fresh_h* ++ tid_fresh_t*

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:103:1-103:48:
def $parameterIR((_annotationList direction typeIR nameIR constantInitializerOptIR'))

1. (Let constantInitializerIR? be constantInitializerOptIR')

2. If ((constantInitializerIR? matches pattern ())), then

  1. Return (direction typeIR nameIR ?())

2. Else Phantom#965

3. If ((constantInitializerOptIR' matches pattern (_))), then

  1. (Let ?((= value)) be constantInitializerOptIR')

  2. Return (direction typeIR nameIR ?(value))

3. Else Phantom#966

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:109:1-112:23:
relation ConstructorParameter_ok: p, TC, constructorParameter

1. (Parameter_ok: p TC |- constructorParameter : constructorParameterIR # tid_fresh*)

2. Result in constructorParameterIR, tid_fresh*

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:114:1-117:23:
relation ConstructorParameters_ok: p, TC, constructorParameter*

1. (Parameters_ok: p TC |- constructorParameter* : constructorParameterIR* # tid_fresh*)

2. Result in constructorParameterIR*, tid_fresh*

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:119:1-119:81:
def $constructorParameterIR(constructorParameterIR)

1. Return $parameterIR(constructorParameterIR)

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:127:1-129:23:
relation ExternMethod_ok: TC_0, tid_extern, methodPrototype

1. Case analysis on methodPrototype

  1. Case (% matches pattern `%%;`)

    1. (Let (annotationList (typeOrVoid name typeParameterListOpt ( parameterList )) ;) be methodPrototype)

    2. (Let nameIR be $name(name))

    3. If ((nameIR =/= tid_extern)), then

      1. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

      2. (Let tid_expl be $name(typeParameter))*

      3. (Let TC_1 be $add_types((local), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

      4. (Type_ok: (local) TC_1 |- typeOrVoid : typeIR_ret # tid*)

      5. If ((tid* matches pattern [])), then

        1. (Let TC_2 be TC_1[local.kind = (extern_method-> typeIR_ret)])

        2. (Let parameter* be $flatten_parameterList(parameterList))

        3. (Parameters_ok: (local) TC_2 |- parameter* : parameterIR* # tid_impl*)

        4. (Let parameterTypeIR be $parameterIR(parameterIR))*

        5. (Let TC_3 be $add_parameters((local), TC_2, parameterTypeIR*))

        6. (Let rid be $rid(name, parameterList))

        7. (Let methodTypeIR be (extern_method( parameterTypeIR* )-> typeIR_ret))

        8. (Let routineTypeDefIR be (((methodTypeIR as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

        9. If ((RoutineTypeDef_wf: $bound((block), TC_0) |- routineTypeDefIR holds)), then

          1. (Let TC_4 be $add_routine_overload((block), TC_0, rid, routineTypeDefIR))

          2. (Let methodPrototypeIR be (annotationList (typeIR_ret nameIR < tid_expl* , tid_impl* >( parameterIR* )) ;))

          3. Result in TC_4, methodPrototypeIR

        9. Else Phantom#967

      5. Else Phantom#968

    3. Else Phantom#969

  2. Case (% matches pattern `%ABSTRACT%;`)

    1. (Let (annotationList abstract (typeOrVoid name typeParameterListOpt ( parameterList )) ;) be methodPrototype)

    2. (Let nameIR be $name(name))

    3. If ((nameIR =/= tid_extern)), then

      1. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

      2. (Let tid_expl be $name(typeParameter))*

      3. (Let TC_1 be $add_types((local), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

      4. (Type_ok: (local) TC_1 |- typeOrVoid : typeIR_ret # tid*)

      5. If ((tid* matches pattern [])), then

        1. (Let TC_2 be TC_1[local.kind = (extern_methodabstract-> typeIR_ret)])

        2. (Let parameter* be $flatten_parameterList(parameterList))

        3. (Parameters_ok: (local) TC_2 |- parameter* : parameterIR* # tid_impl*)

        4. (Let parameterTypeIR be $parameterIR(parameterIR))*

        5. (Let TC_3 be $add_parameters((local), TC_2, parameterTypeIR*))

        6. (Let rid be $rid(name, parameterList))

        7. (Let methodTypeIR be (extern_methodabstract( parameterTypeIR* )-> typeIR_ret))

        8. (Let routineTypeDefIR be (((methodTypeIR as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

        9. If ((RoutineTypeDef_wf: $bound((block), TC_0) |- routineTypeDefIR holds)), then

          1. (Let TC_4 be $add_routine_overload((block), TC_0, rid, routineTypeDefIR))

          2. (Let methodPrototypeIR be (annotationList abstract (typeIR_ret nameIR < tid_expl* , tid_impl* >( parameterIR* )) ;))

          3. Result in TC_4, methodPrototypeIR

        9. Else Phantom#970

      5. Else Phantom#971

    3. Else Phantom#972

1. Else Phantom#973

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:131:1-133:23:
relation ExternMethods_ok: TC', tid_extern, methodPrototype*

1. Case analysis on methodPrototype*

  1. Case (% matches pattern [])

    1. Result in TC', []

  2. Case (% matches pattern _ :: _)

    1. (Let methodPrototype_h :: methodPrototype_t* be methodPrototype*)

    2. (ExternMethod_ok: TC' tid_extern |- methodPrototype_h : TC_1 methodPrototypeIR_h)

    3. (ExternMethods_ok: TC_1 tid_extern |- methodPrototype_t* : TC_2 methodPrototypeIR_t*)

    4. Result in TC_2, methodPrototypeIR_h :: methodPrototypeIR_t*

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:135:1-137:23:
relation ExternConstructor_ok: TC_0, tid_extern, methodPrototype

1. If ((methodPrototype matches pattern `%%(%);`)), then

  1. (Let (annotationList typeIdentifier ( parameterList );) be methodPrototype)

  2. (Let nameIR be $name((typeIdentifier as name)))

  3. If ((nameIR = tid_extern)), then

    1. (Let constructorParameter* be $flatten_parameterList(parameterList))

    2. (ConstructorParameters_ok: (block) TC_0 |- constructorParameter* : constructorParameterIR* # tid_impl*)

    3. (Let constructorParameterTypeIR be $constructorParameterIR(constructorParameterIR))*

    4. (Let typeDefIR'? be $find_type((global), TC_0, (` nameIR)))

    5. If ((typeDefIR'? matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?)

      2. If ((typeDefIR has type polyTypeDefIR)), then

        1. (Let (typeIR_extern < tid_expl* , tid* >) be (typeDefIR as polyTypeDefIR))

        2. If ((tid* matches pattern [])), then

          1. (Let cid be $cid((typeIdentifier as name), (( parameterList ))))

          2. (Let typeIR_extern_spec be (((typeIR_extern < tid_expl* , [] >) < ((tid tid_expl) as typeIR)* >) as typeIR))

          3. (Let constructorTypeIR be (constructor( constructorParameterTypeIR* )-> typeIR_extern_spec))

          4. (Let constructorTypeDefIR be (constructorTypeIR < tid_expl* , tid_impl* >))

          5. If ((ConstructorTypeDef_wf: $bound((block), TC_0) |- constructorTypeDefIR holds)), then

            1. (Let TC_1 be $add_constructor(TC_0, cid, constructorTypeDefIR))

            2. (Let methodPrototypeIR be (annotationList nameIR <, tid_impl* >( constructorParameterIR* );))

            3. Result in TC_1, methodPrototypeIR

          5. Else Phantom#974

        2. Else Phantom#975

      2. Else Phantom#976

    5. Else Phantom#977

  3. Else Phantom#978

1. Else Phantom#979

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:139:1-141:23:
relation ExternConstructors_ok: TC', tid_extern, methodPrototype*

1. Case analysis on methodPrototype*

  1. Case (% matches pattern [])

    1. Result in TC', []

  2. Case (% matches pattern _ :: _)

    1. (Let methodPrototype_h :: methodPrototype_t* be methodPrototype*)

    2. (ExternConstructor_ok: TC' tid_extern |- methodPrototype_h : TC_1 methodPrototypeIR_h)

    3. (ExternConstructors_ok: TC_1 tid_extern |- methodPrototype_t* : TC_2 methodPrototypeIR_t*)

    4. Result in TC_2, methodPrototypeIR_h :: methodPrototypeIR_t*

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:147:1-149:23:
relation ParserTransition_ok: TC_0, nameIR_state*, transitionStatement

1. Case analysis on transitionStatement

  1. Case (% matches pattern ``EMPTY`)

    1. Result in (transition ("reject" ;))

  2. Case (% matches pattern `TRANSITION%`)

    1. (Let (transition stateExpression) be transitionStatement)

    2. If ((stateExpression matches pattern `%;`)), then

      1. (Let (name ;) be stateExpression)

      2. (Let nameIR be $name(name))

      3. If (nameIR is in nameIR_state*), then

        1. (Let transitionStatementIR be (transition (nameIR ;)))

        2. Result in transitionStatementIR

      3. Else Phantom#980

    2. Else Phantom#981

    3. If ((stateExpression has type selectExpression)), then

      1. (Let (select( expressionList_key ){ selectCaseList }) be (stateExpression as selectExpression))

      2. (Let expression_key* be $flatten_expressionList(expressionList_key))

      3. (Expr_ok: (local) TC_0 |- expression_key : typedExpressionIR_key)*

      4. (Let (_expressionIR # (( typeIR_key _ctk ))) be typedExpressionIR_key)*

      5. If ((Type_wf: $bound((local), TC_0) |- ((set< [typeIR_key] >) as typeIR) holds))*, then

        1. (Let selectCase* be $flatten_selectCaseList(selectCaseList))

        2. (SelectCase_ok: TC_0 nameIR_state* typeIR_key* |- selectCase : selectCaseIR)*

        3. (Let transitionStatementIR be (transition ((select( typedExpressionIR_key* ){ selectCaseIR* }) as stateExpressionIR)))

        4. Result in transitionStatementIR

      5. Else Phantom#982

    3. Else Phantom#983

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:151:1-153:20:
relation ParserStmt_ok: TC_0', parserStatement''

1. Case analysis on parserStatement''

  1. Case (% has type constantDeclaration)

    1. (Let constantDeclaration be (parserStatement'' as constantDeclaration))

    2. (Decl_ok: (local) TC_0' |- (constantDeclaration as declaration) : TC_1 declarationIR)

    3. If ((declarationIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (declarationIR as constantDeclarationIR))

      2. Result in TC_1, (constantDeclarationIR as parserStatementIR)

    3. Else Phantom#984

  2. Case (% has type variableDeclaration)

    1. (Let (annotationList type name initializerOpt ;) be (parserStatement'' as variableDeclaration))

    2. If ((initializerOpt matches pattern ``EMPTY`)), then

      1. (Type_ok: (local) TC_0' |- (type as typeOrVoid) : typeIR # tid*)

      2. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((local), TC_0') |- typeIR holds)), then

          1. If ($is_assignable_typeIR(typeIR)), then

            1. (Let nameIR be $name(name))

            2. (Let TC_1 be $add_var((local), TC_0', nameIR, ((inout) typeIR (dyn) ?())))

            3. (Let variableDeclarationIR be (annotationList typeIR nameIR ?() ;))

            4. Result in TC_1, (variableDeclarationIR as parserStatementIR)

          1. Else Phantom#985

        1. Else Phantom#986

      2. Else Phantom#987

    2. Else Phantom#988

    3. If ((initializerOpt has type initializer)), then

      1. (Let (= expression_init) be (initializerOpt as initializer))

      2. (Type_ok: (local) TC_0' |- (type as typeOrVoid) : typeIR # tid*)

      3. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((local), TC_0') |- typeIR holds)), then

          1. If ($is_assignable_typeIR(typeIR)), then

            1. (Expr_ok: (local) TC_0' |- expression_init : typedExpressionIR_init)

            2. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_init, typeIR))

            3. If ((typedExpressionIR? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?)

              2. (Let nameIR be $name(name))

              3. (Let TC_1 be $add_var((local), TC_0', nameIR, ((inout) typeIR (dyn) ?())))

              4. (Let variableDeclarationIR be (annotationList typeIR nameIR ?((= typedExpressionIR_init_cast)) ;))

              5. Result in TC_1, (variableDeclarationIR as parserStatementIR)

            3. Else Phantom#989

          1. Else Phantom#990

        1. Else Phantom#991

      3. Else Phantom#992

    3. Else Phantom#993

  3. Case (% has type emptyStatement)

    1. (Let emptyStatement be (parserStatement'' as emptyStatement))

    2. (Stmt_ok: (local) TC_0' (cont) |- (emptyStatement as statement) : typingContext flow statementIR)

    3. If ((typingContext = TC_0')), then

      1. If ((flow matches pattern `CONT`)), then

        1. If ((statementIR has type emptyStatementIR)), then

          1. (Let emptyStatementIR be (statementIR as emptyStatementIR))

          2. Result in TC_0', (emptyStatementIR as parserStatementIR)

        1. Else Phantom#994

      1. Else Phantom#995

    3. Else Phantom#996

  4. Case (% has type assignmentStatement)

    1. (Let assignmentStatement be (parserStatement'' as assignmentStatement))

    2. (Stmt_ok: (local) TC_0' (cont) |- (assignmentStatement as statement) : TC_1 flow statementIR)

    3. If ((flow matches pattern `CONT`)), then

      1. If ((statementIR has type assignmentStatementIR)), then

        1. (Let assignmentStatementIR be (statementIR as assignmentStatementIR))

        2. Result in TC_1, (assignmentStatementIR as parserStatementIR)

      1. Else Phantom#997

    3. Else Phantom#998

  5. Case (% has type callStatement)

    1. (Let callStatement be (parserStatement'' as callStatement))

    2. (Stmt_ok: (local) TC_0' (cont) |- (callStatement as statement) : TC_1 flow statementIR)

    3. If ((flow matches pattern `CONT`)), then

      1. If ((statementIR has type callStatementIR)), then

        1. (Let callStatementIR be (statementIR as callStatementIR))

        2. Result in TC_1, (callStatementIR as parserStatementIR)

      1. Else Phantom#999

    3. Else Phantom#1000

  6. Case (% has type directApplicationStatement)

    1. (Let directApplicationStatement be (parserStatement'' as directApplicationStatement))

    2. (Stmt_ok: (local) TC_0' (cont) |- (directApplicationStatement as statement) : TC_1 flow statementIR)

    3. If ((flow matches pattern `CONT`)), then

      1. If ((statementIR has type directApplicationStatementIR)), then

        1. (Let directApplicationStatementIR be (statementIR as directApplicationStatementIR))

        2. Result in TC_1, (directApplicationStatementIR as parserStatementIR)

      1. Else Phantom#1001

    3. Else Phantom#1002

  7. Case (% has type parserBlockStatement)

    1. (Let (annotationList { parserStatementList }) be (parserStatement'' as parserBlockStatement))

    2. (Let parserStatement''* be $flatten_parserStatementList(parserStatementList))

    3. (Let TC_1 be $enter(TC_0'))

    4. (ParserStmts_ok: TC_1 |- parserStatement''* : TC_2 parserStatementIR*)

    5. (Let TC_3 be $exit(TC_2))

    6. (Let parserBlockStatementIR be (annotationList { parserStatementIR* }))

    7. Result in TC_1, (parserBlockStatementIR as parserStatementIR)

  8. Case (% has type conditionalStatement)

    1. (Let conditionalStatement be (parserStatement'' as conditionalStatement))

    2. (Stmt_ok: (local) TC_0' (cont) |- (conditionalStatement as statement) : TC_1 flow statementIR)

    3. If ((flow matches pattern `CONT`)), then

      1. If ((statementIR has type conditionalStatementIR)), then

        1. (Let conditionalStatementIR be (statementIR as conditionalStatementIR))

        2. Result in TC_1, (conditionalStatementIR as parserStatementIR)

      1. Else Phantom#1003

    3. Else Phantom#1004

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:155:1-157:20:
relation ParserStmts_ok: TC', parserStatement*

1. Case analysis on parserStatement*

  1. Case (% matches pattern [])

    1. Result in TC', []

  2. Case (% matches pattern _ :: _)

    1. (Let parserStatement_h :: parserStatement_t* be parserStatement*)

    2. (ParserStmt_ok: TC' |- parserStatement_h : TC_1 parserStatementIR_h)

    3. (ParserStmts_ok: TC_1 |- parserStatement_t* : TC_2 parserStatementIR_t*)

    4. Result in TC_2, parserStatementIR_h :: parserStatementIR_t*

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:159:1-161:23:
relation ParserState_ok: TC_0, nameIR_state*, (annotationList state name { parserStatementList transitionStatement })

1. (Let nameIR be $name(name))

2. (Let TC_1 be $enter(TC_0))

3. (Let parserStatement* be $flatten_parserStatementList(parserStatementList))

4. (ParserStmts_ok: TC_1 |- parserStatement* : TC_2 parserStatementIR*)

5. (ParserTransition_ok: TC_2 nameIR_state* |- transitionStatement : transitionStatementIR)

6. (Let TC_3 be $exit(TC_2))

7. (Let parserStateIR be (annotationList state nameIR { parserStatementIR* transitionStatementIR }))

8. Result in parserStateIR

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:163:1-165:20:
relation ParserStates_ok: TC, parserState*

1. (Let (_annotationList state name_state { _parserStatementList _transitionStatement }) be parserState)*

2. (Let nameIR_state be $name(name_state))*

3. If ($distinct_<nameIR>(nameIR_state*)), then

  1. If ("start" is in nameIR_state*), then

    1. If ((~"accept" is in nameIR_state* /\ ~"reject" is in nameIR_state*)), then

      1. (Let nameIR_state_impl* be "accept" :: "reject" :: nameIR_state*)

      2. (ParserState_ok: TC nameIR_state_impl* |- parserState : parserStateIR)*

      3. Result in parserStateIR*

    1. Else Phantom#1005

  1. Else Phantom#1006

3. Else Phantom#1007

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:167:1-170:20:
relation ParserLocalDecl_ok: TC_0, parserLocalDeclaration

1. Case analysis on parserLocalDeclaration

  1. Case (% has type constantDeclaration)

    1. (Let constantDeclaration be (parserLocalDeclaration as constantDeclaration))

    2. (Decl_ok: (block) TC_0 |- (constantDeclaration as declaration) : TC_1 declarationIR)

    3. If ((declarationIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (declarationIR as constantDeclarationIR))

      2. Result in TC_1, (constantDeclarationIR as parserLocalDeclarationIR)

    3. Else Phantom#1008

  2. Case (% has type instantiation)

    1. (Let instantiation be (parserLocalDeclaration as instantiation))

    2. (Decl_ok: (block) TC_0 |- (instantiation as declaration) : TC_1 declarationIR)

    3. If ((declarationIR has type instantiationIR)), then

      1. (Let instantiationIR be (declarationIR as instantiationIR))

      2. Result in TC_1, (instantiationIR as parserLocalDeclarationIR)

    3. Else Phantom#1009

  3. Case (% has type variableDeclaration)

    1. (Let (annotationList type name initializerOpt ;) be (parserLocalDeclaration as variableDeclaration))

    2. If ((initializerOpt matches pattern ``EMPTY`)), then

      1. (Type_ok: (block) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

      2. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((block), TC_0) |- typeIR holds)), then

          1. If ($is_assignable_typeIR(typeIR)), then

            1. (Let nameIR be $name(name))

            2. (Let TC_1 be $add_var((block), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

            3. (Let variableDeclarationIR be (annotationList typeIR nameIR ?() ;))

            4. Result in TC_1, (variableDeclarationIR as parserLocalDeclarationIR)

          1. Else Phantom#1010

        1. Else Phantom#1011

      2. Else Phantom#1012

    2. Else Phantom#1013

    3. If ((initializerOpt has type initializer)), then

      1. (Let (= expression_init) be (initializerOpt as initializer))

      2. (Type_ok: (block) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

      3. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((block), TC_0) |- typeIR holds)), then

          1. If ($is_assignable_typeIR(typeIR)), then

            1. (Expr_ok: (block) TC_0 |- expression_init : typedExpressionIR_init)

            2. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_init, typeIR))

            3. If ((typedExpressionIR? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?)

              2. (Let nameIR be $name(name))

              3. (Let TC_1 be $add_var((block), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

              4. (Let variableDeclarationIR be (annotationList typeIR nameIR ?((= typedExpressionIR_init_cast)) ;))

              5. Result in TC_1, (variableDeclarationIR as parserLocalDeclarationIR)

            3. Else Phantom#1014

          1. Else Phantom#1015

        1. Else Phantom#1016

      3. Else Phantom#1017

    3. Else Phantom#1018

  4. Case (% has type valueSetDeclaration)

    1. (Let (annotationList value_set< valueSetType >( expression ) name ;) be (parserLocalDeclaration as valueSetDeclaration))

    2. (Type_ok: (block) TC_0 |- (valueSetType as typeOrVoid) : typeIR # tid*)

    3. If ((tid* matches pattern [])), then

      1. If ((Type_wf: $bound((block), TC_0) |- ((set< [typeIR] >) as typeIR) holds)), then

        1. (Expr_ok: (block) TC_0 |- expression : typedExpressionIR)

        2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR)

        3. If (~(ctk matches pattern `DYN`)), then

          1. (Let nameIR be $name(name))

          2. (Let TC_1 be $add_var((block), TC_0, nameIR, (() ((set< [typeIR] >) as typeIR) (ctk) ?())))

          3. (Let valueSetDeclarationIR be (annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;))

          4. Result in TC_1, (valueSetDeclarationIR as parserLocalDeclarationIR)

        3. Else Phantom#1019

      1. Else Phantom#1020

    3. Else Phantom#1021

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:172:1-175:20:
relation ParserLocalDecls_ok: TC', parserLocalDeclaration*

1. Case analysis on parserLocalDeclaration*

  1. Case (% matches pattern [])

    1. Result in TC', []

  2. Case (% matches pattern _ :: _)

    1. (Let parserLocalDeclaration_h :: parserLocalDeclaration_t* be parserLocalDeclaration*)

    2. (ParserLocalDecl_ok: TC' |- parserLocalDeclaration_h : TC_1 parserLocalDeclarationIR_h)

    3. (ParserLocalDecls_ok: TC_1 |- parserLocalDeclaration_t* : TC_2 parserLocalDeclarationIR_t*)

    4. Result in TC_2, parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:181:1-183:23:
relation TableKey_ok: TC, TBLC_0, (expression : name_matchkind annotationList ;)

1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

2. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

3. If ((Type_wf: $bound((local), TC) |- ((set< [typeIR] >) as typeIR) holds)), then

  1. (Let nameIR_matchkind be $name(name_matchkind))

  2. If ((((match_kind. nameIR_matchkind) as value) = $find_value((local), TC, (` nameIR_matchkind)))), then

    1. If ($compat_table_key(nameIR_matchkind, typeIR)), then

      1. (Let TBLC_1 be $update_mode(TBLC_0, nameIR_matchkind, typeIR))

      2. (Let TBLC_2 be $add_key(TBLC_1, nameIR_matchkind, typeIR))

      3. (Let tableKeyIR be (typedExpressionIR : nameIR_matchkind annotationList ;))

      4. Result in TBLC_2, tableKeyIR

    1. Else Phantom#1022

  2. Else Phantom#1023

3. Else Phantom#1024

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:185:1-187:23:
relation TableKeys_ok: TC, TBLC', tableKey*

1. Case analysis on tableKey*

  1. Case (% matches pattern [])

    1. Result in TBLC', []

  2. Case (% matches pattern _ :: _)

    1. (Let tableKey_h :: tableKey_t* be tableKey*)

    2. (TableKey_ok: TC TBLC' |- tableKey_h : TBLC_1 tableKeyIR_h)

    3. (TableKeys_ok: TC TBLC_1 |- tableKey_t* : TBLC_2 tableKeyIR_t*)

    4. Result in TBLC_2, tableKeyIR_h :: tableKeyIR_t*

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:189:1-192:23:
relation Call_action_partial_ok: TC, parameterTypeIR*, argumentIR*

1. (Let (parameterTypeIR_data*, parameterTypeIR_control*) be $split_dataplane_parameters(parameterTypeIR*))

2. If ((|parameterTypeIR_data*| = |argumentIR*|)), then

  1. (Call_convention_ok: (local) TC (action) |- parameterTypeIR_data* @ argumentIR* : argumentIR_cast*)

  2. Result in parameterTypeIR_data*, parameterTypeIR_control*, argumentIR_cast*

2. Else Phantom#1025

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:194:1-196:23:
relation TableAction_ok: TC, TBLC_0, (annotationList tableActionReference ;)

1. If ((tableActionReference has type prefixedNonTypeName)), then

  1. (Let prefixedNonTypeName be (tableActionReference as prefixedNonTypeName))

  2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

  3. (Let routineTypeDefIR'? be $find_routine_non_overloaded((local), TC, prefixedNameIR))

  4. If ((routineTypeDefIR'? matches pattern (_))), then

    1. (Let ?(routineTypeDefIR) be routineTypeDefIR'?)

    2. If ((routineTypeDefIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeDefIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `ACTION(%)`)), then

        1. (Let (action( parameterTypeIR* )) be functionTypeIR)

        2. (Call_action_partial_ok: TC |- parameterTypeIR* @ [] : parameterTypeIR_data* , parameterTypeIR_control* @ argumentIR*)

        3. If ((argumentIR* matches pattern [])), then

          1. (Let TBLC_1 be $add_action(TBLC_0, prefixedNameIR, parameterTypeIR*, []))

          2. (Let tableActionIR be (annotationList (prefixedNameIR ( [] )) ;))

          3. Result in TBLC_1, tableActionIR

        3. Else Phantom#1026

      2. Else Phantom#1027

    2. Else Phantom#1028

  4. Else Phantom#1029

1. Else Phantom#1030

2. If ((tableActionReference matches pattern `%(%)`)), then

  1. (Let (prefixedNonTypeName ( argumentList )) be tableActionReference)

  2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

  3. (Let routineTypeDefIR'? be $find_routine_non_overloaded((local), TC, prefixedNameIR))

  4. If ((routineTypeDefIR'? matches pattern (_))), then

    1. (Let ?(routineTypeDefIR) be routineTypeDefIR'?)

    2. If ((routineTypeDefIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeDefIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `ACTION(%)`)), then

        1. (Let (action( parameterTypeIR* )) be functionTypeIR)

        2. (Let argument* be $flatten_argumentList(argumentList))

        3. (Argument_ok: (local) TC |- argument : argumentIR)*

        4. (Call_action_partial_ok: TC |- parameterTypeIR* @ argumentIR* : parameterTypeIR_data* , parameterTypeIR_control* @ argumentIR_cast*)

        5. (Let TBLC_1 be $add_action(TBLC_0, prefixedNameIR, parameterTypeIR*, argumentIR_cast*))

        6. (Let tableActionIR be (annotationList (prefixedNameIR ( argumentIR_cast* )) ;))

        7. Result in TBLC_1, tableActionIR

      2. Else Phantom#1031

    2. Else Phantom#1032

  4. Else Phantom#1033

2. Else Phantom#1034

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:198:1-200:23:
relation TableActions_ok: TC, TBLC', tableAction*

1. Case analysis on tableAction*

  1. Case (% matches pattern [])

    1. Result in TBLC', []

  2. Case (% matches pattern _ :: _)

    1. (Let tableAction_h :: tableAction_t* be tableAction*)

    2. (TableAction_ok: TC TBLC' |- tableAction_h : TBLC_1 tableActionIR_h)

    3. (TableActions_ok: TC TBLC_1 |- tableAction_t* : TBLC_2 tableActionIR_t*)

    4. Result in TBLC_2, tableActionIR_h :: tableActionIR_t*

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:202:1-205:23:
relation Call_action_default_ok: TC, parameterTypeIR*, argumentIR*

1. (Let (parameterTypeIR_data*, parameterTypeIR_control*) be $split_dataplane_parameters(parameterTypeIR*))

2. (Call_convention_ok: (local) TC (action) |- parameterTypeIR* @ argumentIR* : argumentIR_cast*)

3. Result in parameterTypeIR_data*, parameterTypeIR_control*, argumentIR_cast*

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:207:1-209:23:
relation TableDefaultAction_ok: TC, TBLC, (= expression)

1. Case analysis on expression

  1. Case (% has type prefixedNonTypeName)

    1. (Let prefixedNonTypeName be (expression as prefixedNonTypeName))

    2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

    3. If ((?(([], [])) = $find_action(TBLC, prefixedNameIR))), then

      1. Result in (prefixedNameIR ( [] ))

    3. Else Phantom#1035

  2. Case (% has type callExpression)

    1. (Let callExpression be (expression as callExpression))

    2. If ((callExpression matches pattern `%(%)`)), then

      1. (Let (callTarget ( argumentList )) be callExpression)

      2. If ((callTarget has type prefixedNonTypeName)), then

        1. (Let prefixedNonTypeName be (callTarget as prefixedNonTypeName))

        2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

        3. (Let (parameterTypeIR*, argumentListIR)? be $find_action(TBLC, prefixedNameIR))

        4. If (((parameterTypeIR*, argumentListIR)? matches pattern (_))), then

          1. (Let ?((parameterTypeIR_action*, argumentIR_action*)) be (parameterTypeIR*, argumentListIR)?)

          2. (Let argument* be $flatten_argumentList(argumentList))

          3. (Argument_ok: (local) TC |- argument : argumentIR)*

          4. (Call_action_default_ok: TC |- parameterTypeIR_action* @ argumentIR* : parameterTypeIR_action_data* , parameterTypeIR_action_control* @ argumentIR_cast*)

          5. (Let argumentIR_action_data* be argumentIR_action*[0 : |parameterTypeIR_action_data*|])

          6. (Let argumentIR_cast_data* be argumentIR_cast*[0 : |parameterTypeIR_action_data*|])

          7. If ((argumentIR_action_data = argumentIR_cast_data))*, then

            1. Result in (prefixedNameIR ( argumentIR_cast* ))

          7. Else Phantom#1036

        4. Else Phantom#1037

      2. Else Phantom#1038

    2. Else Phantom#1039

1. Else Phantom#1040

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:211:1-213:23:
relation TableEntry_keyset_ok: TC, TBLC, keysetExpression

1. Case analysis on keysetExpression

  1. Case (% has type expression)

    1. (Let expression be (keysetExpression as expression))

    2. If ((|TBLC.keys| = 1)), then

      1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ [(expression as simpleKeysetExpression)] : TBLS simpleKeysetExpressionIR'*)

      2. If ((simpleKeysetExpressionIR'* matches pattern [ _/1 ])), then

        1. (Let [simpleKeysetExpressionIR] be simpleKeysetExpressionIR'*)

        2. Result in TBLS, (simpleKeysetExpressionIR as keysetExpressionIR)

      2. Else Phantom#1041

    2. Else Phantom#1042

  2. Case (% has type tupleKeysetExpression)

    1. (Let tupleKeysetExpression be (keysetExpression as tupleKeysetExpression))

    2. Case analysis on tupleKeysetExpression

      1. Case (% matches pattern `(%&&&%)`)

        1. (Let (( expression_l &&& expression_r )) be tupleKeysetExpression)

        2. If ((|TBLC.keys| = 1)), then

          1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ [(expression_l &&& expression_r)] : TBLS simpleKeysetExpressionIR'*)

          2. If ((simpleKeysetExpressionIR'* matches pattern [ _/1 ])), then

            1. (Let [simpleKeysetExpressionIR] be simpleKeysetExpressionIR'*)

            2. Result in TBLS, ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

          2. Else Phantom#1043

        2. Else Phantom#1044

      2. Case (% matches pattern `(%..%)`)

        1. (Let (( expression_l .. expression_r )) be tupleKeysetExpression)

        2. If ((|TBLC.keys| = 1)), then

          1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ [(expression_l .. expression_r)] : TBLS simpleKeysetExpressionIR'*)

          2. If ((simpleKeysetExpressionIR'* matches pattern [ _/1 ])), then

            1. (Let [simpleKeysetExpressionIR] be simpleKeysetExpressionIR'*)

            2. Result in TBLS, ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

          2. Else Phantom#1045

        2. Else Phantom#1046

      3. Case (% matches pattern `(DEFAULT)`)

        1. (Let matchMode be TBLC.mode)

        2. If ((matchMode matches pattern `NOPRILPM%`)), then

          1. (Let (noprilpm n) be matchMode)

          2. (Let TBLS be (lpm n))

          3. Result in TBLS, ((( [(default)] )) as keysetExpressionIR)

        2. Else Phantom#1047

        3. If ((((TBLC.mode = (nopri)) \/ (TBLC.mode = (pri))) \/ (TBLC.mode = (prilpm)))), then

          1. (Let TBLS be (nolpm))

          2. Result in TBLS, ((( [(default)] )) as keysetExpressionIR)

        3. Else Phantom#1048

      4. Case (% matches pattern `(_)`)

        1. (Let matchMode be TBLC.mode)

        2. If ((matchMode matches pattern `NOPRILPM%`)), then

          1. (Let (noprilpm n) be matchMode)

          2. (Let TBLS be (lpm 0))

          3. Result in TBLS, ((( [(_)] )) as keysetExpressionIR)

        2. Else Phantom#1049

        3. If ((((TBLC.mode = (nopri)) \/ (TBLC.mode = (pri))) \/ (TBLC.mode = (prilpm)))), then

          1. (Let TBLS be (nolpm))

          2. Result in TBLS, ((( [(_)] )) as keysetExpressionIR)

        3. Else Phantom#1050

      5. Case (% matches pattern `(%,%)`)

        1. (Let (( simpleKeysetExpression_h , simpleKeysetExpressionList_t )) be tupleKeysetExpression)

        2. (Let simpleKeysetExpression_t* be $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList_t))

        3. (Let simpleKeysetExpression* be simpleKeysetExpression_h :: simpleKeysetExpression_t*)

        4. If ((|TBLC.keys| = |simpleKeysetExpression*|)), then

          1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ simpleKeysetExpression* : TBLS simpleKeysetExpressionIR*)

          2. Result in TBLS, ((( simpleKeysetExpressionIR* )) as keysetExpressionIR)

        4. Else Phantom#1051

1. Else Phantom#1052

2. If ((keysetExpression has type simpleKeysetExpression)), then

  1. (Let simpleKeysetExpression be (keysetExpression as simpleKeysetExpression))

  2. Case analysis on simpleKeysetExpression

    1. Case (% matches pattern `%&&&%`)

      1. (Let (expression_l &&& expression_r) be simpleKeysetExpression)

      2. If ((|TBLC.keys| = 1)), then

        1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ [(expression_l &&& expression_r)] : TBLS simpleKeysetExpressionIR'*)

        2. If ((simpleKeysetExpressionIR'* matches pattern [ _/1 ])), then

          1. (Let [simpleKeysetExpressionIR] be simpleKeysetExpressionIR'*)

          2. Result in TBLS, (simpleKeysetExpressionIR as keysetExpressionIR)

        2. Else Phantom#1053

      2. Else Phantom#1054

    2. Case (% matches pattern `%..%`)

      1. (Let (expression_l .. expression_r) be simpleKeysetExpression)

      2. If ((|TBLC.keys| = 1)), then

        1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ [(expression_l .. expression_r)] : TBLS simpleKeysetExpressionIR'*)

        2. If ((simpleKeysetExpressionIR'* matches pattern [ _/1 ])), then

          1. (Let [simpleKeysetExpressionIR] be simpleKeysetExpressionIR'*)

          2. Result in TBLS, (simpleKeysetExpressionIR as keysetExpressionIR)

        2. Else Phantom#1055

      2. Else Phantom#1056

    3. Case (% matches pattern `DEFAULT`)

      1. (Let matchMode be TBLC.mode)

      2. If ((matchMode matches pattern `NOPRILPM%`)), then

        1. (Let (noprilpm n) be matchMode)

        2. (Let TBLS be (lpm n))

        3. Result in TBLS, ((default) as keysetExpressionIR)

      2. Else Phantom#1057

      3. If ((((TBLC.mode = (nopri)) \/ (TBLC.mode = (pri))) \/ (TBLC.mode = (prilpm)))), then

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((default) as keysetExpressionIR)

      3. Else Phantom#1058

    4. Case (% matches pattern `_`)

      1. (Let matchMode be TBLC.mode)

      2. If ((matchMode matches pattern `NOPRILPM%`)), then

        1. (Let (noprilpm n) be matchMode)

        2. (Let TBLS be (lpm 0))

        3. Result in TBLS, ((_) as keysetExpressionIR)

      2. Else Phantom#1059

      3. If ((((TBLC.mode = (nopri)) \/ (TBLC.mode = (pri))) \/ (TBLC.mode = (prilpm)))), then

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((_) as keysetExpressionIR)

      3. Else Phantom#1060

  2. Else Phantom#1061

2. Else Phantom#1062

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:215:1-217:23:
relation TableEntry_action_ok: TC, TBLC, tableActionReference

1. If ((tableActionReference has type prefixedNonTypeName)), then

  1. (Let prefixedNonTypeName be (tableActionReference as prefixedNonTypeName))

  2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

  3. If ((?(([], [])) = $find_action(TBLC, prefixedNameIR))), then

    1. Result in (prefixedNameIR ( [] ))

  3. Else Phantom#1063

1. Else Phantom#1064

2. If ((tableActionReference matches pattern `%(%)`)), then

  1. (Let (prefixedNonTypeName ( argumentList )) be tableActionReference)

  2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

  3. (Let (parameterTypeIR*, argumentListIR)? be $find_action(TBLC, prefixedNameIR))

  4. If (((parameterTypeIR*, argumentListIR)? matches pattern (_))), then

    1. (Let ?((parameterTypeIR_action*, argumentIR_action*)) be (parameterTypeIR*, argumentListIR)?)

    2. (Let argument* be $flatten_argumentList(argumentList))

    3. (Argument_ok: (local) TC |- argument : argumentIR)*

    4. (Call_action_default_ok: TC |- parameterTypeIR_action* @ argumentIR* : parameterTypeIR_action_data* , parameterTypeIR_action_control* @ argumentIR_cast*)

    5. (Let argumentIR_action_data* be argumentIR_action*[0 : |parameterTypeIR_action_data*|])

    6. (Let argumentIR_cast_data* be argumentIR_cast*[0 : |parameterTypeIR_action_data*|])

    7. If ((argumentIR_action_data = argumentIR_cast_data))*, then

      1. Result in (prefixedNameIR ( argumentIR_cast* ))

    7. Else Phantom#1065

  4. Else Phantom#1066

2. Else Phantom#1067

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:219:1-222:26:
relation TableEntry_priority_ok: TC, TBLC', TBLS, tableEntryPriority''?

1. Case analysis on tableEntryPriority''?

  1. Case (% matches pattern ())

    1. If ((TBLC'.mode matches pattern `NOPRI`)), then

      1. Result in TBLC', ?()

    1. Else Phantom#1068

    2. (Let matchMode be TBLC'.mode)

    3. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (noprilpm n) be matchMode)

      2. (Let tableEntryState be TBLS)

      3. If ((tableEntryState matches pattern `LPM%`)), then

        1. (Let (lpm n_prefix) be tableEntryState)

        2. Result in TBLC', ?()

      3. Else Phantom#1069

    3. Else Phantom#1070

    4. If (((TBLC'.mode = (pri)) \/ (TBLC'.mode = (prilpm)))), then

      1. Case analysis on TBLC'.priorities.values

        1. Case (% = [])

          1. Case analysis on TBLC'.priorities.largest_wins

            1. Case true

              1. (Let n_size be TBLC'.entries.size)

              2. (Let n_delta be TBLC'.priorities.delta)

              3. (Let n be (((n_size - 1) * n_delta) + 1))

              4. (Let TBLC_1 be $add_table_priority(TBLC', n))

              5. Result in TBLC_1, ?((priority= (d (n as int)) :))

            2. Case false

              1. (Let TBLC_1 be $add_table_priority(TBLC', 1))

              2. Result in TBLC_1, ?((priority= (d (1 as int)) :))

        2. Case (% =/= [])

          1. Case analysis on TBLC'.priorities.largest_wins

            1. Case true

              1. (Let n_last be $find_table_priority_last(TBLC'))

              2. (Let n_delta be TBLC'.priorities.delta)

              3. (Let n be (n_last - n_delta))

              4. (Let TBLC_1 be $add_table_priority(TBLC', n))

              5. Result in TBLC_1, ?((priority= (d (n as int)) :))

            2. Case false

              1. (Let n_last be $find_table_priority_last(TBLC'))

              2. (Let n_delta be TBLC'.priorities.delta)

              3. (Let n be (n_last + n_delta))

              4. (Let TBLC_1 be $add_table_priority(TBLC', n))

              5. Result in TBLC_1, ?((priority= (d (n as int)) :))

    4. Else Phantom#1071

  2. Case (% matches pattern (_))

    1. (Let ?(tableEntryPriority'') be tableEntryPriority''?)

    2. Case analysis on tableEntryPriority''

      1. Case (% matches pattern `PRIORITY=%:`)

        1. (Let (priority= number :) be tableEntryPriority'')

        2. If (((TBLC'.mode = (pri)) \/ (TBLC'.mode = (prilpm)))), then

          1. If (~TBLC'.entries.const), then

            1. Case analysis on TBLC'.priorities.values

              1. Case (% = [])

                1. (Let int be $to_number((number as value)))

                2. If ((int has type nat)), then

                  1. (Let n be (int as nat))

                  2. (Let TBLC_1 be TBLC'[priorities.init = true])

                  3. (Let TBLC_2 be $add_table_priority(TBLC_1, n))

                  4. Result in TBLC_2, ?((priority= number :))

                2. Else Phantom#1072

              2. Case (% =/= [])

                1. If (TBLC'.priorities.init), then

                  1. (Let int be $to_number((number as value)))

                  2. If ((int has type nat)), then

                    1. (Let n be (int as nat))

                    2. (Let TBLC_1 be $add_table_priority(TBLC', n))

                    3. Result in TBLC_1, ?((priority= number :))

                  2. Else Phantom#1073

                1. Else Phantom#1074

          1. Else Phantom#1075

        2. Else Phantom#1076

      2. Case (% matches pattern `PRIORITY=(%):`)

        1. (Let (priority=( expression ):) be tableEntryPriority'')

        2. If (((TBLC'.mode = (pri)) \/ (TBLC'.mode = (prilpm)))), then

          1. If (~TBLC'.entries.const), then

            1. Case analysis on TBLC'.priorities.values

              1. Case (% = [])

                1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

                2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR)

                3. If ((ctk matches pattern `LCTK`)), then

                  1. (Eval_static: (local) TC |- typedExpressionIR ~> value)

                  2. (Let int be $to_number(value))

                  3. If ((int has type nat)), then

                    1. (Let n be (int as nat))

                    2. (Let TBLC_1 be TBLC'[priorities.init = true])

                    3. (Let TBLC_2 be $add_table_priority(TBLC_1, n))

                    4. Result in TBLC_2, ?((priority=( typedExpressionIR ):))

                  3. Else Phantom#1077

                3. Else Phantom#1078

              2. Case (% =/= [])

                1. If (TBLC'.priorities.init), then

                  1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

                  2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR)

                  3. If ((ctk matches pattern `LCTK`)), then

                    1. (Eval_static: (local) TC |- typedExpressionIR ~> value)

                    2. (Let int be $to_number(value))

                    3. If ((int has type nat)), then

                      1. (Let n be (int as nat))

                      2. (Let TBLC_1 be $add_table_priority(TBLC', n))

                      3. Result in TBLC_1, ?((priority=( typedExpressionIR ):))

                    3. Else Phantom#1079

                  3. Else Phantom#1080

                1. Else Phantom#1081

          1. Else Phantom#1082

        2. Else Phantom#1083

    2. Else Phantom#1084

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:224:1-226:23:
relation TableEntry_ok: TC, TBLC_0, tableEntry

1. Case analysis on tableEntry

  1. Case (% matches pattern `%%%:%%;`)

    1. (Let (constOpt tableEntryPriority keysetExpression : tableActionReference annotationList ;) be tableEntry)

    2. (TableEntry_keyset_ok: TC TBLC_0 |- keysetExpression : TBLS keysetExpressionIR)

    3. (TableEntry_action_ok: TC TBLC_0 |- tableActionReference : tableActionReferenceIR)

    4. (TableEntry_priority_ok: TC TBLC_0 TBLS |- ?(tableEntryPriority) : TBLC_1 tableEntryPriorityOptIR)

    5. (Let constOptIR be $flatten_constOpt(constOpt))

    6. (Let tableEntryIR be (constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;))

    7. Result in TBLC_1, tableEntryIR

  2. Case (% matches pattern `%%:%%;`)

    1. (Let (constOpt keysetExpression : tableActionReference annotationList ;) be tableEntry)

    2. (TableEntry_keyset_ok: TC TBLC_0 |- keysetExpression : TBLS keysetExpressionIR)

    3. (TableEntry_action_ok: TC TBLC_0 |- tableActionReference : tableActionReferenceIR)

    4. (TableEntry_priority_ok: TC TBLC_0 TBLS |- ?() : TBLC_1 tableEntryPriorityOptIR)

    5. (Let constOptIR be $flatten_constOpt(constOpt))

    6. (Let tableEntryIR be (constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;))

    7. Result in TBLC_1, tableEntryIR

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:228:1-230:23:
relation TableEntries_ok: TC, TBLC', tableEntry*

1. Case analysis on tableEntry*

  1. Case (% matches pattern [])

    1. Result in TBLC', []

  2. Case (% matches pattern _ :: _)

    1. (Let tableEntry_h :: tableEntry_t* be tableEntry*)

    2. (TableEntry_ok: TC TBLC' |- tableEntry_h : TBLC_1 tableEntryIR_h)

    3. (TableEntries_ok: TC TBLC_1 |- tableEntry_t* : TBLC_2 tableEntryIR_t*)

    4. Result in TBLC_2, tableEntryIR_h :: tableEntryIR_t*

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:232:1-234:23:
relation TableProperty_ok: TC, TBLC_0', tableProperty

1. Case analysis on tableProperty

  1. Case (% matches pattern `KEY={%}`)

    1. (Let (key={ tableKeyList }) be tableProperty)

    2. (Let tableKey* be $flatten_tableKeyList(tableKeyList))

    3. (TableKeys_ok: TC TBLC_0' |- tableKey* : TBLC_1 tableKeyIR*)

    4. Result in TBLC_1, (key={ tableKeyIR* })

  2. Case (% matches pattern `ACTIONS={%}`)

    1. (Let (actions={ tableActionList }) be tableProperty)

    2. (Let tableAction* be $flatten_tableActionList(tableActionList))

    3. (TableActions_ok: TC TBLC_0' |- tableAction* : TBLC_1 tableActionIR*)

    4. Result in TBLC_1, (actions={ tableActionIR* })

  3. Case (% matches pattern `%%ENTRIES={%}`)

    1. (Let (annotationList constOpt entries={ tableEntryList }) be tableProperty)

    2. (Let tableEntry* be $flatten_tableEntryList(tableEntryList))

    3. If (((|TBLC_0'.keys| = 0) => (|tableEntry*| = 0))), then

      1. (Let TBLC_1 be TBLC_0'[entries.size = |tableEntry*|])

      2. (Let constOptIR be $flatten_constOpt(constOpt))

      3. (Let TBLC_2 be TBLC_1[entries.const = (constOptIR = ?((const)))])

      4. (TableEntries_ok: TC TBLC_2 |- tableEntry* : TBLC_3 tableEntryIR*)

      5. Result in TBLC_3, (annotationList constOptIR entries={ tableEntryIR* })

    3. Else Phantom#1085

  4. Case (% matches pattern `%%%%;`)

    1. (Let (annotationList constOpt tableCustomName initializer ;) be tableProperty)

    2. If (("default_action" = $tableCustomName(tableCustomName))), then

      1. (TableDefaultAction_ok: TC TBLC_0' |- initializer : tableActionReferenceIR)

      2. (Let constOptIR be $flatten_constOpt(constOpt))

      3. (Let tablePropertyIR be (annotationList constOptIR default_action= tableActionReferenceIR ;))

      4. Result in TBLC_0', tablePropertyIR

    2. Else Phantom#1086

    3. (Let (annotationList constOpt tableCustomName (= expression) ;) be tableProperty)

    4. If (("size" = $tableCustomName(tableCustomName))), then

      1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

      2. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

      3. If ((($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))), then

        1. (Let constOptIR be $flatten_constOpt(constOpt))

        2. (Let tablePropertyIR be (annotationList constOptIR custom "size" (= typedExpressionIR) ;))

        3. Result in TBLC_0', tablePropertyIR

      3. Else Phantom#1087

    4. Else Phantom#1088

    5. If (("largest_priority_wins" = $tableCustomName(tableCustomName))), then

      1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

      2. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

      3. If ((typeIR has type primitiveTypeIR)), then

        1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

        2. If ((primitiveTypeIR matches pattern `BOOL`)), then

          1. (Eval_static: (local) TC |- typedExpressionIR ~> value)

          2. If ((value has type primitiveValue)), then

            1. (Let primitiveValue be (value as primitiveValue))

            2. If ((primitiveValue matches pattern `B%`)), then

              1. (Let (b b_largest_priority_wins) be primitiveValue)

              2. (Let TBLC_1 be TBLC_0'[priorities.largest_wins = b_largest_priority_wins])

              3. (Let constOptIR be $flatten_constOpt(constOpt))

              4. (Let tablePropertyIR be (annotationList constOptIR custom_const "largest_priority_wins" (= ((b b_largest_priority_wins) as value)) ;))

              5. Result in TBLC_1, tablePropertyIR

            2. Else Phantom#1089

          2. Else Phantom#1090

        2. Else Phantom#1091

      3. Else Phantom#1092

    5. Else Phantom#1093

    6. If (("priority_delta" = $tableCustomName(tableCustomName))), then

      1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

      2. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

      3. If ((($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))), then

        1. (Eval_static: (local) TC |- typedExpressionIR ~> value)

        2. (Let int be $to_number(value))

        3. If ((int has type nat)), then

          1. (Let n_delta be (int as nat))

          2. If ((n_delta > 0)), then

            1. (Let TBLC_1 be TBLC_0'[priorities.delta = n_delta])

            2. (Let constOptIR be $flatten_constOpt(constOpt))

            3. (Let tablePropertyIR be (annotationList constOptIR custom_const "priority_delta" (= ((d (n_delta as int)) as value)) ;))

            4. Result in TBLC_1, tablePropertyIR

          2. Else Phantom#1094

        3. Else Phantom#1095

      3. Else Phantom#1096

    6. Else Phantom#1097

    7. (Let nameIR be $tableCustomName(tableCustomName))

    8. If ((((nameIR =/= "size") /\ (nameIR =/= "largest_priority_wins")) /\ (nameIR =/= "priority_delta"))), then

      1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

      2. (Let constOptIR be $flatten_constOpt(constOpt))

      3. (Let tablePropertyIR be (annotationList constOptIR custom nameIR (= typedExpressionIR) ;))

      4. Result in TBLC_0', tablePropertyIR

    8. Else Phantom#1098

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:236:1-238:23:
relation TableProperties_ok: TC, TBLC', tableProperty*

1. Case analysis on tableProperty*

  1. Case (% matches pattern [])

    1. Result in TBLC', []

  2. Case (% matches pattern _ :: _)

    1. (Let tableProperty_h :: tableProperty_t* be tableProperty*)

    2. (TableProperty_ok: TC TBLC' |- tableProperty_h : TBLC_1 tablePropertyIR_h)

    3. (TableProperties_ok: TC TBLC_1 |- tableProperty_t* : TBLC_2 tablePropertyIR_t*)

    4. Result in TBLC_2, tablePropertyIR_h :: tablePropertyIR_t*

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:240:1-242:20:
relation Table_ok: TC, tableProperty*

1. If (($count_table_keys(tableProperty*) <= 1)), then

  1. If (($count_table_actions(tableProperty*) = 1)), then

    1. (Let TBLC_0 be $empty_tableContext)

    2. (TableProperties_ok: TC TBLC_0 |- tableProperty* : TBLC_1 tablePropertyIR*)

    3. Result in TBLC_1, tablePropertyIR*

  1. Else Phantom#1099

1. Else Phantom#1100

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:244:1-246:23:
relation TableType_ok: TC_0, TBLC, name

1. (Let nameIR be $name(name))

2. (Let tid_enum be "action_list(" ++ nameIR ++ ")")

3. (Let (prefixedNameIR_action, _parameterTypeIR*, _argumentListIR)* be TBLC.actions)

4. (Let id_enum_field be $flatten_prefixedNameIR(prefixedNameIR_action))*

5. (Let typeIR_table_enum be ((table_enum tid_enum { id_enum_field* }) as typeIR))

6. (Let value_enum_field be ((table_enum tid_enum . id_enum_field) as value))*

7. (Let varTypeIR_enum_field be (() typeIR_table_enum (lctk) ?(value_enum_field)))*

8. (Let TC_1 be $add_vars((block), TC_0, tid_enum ++ "." ++ id_enum_field*, varTypeIR_enum_field*))

9. (Let tid_struct be "apply_result(" ++ nameIR ++ ")")

10. (Let typeIR_table_struct be ((table_struct tid_struct { [(((bool) as typeIR) "hit" ;), (((bool) as typeIR) "miss" ;), (typeIR_table_enum "action_run" ;)] }) as typeIR))

11. (Let typeIR_table be ((table nameIR # typeIR_table_struct) as typeIR))

12. Result in TC_1, typeIR_table

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:248:1-251:20:
relation ControlLocalDecl_ok: TC_0, controlLocalDeclaration

1. Case analysis on controlLocalDeclaration

  1. Case (% has type constantDeclaration)

    1. (Let constantDeclaration be (controlLocalDeclaration as constantDeclaration))

    2. (Decl_ok: (block) TC_0 |- (constantDeclaration as declaration) : TC_1 declarationIR)

    3. If ((declarationIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (declarationIR as constantDeclarationIR))

      2. Result in TC_1, (constantDeclarationIR as controlLocalDeclarationIR)

    3. Else Phantom#1101

  2. Case (% has type instantiation)

    1. (Let instantiation be (controlLocalDeclaration as instantiation))

    2. (Decl_ok: (block) TC_0 |- (instantiation as declaration) : TC_1 declarationIR)

    3. If ((declarationIR has type instantiationIR)), then

      1. (Let instantiationIR be (declarationIR as instantiationIR))

      2. Result in TC_1, (instantiationIR as controlLocalDeclarationIR)

    3. Else Phantom#1102

  3. Case (% has type variableDeclaration)

    1. (Let (annotationList type name initializerOpt ;) be (controlLocalDeclaration as variableDeclaration))

    2. If ((initializerOpt matches pattern ``EMPTY`)), then

      1. (Type_ok: (block) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

      2. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((block), TC_0) |- typeIR holds)), then

          1. If ($is_assignable_typeIR(typeIR)), then

            1. (Let nameIR be $name(name))

            2. (Let TC_1 be $add_var((block), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

            3. (Let variableDeclarationIR be (annotationList typeIR nameIR ?() ;))

            4. Result in TC_1, (variableDeclarationIR as controlLocalDeclarationIR)

          1. Else Phantom#1103

        1. Else Phantom#1104

      2. Else Phantom#1105

    2. Else Phantom#1106

    3. If ((initializerOpt has type initializer)), then

      1. (Let (= expression_init) be (initializerOpt as initializer))

      2. (Type_ok: (block) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

      3. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((block), TC_0) |- typeIR holds)), then

          1. If ($is_assignable_typeIR(typeIR)), then

            1. (Expr_ok: (block) TC_0 |- expression_init : typedExpressionIR_init)

            2. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_init, typeIR))

            3. If ((typedExpressionIR? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?)

              2. (Let nameIR be $name(name))

              3. (Let TC_1 be $add_var((block), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

              4. (Let variableDeclarationIR be (annotationList typeIR nameIR ?((= typedExpressionIR_init_cast)) ;))

              5. Result in TC_1, (variableDeclarationIR as controlLocalDeclarationIR)

            3. Else Phantom#1107

          1. Else Phantom#1108

        1. Else Phantom#1109

      3. Else Phantom#1110

    3. Else Phantom#1111

  4. Case (% has type actionDeclaration)

    1. (Let actionDeclaration be (controlLocalDeclaration as actionDeclaration))

    2. (Decl_ok: (block) TC_0 |- (actionDeclaration as declaration) : TC_1 declarationIR)

    3. If ((declarationIR has type actionDeclarationIR)), then

      1. (Let actionDeclarationIR be (declarationIR as actionDeclarationIR))

      2. Result in TC_1, (actionDeclarationIR as controlLocalDeclarationIR)

    3. Else Phantom#1112

  5. Case (% has type tableDeclaration)

    1. (Let (annotationList table name { tablePropertyList }) be (controlLocalDeclaration as tableDeclaration))

    2. (Let TC_1 be TC_0[local.kind = (table_apply_method)])

    3. (Let tableProperty* be $flatten_tablePropertyList(tablePropertyList))

    4. (Table_ok: TC_1 |- tableProperty* : TBLC tablePropertyIR*)

    5. (Let nameIR be $name(name))

    6. (TableType_ok: TC_1 TBLC |- name : TC_2 typeIR_table)

    7. (Let TC_3 be $add_var((block), TC_2, nameIR, (() typeIR_table (dyn) ?())))

    8. (Let tableDeclarationIR be (annotationList table typeIR_table nameIR { tablePropertyIR* }))

    9. Result in TC_3, (tableDeclarationIR as controlLocalDeclarationIR)

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:253:1-256:20:
relation ControlLocalDecls_ok: TC', controlLocalDeclaration*

1. Case analysis on controlLocalDeclaration*

  1. Case (% matches pattern [])

    1. Result in TC', []

  2. Case (% matches pattern _ :: _)

    1. (Let controlLocalDeclaration_h :: controlLocalDeclaration_t* be controlLocalDeclaration*)

    2. (ControlLocalDecl_ok: TC' |- controlLocalDeclaration_h : TC_1 controlLocalDeclarationIR_h)

    3. (ControlLocalDecls_ok: TC_1 |- controlLocalDeclaration_t* : TC_2 controlLocalDeclarationIR_t*)

    4. Result in TC_2, controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:262:1-264:23:
relation Decl_ok: p', TC_0, declaration

1. Case analysis on declaration

  1. Case (% has type constantDeclaration)

    1. (Let (annotationList const type name (= expression_value) ;) be (declaration as constantDeclaration))

    2. (Type_ok: p' TC_0 |- (type as typeOrVoid) : typeIR # tid*)

    3. If ((tid* matches pattern [])), then

      1. If ((Type_wf: $bound(p', TC_0) |- typeIR holds)), then

        1. (Expr_ok: p' TC_0 |- expression_value : typedExpressionIR_value)

        2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR_value)

        3. If ((ctk matches pattern `LCTK`)), then

          1. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_value, typeIR))

          2. If ((typedExpressionIR? matches pattern (_))), then

            1. (Let ?(typedExpressionIR_value_cast) be typedExpressionIR?)

            2. (Eval_static: p' TC_0 |- typedExpressionIR_value_cast ~> value)

            3. (Let nameIR be $name(name))

            4. (Let TC_1 be $add_var(p', TC_0, nameIR, (() typeIR (lctk) ?(value))))

            5. (Let constantDeclarationIR be (annotationList const typeIR nameIR (= value) ;))

            6. Result in TC_1, (constantDeclarationIR as declarationIR)

          2. Else Phantom#1113

        3. Else Phantom#1114

      1. Else Phantom#1115

    3. Else Phantom#1116

  2. Case (% has type instantiation)

    1. (Let instantiation be (declaration as instantiation))

    2. Case analysis on instantiation

      1. Case (% matches pattern `%%(%)%;`)

        1. (Let (annotationList type ( argumentList ) name ;) be instantiation)

        2. Case analysis on type

          1. Case (% has type prefixedTypeName)

            1. (Let prefixedTypeName be (type as prefixedTypeName))

            2. (Let argument* be $flatten_argumentList(argumentList))

            3. (Argument_ok: p' TC_0 |- argument : argumentIR)*

            4. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

            5. (ConstructorType_ok: p' TC_0 |- prefixedNameIR < [] >( argumentIR* ): constructorTypeIR <# tid_impl* >(# id_default* ))

            6. (Inst_ok: p' TC_0 (named) |- constructorTypeIR < [] # tid_impl* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

            7. (Let nameIR be $name(name))

            8. (Let TC_1 be $add_var(p', TC_0, nameIR, (() typeIR_object (ctk) ?())))

            9. (Let instantiationIR be (annotationList typeIR_object prefixedNameIR < typeArgumentIR_inferred* >( argumentIR* ) nameIR ?() ;))

            10. Result in TC_1, (instantiationIR as declarationIR)

          2. Case (% has type specializedType)

            1. (Let (prefixedTypeName < typeArgumentList >) be (type as specializedType))

            2. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

            3. (TypeArguments_ok: p' TC_0 |- typeArgument* : typeArgumentIR* # tid_impl*)

            4. (Let argument* be $flatten_argumentList(argumentList))

            5. (Argument_ok: p' TC_0 |- argument : argumentIR)*

            6. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

            7. (ConstructorType_ok: p' TC_0 |- prefixedNameIR < typeArgumentIR* >( argumentIR* ): constructorTypeIR <# tid_inserted* >(# id_default* ))

            8. (Let tid_infer* be tid_impl* ++ tid_inserted*)

            9. (Inst_ok: p' TC_0 (named) |- constructorTypeIR < typeArgumentIR* # tid_infer* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

            10. (Let nameIR be $name(name))

            11. (Let TC_1 be $add_var(p', TC_0, nameIR, (() typeIR_object (ctk) ?())))

            12. (Let instantiationIR be (annotationList typeIR_object prefixedNameIR < typeArgumentIR_inferred* >( argumentIR* ) nameIR ?() ;))

            13. Result in TC_1, (instantiationIR as declarationIR)

        2. Else Phantom#1117

      2. Case (% matches pattern `%%(%)%%;`)

        1. (Let (annotationList type ( argumentList ) name (={ objectDeclarationList }) ;) be instantiation)

        2. Case analysis on type

          1. Case (% has type prefixedTypeName)

            1. (Let prefixedTypeName be (type as prefixedTypeName))

            2. (Let argument* be $flatten_argumentList(argumentList))

            3. (Argument_ok: p' TC_0 |- argument : argumentIR)*

            4. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

            5. (ConstructorType_ok: p' TC_0 |- prefixedNameIR < [] >( argumentIR* ): constructorTypeIR <# tid_impl* >(# id_default* ))

            6. (Inst_ok: p' TC_0 (named) |- constructorTypeIR < [] # tid_impl* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

            7. If ($is_extern_object_typeIR($canon(typeIR_object))), then

              1. (Let typeIR' be typeIR_object)

              2. If ((typeIR' has type namedTypeIR)), then

                1. (Let namedTypeIR be (typeIR' as namedTypeIR))

                2. If ((namedTypeIR matches pattern `%<%>`)), then

                  1. (Let ((typeIR < tid_expl* , tid'* >) < typeIR_arg* >) be namedTypeIR)

                  2. If ((typeIR has type externObjectTypeIR)), then

                    1. (Let (extern tid_extern rdenv_extern) be (typeIR as externObjectTypeIR))

                    2. If ((tid'* = tid_impl*)), then

                      1. (Let TC_1 be $add_var((local), TC_0, "this", (() typeIR_object (ctk) ?())))

                      2. (Let objectDeclaration* be $flatten_objectDeclarationList(objectDeclarationList))

                      3. (Decls_object_ok: p' TC_1 ({ [] }) ({ [] }) |- objectDeclaration* : frame_init rdenv_init objectDeclarationIR*)

                      4. (Let tid* be tid_expl* ++ tid_impl*)

                      5. (Let theta be ({ (tid : typeIR_arg)* }))

                      6. (Let rdenv_init_subst be $subst_rdenv(theta, rdenv_extern, rdenv_init))

                      7. (Let typeIR_object_init be (((((extern tid_extern rdenv_init_subst) as typeIR) < tid_expl* , tid_impl* >) < typeIR_arg* >) as typeIR))

                      8. If ($is_concrete_extern_object(typeIR_object_init)), then

                        1. (Let nameIR be $name(name))

                        2. (Let TC_2 be $add_var(p', TC_0, nameIR, (() typeIR_object_init (ctk) ?())))

                        3. (Let instantiationIR be (annotationList typeIR_object_init prefixedNameIR < typeArgumentIR_inferred* >( argumentIR* ) nameIR ?((={ objectDeclarationIR* })) ;))

                        4. Result in TC_2, (instantiationIR as declarationIR)

                      8. Else Phantom#1118

                    2. Else Phantom#1119

                  2. Else Phantom#1120

                2. Else Phantom#1121

              2. Else Phantom#1122

            7. Else Phantom#1123

          2. Case (% has type specializedType)

            1. (Let (prefixedTypeName < typeArgumentList >) be (type as specializedType))

            2. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

            3. (TypeArguments_ok: p' TC_0 |- typeArgument* : typeArgumentIR* # tid_impl*)

            4. (Let argument* be $flatten_argumentList(argumentList))

            5. (Argument_ok: p' TC_0 |- argument : argumentIR)*

            6. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

            7. (ConstructorType_ok: p' TC_0 |- prefixedNameIR < typeArgumentIR* >( argumentIR* ): constructorTypeIR <# tid_inserted* >(# id_default* ))

            8. (Let tid_infer* be tid_impl* ++ tid_inserted*)

            9. (Inst_ok: p' TC_0 (named) |- constructorTypeIR < typeArgumentIR* # tid_infer* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

            10. If ($is_extern_object_typeIR($canon(typeIR_object))), then

              1. (Let typeIR' be typeIR_object)

              2. If ((typeIR' has type namedTypeIR)), then

                1. (Let namedTypeIR be (typeIR' as namedTypeIR))

                2. If ((namedTypeIR matches pattern `%<%>`)), then

                  1. (Let ((typeIR < tid_expl* , tid'* >) < typeIR_arg* >) be namedTypeIR)

                  2. If ((typeIR has type externObjectTypeIR)), then

                    1. (Let (extern tid_extern rdenv_extern) be (typeIR as externObjectTypeIR))

                    2. If ((tid'* = tid_impl*)), then

                      1. (Let TC_1 be $add_var((local), TC_0, "this", (() typeIR_object (ctk) ?())))

                      2. (Let objectDeclaration* be $flatten_objectDeclarationList(objectDeclarationList))

                      3. (Decls_object_ok: p' TC_1 ({ [] }) ({ [] }) |- objectDeclaration* : frame_init rdenv_init objectDeclarationIR*)

                      4. (Let tid* be tid_expl* ++ tid_impl*)

                      5. (Let theta be ({ (tid : typeIR_arg)* }))

                      6. (Let rdenv_init_subst be $subst_rdenv(theta, rdenv_extern, rdenv_init))

                      7. (Let typeIR_object_init be (((((extern tid_extern rdenv_init_subst) as typeIR) < tid_expl* , tid_impl* >) < typeIR_arg* >) as typeIR))

                      8. If ($is_concrete_extern_object(typeIR_object_init)), then

                        1. (Let nameIR be $name(name))

                        2. (Let TC_2 be $add_var(p', TC_0, nameIR, (() typeIR_object_init (ctk) ?())))

                        3. (Let instantiationIR be (annotationList typeIR_object_init prefixedNameIR < typeArgumentIR_inferred* >( argumentIR* ) nameIR ?((={ objectDeclarationIR* })) ;))

                        4. Result in TC_2, (instantiationIR as declarationIR)

                      8. Else Phantom#1124

                    2. Else Phantom#1125

                  2. Else Phantom#1126

                2. Else Phantom#1127

              2. Else Phantom#1128

            10. Else Phantom#1129

        2. Else Phantom#1130

  3. Case (% has type functionDeclaration)

    1. (Let (annotationList (typeOrVoid name typeParameterListOpt ( parameterList )) blockStatement) be (declaration as functionDeclaration))

    2. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

    3. (Let tid_expl be $name(typeParameter))*

    4. (Let TC_1 be $add_types((local), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

    5. (Type_ok: (local) TC_1 |- typeOrVoid : typeIR_ret # tid*)

    6. If ((tid* matches pattern [])), then

      1. (Let parameter* be $flatten_parameterList(parameterList))

      2. (Parameters_ok: (local) TC_1 |- parameter* : parameterIR* # tid_impl*)

      3. (Let parameterTypeIR be $parameterIR(parameterIR))*

      4. (Let TC_2 be $add_parameters((local), TC_1, parameterTypeIR*))

      5. (Let TC_3 be TC_2[local.kind = (function-> typeIR_ret)])

      6. (Block_ok: TC_3 (cont) |- blockStatement : _typingContext f blockStatementIR)

      7. If (((f = (ret)) \/ (typeIR_ret = ((void) as typeIR)))), then

        1. (Let rid be $rid(name, parameterList))

        2. (Let functionTypeIR be (function( parameterTypeIR* )-> typeIR_ret))

        3. (Let routineTypeDefIR be (((functionTypeIR as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

        4. If ((RoutineTypeDef_wf: $bound(p', TC_0) |- routineTypeDefIR holds)), then

          1. (Let TC_4 be $add_routine_overload(p', TC_0, rid, routineTypeDefIR))

          2. (Let nameIR be $name(name))

          3. (Let functionDeclarationIR be (annotationList (typeIR_ret nameIR < tid_expl* , tid_impl* >( parameterIR* )) blockStatementIR))

          4. Result in TC_4, (functionDeclarationIR as declarationIR)

        4. Else Phantom#1131

      7. Else Phantom#1132

    6. Else Phantom#1133

  4. Case (% has type actionDeclaration)

    1. (Let (annotationList action name ( parameterList ) blockStatement) be (declaration as actionDeclaration))

    2. (Let TC_1 be TC_0[local.kind = (action)])

    3. (Let parameter* be $flatten_parameterList(parameterList))

    4. (Parameters_ok: (local) TC_1 |- parameter* : parameterIR* # tid*)

    5. If ((tid* matches pattern [])), then

      1. (Let parameterTypeIR be $parameterIR(parameterIR))*

      2. (Let TC_2 be $add_parameters((local), TC_1, parameterTypeIR*))

      3. (Block_ok: TC_2 (cont) |- blockStatement : _typingContext _flow blockStatementIR)

      4. (Let rid be $rid(name, parameterList))

      5. (Let functionTypeIR be (action( parameterTypeIR* )))

      6. If ((RoutineTypeDef_wf: $bound(p', TC_0) |- (functionTypeIR as routineTypeDefIR) holds)), then

        1. (Let TC_3 be $add_routine_non_overload(p', TC_0, rid, (functionTypeIR as routineTypeDefIR)))

        2. (Let nameIR be $name(name))

        3. (Let actionDeclarationIR be (annotationList action nameIR ( parameterIR* ) blockStatementIR))

        4. Result in TC_3, (actionDeclarationIR as declarationIR)

      6. Else Phantom#1134

    5. Else Phantom#1135

1. Else Phantom#1136

2. If ((p' matches pattern `GLOBAL`)), then

  1. Case analysis on declaration

    1. Case (% has type errorDeclaration)

      1. (Let (error{ nameList }) be (declaration as errorDeclaration))

      2. (Let name* be $flatten_nameList(nameList))

      3. (Let nameIR be $name(name))*

      4. If ($distinct_<nameIR>(nameIR*)), then

        1. (Let nameIR_error be "error." ++ nameIR)*

        2. (Let value_error be ((error. nameIR) as value))*

        3. (Let TC_1 be $add_vars((global), TC_0, nameIR_error*, (() ((error) as typeIR) (lctk) ?(value_error))*))

        4. Result in TC_1, ((error{ nameIR* }) as declarationIR)

      4. Else Phantom#1137

    2. Case (% has type matchKindDeclaration)

      1. (Let (match_kind{ nameList _trailingCommaOpt }) be (declaration as matchKindDeclaration))

      2. (Let name* be $flatten_nameList(nameList))

      3. (Let nameIR be $name(name))*

      4. If ($distinct_<nameIR>(nameIR*)), then

        1. (Let value_match_kind be ((match_kind. nameIR) as value))*

        2. (Let TC_1 be $add_vars((global), TC_0, nameIR*, (() ((match_kind) as typeIR) (lctk) ?(value_match_kind))*))

        3. Result in TC_1, ((match_kind{ nameIR* }) as declarationIR)

      4. Else Phantom#1138

    3. Case (% has type externFunctionDeclaration)

      1. (Let (annotationList extern (typeOrVoid name typeParameterListOpt ( parameterList )) ;) be (declaration as externFunctionDeclaration))

      2. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

      3. (Let tid_expl be $name(typeParameter))*

      4. (Let TC_1 be $add_types((local), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

      5. (Type_ok: (local) TC_1 |- typeOrVoid : typeIR_ret # tid*)

      6. If ((tid* matches pattern [])), then

        1. (Let TC_2 be TC_1[local.kind = (extern_function-> typeIR_ret)])

        2. (Let parameter* be $flatten_parameterList(parameterList))

        3. (Parameters_ok: (local) TC_2 |- parameter* : parameterIR* # tid_impl*)

        4. (Let parameterTypeIR be $parameterIR(parameterIR))*

        5. (Let TC_3 be $add_parameters((local), TC_2, parameterTypeIR*))

        6. (Let rid be $rid(name, parameterList))

        7. (Let functionTypeIR be (extern_function( parameterTypeIR* )-> typeIR_ret))

        8. (Let routineTypeDefIR be (((functionTypeIR as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

        9. If ((RoutineTypeDef_wf: $bound((global), TC_0) |- routineTypeDefIR holds)), then

          1. (Let TC_4 be $add_routine_overload((global), TC_0, rid, routineTypeDefIR))

          2. (Let nameIR be $name(name))

          3. (Let externFunctionDeclarationIR be (annotationList extern (typeIR_ret nameIR < tid_expl* , tid_impl* >( parameterIR* )) ;))

          4. Result in TC_4, (externFunctionDeclarationIR as declarationIR)

        9. Else Phantom#1139

      6. Else Phantom#1140

    4. Case (% has type externObjectDeclaration)

      1. (Let (annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }) be (declaration as externObjectDeclaration))

      2. (Let methodPrototype* be $flatten_methodPrototypeList(methodPrototypeList))

      3. (Let (methodPrototype_constructor*, methodPrototype_method*) be $split_constructors(methodPrototype*))

      4. (Let TC_1 be TC_0[block.kind = (extern)])

      5. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

      6. (Let tid_expl be $name(typeParameter))*

      7. (Let TC_2 be $add_types((block), TC_1, tid_expl*, ((tid tid_expl) as typeDefIR)*))

      8. (Let nameIR be $name((nonTypeName as name)))

      9. (ExternMethods_ok: TC_2 nameIR |- methodPrototype_method* : TC_3 methodPrototypeIR_method*)

      10. (Let typeIR_extern be ((extern nameIR TC_3.block.rdenv) as typeIR))

      11. (Let typeDefIR_extern be ((typeIR_extern < tid_expl* , [] >) as typeDefIR))

      12. (Let TC_4 be $add_type((global), TC_0, nameIR, typeDefIR_extern))

      13. (Let TC_5 be TC_4[block.kind = (extern)])

      14. (Let TC_6 be $add_types((block), TC_5, tid_expl*, ((tid tid_expl) as typeDefIR)*))

      15. (ExternConstructors_ok: TC_6 nameIR |- methodPrototype_constructor* : TC_7 methodPrototypeIR_constructor*)

      16. (Let TC_8 be TC_4[global.cdenv = TC_7.global.cdenv])

      17. (Let externObjectDeclarationIR be (annotationList extern nameIR < tid_expl* , [] >{ methodPrototypeIR_constructor* ++ methodPrototypeIR_method* }))

      18. Result in TC_8, (externObjectDeclarationIR as declarationIR)

    5. Case (% has type parserDeclaration)

      1. (Let (annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList }) be (declaration as parserDeclaration))

      2. If ((typeParameterListOpt matches pattern ``EMPTY`)), then

        1. (Let TC_1 be TC_0[block.kind = (parser)])

        2. (Let constructorParameter* be $flatten_constructorParameterListOpt(constructorParameterListOpt))

        3. (ConstructorParameters_ok: (block) TC_1 |- constructorParameter* : constructorParameterIR* # tid*)

        4. If ((tid* matches pattern [])), then

          1. (Let constructorParameterTypeIR be $constructorParameterIR(constructorParameterIR))*

          2. (Let TC_2 be $add_parameters((block), TC_1, constructorParameterTypeIR*))

          3. (Let parameter* be $flatten_parameterList(parameterList))

          4. (Parameters_ok: (block) TC_2 |- parameter* : parameterIR* # tid'*)

          5. If ((tid'* matches pattern [])), then

            1. (Let parameterTypeIR be $parameterIR(parameterIR))*

            2. (Let TC_3 be $add_parameters((block), TC_2, parameterTypeIR*))

            3. (Let parserLocalDeclaration* be $flatten_parserLocalDeclarationList(parserLocalDeclarationList))

            4. (ParserLocalDecls_ok: TC_3 |- parserLocalDeclaration* : TC_4 parserLocalDeclarationIR*)

            5. (Let TC_5 be TC_4[local.kind = (parser_state)])

            6. (Let parserState* be $flatten_parserStateList(parserStateList))

            7. (ParserStates_ok: TC_5 |- parserState* : parserStateIR*)

            8. (Let methodTypeIR be (parser_apply( parameterTypeIR* )))

            9. If ((RoutineTypeDef_wf: $bound((global), TC_0) |- (methodTypeIR as routineTypeDefIR) holds)), then

              1. (Let cid be $cid(name, constructorParameterListOpt))

              2. (Let typeIR_parser be ((parser( parameterTypeIR* )) as typeIR))

              3. (Let typeIR_parser_spec be (((typeIR_parser < [] , [] >) < [] >) as typeIR))

              4. (Let constructorTypeIR be (constructor( constructorParameterTypeIR* )-> typeIR_parser_spec))

              5. (Let constructorTypeDefIR be (constructorTypeIR < [] , [] >))

              6. If ((ConstructorTypeDef_wf: $bound((global), TC_0) |- constructorTypeDefIR holds)), then

                1. (Let TC_6 be $add_constructor(TC_0, cid, constructorTypeDefIR))

                2. (Let nameIR be $name(name))

                3. (Let parserDeclarationIR be (annotationList parser nameIR < [] >( parameterIR* )( constructorParameterIR* ){ parserLocalDeclarationIR* parserStateIR* }))

                4. Result in TC_6, (parserDeclarationIR as declarationIR)

              6. Else Phantom#1141

            9. Else Phantom#1142

          5. Else Phantom#1143

        4. Else Phantom#1144

      2. Else Phantom#1145

    6. Case (% has type controlDeclaration)

      1. (Let (annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody }) be (declaration as controlDeclaration))

      2. If ((typeParameterListOpt matches pattern ``EMPTY`)), then

        1. (Let TC_1 be TC_0[block.kind = (control)])

        2. (Let constructorParameter* be $flatten_constructorParameterListOpt(constructorParameterListOpt))

        3. (ConstructorParameters_ok: (block) TC_1 |- constructorParameter* : constructorParameterIR* # tid*)

        4. If ((tid* matches pattern [])), then

          1. (Let constructorParameterTypeIR be $constructorParameterIR(constructorParameterIR))*

          2. (Let TC_2 be $add_parameters((block), TC_1, constructorParameterTypeIR*))

          3. (Let parameter* be $flatten_parameterList(parameterList))

          4. (Parameters_ok: (block) TC_2 |- parameter* : parameterIR* # tid'*)

          5. If ((tid'* matches pattern [])), then

            1. (Let parameterTypeIR be $parameterIR(parameterIR))*

            2. (Let TC_3 be $add_parameters((block), TC_2, parameterTypeIR*))

            3. (Let controlLocalDeclaration* be $flatten_controlLocalDeclarationList(controlLocalDeclarationList))

            4. (ControlLocalDecls_ok: TC_3 |- controlLocalDeclaration* : TC_4 controlLocalDeclarationIR*)

            5. (Let TC_5 be TC_4[local.kind = (control_apply_method)])

            6. (Block_ok: TC_5 (cont) |- controlBody : _typingContext _flow controlBodyIR)

            7. (Let methodTypeIR be (control_apply( parameterTypeIR* )))

            8. If ((RoutineTypeDef_wf: $bound((global), TC_0) |- (methodTypeIR as routineTypeDefIR) holds)), then

              1. (Let cid be $cid(name, constructorParameterListOpt))

              2. (Let typeIR_control be ((control( parameterTypeIR* )) as typeIR))

              3. (Let typeIR_control_spec be (((typeIR_control < [] , [] >) < [] >) as typeIR))

              4. (Let constructorTypeIR be (constructor( constructorParameterTypeIR* )-> typeIR_control_spec))

              5. (Let constructorTypeDefIR be (constructorTypeIR < [] , [] >))

              6. If ((ConstructorTypeDef_wf: $bound((global), TC_0) |- constructorTypeDefIR holds)), then

                1. (Let TC_6 be $add_constructor(TC_0, cid, constructorTypeDefIR))

                2. (Let nameIR be $name(name))

                3. (Let controlDeclarationIR be (annotationList control nameIR < [] >( parameterIR* )( constructorParameterIR* ){ controlLocalDeclarationIR* apply controlBodyIR }))

                4. Result in TC_6, (controlDeclarationIR as declarationIR)

              6. Else Phantom#1146

            8. Else Phantom#1147

          5. Else Phantom#1148

        4. Else Phantom#1149

      2. Else Phantom#1150

    7. Case (% has type enumTypeDeclaration)

      1. (Let enumTypeDeclaration be (declaration as enumTypeDeclaration))

      2. Case analysis on enumTypeDeclaration

        1. Case (% matches pattern `%ENUM%{%%}`)

          1. (Let (annotationList enum name { nameList_field _trailingCommaOpt }) be enumTypeDeclaration)

          2. (Let nameIR be $name(name))

          3. (Let name_field* be $flatten_nameList(nameList_field))

          4. (Let nameIR_field be $name(name_field))*

          5. (Let typeIR_enum be ((enum nameIR { nameIR_field* }) as typeIR))

          6. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_enum as typeDefIR) holds)), then

            1. (Let TC_1 be $add_type((global), TC_0, nameIR, (typeIR_enum as typeDefIR)))

            2. (Let id_field be nameIR ++ "." ++ nameIR_field)*

            3. (Let value_field be ((nameIR . nameIR_field) as value))*

            4. (Let TC_2 be $add_vars((global), TC_1, id_field*, (() typeIR_enum (lctk) ?(value_field))*))

            5. (Let enumTypeDeclarationIR be (annotationList enum nameIR { nameIR_field* }))

            6. Result in TC_2, (enumTypeDeclarationIR as declarationIR)

          6. Else Phantom#1151

        2. Case (% matches pattern `%ENUM%%{%%}`)

          1. (Let (annotationList enum type name { namedExpressionList_field _trailingCommaOpt }) be enumTypeDeclaration)

          2. (Type_ok: (global) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

          3. If ((tid* matches pattern [])), then

            1. If ((Type_wf: $bound((global), TC_0) |- typeIR holds)), then

              1. (Let nameIR be $name(name))

              2. (Let namedExpression_field* be $flatten_namedExpressionList(namedExpressionList_field))

              3. (Enum_serializable_fields_ok: TC_0 nameIR typeIR |- namedExpression_field* : TC_1 namedExpressionIR_field* # value_field*)

              4. (Let (nameIR_field = _typedExpressionIR) be namedExpressionIR_field)*

              5. (Let id_field be nameIR ++ "." ++ nameIR_field)*

              6. (Let typeIR_enum be ((enum nameIR # typeIR { (nameIR_field = value_field ;)* }) as typeIR))

              7. (Let TC_2 be $add_vars((global), TC_0, id_field*, (() typeIR_enum (lctk) ?(value_field))*))

              8. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_enum as typeDefIR) holds)), then

                1. (Let TC_3 be $add_type((global), TC_2, nameIR, (typeIR_enum as typeDefIR)))

                2. (Let enumTypeDeclarationIR be (annotationList enum typeIR nameIR { namedExpressionIR_field* }))

                3. Result in TC_3, (enumTypeDeclarationIR as declarationIR)

              8. Else Phantom#1152

            1. Else Phantom#1153

          3. Else Phantom#1154

    8. Case (% has type structTypeDeclaration)

      1. (Let (annotationList struct name typeParameterListOpt { typeFieldList }) be (declaration as structTypeDeclaration))

      2. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

      3. (Let tid_expl be $name(typeParameter))*

      4. (Let TC_1 be $add_types((block), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

      5. (Let (annotationList_field type_field name_field ;)* be $flatten_typeFieldList(typeFieldList))

      6. (Type_ok: (block) TC_1 |- (type_field as typeOrVoid) : typeIR_field # tid_impl_field*)*

      7. (Let tid_impl* be $concat_<tid>(tid_impl_field**))

      8. (Let nameIR be $name(name))

      9. (Let nameIR_field be $name(name_field))*

      10. (Let typeIR_struct be ((struct nameIR { (typeIR_field nameIR_field ;)* }) as typeIR))

      11. (Let typeDefIR_struct be ((typeIR_struct < tid_expl* , tid_impl* >) as typeDefIR))

      12. If ((TypeDef_wf: $bound((global), TC_0) |- typeDefIR_struct holds)), then

        1. (Let TC_2 be $add_type((global), TC_0, nameIR, typeDefIR_struct))

        2. (Let structTypeDeclarationIR be (annotationList struct nameIR < tid_expl* , tid_impl* >{ (annotationList_field typeIR_field nameIR_field ;)* }))

        3. Result in TC_2, (structTypeDeclarationIR as declarationIR)

      12. Else Phantom#1155

    9. Case (% has type headerTypeDeclaration)

      1. (Let (annotationList header name typeParameterListOpt { typeFieldList }) be (declaration as headerTypeDeclaration))

      2. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

      3. (Let tid_expl be $name(typeParameter))*

      4. (Let TC_1 be $add_types((block), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

      5. (Let (annotationList_f type_f name_f ;)* be $flatten_typeFieldList(typeFieldList))

      6. (Type_ok: (block) TC_1 |- (type_f as typeOrVoid) : typeIR_f # tid_impl_f*)*

      7. (Let tid_impl* be $concat_<tid>(tid_impl_f**))

      8. (Let nameIR be $name(name))

      9. (Let nameIR_f be $name(name_f))*

      10. (Let typeIR_header be ((header nameIR { (typeIR_f nameIR_f ;)* }) as typeIR))

      11. (Let typeDefIR_header be ((typeIR_header < tid_expl* , tid_impl* >) as typeDefIR))

      12. If ((TypeDef_wf: $bound((global), TC_0) |- typeDefIR_header holds)), then

        1. (Let TC_2 be $add_type((global), TC_0, nameIR, typeDefIR_header))

        2. (Let headerTypeDeclarationIR be (annotationList header nameIR < tid_expl* , tid_impl* >{ (annotationList_f typeIR_f nameIR_f ;)* }))

        3. Result in TC_2, (headerTypeDeclarationIR as declarationIR)

      12. Else Phantom#1156

    10. Case (% has type headerUnionTypeDeclaration)

      1. (Let (annotationList header_union name typeParameterListOpt { typeFieldList }) be (declaration as headerUnionTypeDeclaration))

      2. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

      3. (Let tid_expl be $name(typeParameter))*

      4. (Let TC_1 be $add_types((block), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

      5. (Let (annotationList_f type_f name_f ;)* be $flatten_typeFieldList(typeFieldList))

      6. (Type_ok: (block) TC_1 |- (type_f as typeOrVoid) : typeIR_f # tid_impl_f*)*

      7. (Let tid_impl* be $concat_<tid>(tid_impl_f**))

      8. (Let nameIR be $name(name))

      9. (Let nameIR_f be $name(name_f))*

      10. (Let typeIR_union be ((header_union nameIR { (typeIR_f nameIR_f ;)* }) as typeIR))

      11. (Let typeDefIR_union be ((typeIR_union < tid_expl* , tid_impl* >) as typeDefIR))

      12. If ((TypeDef_wf: $bound((global), TC_0) |- typeDefIR_union holds)), then

        1. (Let TC_2 be $add_type((global), TC_0, nameIR, typeDefIR_union))

        2. (Let headerUnionTypeDeclarationIR be (annotationList header_union nameIR < tid_expl* , tid_impl* >{ (annotationList_f typeIR_f nameIR_f ;)* }))

        3. Result in TC_2, (headerUnionTypeDeclarationIR as declarationIR)

      12. Else Phantom#1157

    11. Case (% has type typedefDeclaration)

      1. (Let typedefDeclaration be (declaration as typedefDeclaration))

      2. Case analysis on typedefDeclaration

        1. Case (% matches pattern `%TYPEDEF%%;`)

          1. (Let (annotationList typedef typedefType name ;) be typedefDeclaration)

          2. Case analysis on typedefType

            1. Case (% has type type)

              1. (Let type be (typedefType as type))

              2. (Type_ok: (global) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

              3. If ((tid* matches pattern [])), then

                1. If ((Type_wf: $bound((global), TC_0) |- typeIR holds)), then

                  1. (Let nameIR be $name(name))

                  2. (Let typeIR_typedef be ((typedef nameIR typeIR) as typeIR))

                  3. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_typedef as typeDefIR) holds)), then

                    1. (Let TC_1 be $add_type((global), TC_0, nameIR, (typeIR_typedef as typeDefIR)))

                    2. (Let typedefDeclarationIR be (annotationList typedef (typeIR as typedefTypeIR) nameIR ;))

                    3. Result in TC_1, (typedefDeclarationIR as declarationIR)

                  3. Else Phantom#1158

                1. Else Phantom#1159

              3. Else Phantom#1160

            2. Case (% has type derivedTypeDeclaration)

              1. (Let derivedTypeDeclaration be (typedefType as derivedTypeDeclaration))

              2. (Decl_ok: (global) TC_0 |- (derivedTypeDeclaration as declaration) : TC_1 declarationIR)

              3. If ((declarationIR has type derivedTypeDeclarationIR)), then

                1. (Let derivedTypeDeclarationIR be (declarationIR as derivedTypeDeclarationIR))

                2. (Let ({ tid'* }) be $diff_set<tid>($dom_map<tid, typeDefIR>(TC_1.global.tdenv), $dom_map<tid, typeDefIR>(TC_0.global.tdenv)))

                3. If ((tid'* matches pattern [ _/1 ])), then

                  1. (Let [tid] be tid'*)

                  2. (Let typeDefIR'? be $find_type((global), TC_1, (` tid)))

                  3. If ((typeDefIR'? matches pattern (_))), then

                    1. (Let ?(typeDefIR) be typeDefIR'?)

                    2. Case analysis on typeDefIR

                      1. Case (% has type typeIR)

                        1. (Let typeIR be (typeDefIR as typeIR))

                        2. (Let nameIR be $name(name))

                        3. (Let typeIR_typedef be ((typedef nameIR typeIR) as typeIR))

                        4. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_typedef as typeDefIR) holds)), then

                          1. (Let TC_2 be $add_type((global), TC_0, nameIR, (typeIR_typedef as typeDefIR)))

                          2. (Let typedefDeclarationIR be (annotationList typedef (derivedTypeDeclarationIR as typedefTypeIR) nameIR ;))

                          3. Result in TC_1, (typedefDeclarationIR as declarationIR)

                        4. Else Phantom#1161

                      2. Case (% has type polyTypeDefIR)

                        1. (Let (typeIR < tid''* , tid'''* >) be (typeDefIR as polyTypeDefIR))

                        2. If ((tid''* matches pattern [])), then

                          1. If ((tid'''* matches pattern [])), then

                            1. (Let nameIR be $name(name))

                            2. (Let typeIR_typedef be ((typedef nameIR (((typeIR < [] , [] >) < [] >) as typeIR)) as typeIR))

                            3. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_typedef as typeDefIR) holds)), then

                              1. (Let TC_2 be $add_type((global), TC_0, nameIR, (typeIR_typedef as typeDefIR)))

                              2. (Let typedefDeclarationIR be (annotationList typedef (derivedTypeDeclarationIR as typedefTypeIR) nameIR ;))

                              3. Result in TC_1, (typedefDeclarationIR as declarationIR)

                            3. Else Phantom#1162

                          1. Else Phantom#1163

                        2. Else Phantom#1164

                  3. Else Phantom#1165

                3. Else Phantom#1166

              3. Else Phantom#1167

        2. Case (% matches pattern `%TYPE%%;`)

          1. (Let (annotationList type type name ;) be typedefDeclaration)

          2. (Type_ok: (global) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

          3. If ((tid* matches pattern [])), then

            1. If ((Type_wf: $bound((global), TC_0) |- typeIR holds)), then

              1. (Let nameIR be $name(name))

              2. (Let typeIR_newtype be ((type nameIR typeIR) as typeIR))

              3. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_newtype as typeDefIR) holds)), then

                1. (Let TC_1 be $add_type((global), TC_0, nameIR, (typeIR_newtype as typeDefIR)))

                2. (Let typedefDeclarationIR be (annotationList type typeIR nameIR ;))

                3. Result in TC_1, (typedefDeclarationIR as declarationIR)

              3. Else Phantom#1168

            1. Else Phantom#1169

          3. Else Phantom#1170

    12. Case (% has type parserTypeDeclaration)

      1. (Let (annotationList parser name typeParameterListOpt ( parameterList );) be (declaration as parserTypeDeclaration))

      2. (Let TC_1 be TC_0[block.kind = (parser)])

      3. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

      4. (Let tid_expl be $name(typeParameter))*

      5. (Let TC_2 be $add_types((block), TC_1, tid_expl*, ((tid tid_expl) as typeDefIR)*))

      6. (Let parameter* be $flatten_parameterList(parameterList))

      7. (Parameters_ok: (block) TC_2 |- parameter* : parameterIR* # tid_impl*)

      8. (Let parameterTypeIR be $parameterIR(parameterIR))*

      9. (Let nameIR be $name(name))

      10. (Let typeIR_parser be ((parser( parameterTypeIR* )) as typeIR))

      11. (Let typeDefIR_parser be ((typeIR_parser < tid_expl* , tid_impl* >) as typeDefIR))

      12. If ((TypeDef_wf: $bound((global), TC_0) |- typeDefIR_parser holds)), then

        1. (Let TC_3 be $add_type((global), TC_0, nameIR, typeDefIR_parser))

        2. (Let parserTypeDeclarationIR be (annotationList parser nameIR < tid_expl* , tid_impl* >( parameterIR* );))

        3. Result in TC_3, (parserTypeDeclarationIR as declarationIR)

      12. Else Phantom#1171

    13. Case (% has type controlTypeDeclaration)

      1. (Let (annotationList control name typeParameterListOpt ( parameterList );) be (declaration as controlTypeDeclaration))

      2. (Let TC_1 be TC_0[block.kind = (control)])

      3. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

      4. (Let tid_expl be $name(typeParameter))*

      5. (Let TC_2 be $add_types((block), TC_1, tid_expl*, ((tid tid_expl) as typeDefIR)*))

      6. (Let parameter* be $flatten_parameterList(parameterList))

      7. (Parameters_ok: (block) TC_2 |- parameter* : parameterIR* # tid_impl*)

      8. (Let parameterTypeIR be $parameterIR(parameterIR))*

      9. (Let nameIR be $name(name))

      10. (Let typeIR_control be ((control( parameterTypeIR* )) as typeIR))

      11. (Let typeDefIR_control be ((typeIR_control < tid_expl* , tid_impl* >) as typeDefIR))

      12. If ((TypeDef_wf: $bound((global), TC_0) |- typeDefIR_control holds)), then

        1. (Let TC_3 be $add_type((global), TC_0, nameIR, typeDefIR_control))

        2. (Let controlTypeDeclarationIR be (annotationList control nameIR < tid_expl* , tid_impl* >( parameterIR* );))

        3. Result in TC_3, (controlTypeDeclarationIR as declarationIR)

      12. Else Phantom#1172

    14. Case (% has type packageTypeDeclaration)

      1. (Let (annotationList package name typeParameterListOpt ( parameterList );) be (declaration as packageTypeDeclaration))

      2. (Let TC_1 be TC_0[block.kind = (package)])

      3. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

      4. (Let tid_expl be $name(typeParameter))*

      5. (Let TC_2 be $add_types((block), TC_1, tid_expl*, ((tid tid_expl) as typeDefIR)*))

      6. (Let constructorParameter* be $flatten_parameterList(parameterList))

      7. (ConstructorParameters_ok: (block) TC_2 |- constructorParameter* : constructorParameterIR* # tid_impl*)

      8. (Let constructorParameterTypeIR be $constructorParameterIR(constructorParameterIR))*

      9. (Let nameIR be $name(name))

      10. (Let (_direction typeIR_package_inner _id _value?) be constructorParameterTypeIR)*

      11. (Let typeIR_package be ((package< typeIR_package_inner* >) as typeIR))

      12. (Let polyTypeDefIR_package be (typeIR_package < tid_expl* , tid_impl* >))

      13. If ((TypeDef_wf: $bound((global), TC_0) |- (polyTypeDefIR_package as typeDefIR) holds)), then

        1. (Let TC_3 be $add_type((global), TC_0, nameIR, (polyTypeDefIR_package as typeDefIR)))

        2. (Let cid be $cid(name, (( parameterList ))))

        3. (Let typeIR_package_spec be ((polyTypeDefIR_package < ((tid tid_expl) as typeIR)* ++ ((tid tid_impl) as typeIR)* >) as typeIR))

        4. (Let constructorTypeIR be (constructor( constructorParameterTypeIR* )-> typeIR_package_spec))

        5. (Let constructorTypeDefIR be (constructorTypeIR < tid_expl* , tid_impl* >))

        6. If ((ConstructorTypeDef_wf: $bound((global), TC_0) |- constructorTypeDefIR holds)), then

          1. (Let TC_4 be $add_constructor(TC_3, cid, constructorTypeDefIR))

          2. (Let packageTypeDeclarationIR be (annotationList package nameIR < tid_expl* , tid_impl* >( constructorParameterIR* );))

          3. Result in TC_4, (packageTypeDeclarationIR as declarationIR)

        6. Else Phantom#1173

      13. Else Phantom#1174

  1. Else Phantom#1175

2. Else Phantom#1176

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:266:1-268:23:
relation Decls_ok: p, TC', declaration*

1. Case analysis on declaration*

  1. Case (% matches pattern [])

    1. Result in TC', []

  2. Case (% matches pattern _ :: _)

    1. (Let declaration_h :: declaration_t* be declaration*)

    2. (Decl_ok: p TC' |- declaration_h : TC_1 declarationIR_h)

    3. (Decls_ok: p TC_1 |- declaration_t* : TC_2 declarationIR_t*)

    4. Result in TC_2, declarationIR_h :: declarationIR_t*

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:270:1-272:17:
relation Program_ok: p4program

1. (Let declaration* be $flatten_p4program(p4program))

2. (Let TC_0 be $empty_typingContext)

3. (Decls_ok: (global) TC_0 |- declaration* : TC_1 declarationIR*)

4. Result in TC_1, (declarationIR* ;)

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:282:18-282:35:
syntax actctxt = 
   | action
   | noaction

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:284:1-287:29:
relation Call_convention_expr_ok: p, TC, actctxt, (direction typeIR_param _id _value?), typedExpressionIR_arg

1. Case analysis on direction

  1. Case (% matches pattern `IN`)

    1. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_arg, typeIR_param))

    2. If ((typedExpressionIR? matches pattern (_))), then

      1. (Let ?(typedExpressionIR_arg_cast) be typedExpressionIR?)

      2. Result in typedExpressionIR_arg_cast

    2. Else Phantom#1177

  2. Case (% matches pattern `OUT`)

    1. (Let (_expressionIR # (( typeIR_arg _ctk ))) be typedExpressionIR_arg)

    2. If ((Type_alpha: typeIR_param ~~ typeIR_arg holds)), then

      1. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_arg holds)), then

        1. Result in typedExpressionIR_arg

      1. Else Phantom#1178

    2. Else Phantom#1179

  3. Case (% matches pattern `INOUT`)

    1. (Let (_expressionIR # (( typeIR_arg _ctk ))) be typedExpressionIR_arg)

    2. If ((Type_alpha: typeIR_param ~~ typeIR_arg holds)), then

      1. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_arg holds)), then

        1. Result in typedExpressionIR_arg

      1. Else Phantom#1180

    2. Else Phantom#1181

1. Else Phantom#1182

2. Case analysis on actctxt

  1. Case (% matches pattern `ACTION`)

    1. If ((direction matches pattern ``EMPTY`)), then

      1. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_arg, typeIR_param))

      2. If ((typedExpressionIR? matches pattern (_))), then

        1. (Let ?(typedExpressionIR_arg_cast) be typedExpressionIR?)

        2. Result in typedExpressionIR_arg_cast

      2. Else Phantom#1183

    1. Else Phantom#1184

  2. Case (% matches pattern `NOACTION`)

    1. If ((direction matches pattern ``EMPTY`)), then

      1. (Let (_expressionIR # (( typeIR_arg ctk_arg ))) be typedExpressionIR_arg)

      2. If ((Type_alpha: typeIR_param ~~ typeIR_arg holds)), then

        1. If (~(ctk_arg matches pattern `DYN`)), then

          1. Result in typedExpressionIR_arg

        1. Else Phantom#1185

      2. Else Phantom#1186

    1. Else Phantom#1187

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:289:1-292:29:
relation Call_convention_argument_ok: p, TC, actctxt, parameterTypeIR, argumentIR

1. If ((argumentIR has type typedExpressionIR)), then

  1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

  2. (Call_convention_expr_ok: p TC actctxt |- parameterTypeIR @ typedExpressionIR : typedExpressionIR_cast)

  3. Result in (typedExpressionIR_cast as argumentIR)

1. Else Phantom#1188

2. Case analysis on argumentIR

  1. Case (% matches pattern `%=%`)

    1. (Let (nameIR = typedExpressionIR) be argumentIR)

    2. (Call_convention_expr_ok: p TC actctxt |- parameterTypeIR @ typedExpressionIR : typedExpressionIR_cast)

    3. Result in (nameIR = typedExpressionIR_cast)

  2. Case (% matches pattern `%=_`)

    1. (Let (nameIR =_) be argumentIR)

    2. (Let (direction _typeIR _id _value?) be parameterTypeIR)

    3. If ((direction matches pattern `OUT`)), then

      1. Result in (nameIR =_)

    3. Else Phantom#1189

  3. Case (% matches pattern `_`)

    1. (Let (direction _typeIR _id _value?) be parameterTypeIR)

    2. If ((direction matches pattern `OUT`)), then

      1. Result in (_)

    2. Else Phantom#1190

2. Else Phantom#1191

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:294:1-297:29:
relation Call_convention_ok: p, TC, actctxt, parameterTypeIR*, argumentIR*

1. Case analysis on parameterTypeIR*

  1. Case (% matches pattern [])

    1. If ((argumentIR* matches pattern [])), then

      1. Result in []

    1. Else Phantom#1192

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t* be parameterTypeIR*)

    2. If ((argumentIR* matches pattern _ :: _)), then

      1. (Let argumentIR_h :: argumentIR_t* be argumentIR*)

      2. (Call_convention_argument_ok: p TC actctxt |- parameterTypeIR_h @ argumentIR_h : argumentIR_h_cast)

      3. (Call_convention_ok: p TC actctxt |- parameterTypeIR_t* @ argumentIR_t* : argumentIR_t_cast*)

      4. Result in argumentIR_h_cast :: argumentIR_t_cast*

    2. Else Phantom#1193

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:307:1-307:52:
def $is_static_routineTarget(routineTargetIR')

1. Case analysis on routineTargetIR'

  1. Case (% matches pattern `%.%`)

    1. (Let (_typedExpressionIR . nameIR) be routineTargetIR')

    2. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

      1. Return (lctk)

  2. Case (% matches pattern `TYPE%.%`)

    1. (Let (type _prefixedNameIR . nameIR) be routineTargetIR')

    2. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

      1. Return (lctk)

2. Otherwise

  1. Return (dyn)

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:318:1-320:23:
relation RoutineTarget_ok: p, TC, routineTarget

1. Case analysis on routineTarget

  1. Case (% has type prefixedNonTypeName)

    1. (Let prefixedNonTypeName be (routineTarget as prefixedNonTypeName))

    2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

    3. If ((((prefixedNameIR = (` "verify")) \/ (prefixedNameIR = (. "verify"))) => (((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind))))), then

      1. Result in (prefixedNameIR as routineTargetIR)

    3. Else Phantom#1194

  2. Case (% has type memberAccessExpression)

    1. (Let (memberAccessBase . member) be (routineTarget as memberAccessExpression))

    2. Case analysis on memberAccessBase

      1. Case (% has type prefixedTypeName)

        1. (Let prefixedTypeName be (memberAccessBase as prefixedTypeName))

        2. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

        3. (Let nameIR be $name(member))

        4. Result in (type prefixedNameIR . nameIR)

      2. Case (% has type expression)

        1. (Let expression_base be (memberAccessBase as expression))

        2. (Let nameIR be $name(member))

        3. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

        4. Result in (typedExpressionIR_base . nameIR)

  3. Case (% has type parenthesizedExpression)

    1. (Let (( expression )) be (routineTarget as parenthesizedExpression))

    2. (RoutineTarget_ok: p TC |- expression : routineTargetIR)

    3. Result in (( routineTargetIR ))

1. Else Phantom#1195

2. If ((routineTarget has type referenceExpression)), then

  1. (Let referenceExpression be (routineTarget as referenceExpression))

  2. If ((referenceExpression matches pattern `THIS`)), then

    1. Result in ((` "this") as routineTargetIR)

  2. Else Phantom#1196

2. Else Phantom#1197

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:322:1-324:23:
relation RoutineTarget_lvalue_ok: p, TC, lvalue

1. (Let expression be $lvalue(lvalue))

2. (RoutineTarget_ok: p TC |- expression : routineTargetIR)

3. Result in routineTargetIR

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:326:1-329:29:
relation RoutineType_ok: p, TC, routineTargetIR'', typeArgumentIR*, argumentIR''*

1. If ((routineTargetIR'' has type prefixedNameIR)), then

  1. (Let prefixedNameIR be (routineTargetIR'' as prefixedNameIR))

  2. (Let (rid, routineTypeDefIR, id*)? be $find_routine_overloaded(p, TC, prefixedNameIR, argumentIR''*))

  3. If (((rid, routineTypeDefIR, id*)? matches pattern (_))), then

    1. (Let ?((rid, routineTypeDefIR, id_default*)) be (rid, routineTypeDefIR, id*)?)

    2. (Let (routineTypeDefIR, tid*) be $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*))

    3. If (((routineTypeDefIR, tid*) has type (functionTypeIR, tid*))), then

      1. (Let (functionTypeIR, tid_impl*) be ((routineTypeDefIR, tid*) as (functionTypeIR, tid*)))

      2. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_impl* })))

      3. If ((RoutineType_wf: bound |- (functionTypeIR as routineTypeIR) holds)), then

        1. Result in (functionTypeIR as routineTypeIR), tid_impl*, id_default*

      3. Else Phantom#1198

    3. Else Phantom#1199

  3. Else Phantom#1200

1. Else Phantom#1201

2. Case analysis on routineTargetIR''

  1. Case (% matches pattern `%.%`)

    1. (Let (typedExpressionIR_base . nameIR) be routineTargetIR'')

    2. If ((typeArgumentIR* matches pattern [])), then

      1. Case analysis on argumentIR''*

        1. Case (% matches pattern [])

          1. Case analysis on nameIR

            1. Case (% is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"])

              1. (Let methodTypeIR be (builtin_method( [] )-> ((int) as typeIR)))

              2. Result in (methodTypeIR as routineTypeIR), [], []

            2. Case (% is in ["isValid"])

              1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

              2. (Let typeIR be $canon(typeIR_base))

              3. Case analysis on typeIR

                1. Case (% has type headerTypeIR)

                  1. (Let (header _tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

                  2. (Let methodTypeIR be (builtin_method( [] )-> ((bool) as typeIR)))

                  3. Result in (methodTypeIR as routineTypeIR), [], []

                2. Case (% has type headerUnionTypeIR)

                  1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR as headerUnionTypeIR))

                  2. (Let methodTypeIR be (builtin_method( [] )-> ((bool) as typeIR)))

                  3. Result in (methodTypeIR as routineTypeIR), [], []

              3. Else Phantom#1202

            3. Case (% is in ["setValid", "setInvalid"])

              1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

              2. (Let typeIR be $canon(typeIR_base))

              3. If ((typeIR has type headerTypeIR)), then

                1. (Let (header _tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

                2. (Let methodTypeIR be (builtin_method( [] )-> ((void) as typeIR)))

                3. Result in (methodTypeIR as routineTypeIR), [], []

              3. Else Phantom#1203

          1. Else Phantom#1204

        2. Case (% matches pattern [ _/1 ])

          1. (Let [argumentIR''] be argumentIR''*)

          2. If (nameIR is in ["push_front", "pop_front"]), then

            1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

            2. (Let typeIR' be $canon(typeIR_base))

            3. If ((typeIR' has type headerStackTypeIR)), then

              1. (Let (typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

              2. (Let parameterTypeIR be (() ((int) as typeIR) "count" ?()))

              3. (Let methodTypeIR be (builtin_method( [parameterTypeIR] )-> ((int) as typeIR)))

              4. Result in (methodTypeIR as routineTypeIR), [], []

            3. Else Phantom#1205

          2. Else Phantom#1206

      1. Else Phantom#1207

    2. Else Phantom#1208

    3. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

    4. (Let typeIR be $canon(typeIR_base))

    5. If ((typeIR has type externObjectTypeIR)), then

      1. (Let (extern _tid ({ (rid_f : routineTypeDefIR_f)* })) be (typeIR as externObjectTypeIR))

      2. (Let id_arg?* be $ids_arguments(argumentIR''*))

      3. (Let (rid, routineTypeDefIR, id*)? be $find_overloaded<routineTypeDefIR>(({ (rid_f : routineTypeDefIR_f)* }), nameIR, id_arg?*))

      4. If (((rid, routineTypeDefIR, id*)? matches pattern (_))), then

        1. (Let ?((rid, routineTypeDefIR, id_default*)) be (rid, routineTypeDefIR, id*)?)

        2. (Let (routineTypeDefIR, tid*) be $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*))

        3. If (((routineTypeDefIR, tid*) has type (routineTypeIR, tid*))), then

          1. (Let (routineTypeIR, tid_impl*) be ((routineTypeDefIR, tid*) as (routineTypeIR, tid*)))

          2. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_impl* })))

          3. If ((RoutineType_wf: bound |- routineTypeIR holds)), then

            1. Result in routineTypeIR, tid_impl*, id_default*

          3. Else Phantom#1209

        3. Else Phantom#1210

      4. Else Phantom#1211

    5. Else Phantom#1212

    6. If ((nameIR = "apply")), then

      1. If ((typeArgumentIR* matches pattern [])), then

        1. Case analysis on typeIR

          1. Case (% has type parserObjectTypeIR)

            1. (Let (parser( parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

            2. (Let methodTypeIR be (parser_apply( parameterTypeIR* )))

            3. (Let (_direction _typeIR id_param value_param?) be parameterTypeIR)*

            4. (Let pid be (id_param # (value_param? =/= ?())))*

            5. (Let rid be ("apply" ( pid* )))

            6. (Let id_arg?* be $ids_arguments(argumentIR''*))

            7. (Let (rid, routineTypeDefIR, id*)'? be $find_overloaded<routineTypeDefIR>(({ [(rid : (methodTypeIR as routineTypeDefIR))] }), "apply", id_arg?*))

            8. If (((rid, routineTypeDefIR, id*)'? matches pattern (_))), then

              1. (Let ?((rid, routineTypeDefIR, id*)) be (rid, routineTypeDefIR, id*)'?)

              2. If (((rid, routineTypeDefIR, id*) has type (rid, methodTypeIR, id*))), then

                1. (Let (rid', methodTypeIR', id_default*) be ((rid, routineTypeDefIR, id*) as (rid, methodTypeIR, id*)))

                2. If ((rid' = rid)), then

                  1. If ((methodTypeIR' = methodTypeIR)), then

                    1. Result in (methodTypeIR as routineTypeIR), [], id_default*

                  1. Else Phantom#1213

                2. Else Phantom#1214

              2. Else Phantom#1215

            8. Else Phantom#1216

          2. Case (% has type controlObjectTypeIR)

            1. (Let (control( parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

            2. (Let methodTypeIR be (control_apply( parameterTypeIR* )))

            3. (Let (_direction _typeIR id_param value_param?) be parameterTypeIR)*

            4. (Let pid be (id_param # (value_param? =/= ?())))*

            5. (Let rid be ("apply" ( pid* )))

            6. (Let id_arg?* be $ids_arguments(argumentIR''*))

            7. (Let (rid, routineTypeDefIR, id*)'? be $find_overloaded<routineTypeDefIR>(({ [(rid : (methodTypeIR as routineTypeDefIR))] }), "apply", id_arg?*))

            8. If (((rid, routineTypeDefIR, id*)'? matches pattern (_))), then

              1. (Let ?((rid, routineTypeDefIR, id*)) be (rid, routineTypeDefIR, id*)'?)

              2. If (((rid, routineTypeDefIR, id*) has type (rid, methodTypeIR, id*))), then

                1. (Let (rid', methodTypeIR', id_default*) be ((rid, routineTypeDefIR, id*) as (rid, methodTypeIR, id*)))

                2. If ((rid' = rid)), then

                  1. If ((methodTypeIR' = methodTypeIR)), then

                    1. Result in (methodTypeIR as routineTypeIR), [], id_default*

                  1. Else Phantom#1217

                2. Else Phantom#1218

              2. Else Phantom#1219

            8. Else Phantom#1220

        1. Else Phantom#1221

        2. If ((argumentIR''* matches pattern [])), then

          1. If ((typeIR has type tableObjectTypeIR)), then

            1. (Let (table _tid # typeIR_table) be (typeIR as tableObjectTypeIR))

            2. (Let methodTypeIR be (table_apply-> typeIR_table))

            3. Result in (methodTypeIR as routineTypeIR), [], []

          1. Else Phantom#1222

        2. Else Phantom#1223

      1. Else Phantom#1224

    6. Else Phantom#1225

  2. Case (% matches pattern `(%)`)

    1. (Let (( routineTargetIR'' )) be routineTargetIR'')

    2. (RoutineType_ok: p TC |- routineTargetIR'' < typeArgumentIR* >( argumentIR''* ): routineTypeIR <# tid_inserted* >(# id_default* ))

    3. Result in routineTypeIR, tid_inserted*, id_default*

2. Else Phantom#1226

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:336:1-340:35:
relation Call_ok: p, TC, routineTypeIR, typeArgumentIR*, tid'*, argumentIR*, id_default'*

1. Case analysis on routineTypeIR

  1. Case (% has type functionTypeIR)

    1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

    2. Case analysis on functionTypeIR

      1. Case (% matches pattern `BUILTIN_FUNCTION(%)->%`)

        1. (Let (builtin_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. If ((tid'* matches pattern [])), then

          1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default'*))

          2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

            1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

            2. If ($callable_builtin_function(p, TC)), then

              1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned* @ argumentIR* : argumentIR_cast*)

              2. Result in typeIR_ret, typeArgumentIR*, argumentIR_cast*

            2. Else Phantom#1227

          2. Else Phantom#1228

        2. Else Phantom#1229

      2. Case (% matches pattern `FUNCTION(%)->%`)

        1. (Let (function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default'*))

        3. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

          1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

          2. (Let inference be $infer(tid'*, parameterTypeIR_aligned*, argumentIR*))

          3. (Let typeIR? be $find_map<tid, typeIR>(inference, tid'))*

          4. If ((typeIR? matches pattern (_)))*, then

            1. (Let ?(typeIR_inferred) be typeIR?)*

            2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

            3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

            4. (Let typeIR_ret_inferred be $subst_type(inference, typeIR_ret))

            5. (Let functionTypeIR_inferred be (function( parameterTypeIR_aligned_inferred* )-> typeIR_ret_inferred))

            6. If ((RoutineType_wf: $bound(p, TC) |- (functionTypeIR_inferred as routineTypeIR) holds)), then

              1. If ($callable_function(p, TC)), then

                1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

                2. Result in typeIR_ret_inferred, typeArgumentIR_inferred*, argumentIR_cast*

              1. Else Phantom#1230

            6. Else Phantom#1231

          4. Else Phantom#1232

        3. Else Phantom#1233

      3. Case (% matches pattern `EXTERN_FUNCTION(%)->%`)

        1. (Let (extern_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default'*))

        3. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

          1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

          2. (Let inference be $infer(tid'*, parameterTypeIR_aligned*, argumentIR*))

          3. (Let typeIR? be $find_map<tid, typeIR>(inference, tid'))*

          4. If ((typeIR? matches pattern (_)))*, then

            1. (Let ?(typeIR_inferred) be typeIR?)*

            2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

            3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

            4. (Let typeIR_ret_inferred be $subst_type(inference, typeIR_ret))

            5. (Let functionTypeIR_inferred be (extern_function( parameterTypeIR_aligned_inferred* )-> typeIR_ret_inferred))

            6. If ((RoutineType_wf: $bound(p, TC) |- (functionTypeIR_inferred as routineTypeIR) holds)), then

              1. If ($callable_extern_function(p, TC)), then

                1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

                2. Result in typeIR_ret_inferred, typeArgumentIR_inferred*, argumentIR_cast*

              1. Else Phantom#1234

            6. Else Phantom#1235

          4. Else Phantom#1236

        3. Else Phantom#1237

      4. Case (% matches pattern `ACTION(%)`)

        1. (Let (action( parameterTypeIR* )) be functionTypeIR)

        2. If ((typeArgumentIR* matches pattern [])), then

          1. If ((tid'* matches pattern [])), then

            1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default'*))

            2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

              1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

              2. If ($callable_action(p, TC)), then

                1. (Call_convention_ok: p TC (action) |- parameterTypeIR_aligned* @ argumentIR* : argumentIR_cast*)

                2. Result in ((void) as typeIR), [], argumentIR_cast*

              2. Else Phantom#1238

            2. Else Phantom#1239

          1. Else Phantom#1240

        2. Else Phantom#1241

  2. Case (% has type methodTypeIR)

    1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

    2. Case analysis on methodTypeIR

      1. Case (% matches pattern `BUILTIN_METHOD(%)->%`)

        1. (Let (builtin_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. If ((tid'* matches pattern [])), then

          1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default'*))

          2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

            1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

            2. If ($callable_builtin_method(p, TC)), then

              1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned* @ argumentIR* : argumentIR_cast*)

              2. Result in typeIR_ret, typeArgumentIR*, argumentIR_cast*

            2. Else Phantom#1242

          2. Else Phantom#1243

        2. Else Phantom#1244

      2. Case (% matches pattern `EXTERN_METHOD(%)->%`)

        1. (Let (extern_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default'*))

        3. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

          1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

          2. (Let inference be $infer(tid'*, parameterTypeIR_aligned*, argumentIR*))

          3. (Let typeIR? be $find_map<tid, typeIR>(inference, tid'))*

          4. If ((typeIR? matches pattern (_)))*, then

            1. (Let ?(typeIR_inferred) be typeIR?)*

            2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

            3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

            4. (Let typeIR_ret_inferred be $subst_type(inference, typeIR_ret))

            5. (Let methodTypeIR_inferred be (extern_method( parameterTypeIR_aligned_inferred* )-> typeIR_ret_inferred))

            6. If ((RoutineType_wf: $bound(p, TC) |- (methodTypeIR_inferred as routineTypeIR) holds)), then

              1. If ($callable_extern_method(p, TC)), then

                1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

                2. Result in typeIR_ret_inferred, typeArgumentIR_inferred*, argumentIR_cast*

              1. Else Phantom#1245

            6. Else Phantom#1246

          4. Else Phantom#1247

        3. Else Phantom#1248

      3. Case (% matches pattern `EXTERN_METHODABSTRACT(%)->%`)

        1. (Let (extern_methodabstract( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default'*))

        3. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

          1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

          2. (Let inference be $infer(tid'*, parameterTypeIR_aligned*, argumentIR*))

          3. (Let typeIR? be $find_map<tid, typeIR>(inference, tid'))*

          4. If ((typeIR? matches pattern (_)))*, then

            1. (Let ?(typeIR_inferred) be typeIR?)*

            2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

            3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

            4. (Let typeIR_ret_inferred be $subst_type(inference, typeIR_ret))

            5. (Let methodTypeIR_inferred be (extern_methodabstract( parameterTypeIR_aligned_inferred* )-> typeIR_ret_inferred))

            6. If ((RoutineType_wf: $bound(p, TC) |- (methodTypeIR_inferred as routineTypeIR) holds)), then

              1. If ($callable_extern_abstract_method(p, TC)), then

                1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

                2. Result in typeIR_ret_inferred, typeArgumentIR_inferred*, argumentIR_cast*

              1. Else Phantom#1249

            6. Else Phantom#1250

          4. Else Phantom#1251

        3. Else Phantom#1252

      4. Case (% matches pattern `PARSER_APPLY(%)`)

        1. (Let (parser_apply( parameterTypeIR* )) be methodTypeIR)

        2. If ((typeArgumentIR* matches pattern [])), then

          1. If ((tid'* matches pattern [])), then

            1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default'*))

            2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

              1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

              2. If ($callable_parser_apply_method(p, TC)), then

                1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned* @ argumentIR* : argumentIR_cast*)

                2. Result in ((void) as typeIR), [], argumentIR_cast*

              2. Else Phantom#1253

            2. Else Phantom#1254

          1. Else Phantom#1255

        2. Else Phantom#1256

      5. Case (% matches pattern `CONTROL_APPLY(%)`)

        1. (Let (control_apply( parameterTypeIR* )) be methodTypeIR)

        2. If ((typeArgumentIR* matches pattern [])), then

          1. If ((tid'* matches pattern [])), then

            1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default'*))

            2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

              1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

              2. If ($callable_control_apply_method(p, TC)), then

                1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned* @ argumentIR* : argumentIR_cast*)

                2. Result in ((void) as typeIR), [], argumentIR_cast*

              2. Else Phantom#1257

            2. Else Phantom#1258

          1. Else Phantom#1259

        2. Else Phantom#1260

      6. Case (% matches pattern `TABLE_APPLY->%`)

        1. (Let (table_apply-> typeIR_table) be methodTypeIR)

        2. If ((typeArgumentIR* matches pattern [])), then

          1. If ((tid'* matches pattern [])), then

            1. If ((argumentIR* matches pattern [])), then

              1. If ((id_default'* matches pattern [])), then

                1. If ($callable_table_apply_method(p, TC)), then

                  1. Result in typeIR_table, [], []

                1. Else Phantom#1261

              1. Else Phantom#1262

            1. Else Phantom#1263

          1. Else Phantom#1264

        2. Else Phantom#1265

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:350:1-353:29:
relation ConstructorType_ok: p, TC, prefixedNameIR, typeArgumentIR*, argumentIR*

1. (Let (rid, constructorTypeDefIR, id*)? be $find_constructor_overloaded(TC, prefixedNameIR, argumentIR*))

2. If (((rid, constructorTypeDefIR, id*)? matches pattern (_))), then

  1. (Let ?((cid, constructorTypeDefIR, id_default*)) be (rid, constructorTypeDefIR, id*)?)

  2. (Let (constructorTypeIR, tid_impl*) be $specialize_constructorTypeDef(constructorTypeDefIR, typeArgumentIR*))

  3. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_impl* })))

  4. If ((ConstructorType_wf: bound |- constructorTypeIR holds)), then

    1. Result in constructorTypeIR, tid_impl*, id_default*

  4. Else Phantom#1266

2. Else Phantom#1267

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:360:19-360:31:
syntax instctxt = 
   | named
   | anon

;; ../../../../examples/p4-concrete/5.04-typing-relation.spectec:362:1-369:38:
relation Inst_ok: cursor', TC, instctxt, constructorTypeIR, typeArgumentIR*, tid_infer*, argumentIR*, id_default*

1. If ((cursor' matches pattern `GLOBAL`)), then

  1. (Let (constructor( parameterTypeIR* )-> typeIR_object) be constructorTypeIR)

  2. (Let typeIR be $canon(typeIR_object))

  3. If ((typeIR has type packageObjectTypeIR)), then

    1. (Let (package< _typeIR* >) be (typeIR as packageObjectTypeIR))

    2. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

    3. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

      1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

      2. (Let inference be $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*))

      3. (Let typeIR'? be $find_map<tid, typeIR>(inference, tid_infer))*

      4. If ((typeIR'? matches pattern (_)))*, then

        1. (Let ?(typeIR_inferred) be typeIR'?)*

        2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

        3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

        4. (Let typeIR_object_inferred be $subst_type(inference, typeIR_object))

        5. (Let constructorTypeIR_inferred be (constructor( parameterTypeIR_aligned_inferred* )-> typeIR_object_inferred))

        6. If ((ConstructorType_wf: $bound((global), TC) |- constructorTypeIR_inferred holds)), then

          1. If ($instantiable((global), TC, instctxt, typeIR_object_inferred)), then

            1. (Call_convention_ok: (block) TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

            2. Result in typeIR_object_inferred, typeArgumentIR_inferred*, argumentIR_cast*

          1. Else Phantom#1268

        6. Else Phantom#1269

      4. Else Phantom#1270

    3. Else Phantom#1271

  3. Else Phantom#1272

1. Else Phantom#1273

2. (Let (constructor( parameterTypeIR* )-> typeIR_object) be constructorTypeIR)

3. If (~$is_package_object_typeIR($canon(typeIR_object))), then

  1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

  2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

    1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

    2. (Let inference be $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*))

    3. (Let typeIR? be $find_map<tid, typeIR>(inference, tid_infer))*

    4. If ((typeIR? matches pattern (_)))*, then

      1. (Let ?(typeIR_inferred) be typeIR?)*

      2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

      3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

      4. (Let typeIR_object_inferred be $subst_type(inference, typeIR_object))

      5. (Let constructorTypeIR_inferred be (constructor( parameterTypeIR_aligned_inferred* )-> typeIR_object_inferred))

      6. If ((ConstructorType_wf: $bound(cursor', TC) |- constructorTypeIR_inferred holds)), then

        1. If ($instantiable(cursor', TC, instctxt, typeIR_object_inferred)), then

          1. (Call_convention_ok: cursor' TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

          2. Result in typeIR_object_inferred, typeArgumentIR_inferred*, argumentIR_cast*

        1. Else Phantom#1274

      6. Else Phantom#1275

    4. Else Phantom#1276

  2. Else Phantom#1277

3. Else Phantom#1278

;; ../../../../examples/p4-concrete/5.05.2-subtype.spectec:338:1-342:23:
def $reduce_serenum_unary(typedExpressionIR, $check)

1. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

2. Case analysis on $check(typeIR)

  1. Case true

    1. Return ?(typedExpressionIR)

  2. Case false

    1. (Let typeIR' be typeIR)

    2. If ((typeIR' has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR' as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

        1. (Let (enum _tid # typeIR_underlying { _valueFieldIR* }) be enumTypeIR)

        2. (Let typedExpressionIR_cast be (((( typeIR_underlying ) typedExpressionIR) as expressionIR) # (( typeIR_underlying _ctk ))))

        3. Return $reduce_serenum_unary(typedExpressionIR_cast, $check)

3. Otherwise

  1. Return ?()

;; ../../../../examples/p4-concrete/5.05.2-subtype.spectec:363:1-368:44:
def $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $check)

1. (Let (_expressionIR # (( typeIR_l _ctk ))) be typedExpressionIR_l)

2. (Let (_expressionIR' # (( typeIR_r _ctk' ))) be typedExpressionIR_r)

3. Case analysis on $check(typeIR_l, typeIR_r)

  1. Case true

    1. Return ?((typedExpressionIR_l, typedExpressionIR_r))

  2. Case false

    1. (Let typeIR be typeIR_l)

    2. If ((typeIR has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

        1. (Let (enum _tid # typeIR_l_underlying { _valueFieldIR* }) be enumTypeIR)

        2. (Let typedExpressionIR_l_cast be (((( typeIR_l_underlying ) typedExpressionIR_l) as expressionIR) # (( typeIR_l_underlying _ctk' ))))

        3. Return $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r, $check)

    3. (Let typeIR be typeIR_r)

    4. If ((typeIR has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

        1. (Let (enum _tid # typeIR_r_underlying { _valueFieldIR* }) be enumTypeIR)

        2. (Let typedExpressionIR_r_cast be (((( typeIR_r_underlying ) typedExpressionIR_r) as expressionIR) # (( typeIR_r_underlying _ctk' ))))

        3. Return $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r_cast, $check)

4. Otherwise

  1. Return ?()

;; ../../../../examples/p4-concrete/5.05.2-subtype.spectec:408:1-408:66:
def $coerce_unary(typedExpressionIR, typeIR_to)

1. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

2. Case analysis on (Type_alpha: typeIR ~~ typeIR_to holds)

  1. Case true

    1. Return ?(typedExpressionIR)

  2. Case false

    1. If ((Sub_impl: typeIR <: typeIR_to holds)), then

      1. (Let typedExpressionIR_cast be (((( typeIR_to ) typedExpressionIR) as expressionIR) # (( typeIR_to _ctk ))))

      2. Return ?(typedExpressionIR_cast)

    1. Else Phantom#1279

;; ../../../../examples/p4-concrete/5.05.2-subtype.spectec:423:1-424:44:
def $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)

1. (Let (_expressionIR # (( typeIR_l _ctk ))) be typedExpressionIR_l)

2. (Let (_expressionIR' # (( typeIR_r _ctk' ))) be typedExpressionIR_r)

3. Case analysis on (Type_alpha: typeIR_l ~~ typeIR_r holds)

  1. Case true

    1. Return ?((typedExpressionIR_l, typedExpressionIR_r))

  2. Case false

    1. Case analysis on (Sub_impl: typeIR_l <: typeIR_r holds)

      1. Case true

        1. (Let typedExpressionIR_l_cast be (((( typeIR_r ) typedExpressionIR_l) as expressionIR) # (( typeIR_r _ctk' ))))

        2. Return ?((typedExpressionIR_l_cast, typedExpressionIR_r))

      2. Case false

        1. If ((Sub_impl: typeIR_r <: typeIR_l holds)), then

          1. (Let typedExpressionIR_r_cast be (((( typeIR_l ) typedExpressionIR_r) as expressionIR) # (( typeIR_l _ctk' ))))

          2. Return ?((typedExpressionIR_l, typedExpressionIR_r_cast))

4. Otherwise

  1. Return ?()

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:69:1-69:32:
def $compat_lnot(typeIR)

1. Return $compat'_lnot($canon(typeIR))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:70:1-70:33:
def $compat'_lnot(typeIR)

1. If ((typeIR has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

  2. If ((primitiveTypeIR matches pattern `BOOL`)), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:90:1-90:32:
def $compat_bnot(typeIR)

1. Return $compat'_bnot($canon(typeIR))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:91:1-91:33:
def $compat'_bnot(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< _nat >) be numberTypeIR)

      2. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:112:1-112:38:
def $compat_uplusminus(typeIR)

1. Return $compat'_uplusminus($canon(typeIR))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:113:1-113:39:
def $compat'_uplusminus(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT`)

      1. Return true

    2. Case (% matches pattern `INT<%>`)

      1. (Let (int< _nat >) be numberTypeIR)

      2. Return true

    3. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:138:1-138:49:
def $compat_plusminusmult(typeIR_l, typeIR_r)

1. Return $compat'_plusminusmult($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:139:1-139:50:
def $compat'_plusminusmult(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT`)

      1. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `INT`)), then

          1. Return true

    2. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `INT<%>`)), then

          1. (Let (int< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    3. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

          1. (Let (bit< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:175:1-175:48:
def $compat_satplusminus(typeIR_l, typeIR_r)

1. Return $compat'_satplusminus($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:176:1-176:49:
def $compat'_satplusminus(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `INT<%>`)), then

          1. (Let (int< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

          1. (Let (bit< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:211:1-211:42:
def $compat_divmod(typeIR_l, typeIR_r)

1. Return $compat'_divmod($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:212:1-212:43:
def $compat'_divmod(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT`)), then

    1. If ((typeIR''' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `INT`)), then

        1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:278:1-278:41:
def $compat_shift(typeIR_l, typeIR_r)

1. Return $compat'_shift($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:279:1-279:42:
def $compat'_shift(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT`)

      1. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `INT`)

            1. Return true

          2. Case (% matches pattern `INT<%>`)

            1. (Let (int< _nat >) be numberTypeIR')

            2. Return true

          3. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< _nat >) be numberTypeIR')

            2. Return true

    2. Case (% matches pattern `INT<%>`)

      1. (Let (int< _nat >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `INT`)

            1. Return true

          2. Case (% matches pattern `INT<%>`)

            1. (Let (int< _nat' >) be numberTypeIR')

            2. Return true

          3. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< _nat' >) be numberTypeIR')

            2. Return true

    3. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `INT`)

            1. Return true

          2. Case (% matches pattern `INT<%>`)

            1. (Let (int< _nat' >) be numberTypeIR')

            2. Return true

          3. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< _nat' >) be numberTypeIR')

            2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:369:1-369:43:
def $compat_compare(typeIR_l, typeIR_r)

1. Return $compat'_compare($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:370:1-370:44:
def $compat'_compare(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT`)

      1. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `INT`)), then

          1. Return true

    2. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `INT<%>`)), then

          1. (Let (int< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    3. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

          1. (Let (bit< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:406:1-406:43:
def $compat_bitwise(typeIR_l, typeIR_r)

1. Return $compat'_bitwise($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:407:1-407:44:
def $compat'_bitwise(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `INT<%>`)), then

          1. (Let (int< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

          1. (Let (bit< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:442:1-442:42:
def $compat_concat(typeIR_l, typeIR_r)

1. Return $compat'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:443:1-443:43:
def $compat'_concat(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< _nat >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `INT<%>`)

            1. (Let (int< _nat' >) be numberTypeIR')

            2. Return true

          2. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< _nat' >) be numberTypeIR')

            2. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `INT<%>`)

            1. (Let (int< _nat' >) be numberTypeIR')

            2. Return true

          2. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< _nat' >) be numberTypeIR')

            2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:454:1-454:45:
def $result_concat(typeIR_l, typeIR_r)

1. Return $result'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:455:1-455:46:
def $result'_concat(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< w_a >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `INT<%>`)

            1. (Let (int< w_b >) be numberTypeIR')

            2. Return ?(((int< (w_a + w_b) >) as typeIR))

          2. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< w_b >) be numberTypeIR')

            2. Return ?(((int< (w_a + w_b) >) as typeIR))

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< w_a >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `INT<%>`)

            1. (Let (int< w_b >) be numberTypeIR')

            2. Return ?(((bit< (w_a + w_b) >) as typeIR))

          2. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< w_b >) be numberTypeIR')

            2. Return ?(((bit< (w_a + w_b) >) as typeIR))

2. Otherwise

  1. Return ?()

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:492:1-492:43:
def $compat_logical(typeIR_l, typeIR_r)

1. Return $compat'_logical($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:493:1-493:44:
def $compat'_logical(typeIR'', typeIR''')

1. If ((typeIR'' has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

  2. If ((primitiveTypeIR matches pattern `BOOL`)), then

    1. If ((typeIR''' has type primitiveTypeIR)), then

      1. (Let primitiveTypeIR' be (typeIR''' as primitiveTypeIR))

      2. If ((primitiveTypeIR' matches pattern `BOOL`)), then

        1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:873:1-873:39:
def $compat_array_index(typeIR)

1. Return $compat'_arrayindex($canon(typeIR))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:874:1-874:39:
def $compat'_arrayindex(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT`)

      1. Return true

    2. Case (% matches pattern `INT<%>`)

      1. (Let (int< _nat >) be numberTypeIR)

      2. Return true

    3. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:964:1-964:41:
def $compat_bitslice_base(typeIR)

1. Return $compat'_bitslice_base($canon(typeIR))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:965:1-965:42:
def $compat'_bitslice_base(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT`)

      1. Return true

    2. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. Return (w > 0)

    3. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:975:1-975:42:
def $compat_bitslice_index(typeIR)

1. Return $compat'_bitslice_index($canon(typeIR))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:976:1-976:43:
def $compat'_bitslice_index(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT`)

      1. Return true

    2. Case (% matches pattern `INT<%>`)

      1. (Let (int< _nat >) be numberTypeIR)

      2. Return true

    3. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:986:1-986:48:
def $is_valid_bitslice(typeIR, n_lo, n_hi)

1. Return ((n_lo <= n_hi) /\ $is_valid_bitslice'($canon(typeIR), n_lo, n_hi))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:987:1-987:49:
def $is_valid_bitslice'(typeIR', _nat'', _nat''')

1. If ((typeIR' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT`)

      1. Return true

    2. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. (Let w_slice be ((_nat''' - _nat'') + 1))

      3. Return ((_nat''' <= w) /\ (w_slice <= w))

    3. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< w >) be numberTypeIR)

      2. (Let w_slice be ((_nat''' - _nat'') + 1))

      3. Return ((_nat''' <= w) /\ (w_slice <= w))

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:1114:1-1114:46:
def $is_concrete_extern_object(typeIR)

1. Return $is_concrete_extern_object'($canon(typeIR))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:1115:1-1115:47:
def $is_concrete_extern_object'(typeIR)

1. If (~$is_extern_object_typeIR(typeIR)), then

  1. Return true

2. If ((typeIR has type externObjectTypeIR)), then

  1. (Let (extern _tid ({ (_rid : routineTypeDefIR)* })) be (typeIR as externObjectTypeIR))

  2. If ($is_concrete_extern_object''(routineTypeDefIR))*, then

    1. Return true

3. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:1116:1-1116:58:
def $is_concrete_extern_object''(routineTypeDefIR)

1. Case analysis on routineTypeDefIR

  1. Case (% has type routineTypeIR)

    1. (Let routineTypeIR be (routineTypeDefIR as routineTypeIR))

    2. Return $is_concrete_extern_object'''(routineTypeIR)

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (routineTypeIR < _tid* , _tid'* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. Return (true = $is_concrete_extern_object'''(routineTypeIR))

;; ../../../../examples/p4-concrete/5.06.2-typing-expression.spectec:1117:1-1117:56:
def $is_concrete_extern_object'''(routineTypeIR')

1. If ((routineTypeIR' has type methodTypeIR)), then

  1. (Let methodTypeIR be (routineTypeIR' as methodTypeIR))

  2. If ((methodTypeIR matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

    1. (Let (extern_methodabstract( _parameterTypeIR* )-> _typeIR) be methodTypeIR)

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../examples/p4-concrete/5.10-typing-statement.spectec:88:1-88:46:
def $compat_direct_application(typeIR)

1. Return $compat'_direct_application($canon(typeIR))

;; ../../../../examples/p4-concrete/5.10-typing-statement.spectec:89:1-89:47:
def $compat'_direct_application(typeIR)

1. Case analysis on typeIR

  1. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

    2. Return true

  2. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.10-typing-statement.spectec:204:1-206:26:
relation SwitchLabel_table_ok: TC, tid_table, bool', switchLabel

1. If ((bool' = true)), then

  1. If ((switchLabel matches pattern `DEFAULT`)), then

    1. Result in (default)

  1. Else Phantom#1280

1. Else Phantom#1281

2. If ((switchLabel has type prefixedNonTypeName)), then

  1. (Let prefixedNonTypeName be (switchLabel as prefixedNonTypeName))

  2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

  3. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` nameIR_label) be prefixedNameIR)

    2. (Let tid_table_enum be "action_list(" ++ tid_table ++ ")")

    3. (Let id_label be tid_table_enum ++ "." ++ nameIR_label)

    4. (Let varTypeIR? be $find_var((local), TC, (` id_label)))

    5. If ((varTypeIR? matches pattern (_))), then

      1. (Let ?((_direction typeIR_label ctk_label value?)) be varTypeIR?)

      2. If ((value? matches pattern (_))), then

        1. (Let ?(value_label) be value?)

        2. If ((value_label = ((table_enum tid_table_enum . nameIR_label) as value))), then

          1. (Let typedExpressionIR_label be (((` nameIR_label) as expressionIR) # (( typeIR_label ctk_label ))))

          2. Result in (typedExpressionIR_label as switchLabelIR)

        2. Else Phantom#1282

      2. Else Phantom#1283

    5. Else Phantom#1284

  3. Else Phantom#1285

2. Else Phantom#1286

;; ../../../../examples/p4-concrete/5.10-typing-statement.spectec:233:1-235:29:
relation SwitchCase_table_ok: TC, f, tid_table, b_last, switchCase

1. Case analysis on switchCase

  1. Case (% matches pattern `%:%`)

    1. (Let (switchLabel : blockStatement) be switchCase)

    2. (SwitchLabel_table_ok: TC tid_table b_last |- switchLabel : switchLabelIR)

    3. (Block_ok: TC f |- blockStatement : TC_post f_post blockStatementIR)

    4. (Let switchCaseIR be (switchLabelIR : blockStatementIR))

    5. Result in f_post, switchCaseIR, switchLabel

  2. Case (% matches pattern `%:`)

    1. (Let (switchLabel :) be switchCase)

    2. (SwitchLabel_table_ok: TC tid_table b_last |- switchLabel : switchLabelIR)

    3. (Let switchCaseIR be (switchLabelIR :))

    4. Result in f, switchCaseIR, switchLabel

;; ../../../../examples/p4-concrete/5.10-typing-statement.spectec:261:1-263:26:
relation SwitchCases_table_ok: TC, f, tid_table, switchCase*

1. Case analysis on switchCase*

  1. Case (% matches pattern [])

    1. Result in f, [], []

  2. Case (% matches pattern _ :: _)

    1. (Let switchCase_h :: switchCase_t* be switchCase*)

    2. (Let b_last be (switchCase_t* = []))

    3. (SwitchCase_table_ok: TC f tid_table b_last |- switchCase_h : f_h switchCaseIR_h # switchLabel_h)

    4. (SwitchCases_table_ok: TC f_h tid_table |- switchCase_t* : f_t switchCaseIR_t* # switchLabel_t*)

    5. Result in f_t, switchCaseIR_h :: switchCaseIR_t*, switchLabel_h :: switchLabel_t*

;; ../../../../examples/p4-concrete/5.10-typing-statement.spectec:300:1-302:26:
relation SwitchLabel_general_ok: TC, _typeIR', bool', switchLabel

1. If ((bool' = true)), then

  1. If ((switchLabel matches pattern `DEFAULT`)), then

    1. Result in (default)

  1. Else Phantom#1287

1. Else Phantom#1288

2. If ((switchLabel has type expressionNonBrace)), then

  1. (Let expressionNonBrace_label be (switchLabel as expressionNonBrace))

  2. (Let expression_label be $expressionNonBrace(expressionNonBrace_label))

  3. (Expr_ok: (local) TC |- expression_label : typedExpressionIR_label)

  4. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_label, _typeIR'))

  5. If ((typedExpressionIR? matches pattern (_))), then

    1. (Let ?(typedExpressionIR_label_cast) be typedExpressionIR?)

    2. (Let (_expressionIR # (( _typeIR' ctk ))) be typedExpressionIR_label_cast)

    3. If ((ctk matches pattern `LCTK`)), then

      1. Result in (typedExpressionIR_label_cast as switchLabelIR)

    3. Else Phantom#1289

  5. Else Phantom#1290

2. Else Phantom#1291

;; ../../../../examples/p4-concrete/5.10-typing-statement.spectec:323:1-325:29:
relation SwitchCase_general_ok: TC, f, typeIR_switch, b_last, switchCase

1. Case analysis on switchCase

  1. Case (% matches pattern `%:%`)

    1. (Let (switchLabel : blockStatement) be switchCase)

    2. (SwitchLabel_general_ok: TC typeIR_switch b_last |- switchLabel : switchLabelIR)

    3. (Block_ok: TC f |- blockStatement : TC_post f_post blockStatementIR)

    4. (Let switchCaseIR be (switchLabelIR : blockStatementIR))

    5. Result in f_post, switchCaseIR, switchLabel

  2. Case (% matches pattern `%:`)

    1. (Let (switchLabel :) be switchCase)

    2. (SwitchLabel_general_ok: TC typeIR_switch b_last |- switchLabel : switchLabelIR)

    3. (Let switchCaseIR be (switchLabelIR :))

    4. Result in f, switchCaseIR, switchLabel

;; ../../../../examples/p4-concrete/5.10-typing-statement.spectec:351:1-353:26:
relation SwitchCases_general_ok: TC, f, typeIR_switch, switchCase*

1. Case analysis on switchCase*

  1. Case (% matches pattern [])

    1. Result in f, [], []

  2. Case (% matches pattern _ :: _)

    1. (Let switchCase_h :: switchCase_t* be switchCase*)

    2. (Let b_last be (switchCase_t* = []))

    3. (SwitchCase_general_ok: TC f typeIR_switch b_last |- switchCase_h : f_h switchCaseIR_h # switchLabel_h)

    4. (SwitchCases_general_ok: TC f_h typeIR_switch |- switchCase_t* : f_t switchCaseIR_t* # switchLabel_t*)

    5. Result in f_t, switchCaseIR_h :: switchCaseIR_t*, switchLabel_h :: switchLabel_t*

;; ../../../../examples/p4-concrete/5.10-typing-statement.spectec:368:1-368:34:
def $compat_switch(typeIR)

1. Return $compat'_switch($canon(typeIR))

;; ../../../../examples/p4-concrete/5.10-typing-statement.spectec:369:1-369:35:
def $compat'_switch(typeIR)

1. Case analysis on typeIR

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `ERROR`)), then

      1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

  3. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.11-typing-declaration.spectec:88:1-91:29:
relation Decl_object_ok: p, TC_0, frame, rdenv, objectDeclaration

1. Case analysis on objectDeclaration

  1. Case (% has type functionDeclaration)

    1. (Let (annotationList (typeOrVoid name typeParameterListOpt ( parameterList )) blockStatement) be (objectDeclaration as functionDeclaration))

    2. (Let TC_1 be TC_0[block.kind = (extern)])

    3. (Let TC_2 be TC_1[block.frame = frame])

    4. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

    5. (Let tid_expl be $name(typeParameter))*

    6. (Let TC_3 be $add_types((local), TC_2, tid_expl*, ((tid tid_expl) as typeDefIR)*))

    7. (Type_ok: (local) TC_3 |- typeOrVoid : typeIR_ret # tid*)

    8. If ((tid* matches pattern [])), then

      1. (Let parameter* be $flatten_parameterList(parameterList))

      2. (Parameters_ok: (local) TC_3 |- parameter* : parameterIR* # tid_impl*)

      3. (Let parameterTypeIR be $parameterIR(parameterIR))*

      4. (Let TC_4 be $add_parameters((local), TC_3, parameterTypeIR*))

      5. (Let TC_5 be TC_4[local.kind = (extern_method-> typeIR_ret)])

      6. (Block_ok: TC_5 (cont) |- blockStatement : _typingContext f blockStatementIR)

      7. If (((f = (ret)) \/ (typeIR_ret = ((void) as typeIR)))), then

        1. (Let rid be $rid(name, parameterList))

        2. (Let methodTypeIR be (extern_method( parameterTypeIR* )-> typeIR_ret))

        3. (Let routineTypeDefIR be (((methodTypeIR as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

        4. If ((RoutineTypeDef_wf: $bound(p, TC_0) |- routineTypeDefIR holds)), then

          1. (Let rdenv_init be $update_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

          2. (Let nameIR be $name(name))

          3. (Let functionDeclarationIR be (annotationList (typeIR_ret nameIR < tid_expl* , tid_impl* >( parameterIR* )) blockStatementIR))

          4. Result in frame, rdenv_init, (functionDeclarationIR as objectDeclarationIR)

        4. Else Phantom#1292

      7. Else Phantom#1293

    8. Else Phantom#1294

  2. Case (% has type instantiation)

    1. (Let instantiation be (objectDeclaration as instantiation))

    2. (Decl_ok: p TC_0 |- (instantiation as declaration) : TC_1 declarationIR)

    3. If ((declarationIR has type instantiationIR)), then

      1. (Let instantiationIR be (declarationIR as instantiationIR))

      2. (Let (_annotationList _typeIR _prefixedNameIR < _typeArgumentListIR >( _argumentListIR ) nameIR _objectInitializerOptIR ;) be instantiationIR)

      3. (Let varTypeIR'? be $find_var(p, TC_1, (` nameIR)))

      4. If ((varTypeIR'? matches pattern (_))), then

        1. (Let ?(varTypeIR) be varTypeIR'?)

        2. (Let frame_init be $update_map<id, varTypeIR>(frame, nameIR, varTypeIR))

        3. Result in frame_init, rdenv, (instantiationIR as objectDeclarationIR)

      4. Else Phantom#1295

    3. Else Phantom#1296

;; ../../../../examples/p4-concrete/5.11-typing-declaration.spectec:151:1-154:29:
relation Decls_object_ok: p, TC, frame', rdenv', objectDeclaration*

1. Case analysis on objectDeclaration*

  1. Case (% matches pattern [])

    1. Result in frame', rdenv', []

  2. Case (% matches pattern _ :: _)

    1. (Let objectDeclaration_h :: objectDeclaration_t* be objectDeclaration*)

    2. (Decl_object_ok: p TC frame' rdenv' |- objectDeclaration_h : frame_1 rdenv_1 objectDeclarationIR_h)

    3. (Decls_object_ok: p TC frame_1 rdenv_1 |- objectDeclaration_t* : frame_2 rdenv_2 objectDeclarationIR_t*)

    4. Result in frame_2, rdenv_2, objectDeclarationIR_h :: objectDeclarationIR_t*

;; ../../../../examples/p4-concrete/5.11-typing-declaration.spectec:169:1-169:46:
def $subst_rdenv(theta, rdenv_extern, set<pair<rid, routineTypeDefIR>>')

1. If ((set<pair<rid, routineTypeDefIR>>' = ({ [] }))), then

  1. Return rdenv_extern

1. Else Phantom#1297

2. (Let ({ pair<rid, routineTypeDefIR>* }) be set<pair<rid, routineTypeDefIR>>')

3. If ((pair<rid, routineTypeDefIR>* matches pattern _ :: _)), then

  1. (Let (rid_init_h : routineTypeDefIR_init_h) :: (rid_init_t : routineTypeDefIR_init_t)* be pair<rid, routineTypeDefIR>*)

  2. (Let routineTypeDefIR''? be $find_map<rid, routineTypeDefIR>(rdenv_extern, rid_init_h))

  3. If ((routineTypeDefIR''? matches pattern (_))), then

    1. (Let ?(routineTypeDefIR') be routineTypeDefIR''?)

    2. If ((routineTypeDefIR' has type polyRoutineTypeDefIR)), then

      1. (Let (routineTypeIR < tid_expl* , tid_impl* >) be (routineTypeDefIR' as polyRoutineTypeDefIR))

      2. If ((routineTypeIR has type methodTypeIR)), then

        1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

        2. If ((methodTypeIR matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

          1. (Let (extern_methodabstract( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

          2. (Let routineTypeDefIR be ((((extern_method( parameterTypeIR* )-> typeIR_ret) as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

          3. (Let routineTypeDefIR_subst be $subst_routineTypeDef(theta, routineTypeDefIR))

          4. If ((RoutineTypeDef_alpha: routineTypeDefIR_subst ~~ routineTypeDefIR_init_h holds)), then

            1. (Let rdenv_extern_subst be $update_map<rid, routineTypeDefIR>(rdenv_extern, rid_init_h, routineTypeDefIR_subst))

            2. Return $subst_rdenv(theta, rdenv_extern_subst, ({ (rid_init_t : routineTypeDefIR_init_t)* }))

          4. Else Phantom#1298

        2. Else Phantom#1299

      2. Else Phantom#1300

    2. Else Phantom#1301

  3. Else Phantom#1302

3. Else Phantom#1303

;; ../../../../examples/p4-concrete/5.11-typing-declaration.spectec:418:1-418:81:
def $split_constructors(methodPrototype*)

1. Case analysis on methodPrototype*

  1. Case (% matches pattern [])

    1. Return ([], [])

  2. Case (% matches pattern _ :: _)

    1. (Let methodPrototype_h :: methodPrototype_t* be methodPrototype*)

    2. (Let methodPrototype' be methodPrototype_h)

    3. Case analysis on methodPrototype'

      1. Case (% matches pattern `%%(%);`)

        1. (Let (_annotationList _typeIdentifier ( _parameterList );) be methodPrototype')

        2. (Let (methodPrototype_t_constructor*, methodPrototype_t_method*) be $split_constructors(methodPrototype_t*))

        3. Return (methodPrototype_h :: methodPrototype_t_constructor*, methodPrototype_t_method*)

      2. Case (% matches pattern `%%;`)

        1. (Let (_annotationList _functionPrototype ;) be methodPrototype')

        2. (Let (methodPrototype_t_constructor*, methodPrototype_t_method*) be $split_constructors(methodPrototype_t*))

        3. Return (methodPrototype_t_constructor*, methodPrototype_h :: methodPrototype_t_method*)

      3. Case (% matches pattern `%ABSTRACT%;`)

        1. (Let (_annotationList abstract _functionPrototype ;) be methodPrototype')

        2. (Let (methodPrototype_t_constructor*, methodPrototype_t_method*) be $split_constructors(methodPrototype_t*))

        3. Return (methodPrototype_t_constructor*, methodPrototype_h :: methodPrototype_t_method*)

    3. Else Phantom#1304

;; ../../../../examples/p4-concrete/5.11-typing-declaration.spectec:616:1-619:26:
relation Enum_serializable_field_ok: TC_0, nameIR_enum, typeIR, (name = expression)

1. (Expr_ok: (block) TC_0 |- expression : typedExpressionIR)

2. (Let typedExpressionIR'? be $coerce_unary(typedExpressionIR, typeIR))

3. If ((typedExpressionIR'? matches pattern (_))), then

  1. (Let ?(typedExpressionIR_cast) be typedExpressionIR'?)

  2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR_cast)

  3. If ((ctk matches pattern `LCTK`)), then

    1. (Eval_static: (block) TC_0 |- typedExpressionIR_cast ~> value)

    2. (Let nameIR be $name(name))

    3. (Let typeIR_enum be ((enum nameIR_enum # typeIR { [] }) as typeIR))

    4. (Let value_enum be ((nameIR_enum . nameIR # value) as value))

    5. (Let TC_1 be $add_var((block), TC_0, nameIR, (() typeIR_enum (lctk) ?(value_enum))))

    6. Result in TC_1, (nameIR = typedExpressionIR_cast), value

  3. Else Phantom#1305

3. Else Phantom#1306

;; ../../../../examples/p4-concrete/5.11-typing-declaration.spectec:638:1-641:26:
relation Enum_serializable_fields_ok: TC', nameIR_enum, typeIR, namedExpression*

1. Case analysis on namedExpression*

  1. Case (% matches pattern [])

    1. Result in TC', [], []

  2. Case (% matches pattern _ :: _)

    1. (Let namedExpression_h :: namedExpression_t* be namedExpression*)

    2. (Enum_serializable_field_ok: TC' nameIR_enum typeIR |- namedExpression_h : TC_1 namedExpressionIR_h # value_field_h)

    3. (Enum_serializable_fields_ok: TC_1 nameIR_enum typeIR |- namedExpression_t* : TC_2 namedExpressionIR_t* # value_field_t*)

    4. (Let namedExpressionIR* be namedExpressionIR_h :: namedExpressionIR_t*)

    5. (Let value_field* be value_field_h :: value_field_t*)

    6. Result in TC_2, namedExpressionIR*, value_field*

;; ../../../../examples/p4-concrete/5.13.1-typing-parser-statement.spectec:33:1-35:23:
relation SelectCase_keyset_simple_ok: TC, typeIR_key, simpleKeysetExpression

1. If ((simpleKeysetExpression has type expression)), then

  1. (Let expression be (simpleKeysetExpression as expression))

  2. (Expr_ok: (local) TC |- expression : typedExpressionIR)

  3. (Let (_expressionIR # (( typeIR'' _ctk ))) be typedExpressionIR)

  4. If ((typeIR'' has type setTypeIR)), then

    1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

    2. If ((typeIR'* matches pattern [ _/1 ])), then

      1. (Let [typeIR] be typeIR'*)

      2. Case analysis on (Type_alpha: typeIR ~~ typeIR_key holds)

        1. Case true

          1. Result in (typedExpressionIR as simpleKeysetExpressionIR)

        2. Case false

          1. If ((Sub_impl: typeIR <: typeIR_key holds)), then

            1. (Let typeIR_cast be ((set< [typeIR_key] >) as typeIR))

            2. (Let typedExpressionIR_cast be (((( typeIR_cast ) typedExpressionIR) as expressionIR) # (( typeIR_cast (dyn) ))))

            3. Result in (typedExpressionIR_cast as simpleKeysetExpressionIR)

          1. Else Phantom#1307

    2. Else Phantom#1308

  4. Else Phantom#1309

  5. If (~$is_set_typeIR(typeIR'')), then

    1. If ((Sub_impl: typeIR'' <: typeIR_key holds)), then

      1. (Let typeIR_cast be ((set< [typeIR_key] >) as typeIR))

      2. (Let typedExpressionIR_cast be (((( typeIR_cast ) typedExpressionIR) as expressionIR) # (( typeIR_cast (dyn) ))))

      3. Result in (typedExpressionIR_cast as simpleKeysetExpressionIR)

    1. Else Phantom#1310

  5. Else Phantom#1311

1. Else Phantom#1312

2. Case analysis on simpleKeysetExpression

  1. Case (% matches pattern `%&&&%`)

    1. (Let (expression_l &&& expression_r) be simpleKeysetExpression)

    2. (Expr_ok: (local) TC |- expression_l : typedExpressionIR_l)

    3. (Expr_ok: (local) TC |- expression_r : typedExpressionIR_r)

    4. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

    5. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

      1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

      2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask))

      3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

        2. (Let (_expressionIR # (( typeIR_reduced _ctk ))) be typedExpressionIR_l_reduced)

        3. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_l_reduced, typeIR_key))

        4. If ((typedExpressionIR? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_l_coerced) be typedExpressionIR?)

          2. (Let typedExpressionIR'? be $coerce_unary(typedExpressionIR_r_reduced, typeIR_key))

          3. If ((typedExpressionIR'? matches pattern (_))), then

            1. (Let ?(typedExpressionIR_r_coerced) be typedExpressionIR'?)

            2. Result in (typedExpressionIR_l_coerced &&& typedExpressionIR_r_coerced)

          3. Else Phantom#1313

        4. Else Phantom#1314

      3. Else Phantom#1315

    5. Else Phantom#1316

  2. Case (% matches pattern `%..%`)

    1. (Let (expression_l .. expression_r) be simpleKeysetExpression)

    2. (Expr_ok: (local) TC |- expression_l : typedExpressionIR_l)

    3. (Expr_ok: (local) TC |- expression_r : typedExpressionIR_r)

    4. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

    5. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

      1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

      2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range))

      3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

        2. (Let (_expressionIR # (( typeIR_reduced _ctk ))) be typedExpressionIR_l_reduced)

        3. (Let (_expressionIR' # (( typeIR _ctk' ))) be typedExpressionIR_r_reduced)

        4. If ((typeIR = typeIR_reduced)), then

          1. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_l_reduced, typeIR_key))

          2. If ((typedExpressionIR? matches pattern (_))), then

            1. (Let ?(typedExpressionIR_l_coerced) be typedExpressionIR?)

            2. (Let typedExpressionIR'? be $coerce_unary(typedExpressionIR_r_reduced, typeIR_key))

            3. If ((typedExpressionIR'? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_r_coerced) be typedExpressionIR'?)

              2. Result in (typedExpressionIR_l_coerced .. typedExpressionIR_r_coerced)

            3. Else Phantom#1317

          2. Else Phantom#1318

        4. Else Phantom#1319

      3. Else Phantom#1320

    5. Else Phantom#1321

  3. Case (% matches pattern `DEFAULT`)

    1. Result in (default)

  4. Case (% matches pattern `_`)

    1. Result in (_)

2. Else Phantom#1322

;; ../../../../examples/p4-concrete/5.13.1-typing-parser-statement.spectec:76:1-76:40:
def $compat_mask(typeIR_l, typeIR_r)

1. Return $compat'_mask($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../examples/p4-concrete/5.13.1-typing-parser-statement.spectec:77:1-77:41:
def $compat'_mask(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT`)

      1. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `INT`)), then

          1. Return true

    2. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `INT<%>`)), then

          1. (Let (int< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    3. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

          1. (Let (bit< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.13.1-typing-parser-statement.spectec:113:1-113:41:
def $compat_range(typeIR_l, typeIR_r)

1. Return $compat'_range($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../examples/p4-concrete/5.13.1-typing-parser-statement.spectec:114:1-114:42:
def $compat'_range(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT`)

      1. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `INT`)), then

          1. Return true

    2. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `INT<%>`)), then

          1. (Let (int< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    3. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

          1. (Let (bit< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.13.1-typing-parser-statement.spectec:161:1-163:23:
relation SelectCase_keyset_ok: TC, typeIR'*, keysetExpression

1. Case analysis on typeIR'*

  1. Case (% matches pattern [ _/1 ])

    1. (Let [typeIR_key] be typeIR'*)

    2. If ((keysetExpression has type expression)), then

      1. (Let expression be (keysetExpression as expression))

      2. (SelectCase_keyset_simple_ok: TC typeIR_key |- (expression as simpleKeysetExpression) : simpleKeysetExpressionIR)

      3. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

    2. Else Phantom#1323

    3. If ((keysetExpression has type simpleKeysetExpression)), then

      1. (Let simpleKeysetExpression be (keysetExpression as simpleKeysetExpression))

      2. Case analysis on simpleKeysetExpression

        1. Case (% matches pattern `%&&&%`)

          1. (Let (expression_l &&& expression_r) be simpleKeysetExpression)

          2. (SelectCase_keyset_simple_ok: TC typeIR_key |- (expression_l &&& expression_r) : simpleKeysetExpressionIR)

          3. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

        2. Case (% matches pattern `%..%`)

          1. (Let (expression_l .. expression_r) be simpleKeysetExpression)

          2. (SelectCase_keyset_simple_ok: TC typeIR_key |- (expression_l .. expression_r) : simpleKeysetExpressionIR)

          3. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

        3. Case (% matches pattern `DEFAULT`)

          1. (SelectCase_keyset_simple_ok: TC typeIR_key |- (default) : simpleKeysetExpressionIR)

          2. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

      2. Else Phantom#1324

    3. Else Phantom#1325

    4. (Let [typeIR'] be typeIR'*)

    5. If ((keysetExpression has type simpleKeysetExpression)), then

      1. (Let simpleKeysetExpression be (keysetExpression as simpleKeysetExpression))

      2. If ((simpleKeysetExpression matches pattern `_`)), then

        1. (SelectCase_keyset_simple_ok: TC typeIR' |- (_) : simpleKeysetExpressionIR)

        2. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

      2. Else Phantom#1326

    5. Else Phantom#1327

    6. (Let [typeIR'] be typeIR'*)

    7. If ((keysetExpression has type tupleKeysetExpression)), then

      1. (Let tupleKeysetExpression be (keysetExpression as tupleKeysetExpression))

      2. If ((tupleKeysetExpression matches pattern `(%&&&%)`)), then

        1. (Let (( expression_l &&& expression_r )) be tupleKeysetExpression)

        2. (SelectCase_keyset_simple_ok: TC typeIR' |- (expression_l &&& expression_r) : simpleKeysetExpressionIR)

        3. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

      2. Else Phantom#1328

    7. Else Phantom#1329

    8. (Let [typeIR'] be typeIR'*)

    9. If ((keysetExpression has type tupleKeysetExpression)), then

      1. (Let tupleKeysetExpression be (keysetExpression as tupleKeysetExpression))

      2. If ((tupleKeysetExpression matches pattern `(%..%)`)), then

        1. (Let (( expression_l .. expression_r )) be tupleKeysetExpression)

        2. (SelectCase_keyset_simple_ok: TC typeIR' |- (expression_l .. expression_r) : simpleKeysetExpressionIR)

        3. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

      2. Else Phantom#1330

    9. Else Phantom#1331

    10. (Let [typeIR'] be typeIR'*)

    11. If ((keysetExpression has type tupleKeysetExpression)), then

      1. (Let tupleKeysetExpression be (keysetExpression as tupleKeysetExpression))

      2. If ((tupleKeysetExpression matches pattern `(DEFAULT)`)), then

        1. (SelectCase_keyset_simple_ok: TC typeIR' |- (default) : simpleKeysetExpressionIR)

        2. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

      2. Else Phantom#1332

    11. Else Phantom#1333

    12. (Let [typeIR'] be typeIR'*)

    13. If ((keysetExpression has type tupleKeysetExpression)), then

      1. (Let tupleKeysetExpression be (keysetExpression as tupleKeysetExpression))

      2. If ((tupleKeysetExpression matches pattern `(_)`)), then

        1. (SelectCase_keyset_simple_ok: TC typeIR' |- (_) : simpleKeysetExpressionIR)

        2. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

      2. Else Phantom#1334

    13. Else Phantom#1335

  2. Case (% matches pattern [])

    1. If ((keysetExpression has type simpleKeysetExpression)), then

      1. (Let simpleKeysetExpression be (keysetExpression as simpleKeysetExpression))

      2. If ((simpleKeysetExpression matches pattern `DEFAULT`)), then

        1. Result in ((default) as keysetExpressionIR)

      2. Else Phantom#1336

    1. Else Phantom#1337

1. Else Phantom#1338

2. Case analysis on keysetExpression

  1. Case (% has type simpleKeysetExpression)

    1. (Let simpleKeysetExpression be (keysetExpression as simpleKeysetExpression))

    2. Case analysis on simpleKeysetExpression

      1. Case (% matches pattern `DEFAULT`)

        1. If ((|typeIR'*| > 1)), then

          1. (SelectCase_keyset_simple_ok: TC ((seq< typeIR'* >) as typeIR) |- (default) : simpleKeysetExpressionIR)

          2. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

        1. Else Phantom#1339

      2. Case (% matches pattern `_`)

        1. If ((|typeIR'*| > 1)), then

          1. (SelectCase_keyset_simple_ok: TC ((seq< typeIR'* >) as typeIR) |- (_) : simpleKeysetExpressionIR)

          2. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

        1. Else Phantom#1340

    2. Else Phantom#1341

  2. Case (% has type tupleKeysetExpression)

    1. (Let tupleKeysetExpression be (keysetExpression as tupleKeysetExpression))

    2. Case analysis on tupleKeysetExpression

      1. Case (% matches pattern `(DEFAULT)`)

        1. If ((|typeIR'*| > 1)), then

          1. (SelectCase_keyset_simple_ok: TC ((seq< typeIR'* >) as typeIR) |- (default) : simpleKeysetExpressionIR)

          2. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

        1. Else Phantom#1342

      2. Case (% matches pattern `(_)`)

        1. If ((|typeIR'*| > 1)), then

          1. (SelectCase_keyset_simple_ok: TC ((seq< typeIR'* >) as typeIR) |- (_) : simpleKeysetExpressionIR)

          2. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

        1. Else Phantom#1343

      3. Case (% matches pattern `(%,%)`)

        1. (Let (( simpleKeysetExpression_h , simpleKeysetExpressionList_t )) be tupleKeysetExpression)

        2. (Let simpleKeysetExpression_t* be $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList_t))

        3. (Let simpleKeysetExpression* be simpleKeysetExpression_h :: simpleKeysetExpression_t*)

        4. If ((|typeIR'*| = |simpleKeysetExpression*|)), then

          1. (SelectCase_keyset_simple_ok: TC typeIR' |- simpleKeysetExpression : simpleKeysetExpressionIR)*

          2. Result in ((( simpleKeysetExpressionIR* )) as keysetExpressionIR)

        4. Else Phantom#1344

    2. Else Phantom#1345

;; ../../../../examples/p4-concrete/5.13.1-typing-parser-statement.spectec:278:1-280:26:
relation SelectCase_ok: TC, nameIR_state*, typeIR_key*, (keysetExpression : name ;)

1. (SelectCase_keyset_ok: TC typeIR_key* |- keysetExpression : keysetExpressionIR)

2. (Let nameIR be $name(name))

3. If (nameIR is in nameIR_state*), then

  1. Result in (keysetExpressionIR : nameIR ;)

3. Else Phantom#1346

;; ../../../../examples/p4-concrete/5.14.1-typing-control-table.spectec:7:1-7:52:
def $compat_table_exact_optional_key(typeIR)

1. Return $compat'_table_exact_optional_key($canon(typeIR))

;; ../../../../examples/p4-concrete/5.14.1-typing-control-table.spectec:8:1-8:53:
def $compat'_table_exact_optional_key(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `BOOL`)

        1. Return true

      2. Case (% matches pattern `ERROR`)

        1. Return true

    2. Else Phantom#1347

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR'') be aliasTypeIR)

      2. Return $compat_table_exact_optional_key(typeIR'')

    2. Else Phantom#1348

  4. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # typeIR'' { _valueFieldIR* }) be enumTypeIR)

        2. Return $compat_table_exact_optional_key(typeIR'')

1. Else Phantom#1349

;; ../../../../examples/p4-concrete/5.14.1-typing-control-table.spectec:21:1-21:55:
def $compat_table_lpm_ternary_range_key(typeIR)

1. Return $compat'_table_lpm_ternary_range_key($canon(typeIR))

;; ../../../../examples/p4-concrete/5.14.1-typing-control-table.spectec:22:1-22:56:
def $compat'_table_lpm_ternary_range_key(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT`)

        1. Return true

      2. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      3. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

    2. Else Phantom#1350

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR'') be aliasTypeIR)

      2. Return $compat_table_lpm_ternary_range_key(typeIR'')

    2. Else Phantom#1351

  3. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum _tid # typeIR'' { _valueFieldIR* }) be enumTypeIR)

      2. Return $compat_table_lpm_ternary_range_key(typeIR'')

    2. Else Phantom#1352

1. Else Phantom#1353

;; ../../../../examples/p4-concrete/5.14.1-typing-control-table.spectec:34:1-34:45:
def $compat_table_key(nameIR, typeIR)

1. Case analysis on nameIR

  1. Case (% = "exact")

    1. If ($compat_table_exact_optional_key(typeIR)), then

      1. Return true

  2. Case (% = "optional")

    1. If ($compat_table_exact_optional_key(typeIR)), then

      1. Return true

  3. Case (% = "lpm")

    1. If ($compat_table_lpm_ternary_range_key(typeIR)), then

      1. Return true

  4. Case (% = "ternary")

    1. If ($compat_table_lpm_ternary_range_key(typeIR)), then

      1. Return true

  5. Case (% = "range")

    1. If ($compat_table_lpm_ternary_range_key(typeIR)), then

      1. Return true

2. Otherwise

  1. Return false

;; ../../../../examples/p4-concrete/5.14.1-typing-control-table.spectec:87:1-88:41:
def $split_dataplane_parameters(parameterTypeIR*)

1. Case analysis on parameterTypeIR*

  1. Case (% matches pattern [])

    1. Return ([], [])

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t* be parameterTypeIR*)

    2. (Let (direction _typeIR _id _value?) be parameterTypeIR_h)

    3. Case analysis on (direction matches pattern ``EMPTY`)

      1. Case true

        1. (Let (parameterTypeIR_data*, parameterTypeIR_control*) be $split_dataplane_parameters(parameterTypeIR_t*))

        2. Return (parameterTypeIR_data*, parameterTypeIR_h :: parameterTypeIR_control*)

      2. Case false

        1. (Let (parameterTypeIR_data*, parameterTypeIR_control*) be $split_dataplane_parameters(parameterTypeIR_t*))

        2. Return (parameterTypeIR_h :: parameterTypeIR_data*, parameterTypeIR_control*)

;; ../../../../examples/p4-concrete/5.14.1-typing-control-table.spectec:238:1-241:26:
relation TableEntry_keyset_simple_ok: TC, TBLC, (typeIR_key, text'), simpleKeysetExpression

1. Case analysis on text'

  1. Case (% = "lpm")

    1. If ((simpleKeysetExpression has type expression)), then

      1. (Let expression be (simpleKeysetExpression as expression))

      2. (Let matchMode be TBLC.mode)

      3. If ((matchMode matches pattern `NOPRILPM%`)), then

        1. (Let (noprilpm n) be matchMode)

        2. (Expr_ok: (local) TC |- expression : typedExpressionIR)

        3. (Let (_expressionIR # (( typeIR ctk ))) be typedExpressionIR)

        4. If ((Sub_impl: typeIR <: typeIR_key holds)), then

          1. (Let typeIR_set be ((set< [typeIR_key] >) as typeIR))

          2. (Let typedExpressionIR_set be (((( typeIR_set ) typedExpressionIR) as expressionIR) # (( typeIR_set ctk ))))

          3. Result in (lpm n), (typedExpressionIR_set as simpleKeysetExpressionIR)

        4. Else Phantom#1354

      3. Else Phantom#1355

    1. Else Phantom#1356

    2. Case analysis on simpleKeysetExpression

      1. Case (% matches pattern `%&&&%`)

        1. (Let (expression_l &&& expression_r) be simpleKeysetExpression)

        2. (Let matchMode be TBLC.mode)

        3. If ((matchMode matches pattern `NOPRILPM%`)), then

          1. (Let (noprilpm n) be matchMode)

          2. (Expr_ok: (local) TC |- expression_l : typedExpressionIR_l)

          3. (Expr_ok: (local) TC |- expression_r : typedExpressionIR_r)

          4. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

          5. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

            2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask))

            3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

              1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

              2. (Let (_expressionIR # (( typeIR_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

              3. If ((Sub_impl: typeIR_reduced <: typeIR_key holds)), then

                1. If ((ctk_r_reduced matches pattern `LCTK`)), then

                  1. (Eval_static: (local) TC |- typedExpressionIR_r_reduced ~> value_r)

                  2. (Let i_r be $to_number(value_r))

                  3. (Let n_prefix be $tableEntry_lpm_prefix(((n w $to_bitstr((n as int), i_r)) as value)))

                  4. Result in (lpm n_prefix), (typedExpressionIR_l_reduced &&& typedExpressionIR_r_reduced)

                1. Else Phantom#1357

              3. Else Phantom#1358

            3. Else Phantom#1359

          5. Else Phantom#1360

        3. Else Phantom#1361

      2. Case (% matches pattern `DEFAULT`)

        1. (Let matchMode be TBLC.mode)

        2. If ((matchMode matches pattern `NOPRILPM%`)), then

          1. (Let (noprilpm n) be matchMode)

          2. Result in (lpm n), (default)

        2. Else Phantom#1362

      3. Case (% matches pattern `_`)

        1. (Let matchMode be TBLC.mode)

        2. If ((matchMode matches pattern `NOPRILPM%`)), then

          1. (Let (noprilpm _nat) be matchMode)

          2. Result in (lpm 0), (_)

        2. Else Phantom#1363

    2. Else Phantom#1364

  2. Case (% = "ternary")

    1. If ((simpleKeysetExpression matches pattern `%&&&%`)), then

      1. (Let (expression_l &&& expression_r) be simpleKeysetExpression)

      2. (Expr_ok: (local) TC |- expression_l : typedExpressionIR_l)

      3. (Expr_ok: (local) TC |- expression_r : typedExpressionIR_r)

      4. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

      5. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

        2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask))

        3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

          2. (Let (_expressionIR # (( typeIR_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

          3. If ((Sub_impl: typeIR_reduced <: typeIR_key holds)), then

            1. Result in (nolpm), (typedExpressionIR_l_reduced &&& typedExpressionIR_r_reduced)

          3. Else Phantom#1365

        3. Else Phantom#1366

      5. Else Phantom#1367

    1. Else Phantom#1368

  3. Case (% = "range")

    1. If ((simpleKeysetExpression matches pattern `%..%`)), then

      1. (Let (expression_l .. expression_r) be simpleKeysetExpression)

      2. (Expr_ok: (local) TC |- expression_l : typedExpressionIR_l)

      3. (Expr_ok: (local) TC |- expression_r : typedExpressionIR_r)

      4. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

      5. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

        2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range))

        3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

          2. (Let (_expressionIR # (( typeIR_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

          3. If ((Sub_impl: typeIR_reduced <: typeIR_key holds)), then

            1. Result in (nolpm), (typedExpressionIR_l_reduced .. typedExpressionIR_r_reduced)

          3. Else Phantom#1369

        3. Else Phantom#1370

      5. Else Phantom#1371

    1. Else Phantom#1372

1. Else Phantom#1373

2. If ((simpleKeysetExpression has type expression)), then

  1. (Let expression be (simpleKeysetExpression as expression))

  2. If ((text' =/= "lpm")), then

    1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

    2. (Let (_expressionIR # (( typeIR ctk ))) be typedExpressionIR)

    3. If ((Sub_impl: typeIR <: typeIR_key holds)), then

      1. (Let typeIR_set be ((set< [typeIR_key] >) as typeIR))

      2. (Let typedExpressionIR_set be (((( typeIR_set ) typedExpressionIR) as expressionIR) # (( typeIR_set ctk ))))

      3. Result in (nolpm), (typedExpressionIR_set as simpleKeysetExpressionIR)

    3. Else Phantom#1374

  2. Else Phantom#1375

2. Else Phantom#1376

3. Case analysis on simpleKeysetExpression

  1. Case (% matches pattern `DEFAULT`)

    1. If ((text' =/= "exact")), then

      1. Result in (nolpm), (default)

    1. Else Phantom#1377

  2. Case (% matches pattern `_`)

    1. If ((text' =/= "exact")), then

      1. Result in (nolpm), (_)

    1. Else Phantom#1378

3. Else Phantom#1379

;; ../../../../examples/p4-concrete/5.14.1-typing-control-table.spectec:380:1-383:29:
relation TableEntry_keysets_simple_ok: TC, TBLC, TBLS', matchKey*, simpleKeysetExpression*

1. Case analysis on matchKey*

  1. Case (% matches pattern [])

    1. If ((simpleKeysetExpression* matches pattern [])), then

      1. Result in TBLS', []

    1. Else Phantom#1380

  2. Case (% matches pattern _ :: _)

    1. (Let matchKey_h :: matchKey_t* be matchKey*)

    2. If ((simpleKeysetExpression* matches pattern _ :: _)), then

      1. (Let simpleKeysetExpression_h :: simpleKeysetExpression_t* be simpleKeysetExpression*)

      2. (TableEntry_keyset_simple_ok: TC TBLC |- matchKey_h @ simpleKeysetExpression_h : TBLS_1 simpleKeysetExpressionIR_h)

      3. (Let TBLS_2 be $join_tableEntryState(TBLS', TBLS_1))

      4. (TableEntry_keysets_simple_ok: TC TBLC TBLS_2 |- matchKey_t* @ simpleKeysetExpression_t* : TBLS_3 simpleKeysetExpressionIR_t*)

      5. Result in TBLS_3, simpleKeysetExpressionIR_h :: simpleKeysetExpressionIR_t*

    2. Else Phantom#1381

;; ../../../../examples/p4-concrete/5.14.1-typing-control-table.spectec:900:1-900:44:
def $count_table_keys(tableProperty''*)

1. Case analysis on tableProperty''*

  1. Case (% matches pattern [])

    1. Return 0

  2. Case (% matches pattern _ :: _)

    1. (Let tableProperty'' :: tableProperty_t* be tableProperty''*)

    2. If ((tableProperty'' matches pattern `KEY={%}`)), then

      1. (Let (key={ _tableKeyList }) be tableProperty'')

      2. Return (1 + $count_table_keys(tableProperty_t*))

    2. Else Phantom#1382

    3. (Let tableProperty_h :: tableProperty_t* be tableProperty''*)

    4. Otherwise

      1. Return $count_table_keys(tableProperty_t*)

;; ../../../../examples/p4-concrete/5.14.1-typing-control-table.spectec:913:1-913:47:
def $count_table_actions(tableProperty''*)

1. Case analysis on tableProperty''*

  1. Case (% matches pattern [])

    1. Return 0

  2. Case (% matches pattern _ :: _)

    1. (Let tableProperty'' :: tableProperty_t* be tableProperty''*)

    2. If ((tableProperty'' matches pattern `ACTIONS={%}`)), then

      1. (Let (actions={ _tableActionList }) be tableProperty'')

      2. Return (1 + $count_table_actions(tableProperty_t*))

    2. Else Phantom#1383

    3. (Let tableProperty_h :: tableProperty_t* be tableProperty''*)

    4. Otherwise

      1. Return $count_table_actions(tableProperty_t*)

;; ../../../../examples/p4-concrete/5.15.1-typing-call-convention.spectec:7:1-7:73:
def $filter_default_parameters(parameterTypeIR*, id_default*)

1. Case analysis on parameterTypeIR*

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t* be parameterTypeIR*)

    2. (Let (_direction _typeIR id_h _value?) be parameterTypeIR_h)

    3. If (id_h is in id_default*), then

      1. Return $filter_default_parameters(parameterTypeIR_t*, id_default*)

    3. Else Phantom#1384

    4. Otherwise

      1. Return parameterTypeIR_h :: $filter_default_parameters(parameterTypeIR_t*, id_default*)

;; ../../../../examples/p4-concrete/5.15.1-typing-call-convention.spectec:26:1-26:71:
def $align_parameters(parameterTypeIR*, argumentIR*)

1. (Let (_direction _typeIR id _value?) be parameterTypeIR)*

2. (Let parameterTypeIR'? be $align_parameters'(({ (id : parameterTypeIR)* }), parameterTypeIR, argumentIR))*

3. If ((parameterTypeIR'? matches pattern (_)))*, then

  1. (Let ?(parameterTypeIR_aligned) be parameterTypeIR'?)*

  2. Return parameterTypeIR_aligned*

3. Else Phantom#1385

;; ../../../../examples/p4-concrete/5.15.1-typing-call-convention.spectec:27:1-27:96:
def $align_parameters'(_map<id, parameterTypeIR>', parameterTypeIR', argumentIR)

1. If ((argumentIR has type typedExpressionIR)), then

  1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

  2. Return ?(parameterTypeIR')

1. Else Phantom#1386

2. (Let ({ (id_param : parameterTypeIR')* }) be _map<id, parameterTypeIR>')

3. Case analysis on argumentIR

  1. Case (% matches pattern `%=%`)

    1. (Let (nameIR = _typedExpressionIR) be argumentIR)

    2. Return $find_map<id, parameterTypeIR>(({ (id_param : parameterTypeIR')* }), nameIR)

  2. Case (% matches pattern `%=_`)

    1. (Let (nameIR =_) be argumentIR)

    2. Return $find_map<id, parameterTypeIR>(({ (id_param : parameterTypeIR')* }), nameIR)

  3. Case (% matches pattern `_`)

    1. Return ?(parameterTypeIR')

3. Else Phantom#1387

;; ../../../../examples/p4-concrete/5.15.1-typing-call-convention.spectec:60:1-62:23:
relation Expr_lvalue_ok: p, TC, (expressionIR # (( _typeIR _ctk )))

1. Case analysis on expressionIR

  1. Case (% has type prefixedNameIR)

    1. (Let prefixedNameIR be (expressionIR as prefixedNameIR))

    2. (Let varTypeIR? be $find_var(p, TC, prefixedNameIR))

    3. If ((varTypeIR? matches pattern (_))), then

      1. (Let ?((direction _typeIR' ctk _value?)) be varTypeIR?)

      2. If ((ctk matches pattern `DYN`)), then

        1. If (((direction = (out)) \/ (direction = (inout)))), then

          1. The relation holds

        1. Else Phantom#1388

      2. Else Phantom#1389

    3. Else Phantom#1390

  2. Case (% has type memberAccessExpressionIR)

    1. (Let (memberAccessBaseIR . nameIR) be (expressionIR as memberAccessExpressionIR))

    2. If ((memberAccessBaseIR has type typedExpressionIR)), then

      1. (Let typedExpressionIR_base be (memberAccessBaseIR as typedExpressionIR))

      2. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_base holds)), then

        1. (Let (_expressionIR # (( typeIR_base _ctk' ))) be typedExpressionIR_base)

        2. (Let typeIR' be $canon(typeIR_base))

        3. If ((typeIR' has type headerStackTypeIR)), then

          1. (Let (typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

          2. If (((nameIR = "next") \/ (nameIR = "last"))), then

            1. If ((((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind)))), then

              1. The relation holds

            1. Else Phantom#1391

          2. Else Phantom#1392

        3. Else Phantom#1393

        4. If (~$is_headerStackTypeIR($canon(typeIR_base))), then

          1. The relation holds

        4. Else Phantom#1394

      2. Else Phantom#1395

    2. Else Phantom#1396

  3. Case (% has type indexAccessExpressionIR)

    1. (Let indexAccessExpressionIR be (expressionIR as indexAccessExpressionIR))

    2. Case analysis on indexAccessExpressionIR

      1. Case (% matches pattern `%[%]`)

        1. (Let (typedExpressionIR_base [ typedExpressionIR_index ]) be indexAccessExpressionIR)

        2. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_base holds)), then

          1. The relation holds

        2. Else Phantom#1397

      2. Case (% matches pattern `%[%:%]`)

        1. (Let (typedExpressionIR_base [ typedExpressionIR_hi : typedExpressionIR_lo ]) be indexAccessExpressionIR)

        2. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_base holds)), then

          1. The relation holds

        2. Else Phantom#1398

1. Else Phantom#1399

;; ../../../../examples/p4-concrete/5.15.2-typing-call-inference.spectec:6:1-7:12:
syntax infer = 
   | knownas typeIR
   | unknown

;; ../../../../examples/p4-concrete/5.15.2-typing-call-inference.spectec:9:21-9:36:
syntax constraint = map<tid, infer>

;; ../../../../examples/p4-concrete/5.15.2-typing-call-inference.spectec:11:1-11:41:
def $empty_constraint(tid*)

1. Return ({ (tid : (unknown))* })

;; ../../../../examples/p4-concrete/5.15.2-typing-call-inference.spectec:14:20-14:36:
syntax inference = map<tid, typeIR>

;; ../../../../examples/p4-concrete/5.15.2-typing-call-inference.spectec:20:1-20:60:
def $infer(tid_infer*, parameterTypeIR*, argumentIR*)

1. (Let constraint_init be $empty_constraint(tid_infer*))

2. (Let constraint_pair be $infer'(constraint_init, parameterTypeIR, argumentIR))*

3. (Let constraint_inferred be $merge_constraints(constraint_init, constraint_pair*))

4. (Let inference be $resolve_constraint(constraint_inferred))

5. Return inference

;; ../../../../examples/p4-concrete/5.15.2-typing-call-inference.spectec:21:1-21:66:
def $infer'(constraint, parameterTypeIR, argumentIR)

1. If ((argumentIR has type typedExpressionIR)), then

  1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

  2. (Let (_direction typeIR_param _id _value?) be parameterTypeIR)

  3. (Let (_expressionIR # (( typeIR_arg _ctk ))) be typedExpressionIR)

  4. Return $gen_constraint_type(constraint, typeIR_param, typeIR_arg)

1. Else Phantom#1400

2. Case analysis on argumentIR

  1. Case (% matches pattern `%=%`)

    1. (Let (nameIR = typedExpressionIR) be argumentIR)

    2. (Let (_direction typeIR_param _id _value?) be parameterTypeIR)

    3. (Let (_expressionIR # (( typeIR_arg _ctk ))) be typedExpressionIR)

    4. Return $gen_constraint_type(constraint, typeIR_param, typeIR_arg)

  2. Case (% matches pattern `%=_`)

    1. (Let (nameIR =_) be argumentIR)

    2. Return constraint

  3. Case (% matches pattern `_`)

    1. Return constraint

2. Else Phantom#1401

;; ../../../../examples/p4-concrete/5.15.2-typing-call-inference.spectec:23:1-23:66:
def $gen_constraint_type(constraint', typeIR'', typeIR_arg')

1. Case analysis on typeIR''

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. Case analysis on namedTypeIR

      1. Case (% matches pattern `TID%`)

        1. (Let (tid tid_param) be namedTypeIR)

        2. If ($in_set<tid>(tid_param, $dom_map<tid, infer>(constraint'))), then

          1. Return $update_map<tid, infer>(constraint', tid_param, (knownas typeIR_arg'))

      2. Case (% matches pattern `%<%>`)

        1. (Let (polyTypeDefIR_param < typeIR_param* >) be namedTypeIR)

        2. If ((typeIR_arg' has type namedTypeIR)), then

          1. (Let namedTypeIR' be (typeIR_arg' as namedTypeIR))

          2. If ((namedTypeIR' matches pattern `%<%>`)), then

            1. (Let (polyTypeDefIR_arg < typeIR_arg'* >) be namedTypeIR')

            2. (Let typeIR_specialized_param be $specialize_typeDef((polyTypeDefIR_param as typeDefIR), typeIR_param*))

            3. (Let typeIR_specialized_arg be $specialize_typeDef((polyTypeDefIR_arg as typeDefIR), typeIR_arg'*))

            4. If (($is_nominal_typeIR(typeIR_specialized_param) /\ $is_nominal_typeIR(typeIR_specialized_arg))), then

              1. (Let constraint_1 be $gen_constraint_type(constraint', typeIR_specialized_param, typeIR_specialized_arg))

              2. (Let constraint_2 be $gen_constraint_types(constraint_1, typeIR_param*, typeIR_arg'*))

              3. Return constraint_2

            5. If ((~$is_nominal_typeIR(typeIR_specialized_param) /\ ~$is_nominal_typeIR(typeIR_specialized_arg))), then

              1. (Let constraint_1 be $gen_constraint_type(constraint', typeIR_specialized_param, typeIR_specialized_arg))

              2. Return constraint_1

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. Case analysis on aliasTypeIR

      1. Case (% matches pattern `TYPEDEF%%`)

        1. (Let (typedef _tid typeIR_param) be aliasTypeIR)

        2. Return $gen_constraint_type(constraint', typeIR_param, typeIR_arg')

      2. Case (% matches pattern `TYPE%%`)

        1. (Let (type tid typeIR'') be aliasTypeIR)

        2. If ((typeIR_arg' has type aliasTypeIR)), then

          1. (Let aliasTypeIR' be (typeIR_arg' as aliasTypeIR))

          2. If ((aliasTypeIR' matches pattern `TYPE%%`)), then

            1. (Let (type tid' typeIR_arg') be aliasTypeIR')

            2. If ((tid = tid')), then

              1. Return $gen_constraint_type(constraint', typeIR'', typeIR_arg')

  3. Case (% has type listTypeIR)

    1. (Let (list< typeIR'' >) be (typeIR'' as listTypeIR))

    2. If ((typeIR_arg' has type listTypeIR)), then

      1. (Let (list< typeIR_arg' >) be (typeIR_arg' as listTypeIR))

      2. Return $gen_constraint_type(constraint', typeIR'', typeIR_arg')

  4. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. If ((typeIR_arg' has type tupleTypeIR)), then

      1. (Let (tuple< typeIR_arg'* >) be (typeIR_arg' as tupleTypeIR))

      2. Return $gen_constraint_types(constraint', typeIR''*, typeIR_arg'*)

  5. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'' [ n_size ]) be (typeIR'' as headerStackTypeIR))

    2. If ((typeIR_arg' has type headerStackTypeIR)), then

      1. (Let (typeIR_arg' [ n_size' ]) be (typeIR_arg' as headerStackTypeIR))

      2. If ((n_size = n_size')), then

        1. Return $gen_constraint_type(constraint', typeIR'', typeIR_arg')

  6. Case (% has type structTypeIR)

    1. (Let (struct tid { (typeIR'' id_field ;)* }) be (typeIR'' as structTypeIR))

    2. If ((typeIR_arg' has type structTypeIR)), then

      1. (Let (struct tid' { (typeIR_arg' id_field' ;)* }) be (typeIR_arg' as structTypeIR))

      2. If ((id_field = id_field'))*, then

        1. If ((tid = tid')), then

          1. Return $gen_constraint_types(constraint', typeIR''*, typeIR_arg'*)

  7. Case (% has type headerTypeIR)

    1. (Let (header tid { (typeIR'' id_field ;)* }) be (typeIR'' as headerTypeIR))

    2. If ((typeIR_arg' has type headerTypeIR)), then

      1. (Let (header tid' { (typeIR_arg' id_field' ;)* }) be (typeIR_arg' as headerTypeIR))

      2. If ((id_field = id_field'))*, then

        1. If ((tid = tid')), then

          1. Return $gen_constraint_types(constraint', typeIR''*, typeIR_arg'*)

  8. Case (% has type headerUnionTypeIR)

    1. (Let (header_union tid { (typeIR'' id_field ;)* }) be (typeIR'' as headerUnionTypeIR))

    2. If ((typeIR_arg' has type headerUnionTypeIR)), then

      1. (Let (header_union tid' { (typeIR_arg' id_field' ;)* }) be (typeIR_arg' as headerUnionTypeIR))

      2. If ((id_field = id_field'))*, then

        1. If ((tid = tid')), then

          1. Return $gen_constraint_types(constraint', typeIR''*, typeIR_arg'*)

  9. Case (% has type externObjectTypeIR)

    1. (Let (extern tid ({ (rid : routineTypeDefIR_param)* })) be (typeIR'' as externObjectTypeIR))

    2. If ((typeIR_arg' has type externObjectTypeIR)), then

      1. (Let (extern tid' ({ (rid' : routineTypeDefIR_arg)* })) be (typeIR_arg' as externObjectTypeIR))

      2. If ((rid = rid'))*, then

        1. If ((tid = tid')), then

          1. Return $gen_constraint_routines(constraint', routineTypeDefIR_param*, routineTypeDefIR_arg*)

  10. Case (% has type parserObjectTypeIR)

    1. (Let (parser( parameterTypeIR_param* )) be (typeIR'' as parserObjectTypeIR))

    2. If ((typeIR_arg' has type parserObjectTypeIR)), then

      1. (Let (parser( parameterTypeIR_arg* )) be (typeIR_arg' as parserObjectTypeIR))

      2. (Let (direction typeIR'' _id _value?) be parameterTypeIR_param)*

      3. (Let (direction' typeIR_arg' _id' _value'?) be parameterTypeIR_arg)*

      4. If ((direction' = direction))*, then

        1. Return $gen_constraint_types(constraint', typeIR''*, typeIR_arg'*)

  11. Case (% has type controlObjectTypeIR)

    1. (Let (control( parameterTypeIR_param* )) be (typeIR'' as controlObjectTypeIR))

    2. If ((typeIR_arg' has type controlObjectTypeIR)), then

      1. (Let (control( parameterTypeIR_arg* )) be (typeIR_arg' as controlObjectTypeIR))

      2. (Let (direction typeIR'' _id _value?) be parameterTypeIR_param)*

      3. (Let (direction' typeIR_arg' _id' _value'?) be parameterTypeIR_arg)*

      4. If ((direction' = direction))*, then

        1. Return $gen_constraint_types(constraint', typeIR''*, typeIR_arg'*)

  12. Case (% has type packageObjectTypeIR)

    1. (Let (package< typeIR''* >) be (typeIR'' as packageObjectTypeIR))

    2. If ((typeIR_arg' has type packageObjectTypeIR)), then

      1. (Let (package< typeIR_arg'* >) be (typeIR_arg' as packageObjectTypeIR))

      2. Return $gen_constraint_types(constraint', typeIR''*, typeIR_arg'*)

2. If ((typeIR_arg' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR_arg' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPEDEF%%`)), then

    1. (Let (typedef _tid typeIR_arg') be aliasTypeIR)

    2. Return $gen_constraint_type(constraint', typeIR'', typeIR_arg')

3. Otherwise

  1. Return constraint'

;; ../../../../examples/p4-concrete/5.15.2-typing-call-inference.spectec:24:1-24:69:
def $gen_constraint_types(constraint, typeIR_param*, typeIR_arg*)

1. (Let constraint_pair be $gen_constraint_type(constraint, typeIR_param, typeIR_arg))*

2. Return $merge_constraints(constraint, constraint_pair*)

;; ../../../../examples/p4-concrete/5.15.2-typing-call-inference.spectec:25:1-28:15:
def $gen_constraint_routine(constraint_0, routineTypeDefIR, routineTypeDefIR')

1. If ((routineTypeDefIR has type polyRoutineTypeDefIR)), then

  1. (Let (routineTypeIR < _tid* , _tid'* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

  2. If ((routineTypeIR has type methodTypeIR)), then

    1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

    2. Case analysis on methodTypeIR

      1. Case (% matches pattern `EXTERN_METHOD(%)->%`)

        1. (Let (extern_method( parameterTypeIR_param* )-> typeIR_ret_param) be methodTypeIR)

        2. If ((routineTypeDefIR' has type polyRoutineTypeDefIR)), then

          1. (Let (routineTypeIR' < _tid''* , _tid'''* >) be (routineTypeDefIR' as polyRoutineTypeDefIR))

          2. If ((routineTypeIR' has type methodTypeIR)), then

            1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

            2. If ((methodTypeIR' matches pattern `EXTERN_METHOD(%)->%`)), then

              1. (Let (extern_method( parameterTypeIR_arg* )-> typeIR_ret_arg) be methodTypeIR')

              2. (Let (direction typeIR_param _id _value?) be parameterTypeIR_param)*

              3. (Let (direction' typeIR_arg _id' _value'?) be parameterTypeIR_arg)*

              4. If ((direction' = direction))*, then

                1. (Let constraint_1 be $gen_constraint_types(constraint_0, typeIR_param*, typeIR_arg*))

                2. (Let constraint_2 be $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg))

                3. Return constraint_2

              4. Else Phantom#1402

            2. Else Phantom#1403

          2. Else Phantom#1404

        2. Else Phantom#1405

      2. Case (% matches pattern `EXTERN_METHODABSTRACT(%)->%`)

        1. (Let (extern_methodabstract( parameterTypeIR_param* )-> typeIR_ret_param) be methodTypeIR)

        2. If ((routineTypeDefIR' has type polyRoutineTypeDefIR)), then

          1. (Let (routineTypeIR' < _tid''* , _tid'''* >) be (routineTypeDefIR' as polyRoutineTypeDefIR))

          2. If ((routineTypeIR' has type methodTypeIR)), then

            1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

            2. If ((methodTypeIR' matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

              1. (Let (extern_methodabstract( parameterTypeIR_arg* )-> typeIR_ret_arg) be methodTypeIR')

              2. (Let (direction typeIR_param _id _value?) be parameterTypeIR_param)*

              3. (Let (direction' typeIR_arg _id' _value'?) be parameterTypeIR_arg)*

              4. If ((direction' = direction))*, then

                1. (Let constraint_1 be $gen_constraint_types(constraint_0, typeIR_param*, typeIR_arg*))

                2. (Let constraint_2 be $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg))

                3. Return constraint_2

              4. Else Phantom#1406

            2. Else Phantom#1407

          2. Else Phantom#1408

        2. Else Phantom#1409

    2. Else Phantom#1410

  2. Else Phantom#1411

1. Else Phantom#1412

;; ../../../../examples/p4-concrete/5.15.2-typing-call-inference.spectec:29:1-32:15:
def $gen_constraint_routines(constraint, routineTypeDefIR_param*, routineTypeDefIR_arg*)

1. (Let constraint_pair be $gen_constraint_routine(constraint, routineTypeDefIR_param, routineTypeDefIR_arg))*

2. Return $merge_constraints(constraint, constraint_pair*)

;; ../../../../examples/p4-concrete/5.15.2-typing-call-inference.spectec:34:1-34:59:
def $merge_constraint(constraint_pre, constraint_post)

1. (Let ({ tid_pre* }) be $dom_map<tid, infer>(constraint_pre))

2. (Let ({ tid_post* }) be $dom_map<tid, infer>(constraint_post))

3. If ($eq_set<tid>(({ tid_pre* }), ({ tid_post* }))), then

  1. Return $merge_constraint'(constraint_pre, constraint_post, tid_pre*, ({ [] }))

3. Else Phantom#1413

;; ../../../../examples/p4-concrete/5.15.2-typing-call-inference.spectec:35:1-35:78:
def $merge_constraint'(constraint_pre, constraint_post, tid*, constraint)

1. Case analysis on tid*

  1. Case (% matches pattern [])

    1. Return constraint

  2. Case (% matches pattern _ :: _)

    1. (Let tid_h :: tid_t* be tid*)

    2. If ((?((unknown)) = $find_map<tid, infer>(constraint_pre, tid_h))), then

      1. If ((?((unknown)) = $find_map<tid, infer>(constraint_post, tid_h))), then

        1. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (unknown)))

        2. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*, constraint_updated)

      1. Else Phantom#1414

      2. (Let infer'? be $find_map<tid, infer>(constraint_post, tid_h))

      3. If ((infer'? matches pattern (_))), then

        1. (Let ?(infer) be infer'?)

        2. If ((infer matches pattern `KNOWNAS%`)), then

          1. (Let (knownas typeIR_post) be infer)

          2. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (knownas typeIR_post)))

          3. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*, constraint_updated)

        2. Else Phantom#1415

      3. Else Phantom#1416

    2. Else Phantom#1417

    3. (Let infer'? be $find_map<tid, infer>(constraint_pre, tid_h))

    4. If ((infer'? matches pattern (_))), then

      1. (Let ?(infer) be infer'?)

      2. If ((infer matches pattern `KNOWNAS%`)), then

        1. (Let (knownas typeIR_pre) be infer)

        2. If ((?((unknown)) = $find_map<tid, infer>(constraint_post, tid_h))), then

          1. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (knownas typeIR_pre)))

          2. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*, constraint_updated)

        2. Else Phantom#1418

        3. (Let infer'''? be $find_map<tid, infer>(constraint_post, tid_h))

        4. If ((infer'''? matches pattern (_))), then

          1. (Let ?(infer'') be infer'''?)

          2. If ((infer'' matches pattern `KNOWNAS%`)), then

            1. (Let (knownas typeIR_post) be infer'')

            2. Case analysis on (Sub_impl: typeIR_pre <: typeIR_post holds)

              1. Case true

                1. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (knownas typeIR_post)))

                2. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*, constraint_updated)

              2. Case false

                1. If ((Sub_impl: typeIR_post <: typeIR_pre holds)), then

                  1. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (knownas typeIR_pre)))

                  2. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*, constraint_updated)

                1. Else Phantom#1419

          2. Else Phantom#1420

        4. Else Phantom#1421

      2. Else Phantom#1422

    4. Else Phantom#1423

;; ../../../../examples/p4-concrete/5.15.2-typing-call-inference.spectec:36:1-36:61:
def $merge_constraints(constraint_pre', constraint*)

1. Case analysis on constraint*

  1. Case (% matches pattern [])

    1. Return constraint_pre'

  2. Case (% matches pattern _ :: _)

    1. (Let constraint_post_h :: constraint_post_t* be constraint*)

    2. (Let constraint_pre_1 be $merge_constraint(constraint_pre', constraint_post_h))

    3. (Let constraint_pre_2 be $merge_constraints(constraint_pre_1, constraint_post_t*))

    4. Return constraint_pre_2

;; ../../../../examples/p4-concrete/5.15.2-typing-call-inference.spectec:38:1-38:48:
def $resolve_constraint(({ (tid : infer)* }))

1. If ((infer matches pattern `KNOWNAS%`))*, then

  1. (Let (knownas typeIR) be infer)*

  2. Return ({ (tid : typeIR)* })

1. Else Phantom#1424

;; ../../../../examples/p4-concrete/5.15.3-typing-constructor-call.spectec:21:1-21:65:
def $instantiable_extern(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return true

  2. Case (% matches pattern `BLOCK`)

    1. Return true

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../examples/p4-concrete/5.15.3-typing-constructor-call.spectec:27:1-27:65:
def $instantiable_parser(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return (instctxt = (anon))

  2. Case (% matches pattern `BLOCK`)

    1. Return $is_parser_blockKind(TC.block.kind)

  3. Case (% matches pattern `LOCAL`)

    1. Return $is_parser_state_localKind(TC.local.kind)

;; ../../../../examples/p4-concrete/5.15.3-typing-constructor-call.spectec:36:1-36:66:
def $instantiable_control(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return (instctxt = (anon))

  2. Case (% matches pattern `BLOCK`)

    1. Return $is_control_blockKind(TC.block.kind)

  3. Case (% matches pattern `LOCAL`)

    1. Return $is_control_apply_method_localKind(TC.local.kind)

;; ../../../../examples/p4-concrete/5.15.3-typing-constructor-call.spectec:45:1-45:66:
def $instantiable_package(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return true

  2. Case (% matches pattern `BLOCK`)

    1. Return $is_package_blockKind(TC.block.kind)

  3. Case (% matches pattern `LOCAL`)

    1. Return false

;; ../../../../examples/p4-concrete/5.15.3-typing-constructor-call.spectec:52:1-52:64:
def $instantiable_table(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return $is_control_blockKind(TC.block.kind)

  3. Case (% matches pattern `LOCAL`)

    1. Return false

;; ../../../../examples/p4-concrete/5.15.3-typing-constructor-call.spectec:59:1-59:66:
def $instantiable(p, TC, instctxt, typeIR)

1. If ($is_extern_object_typeIR($canon(typeIR))), then

  1. Return $instantiable_extern(p, TC, instctxt)

1. Else Phantom#1425

2. If ($is_parser_object_typeIR($canon(typeIR))), then

  1. Return $instantiable_parser(p, TC, instctxt)

2. Else Phantom#1426

3. If ($is_control_object_typeIR($canon(typeIR))), then

  1. Return $instantiable_control(p, TC, instctxt)

3. Else Phantom#1427

4. If ($is_package_object_typeIR($canon(typeIR))), then

  1. Return $instantiable_package(p, TC, instctxt)

4. Else Phantom#1428

5. If ($is_table_object_typeIR($canon(typeIR))), then

  1. Return $instantiable_table(p, TC, instctxt)

5. Else Phantom#1429

;; ../../../../examples/p4-concrete/5.15.4-typing-routine-call.spectec:55:1-55:33:
def $lvalue(lvalue'')

1. If ((lvalue'' has type referenceExpression)), then

  1. (Let referenceExpression be (lvalue'' as referenceExpression))

  2. Return (referenceExpression as expression)

1. Else Phantom#1430

2. Case analysis on lvalue''

  1. Case (% matches pattern `%.%`)

    1. (Let (lvalue_base . member) be lvalue'')

    2. (Let expression_base be $lvalue(lvalue_base))

    3. Return (((expression_base as memberAccessBase) . member) as expression)

  2. Case (% matches pattern `%[%]`)

    1. (Let (lvalue_base [ expression_index ]) be lvalue'')

    2. (Let expression_base be $lvalue(lvalue_base))

    3. Return ((expression_base [ expression_index ]) as expression)

  3. Case (% matches pattern `%[%:%]`)

    1. (Let (lvalue_base [ expression_hi : expression_lo ]) be lvalue'')

    2. (Let expression_base be $lvalue(lvalue_base))

    3. Return ((expression_base [ expression_hi : expression_lo ]) as expression)

  4. Case (% matches pattern `(%)`)

    1. (Let (( lvalue'' )) be lvalue'')

    2. (Let expression be $lvalue(lvalue''))

    3. Return ((( expression )) as expression)

2. Else Phantom#1431

;; ../../../../examples/p4-concrete/5.15.4-typing-routine-call.spectec:239:1-239:61:
def $callable_builtin_function(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return true

  2. Case (% matches pattern `BLOCK`)

    1. Return true

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../examples/p4-concrete/5.15.4-typing-routine-call.spectec:266:1-266:53:
def $callable_function(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))

  3. Case (% matches pattern `LOCAL`)

    1. Return (~$is_extern_method_localKind(TC.local.kind) /\ ~$is_extern_abstract_method_localKind(TC.local.kind))

;; ../../../../examples/p4-concrete/5.15.4-typing-routine-call.spectec:310:1-310:60:
def $callable_extern_function(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../examples/p4-concrete/5.15.4-typing-routine-call.spectec:352:1-352:51:
def $callable_action(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return false

  3. Case (% matches pattern `LOCAL`)

    1. Return ($is_action_localKind(TC.local.kind) \/ $is_control_apply_method_localKind(TC.local.kind))

;; ../../../../examples/p4-concrete/5.15.4-typing-routine-call.spectec:383:1-383:59:
def $callable_builtin_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return true

  2. Case (% matches pattern `BLOCK`)

    1. Return true

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../examples/p4-concrete/5.15.4-typing-routine-call.spectec:410:1-410:58:
def $callable_extern_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../examples/p4-concrete/5.15.4-typing-routine-call.spectec:452:1-452:67:
def $callable_extern_abstract_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../examples/p4-concrete/5.15.4-typing-routine-call.spectec:494:1-494:64:
def $callable_parser_apply_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return false

  3. Case (% matches pattern `LOCAL`)

    1. Return $is_parser_state_localKind(TC.local.kind)

;; ../../../../examples/p4-concrete/5.15.4-typing-routine-call.spectec:522:1-522:65:
def $callable_control_apply_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return false

  3. Case (% matches pattern `LOCAL`)

    1. Return $is_control_apply_method_localKind(TC.local.kind)

;; ../../../../examples/p4-concrete/5.15.4-typing-routine-call.spectec:550:1-550:63:
def $callable_table_apply_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return false

  3. Case (% matches pattern `LOCAL`)

    1. Return ($is_control_apply_method_localKind(TC.local.kind) \/ $is_table_apply_method_localKind(TC.local.kind))

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:5:1-5:27:
def $empty_theta

1. Return $empty_map<tid, typeIR>

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:9:15-9:29:
syntax venv = map<id, value>

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:11:1-11:25:
def $empty_venv

1. Return $empty_map<id, value>

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:15:19-15:41:
syntax stateDyn = parserBlockStatementIR

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:18:15-18:36:
syntax senv = map<nameIR, stateDyn>

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:20:1-20:25:
def $empty_senv

1. Return $empty_map<nameIR, stateDyn>

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:28:1-31:34:
syntax lvalueDyn = 
   | ` nameIR
   | . nameIR
   | lvalueDyn . nameIR
   | lvalueDyn [ value ]
   | lvalueDyn [ value : value ]

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:40:1-43:96:
syntax funcDyn = 
   | builtin_function< typeParameterListIR >( parameterListIR ){ blockElementStatementListIR }
   | function< typeParameterListIR >( parameterListIR ) blockStatementIR
   | action( parameterListIR ){ blockStatementIR }
   | extern_function< typeParameterListIR >( parameterListIR ){ blockElementStatementIR? }

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:46:1-51:41:
syntax methodDyn = 
   | builtin_method( parameterListIR )# lvalueDyn
   | extern_method< typeParameterListIR >( parameterListIR ) blockStatementIR?
   | extern_methodabstract< typeParameterListIR >( parameterListIR )
   | parser_apply( parameterListIR ){ parserLocalDeclarationListIR ; senv }
   | control_apply( parameterListIR ){ controlLocalDeclarationListIR ; renv ; blockElementStatementListIR }
   | table_apply{ tablePropertyListIR }

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:54:1-55:14:
syntax routineDyn = 
   | builtin_function< typeParameterListIR >( parameterListIR ){ blockElementStatementListIR }
   | function< typeParameterListIR >( parameterListIR ) blockStatementIR
   | action( parameterListIR ){ blockStatementIR }
   | extern_function< typeParameterListIR >( parameterListIR ){ blockElementStatementIR? }
   | builtin_method( parameterListIR )# lvalueDyn
   | extern_method< typeParameterListIR >( parameterListIR ) blockStatementIR?
   | extern_methodabstract< typeParameterListIR >( parameterListIR )
   | parser_apply( parameterListIR ){ parserLocalDeclarationListIR ; senv }
   | control_apply( parameterListIR ){ controlLocalDeclarationListIR ; renv ; blockElementStatementListIR }
   | table_apply{ tablePropertyListIR }

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:58:15-58:35:
syntax renv = map<rid, routineDyn>

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:60:1-60:25:
def $empty_renv

1. Return $empty_map<rid, routineDyn>

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:68:1-72:42:
syntax consDyn = 
   | extern nameIR < typeParameterListIR >( constructorParameterListIR ){ methodPrototypeListIR }
   | parser< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }
   | control< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }
   | package< typeParameterListIR >( constructorParameterListIR )
   | table nameIR { tablePropertyListIR }

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:75:15-75:32:
syntax cenv = map<cid, consDyn>

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:77:1-77:25:
def $empty_cenv

1. Return $empty_map<cid, consDyn>

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:85:1-89:44:
syntax objDyn = 
   | extern{ tid theta venv renv }
   | parser{ venv parameterListIR parserLocalDeclarationListIR senv }
   | control{ venv parameterListIR controlLocalDeclarationListIR renv controlBodyIR }
   | package{ theta venv }
   | table{ tid venv tablePropertyListIR }

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:92:14-92:30:
syntax sto = map<oid, objDyn>

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:94:1-94:23:
def $empty_sto

1. Return $empty_map<oid, objDyn>

;; ../../../../examples/p4-concrete/6.01-env-dynamic.spectec:98:1-98:37:
def $add_sto(sto, oid, objDyn)

1. Return $add_map<oid, objDyn>(sto, oid, objDyn)

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:8:3-11:16:
syntax globalInstantiationLayer = {cenv cenv, tdenv tdenv, renv renv, venv venv}

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:16:3-19:16:
syntax blockInstantiationLayer = {theta theta, renv renv, senv senv, venv venv}

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:24:3-25:18:
syntax localInstantiationLayer = {theta theta, venvs venv*}

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:32:3-35:36:
syntax contextInst = {path oid, global globalInstantiationLayer, block blockInstantiationLayer, local localInstantiationLayer}

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:43:1-43:45:
def $empty_block

1. Return {theta $empty_theta, renv $empty_renv, senv $empty_senv, venv $empty_venv}

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:51:1-51:45:
def $empty_local

1. Return {theta $empty_theta, venvs []}

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:57:1-57:40:
def $empty_context_inst

1. (Let globalInstantiationLayer be {cenv $empty_cenv, tdenv $empty_tdenv, renv $empty_renv, venv $empty_venv})

2. (Let blockInstantiationLayer be $empty_block)

3. (Let localInstantiationLayer be $empty_local)

4. (Let Ci be {path [], global globalInstantiationLayer, block blockInstantiationLayer, local localInstantiationLayer})

5. Return Ci

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:78:1-78:43:
def $enter_inst(Ci)

1. Return Ci[local.venvs = $empty_venv :: Ci.local.venvs]

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:82:1-82:42:
def $exit_inst(Ci)

1. (Let venv* be Ci.local.venvs)

2. If ((venv* matches pattern _ :: _)), then

  1. (Let venv_h :: venv_t* be venv*)

  2. Return Ci[local.venvs = venv_t*]

2. Else Phantom#1432

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:91:1-91:47:
def $enter_path(Ci, id)

1. Return Ci[path = Ci.path ++ [id]]

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:99:1-99:58:
def $copy_context_inst(cursor, Ci)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return Ci[block = $empty_block][local = $empty_local]

  2. Case (% matches pattern `BLOCK`)

    1. Return Ci[local = $empty_local]

  3. Case (% matches pattern `LOCAL`)

    1. Return Ci

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:111:1-111:65:
def $add_value_inst(cursor, Ci, id, value)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. If (~$in_set<id>(id, $dom_map<id, value>(Ci.global.venv))), then

      1. (Let venv be $add_map<id, value>(Ci.global.venv, id, value))

      2. Return Ci[global.venv = venv]

    1. Else Phantom#1433

  2. Case (% matches pattern `BLOCK`)

    1. If (~$in_set<id>(id, $dom_map<id, value>(Ci.block.venv))), then

      1. (Let venv be $add_map<id, value>(Ci.block.venv, id, value))

      2. Return Ci[block.venv = venv]

    1. Else Phantom#1434

  3. Case (% matches pattern `LOCAL`)

    1. (Let venv* be Ci.local.venvs)

    2. If ((venv* matches pattern _ :: _)), then

      1. (Let venv_h :: venv_t* be venv*)

      2. If (~$in_set<id>(id, $dom_map<id, value>(venv_h))), then

        1. (Let venv_h' be $add_map<id, value>(venv_h, id, value))

        2. Return Ci[local.venvs = venv_h' :: venv_t*]

      2. Else Phantom#1435

    2. Else Phantom#1436

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:112:1-112:68:
def $add_values_inst(p, Ci, id*, value*)

1. Case analysis on id*

  1. Case (% matches pattern [])

    1. If ((value* matches pattern [])), then

      1. Return Ci

    1. Else Phantom#1437

  2. Case (% matches pattern _ :: _)

    1. (Let id_h :: id_t* be id*)

    2. If ((value* matches pattern _ :: _)), then

      1. (Let value_h :: value_t* be value*)

      2. (Let Ci' be $add_value_inst(p, Ci, id_h, value_h))

      3. (Let Ci'' be $add_values_inst(p, Ci', id_t*, value_t*))

      4. Return Ci''

    2. Else Phantom#1438

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:132:1-132:73:
def $add_typedef_inst(cursor, Ci, tid, typeDefIR)

1. If ((cursor matches pattern `GLOBAL`)), then

  1. (Let tdenv be $add_map<tid, typeDefIR>(Ci.global.tdenv, tid, typeDefIR))

  2. Return Ci[global.tdenv = tdenv]

1. Else Phantom#1439

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:139:1-139:73:
def $add_state_inst(cursor, Ci, nameIR, stateDyn)

1. If ((cursor matches pattern `BLOCK`)), then

  1. If (~$in_set<nameIR>(nameIR, $dom_map<nameIR, stateDyn>(Ci.block.senv))), then

    1. (Let senv be $add_map<nameIR, stateDyn>(Ci.block.senv, nameIR, stateDyn))

    2. Return Ci[block.senv = senv]

  1. Else Phantom#1440

1. Else Phantom#1441

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:147:1-147:70:
def $add_types_inst(p, Ci, tid*, typeIR*)

1. Case analysis on tid*

  1. Case (% matches pattern [])

    1. If ((typeIR* matches pattern [])), then

      1. Return Ci

    1. Else Phantom#1442

  2. Case (% matches pattern _ :: _)

    1. (Let tid_h :: tid_t* be tid*)

    2. If ((typeIR* matches pattern _ :: _)), then

      1. (Let typeIR_h :: typeIR_t* be typeIR*)

      2. (Let Ci' be $add_type_inst(p, Ci, tid_h, typeIR_h))

      3. Return $add_types_inst(p, Ci', tid_t*, typeIR_t*)

    2. Else Phantom#1443

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:148:1-148:67:
def $add_type_inst(cursor, Ci, tid, typeIR)

1. Case analysis on cursor

  1. Case (% matches pattern `BLOCK`)

    1. (Let theta be $add_map<tid, typeIR>(Ci.block.theta, tid, typeIR))

    2. Return Ci[block.theta = theta]

  2. Case (% matches pattern `LOCAL`)

    1. (Let theta be $add_map<tid, typeIR>(Ci.local.theta, tid, typeIR))

    2. Return Ci[local.theta = theta]

1. Else Phantom#1444

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:162:1-162:83:
def $add_routine_overload_inst(cursor, Ci, rid, routineDyn)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. If (~$in_set<rid>(rid, $dom_map<rid, routineDyn>(Ci.global.renv))), then

      1. (Let renv be $add_map<rid, routineDyn>(Ci.global.renv, rid, routineDyn))

      2. Return Ci[global.renv = renv]

    1. Else Phantom#1445

  2. Case (% matches pattern `BLOCK`)

    1. If (~$in_set<rid>(rid, $dom_map<rid, routineDyn>(Ci.block.renv))), then

      1. (Let renv be $add_map<rid, routineDyn>(Ci.block.renv, rid, routineDyn))

      2. Return Ci[block.renv = renv]

    1. Else Phantom#1446

1. Else Phantom#1447

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:171:1-171:87:
def $add_routine_non_overload_inst(cursor, Ci, rid, routineDyn)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let (id ( _pid* )) be rid)

    2. (Let ({ (id_k ( _pid'* ))* }) be $dom_map<rid, routineDyn>(Ci.global.renv))

    3. If (~$in_set<id>(id, ({ id_k* }))), then

      1. (Let renv be $add_map<rid, routineDyn>(Ci.global.renv, rid, routineDyn))

      2. Return Ci[global.renv = renv]

    3. Else Phantom#1448

  2. Case (% matches pattern `BLOCK`)

    1. (Let (id ( _pid* )) be rid)

    2. (Let ({ (id_k ( _pid'* ))* }) be $dom_map<rid, routineDyn>(Ci.block.renv))

    3. If (~$in_set<id>(id, ({ id_k* }))), then

      1. (Let renv be $add_map<rid, routineDyn>(Ci.block.renv, rid, routineDyn))

      2. Return Ci[block.renv = renv]

    3. Else Phantom#1449

1. Else Phantom#1450

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:186:1-186:75:
def $add_constructor_inst(cursor, Ci, cid, consDyn)

1. If ((cursor matches pattern `GLOBAL`)), then

  1. (Let cenv be $add_map<cid, consDyn>(Ci.global.cenv, cid, consDyn))

  2. Return Ci[global.cenv = cenv]

1. Else Phantom#1451

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:197:1-197:66:
def $find_value_inst(p', Ci, prefixedNameIR)

1. If ((prefixedNameIR matches pattern `.%`)), then

  1. (Let (. id) be prefixedNameIR)

  2. (Let value'? be $find_map<id, value>(Ci.global.venv, id))

  3. If ((value'? matches pattern (_))), then

    1. (Let ?(value) be value'?)

    2. Return value

  3. Else Phantom#1452

1. Else Phantom#1453

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let value'? be $find_map<id, value>(Ci.global.venv, id))

      3. If ((value'? matches pattern (_))), then

        1. (Let ?(value) be value'?)

        2. Return value

      3. Else Phantom#1454

    1. Else Phantom#1455

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let value'? be $find_map<id, value>(Ci.block.venv, id))

      3. If ((value'? matches pattern (_))), then

        1. (Let ?(value) be value'?)

        2. Return value

      3. Else Phantom#1456

      4. If (($find_map<id, value>(Ci.block.venv, id) = ?())), then

        1. Return $find_value_inst((global), Ci, (` id))

      4. Else Phantom#1457

    1. Else Phantom#1458

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let venv* be Ci.local.venvs)

      3. (Let value'? be $find_maps<id, value>(venv*, id))

      4. If ((value'? matches pattern (_))), then

        1. (Let ?(value) be value'?)

        2. Return value

      4. Else Phantom#1459

      5. If (($find_maps<id, value>(Ci.local.venvs, id) = ?())), then

        1. Return $find_value_inst((block), Ci, (` id))

      5. Else Phantom#1460

    1. Else Phantom#1461

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:219:1-219:73:
def $find_typedef_inst(_cursor, Ci, prefixedNameIR)

1. Case analysis on prefixedNameIR

  1. Case (% matches pattern ``%`)

    1. (Let (` nameIR) be prefixedNameIR)

    2. Return $find_map<tid, typeDefIR>(Ci.global.tdenv, nameIR)

  2. Case (% matches pattern `.%`)

    1. (Let (. nameIR) be prefixedNameIR)

    2. Return $find_map<tid, typeDefIR>(Ci.global.tdenv, nameIR)

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:228:1-228:44:
def $ids_arguments_IR(argumentIR*)

1. Return $id_argument_IR(argumentIR)*

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:229:1-229:38:
def $id_argument_IR(argumentIR)

1. If ((argumentIR has type typedExpressionIR)), then

  1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

  2. Return ?()

1. Else Phantom#1462

2. Case analysis on argumentIR

  1. Case (% matches pattern `%=%`)

    1. (Let (nameIR = _typedExpressionIR) be argumentIR)

    2. Return ?(nameIR)

  2. Case (% matches pattern `%=_`)

    1. (Let (nameIR =_) be argumentIR)

    2. Return ?(nameIR)

  3. Case (% matches pattern `_`)

    1. Return ?()

2. Else Phantom#1463

;; ../../../../examples/p4-concrete/6.02-context-instantiation.spectec:237:1-237:103:
def $find_constructor_overloaded_inst(Ci, prefixedNameIR, argumentIR*)

1. Case analysis on prefixedNameIR

  1. Case (% matches pattern ``%`)

    1. (Let (` id) be prefixedNameIR)

    2. (Let id_arg?* be $ids_arguments_IR(argumentIR*))

    3. Return $find_overloaded<consDyn>(Ci.global.cenv, id, id_arg?*)

  2. Case (% matches pattern `.%`)

    1. (Let (. id) be prefixedNameIR)

    2. (Let id_arg?* be $ids_arguments_IR(argumentIR*))

    3. Return $find_overloaded<consDyn>(Ci.global.cenv, id, id_arg?*)

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:6:1-8:35:
relation Constructor_inst: p, Ci, sto_0', consDyn, typeArgumentIR*, argumentIR*, id_default*

1. Case analysis on consDyn

  1. Case (% matches pattern `EXTERN%<%>(%){%}`)

    1. (Let (extern nameIR < typeParameterIR* >( constructorParameterIR* ){ methodPrototypeIR* }) be consDyn)

    2. (Let p_callee be (block))

    3. (Let Ci_callee_0 be $copy_context_inst((global), Ci))

    4. (Let Ci_callee_1 be $add_types_inst(p_callee, Ci_callee_0, typeParameterIR*, typeArgumentIR*))

    5. (Let (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*) be $align_cparams_with_args(constructorParameterIR*, argumentIR*, id_default*))

    6. (Let (_annotationList _direction _typeIR id_aligned _constantInitializerOptIR) be constructorParameterIR_aligned)*

    7. (Bind_args: p Ci ; p_callee Ci_callee_1 sto_0' |- id_aligned* argumentIR_aligned* ==> Ci_callee_2 sto_1)

    8. (Let (_annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR') be constructorParameterIR_default)*

    9. (Let Ci_callee_3 be $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*, value_default*))

    10. (ExternMethods_inst: Ci_callee_3 |- methodPrototypeIR* ==> Ci_callee_4)

    11. (Let objDyn be (extern{ nameIR Ci_callee_4.block.theta Ci_callee_4.block.venv Ci_callee_4.block.renv }))

    12. Result in sto_1, objDyn

  2. Case (% matches pattern `PARSER<%>(%)(%){%%}`)

    1. (Let (parser< typeParameterIR* >( parameterIR* )( constructorParameterIR* ){ parserLocalDeclarationIR* parserStateIR* }) be consDyn)

    2. (Let p_callee be (block))

    3. (Let Ci_callee_0 be $copy_context_inst((global), Ci))

    4. (Let Ci_callee_1 be $add_types_inst(p_callee, Ci_callee_0, typeParameterIR*, typeArgumentIR*))

    5. (Let (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*) be $align_cparams_with_args(constructorParameterIR*, argumentIR*, id_default*))

    6. (Let (_annotationList _direction _typeIR id_aligned _constantInitializerOptIR) be constructorParameterIR_aligned)*

    7. (Bind_args: p Ci ; p_callee Ci_callee_1 sto_0' |- id_aligned* argumentIR_aligned* ==> Ci_callee_2 sto_1)

    8. (Let (_annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR') be constructorParameterIR_default)*

    9. (Let Ci_callee_3 be $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*, value_default*))

    10. (ParserLocalDecls_inst: Ci_callee_3 sto_1 |- parserLocalDeclarationIR* ==> Ci_local sto_2 parserLocalDeclarationIR_inst*)

    11. (Let stateDyn_empty be (() { [] }))

    12. (Let Ci_local_1 be $add_state_inst((block), Ci_local, "accept", stateDyn_empty))

    13. (Let Ci_local_2 be $add_state_inst((block), Ci_local_1, "reject", stateDyn_empty))

    14. (ParserStates_inst: Ci_local_2 sto_2 |- parserStateIR* ==> Ci_state sto_3)

    15. (Let objDyn be (parser{ Ci_callee_3.block.venv parameterIR* parserLocalDeclarationIR_inst* Ci_state.block.senv }))

    16. Result in sto_3, objDyn

  3. Case (% matches pattern `CONTROL<%>(%)(%){%APPLY%}`)

    1. (Let (control< typeParameterIR* >( parameterIR* )( constructorParameterIR* ){ controlLocalDeclarationIR* apply controlBodyIR }) be consDyn)

    2. (Let p_callee be (block))

    3. (Let Ci_callee_0 be $copy_context_inst((global), Ci))

    4. (Let Ci_callee_1 be $add_types_inst(p_callee, Ci_callee_0, typeParameterIR*, typeArgumentIR*))

    5. (Let (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*) be $align_cparams_with_args(constructorParameterIR*, argumentIR*, id_default*))

    6. (Let (_annotationList _direction _typeIR id_aligned _constantInitializerOptIR) be constructorParameterIR_aligned)*

    7. (Bind_args: p Ci ; p_callee Ci_callee_1 sto_0' |- id_aligned* argumentIR_aligned* ==> Ci_callee_2 sto_1)

    8. (Let (_annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR') be constructorParameterIR_default)*

    9. (Let Ci_callee_3 be $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*, value_default*))

    10. (ControlLocalDecls_inst: Ci_callee_3 sto_1 |- controlLocalDeclarationIR* ==> Ci_local sto_2 controlLocalDeclarationIR'*)

    11. (Block_inst: (local) Ci_local sto_2 |- controlBodyIR ==> _contextInst sto_3 controlBodyIR')

    12. (Let objDyn be (control{ Ci_callee_3.block.venv parameterIR* controlLocalDeclarationIR'* Ci_local.block.renv controlBodyIR' }))

    13. Result in sto_3, objDyn

  4. Case (% matches pattern `PACKAGE<%>(%)`)

    1. (Let (package< typeParameterIR* >( constructorParameterIR* )) be consDyn)

    2. (Let p_callee be (block))

    3. (Let Ci_callee_0 be $copy_context_inst((global), Ci))

    4. (Let Ci_callee_1 be $add_types_inst(p_callee, Ci_callee_0, typeParameterIR*, typeArgumentIR*))

    5. (Let (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*) be $align_cparams_with_args(constructorParameterIR*, argumentIR*, id_default*))

    6. (Let (_annotationList _direction _typeIR id_aligned _constantInitializerOptIR) be constructorParameterIR_aligned)*

    7. (Bind_args: p Ci ; p_callee Ci_callee_1 sto_0' |- id_aligned* argumentIR_aligned* ==> Ci_callee_2 sto_1)

    8. (Let (_annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR') be constructorParameterIR_default)*

    9. (Let Ci_callee_3 be $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*, value_default*))

    10. (Let objDyn be (package{ Ci_callee_3.block.theta Ci_callee_3.block.venv }))

    11. Result in sto_1, objDyn

  5. Case (% matches pattern `TABLE%{%}`)

    1. (Let (table nameIR { tablePropertyListIR }) be consDyn)

    2. (Let p_callee be (local))

    3. (Let Ci_callee_0 be $copy_context_inst((block), Ci))

    4. (Let Ci_callee_1 be $add_types_inst(p_callee, Ci_callee_0, [], typeArgumentIR*))

    5. (Let (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*) be $align_cparams_with_args([], argumentIR*, id_default*))

    6. (Let (_annotationList _direction _typeIR id_aligned _constantInitializerOptIR) be constructorParameterIR_aligned)*

    7. (Bind_args: p Ci ; p_callee Ci_callee_1 sto_0' |- id_aligned* argumentIR_aligned* ==> Ci_callee_2 sto_1)

    8. (Let (_annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR') be constructorParameterIR_default)*

    9. (Let Ci_callee_3 be $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*, value_default*))

    10. (Let Ci_frame be $enter_inst(Ci_callee_3))

    11. (TableProperties_inst: Ci_frame sto_1 |- tablePropertyListIR ==> Ci_table sto_2 tablePropertyListIR_inst)

    12. (Let tablePropertyListIR_dynamic be $init_table(tablePropertyListIR_inst))

    13. (Let venv'* be Ci_table.local.venvs)

    14. If ((venv'* matches pattern _ :: _)), then

      1. (Let venv :: _venv* be venv'*)

      2. (Let objDyn be (table{ nameIR venv tablePropertyListIR_dynamic }))

      3. Result in sto_2, objDyn

    14. Else Phantom#1464

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:16:1-18:35:
relation Bind_args: p_caller, Ci_caller, p_callee, Ci_callee', sto', id*, argumentIR*

1. Case analysis on id*

  1. Case (% matches pattern [])

    1. If ((argumentIR* matches pattern [])), then

      1. Result in Ci_callee', sto'

    1. Else Phantom#1465

  2. Case (% matches pattern _ :: _)

    1. (Let id_h :: id_t* be id*)

    2. If ((argumentIR* matches pattern _ :: _)), then

      1. (Let argumentIR_h :: argumentIR_t* be argumentIR*)

      2. (Bind_arg: p_caller Ci_caller ; p_callee Ci_callee' sto' |- id_h argumentIR_h ==> Ci_callee_1 sto_1)

      3. (Bind_args: p_caller Ci_caller ; p_callee Ci_callee_1 sto_1 |- id_t* argumentIR_t* ==> Ci_callee_2 sto_2)

      4. Result in Ci_callee_2, sto_2

    2. Else Phantom#1466

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:20:1-22:35:
relation Bind_arg: p_caller, Ci_caller, p_callee, Ci_callee_0, sto_0, id, argumentIR

1. (Let Ci_caller_inner be $enter_path(Ci_caller, id))

2. (Argument_inst: p_caller Ci_caller_inner sto_0 |- argumentIR ==> sto_1 value)

3. (Let Ci_callee_1 be $add_value_inst(p_callee, Ci_callee_0, id, value))

4. Result in Ci_callee_1, sto_1

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:32:1-34:26:
relation Expr_inst: p, Ci, sto', (expressionIR # _expressionNoteIR')

1. Case analysis on expressionIR

  1. Case (% has type literalExpression)

    1. (Let literalExpression be (expressionIR as literalExpression))

    2. Case analysis on literalExpression

      1. Case (% matches pattern `TRUE`)

        1. Result in sto', ((b true) as value)

      2. Case (% matches pattern `FALSE`)

        1. Result in sto', ((b false) as value)

    2. Else Phantom#1467

  2. Case (% has type prefixedNameIR)

    1. (Let prefixedNameIR be (expressionIR as prefixedNameIR))

    2. (Let value be $find_value_inst(p, Ci, prefixedNameIR))

    3. Result in sto', value

  3. Case (% has type defaultExpression)

    1. (Let defaultExpression be (expressionIR as defaultExpression))

    2. If ((defaultExpression matches pattern `...`)), then

      1. Result in sto', ((default) as value)

    2. Else Phantom#1468

  4. Case (% has type unaryExpressionIR)

    1. (Let (unop typedExpressionIR) be (expressionIR as unaryExpressionIR))

    2. Case analysis on unop

      1. Case (% matches pattern `~`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR ==> sto_1 value)

        2. Result in sto_1, $un_bnot(value)

      2. Case (% matches pattern `!`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR ==> sto_1 value)

        2. Result in sto_1, $un_lnot(value)

      3. Case (% matches pattern `+`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR ==> sto_1 value)

        2. Result in sto_1, $un_plus(value)

      4. Case (% matches pattern `-`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR ==> sto_1 value)

        2. Result in sto_1, $un_minus(value)

  5. Case (% has type binaryExpressionIR)

    1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

    2. Case analysis on binop

      1. Case (% matches pattern `*`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, $bin_mul(value_l, value_r)

      2. Case (% matches pattern `/`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, $bin_div(value_l, value_r)

      3. Case (% matches pattern `%`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, $bin_mod(value_l, value_r)

      4. Case (% matches pattern `+`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, $bin_plus(value_l, value_r)

      5. Case (% matches pattern `-`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, $bin_minus(value_l, value_r)

      6. Case (% matches pattern `|+|`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, $bin_satplus(value_l, value_r)

      7. Case (% matches pattern `|-|`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, $bin_satminus(value_l, value_r)

      8. Case (% matches pattern `<<`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, $bin_shl(value_l, value_r)

      9. Case (% matches pattern `>>`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, $bin_shr(value_l, value_r)

      10. Case (% matches pattern `<=`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, ((b $bin_le(value_l, value_r)) as value)

      11. Case (% matches pattern `>=`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, ((b $bin_ge(value_l, value_r)) as value)

      12. Case (% matches pattern `<`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, ((b $bin_lt(value_l, value_r)) as value)

      13. Case (% matches pattern `>`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, ((b $bin_gt(value_l, value_r)) as value)

      14. Case (% matches pattern `!=`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, ((b $bin_ne(value_l, value_r)) as value)

      15. Case (% matches pattern `==`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, ((b $bin_eq(value_l, value_r)) as value)

      16. Case (% matches pattern `&`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, $bin_band(value_l, value_r)

      17. Case (% matches pattern `^`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, $bin_bxor(value_l, value_r)

      18. Case (% matches pattern `|`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, $bin_bor(value_l, value_r)

      19. Case (% matches pattern `++`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, $bin_concat(value_l, value_r)

      20. Case (% matches pattern `&&`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, $bin_land(value_l, value_r)

      21. Case (% matches pattern `||`)

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto_1 value_l)

        2. (Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r)

        3. Result in sto_2, $bin_lor(value_l, value_r)

  6. Case (% has type ternaryExpressionIR)

    1. (Let (typedExpressionIR_c ? typedExpressionIR_t : typedExpressionIR_e) be (expressionIR as ternaryExpressionIR))

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_c ==> sto_1 value)

    3. If ((value = ((b true) as value))), then

      1. (Expr_inst: p Ci sto_1 |- typedExpressionIR_t ==> sto_2 value_true)

      2. Result in sto_2, value_true

    3. Else Phantom#1469

    4. If ((value = ((b false) as value))), then

      1. (Expr_inst: p Ci sto_1 |- typedExpressionIR_e ==> sto_2 value_false)

      2. Result in sto_2, value_false

    4. Else Phantom#1470

  7. Case (% has type castExpressionIR)

    1. (Let (( typeIR ) typedExpressionIR) be (expressionIR as castExpressionIR))

    2. (Expr_inst: p Ci sto' |- typedExpressionIR ==> sto_1 value)

    3. (Let value_cast be $cast_op(typeIR, value))

    4. Result in sto_1, value_cast

  8. Case (% has type dataExpressionIR)

    1. (Let dataExpressionIR be (expressionIR as dataExpressionIR))

    2. Case analysis on dataExpressionIR

      1. Case (% matches pattern `{#}`)

        1. Result in sto', (({#}) as value)

      2. Case (% matches pattern `SEQ{%}`)

        1. (Let (seq{ typedExpressionListIR }) be dataExpressionIR)

        2. (Exprs_inst: p Ci sto' |- typedExpressionListIR ==> sto_1 value*)

        3. Result in sto_1, ((seq( value* )) as value)

      3. Case (% matches pattern `SEQ{%,...}`)

        1. (Let (seq{ typedExpressionListIR ,...}) be dataExpressionIR)

        2. (Exprs_inst: p Ci sto' |- typedExpressionListIR ==> sto_1 value*)

        3. Result in sto_1, ((seq( value* ,...)) as value)

      4. Case (% matches pattern `RECORD{%}`)

        1. (Let (record{ (nameIR = typedExpressionIR)* }) be dataExpressionIR)

        2. (Exprs_inst: p Ci sto' |- typedExpressionIR* ==> sto_1 value*)

        3. Result in sto_1, ((record{ (value nameIR ;)* }) as value)

      5. Case (% matches pattern `RECORD{%,...}`)

        1. (Let (record{ (nameIR = typedExpressionIR)* ,...}) be dataExpressionIR)

        2. (Exprs_inst: p Ci sto' |- typedExpressionIR* ==> sto_1 value*)

        3. Result in sto_1, ((record{ (value nameIR ;)* ,...}) as value)

  9. Case (% has type errorAccessExpressionIR)

    1. (Let (error. nameIR) be (expressionIR as errorAccessExpressionIR))

    2. (Let nameIR_error be "error." ++ nameIR)

    3. (Let value_error be $find_value_inst(p, Ci, (` nameIR_error)))

    4. Result in sto', value_error

  10. Case (% has type memberAccessExpressionIR)

    1. (Let (memberAccessBaseIR . nameIR) be (expressionIR as memberAccessExpressionIR))

    2. If ((memberAccessBaseIR matches pattern `TYPE%`)), then

      1. (Let (type prefixedNameIR) be memberAccessBaseIR)

      2. (Let typeDefIR'? be $find_typedef_inst(p, Ci, prefixedNameIR))

      3. If ((typeDefIR'? matches pattern (_))), then

        1. (Let ?(typeDefIR) be typeDefIR'?)

        2. If ((typeDefIR has type enumTypeIR)), then

          1. (Let enumTypeIR be (typeDefIR as enumTypeIR))

          2. Case analysis on enumTypeIR

            1. Case (% matches pattern `ENUM%{%}`)

              1. (Let (enum tid { _id* }) be enumTypeIR)

              2. Result in sto', ((tid . nameIR) as value)

            2. Case (% matches pattern `ENUM%#%{%}`)

              1. (Let (enum tid # _typeIR { (id_member = value_member ;)* }) be enumTypeIR)

              2. (Let value'? be $assoc_<nameIR, value>(nameIR, (id_member, value_member)*))

              3. If ((value'? matches pattern (_))), then

                1. (Let ?(value) be value'?)

                2. Result in sto', ((tid . nameIR # value) as value)

              3. Else Phantom#1471

        2. Else Phantom#1472

      3. Else Phantom#1473

    2. Else Phantom#1474

    3. If ((memberAccessBaseIR has type typedExpressionIR)), then

      1. (Let typedExpressionIR be (memberAccessBaseIR as typedExpressionIR))

      2. If ((nameIR = "size")), then

        1. (Expr_inst: p Ci sto' |- typedExpressionIR ==> sto_1 value)

        2. (Let value' be value)

        3. If ((value' has type headerStackValue)), then

          1. (Let ([ _value* #( _nat ; n_size )]) be (value' as headerStackValue))

          2. Result in sto_1, ((d (n_size as int)) as value)

        3. Else Phantom#1475

      2. Else Phantom#1476

    3. Else Phantom#1477

  11. Case (% has type indexAccessExpressionIR)

    1. (Let indexAccessExpressionIR be (expressionIR as indexAccessExpressionIR))

    2. If ((indexAccessExpressionIR matches pattern `%[%:%]`)), then

      1. (Let (typedExpressionIR_b [ typedExpressionIR_l : typedExpressionIR_h ]) be indexAccessExpressionIR)

      2. (Expr_inst: p Ci sto' |- typedExpressionIR_b ==> sto_1 value_b)

      3. (Expr_inst: p Ci sto_1 |- typedExpressionIR_l ==> sto_2 value_l)

      4. (Expr_inst: p Ci sto_2 |- typedExpressionIR_h ==> sto_3 value_h)

      5. Result in sto_3, $bitacc_op(value_b, value_l, value_h)

    2. Else Phantom#1478

  12. Case (% has type callExpressionIR)

    1. (Let callExpressionIR be (expressionIR as callExpressionIR))

    2. Case analysis on callExpressionIR

      1. Case (% matches pattern `%(%)`)

        1. (Let ((prefixedNameIR < typeArgumentListIR >) ( argumentListIR )) be callExpressionIR)

        2. (Let (cid, consDyn, id*)? be $find_constructor_overloaded_inst(Ci, prefixedNameIR, argumentListIR))

        3. If (((cid, consDyn, id*)? matches pattern (_))), then

          1. (Let ?((_cid, consDyn, id_default*)) be (cid, consDyn, id*)?)

          2. (Constructor_inst: p Ci sto' |- consDyn < typeArgumentListIR >( argumentListIR # id_default* )==> sto_1 objDyn)

          3. (Let oid be Ci.path)

          4. (Let sto_2 be $add_sto(sto_1, oid, objDyn))

          5. (Let value be ((! oid) as value))

          6. Result in sto_2, value

        3. Else Phantom#1479

      2. Case (% matches pattern `%<%>(%)`)

        1. (Let (routineTargetIR < typeArgumentIR* >( argumentIR* )) be callExpressionIR)

        2. Case analysis on routineTargetIR

          1. Case (% matches pattern `%.%`)

            1. (Let (typedExpressionIR . nameIR) be routineTargetIR)

            2. If ((typeArgumentIR* matches pattern [])), then

              1. If ((argumentIR* matches pattern [])), then

                1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR)

                2. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

                  1. Result in sto', $sizeof(typeIR_base, nameIR)

                2. Else Phantom#1480

              1. Else Phantom#1481

            2. Else Phantom#1482

          2. Case (% matches pattern `TYPE%.%`)

            1. (Let (type prefixedNameIR . nameIR) be routineTargetIR)

            2. If ((typeArgumentIR* matches pattern [])), then

              1. If ((argumentIR* matches pattern [])), then

                1. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

                  1. (Let typeDefIR'? be $find_typedef_inst(p, Ci, prefixedNameIR))

                  2. If ((typeDefIR'? matches pattern (_))), then

                    1. (Let ?(typeDefIR) be typeDefIR'?)

                    2. If ((typeDefIR has type typeIR)), then

                      1. (Let typeIR_base be (typeDefIR as typeIR))

                      2. Result in sto', $sizeof(typeIR_base, nameIR)

                    2. Else Phantom#1483

                  2. Else Phantom#1484

                1. Else Phantom#1485

              1. Else Phantom#1486

            2. Else Phantom#1487

        2. Else Phantom#1488

        3. (Let (routineTargetIR' < typeArgumentListIR >( argumentListIR )) be callExpressionIR)

        4. If ((routineTargetIR' matches pattern `(%)`)), then

          1. (Let (( routineTargetIR )) be routineTargetIR')

          2. (Expr_inst: p Ci sto' |- (((routineTargetIR < typeArgumentListIR >( argumentListIR )) as expressionIR) # _expressionNoteIR') ==> sto_1 value)

          3. Result in sto_1, value

        4. Else Phantom#1489

  13. Case (% has type parenthesizedExpressionIR)

    1. (Let (( typedExpressionIR )) be (expressionIR as parenthesizedExpressionIR))

    2. (Expr_inst: p Ci sto' |- typedExpressionIR ==> sto_1 value)

    3. Result in sto_1, value

2. Case analysis on expressionIR

  1. Case (% has type number)

    1. (Let number be (expressionIR as number))

    2. Case analysis on number

      1. Case (% matches pattern `D%`)

        1. (Let (d i) be number)

        2. Result in sto', ((d i) as value)

      2. Case (% matches pattern `%S%`)

        1. (Let (n s i) be number)

        2. Result in sto', ((n s i) as value)

      3. Case (% matches pattern `%W%`)

        1. (Let (n w i) be number)

        2. Result in sto', ((n w i) as value)

  2. Case (% has type stringLiteral)

    1. (Let (" text ") be (expressionIR as stringLiteral))

    2. Result in sto', ((" text ") as value)

2. Else Phantom#1490

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:36:1-38:26:
relation Exprs_inst: p, Ci, sto', typedExpressionIR*

1. Case analysis on typedExpressionIR*

  1. Case (% matches pattern [])

    1. Result in sto', []

  2. Case (% matches pattern _ :: _)

    1. (Let typedExpressionIR_h :: typedExpressionIR_t* be typedExpressionIR*)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_h ==> sto_1 value_h)

    3. (Exprs_inst: p Ci sto_1 |- typedExpressionIR_t* ==> sto_2 value_t*)

    4. Result in sto_2, value_h :: value_t*

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:44:1-46:26:
relation Argument_inst: p, Ci, sto, argumentIR

1. If ((argumentIR has type typedExpressionIR)), then

  1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

  2. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value)

  3. Result in sto_1, value

1. Else Phantom#1491

2. If ((argumentIR matches pattern `%=%`)), then

  1. (Let (nameIR = typedExpressionIR) be argumentIR)

  2. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value)

  3. Result in sto_1, value

2. Else Phantom#1492

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:52:1-54:26:
relation Stmt_inst: p, Ci, sto', statementIR'''

1. Case analysis on statementIR'''

  1. Case (% has type emptyStatementIR)

    1. (Let emptyStatementIR be (statementIR''' as emptyStatementIR))

    2. Result in Ci, sto', (emptyStatementIR as statementIR)

  2. Case (% has type assignmentStatementIR)

    1. (Let assignmentStatementIR be (statementIR''' as assignmentStatementIR))

    2. Result in Ci, sto', (assignmentStatementIR as statementIR)

  3. Case (% has type callStatementIR)

    1. (Let callStatementIR be (statementIR''' as callStatementIR))

    2. Result in Ci, sto', (callStatementIR as statementIR)

  4. Case (% has type directApplicationStatementIR)

    1. (Let (prefixedNameIR .apply( argumentListIR );) be (statementIR''' as directApplicationStatementIR))

    2. (Let (cid, consDyn, id*)? be $find_constructor_overloaded_inst(Ci, prefixedNameIR, []))

    3. If (((cid, consDyn, id*)? matches pattern (_))), then

      1. (Let ?((_cid, consDyn, _id*)) be (cid, consDyn, id*)?)

      2. (Constructor_inst: p Ci sto' |- consDyn < [] >( [] # [] )==> sto_1 objDyn)

      3. (Let tid_fresh be $fresh_tid)

      4. (Let tid be $flatten_prefixedNameIR(prefixedNameIR))

      5. (Let typeIR be ((tid tid) as typeIR))

      6. (Let nameIR be $concat_text([tid, "_", tid_fresh]))

      7. (Let oid be Ci.path ++ [nameIR])

      8. (Let sto_2 be $add_sto(sto_1, oid, objDyn))

      9. (Let constantDeclarationIR be (() const typeIR nameIR (= ((! oid) as value)) ;))

      10. (Let routineTargetIR be ((((` tid) as expressionIR) # (( typeIR (ctk) ))) . "apply"))

      11. (Let callStatementIR be (routineTargetIR < [] >( argumentListIR );))

      12. (Let blockStatementIR be (() { [(constantDeclarationIR as blockElementStatementIR), (callStatementIR as blockElementStatementIR)] }))

      13. Result in Ci, sto_2, (blockStatementIR as statementIR)

    3. Else Phantom#1493

  5. Case (% has type returnStatementIR)

    1. (Let returnStatementIR be (statementIR''' as returnStatementIR))

    2. Result in Ci, sto', (returnStatementIR as statementIR)

  6. Case (% has type exitStatementIR)

    1. (Let exitStatementIR be (statementIR''' as exitStatementIR))

    2. Result in Ci, sto', (exitStatementIR as statementIR)

  7. Case (% has type blockStatementIR)

    1. (Let (annotationList { blockElementStatementListIR }) be (statementIR''' as blockStatementIR))

    2. (Block_inst: p Ci sto' |- (annotationList { blockElementStatementListIR }) ==> Ci_1 sto_1 (_annotationList { blockElementStatementListIR' }))

    3. Result in Ci_1, sto_1, ((annotationList { blockElementStatementListIR' }) as statementIR)

  8. Case (% has type conditionalStatementIR)

    1. (Let conditionalStatementIR be (statementIR''' as conditionalStatementIR))

    2. Case analysis on conditionalStatementIR

      1. Case (% matches pattern `IF(%)%`)

        1. (Let (if( typedExpressionIR ) statementIR''') be conditionalStatementIR)

        2. (Stmt_inst: p Ci sto' |- statementIR''' ==> Ci_1 sto_1 statementIR')

        3. Result in Ci_1, sto_1, ((if( typedExpressionIR ) statementIR') as statementIR)

      2. Case (% matches pattern `IF(%)%ELSE%`)

        1. (Let (if( typedExpressionIR ) statementIR_then else statementIR_else) be conditionalStatementIR)

        2. (Stmt_inst: p Ci sto' |- statementIR_then ==> Ci_1 sto_1 statementIR_then')

        3. (Stmt_inst: p Ci_1 sto_1 |- statementIR_else ==> Ci_2 sto_2 statementIR_else')

        4. Result in Ci_2, sto_2, ((if( typedExpressionIR ) statementIR_then' else statementIR_else') as statementIR)

  9. Case (% has type breakStatementIR)

    1. (Let breakStatementIR be (statementIR''' as breakStatementIR))

    2. Result in Ci, sto', (breakStatementIR as statementIR)

  10. Case (% has type continueStatementIR)

    1. (Let continueStatementIR be (statementIR''' as continueStatementIR))

    2. Result in Ci, sto', (continueStatementIR as statementIR)

  11. Case (% has type switchStatementIR)

    1. (Let (switch( typedExpressionIR ){ switchCaseListIR }) be (statementIR''' as switchStatementIR))

    2. (SwitchCases_inst: p Ci sto' |- switchCaseListIR ==> Ci_1 sto_1 switchCaseListIR')

    3. Result in Ci_1, sto_1, ((switch( typedExpressionIR ){ switchCaseListIR' }) as statementIR)

1. Else Phantom#1494

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:56:1-58:26:
relation Stmts_inst: 



;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:60:1-62:26:
relation SwitchCases_inst: p, Ci', sto', switchCaseIR*

1. Case analysis on switchCaseIR*

  1. Case (% matches pattern [])

    1. Result in Ci', sto', []

  2. Case (% matches pattern _ :: _)

    1. (Let switchCaseIR_h :: switchCaseIR_t* be switchCaseIR*)

    2. (SwitchCase_inst: p Ci' sto' |- switchCaseIR_h ==> Ci_1 sto_1 switchCaseIR_h')

    3. (SwitchCases_inst: p Ci_1 sto_1 |- switchCaseIR_t* ==> Ci_2 sto_2 switchCaseIR_t'*)

    4. Result in Ci_2, sto_2, switchCaseIR_h' :: switchCaseIR_t'*

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:64:1-66:26:
relation SwitchCase_inst: p, Ci, sto, switchCaseIR

1. Case analysis on switchCaseIR

  1. Case (% matches pattern `%:%`)

    1. (Let (switchLabelIR : blockStatementIR) be switchCaseIR)

    2. (Stmt_inst: p Ci sto |- (blockStatementIR as statementIR) ==> Ci_1 sto_1 statementIR)

    3. If ((statementIR has type blockStatementIR)), then

      1. (Let blockStatementIR' be (statementIR as blockStatementIR))

      2. Result in Ci_1, sto_1, (switchLabelIR : blockStatementIR')

    3. Else Phantom#1495

  2. Case (% matches pattern `%:`)

    1. (Let (switchLabelIR :) be switchCaseIR)

    2. Result in Ci, sto, (switchLabelIR :)

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:68:1-70:26:
relation BlockElementStmt_inst: p', Ci, sto, blockElementStatementIR

1. Case analysis on blockElementStatementIR

  1. Case (% has type constantDeclarationIR)

    1. (Let constantDeclarationIR be (blockElementStatementIR as constantDeclarationIR))

    2. (Decl_inst: p' Ci sto |- (constantDeclarationIR as declarationIR) ==> Ci_1 sto_1 declarationIR'?)

    3. If ((declarationIR'? matches pattern (_))), then

      1. (Let ?(declarationIR) be declarationIR'?)

      2. If ((declarationIR has type constantDeclarationIR)), then

        1. (Let constantDeclarationIR' be (declarationIR as constantDeclarationIR))

        2. Result in Ci_1, sto_1, ?((constantDeclarationIR' as blockElementStatementIR))

      2. Else Phantom#1496

    3. Else Phantom#1497

  2. Case (% has type variableDeclarationIR)

    1. (Let variableDeclarationIR be (blockElementStatementIR as variableDeclarationIR))

    2. Result in Ci, sto, ?((variableDeclarationIR as blockElementStatementIR))

  3. Case (% has type statementIR)

    1. (Let statementIR be (blockElementStatementIR as statementIR))

    2. (Stmt_inst: (local) Ci sto |- statementIR ==> Ci_1 sto_1 statementIR_inst)

    3. Result in Ci_1, sto_1, ?((statementIR_inst as blockElementStatementIR))

2. If ((p' matches pattern `GLOBAL`)), then

  1. If ((blockElementStatementIR has type variableDeclarationIR)), then

    1. (Let variableDeclarationIR be (blockElementStatementIR as variableDeclarationIR))

    2. Result in Ci, sto, ?()

  1. Else Phantom#1498

2. Else Phantom#1499

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:72:1-74:26:
relation BlockElementStmts_inst: p, Ci', sto', blockElementStatementIR*

1. Case analysis on blockElementStatementIR*

  1. Case (% matches pattern [])

    1. Result in Ci', sto', []

  2. Case (% matches pattern _ :: _)

    1. (Let blockElementStatementIR_h :: blockElementStatementIR_t* be blockElementStatementIR*)

    2. (BlockElementStmt_inst: p Ci' sto' |- blockElementStatementIR_h ==> Ci_1 sto_1 blockElementStatementIR'?)

    3. If ((blockElementStatementIR'? matches pattern (_))), then

      1. (Let ?(blockElementStatementIR_h') be blockElementStatementIR'?)

      2. (BlockElementStmts_inst: p Ci_1 sto_1 |- blockElementStatementIR_t* ==> Ci_2 sto_2 blockElementStatementIR_t'*)

      3. Result in Ci_2, sto_2, blockElementStatementIR_h' :: blockElementStatementIR_t'*

    3. Else Phantom#1500

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:76:1-78:26:
relation Block_inst: p, Ci_0, sto_0, (annotationList { blockElementStatementListIR })

1. (Let Ci_1 be $enter_inst(Ci_0))

2. (BlockElementStmts_inst: p Ci_1 sto_0 |- blockElementStatementListIR ==> Ci_2 sto_1 blockElementStatementListIR_inst)

3. (Let Ci_3 be $exit_inst(Ci_2))

4. Result in Ci_2, sto_1, (annotationList { blockElementStatementListIR_inst })

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:84:1-86:20:
relation Bind_method: rdenv_0, methodPrototypeIR

1. Case analysis on methodPrototypeIR

  1. Case (% matches pattern `%%;`)

    1. (Let (_annotationList (typeIR_ret nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR* )) ;) be methodPrototypeIR)

    2. (Let rid be $rid_IR(nameIR, parameterIR*))

    3. (Let parameterTypeIR be $parameterIR(parameterIR))*

    4. (Let methodTypeIR be (extern_method( parameterTypeIR* )-> typeIR_ret))

    5. (Let routineTypeDefIR be (((methodTypeIR as routineTypeIR) < typeParameterListIR , typeParameterListIR_inferred >) as routineTypeDefIR))

    6. (Let rdenv_1 be $add_map<rid, routineTypeDefIR>(rdenv_0, rid, routineTypeDefIR))

    7. Result in rdenv_1

  2. Case (% matches pattern `%ABSTRACT%;`)

    1. (Let (_annotationList abstract (typeIR_ret nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR* )) ;) be methodPrototypeIR)

    2. (Let rid be $rid_IR(nameIR, parameterIR*))

    3. (Let parameterTypeIR be $parameterIR(parameterIR))*

    4. (Let methodTypeIR be (extern_methodabstract( parameterTypeIR* )-> typeIR_ret))

    5. (Let routineTypeDefIR be (((methodTypeIR as routineTypeIR) < typeParameterListIR , typeParameterListIR_inferred >) as routineTypeDefIR))

    6. (Let rdenv_1 be $add_map<rid, routineTypeDefIR>(rdenv_0, rid, routineTypeDefIR))

    7. Result in rdenv_1

1. Else Phantom#1501

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:88:1-90:20:
relation Bind_methods: rdenv', methodPrototypeIR*

1. Case analysis on methodPrototypeIR*

  1. Case (% matches pattern [])

    1. Result in rdenv'

  2. Case (% matches pattern _ :: _)

    1. (Let methodPrototypeIR_h :: methodPrototypeIR_t* be methodPrototypeIR*)

    2. (Bind_method: rdenv' |- methodPrototypeIR_h ==> rdenv_1)

    3. (Bind_methods: rdenv_1 |- methodPrototypeIR_t* ==> rdenv_2)

    4. Result in rdenv_2

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:92:1-94:29:
relation Bind_constructor: p, Ci_0, typeParameterListIR, methodPrototypeListIR, methodPrototypeIR

1. If ((methodPrototypeIR matches pattern `%%<,%>(%);`)), then

  1. (Let (annotationList nameIR <, typeParameterListIR_inferred >( parameterListIR );) be methodPrototypeIR)

  2. (Let cid be $cid_IR(nameIR, parameterListIR))

  3. (Let consDyn be (extern nameIR < typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ){ methodPrototypeListIR }))

  4. (Let Ci_1 be $add_constructor_inst(p, Ci_0, cid, consDyn))

  5. Result in Ci_1

1. Else Phantom#1502

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:96:1-98:29:
relation Bind_constructors: p, Ci', typeParameterListIR, methodPrototypeListIR, methodPrototypeIR*

1. Case analysis on methodPrototypeIR*

  1. Case (% matches pattern [])

    1. Result in Ci'

  2. Case (% matches pattern _ :: _)

    1. (Let methodPrototypeIR_h :: methodPrototypeIR_t* be methodPrototypeIR*)

    2. (Bind_constructor: p Ci' typeParameterListIR methodPrototypeListIR |- methodPrototypeIR_h ==> Ci_1)

    3. (Bind_constructors: p Ci_1 typeParameterListIR methodPrototypeListIR |- methodPrototypeIR_t* ==> Ci_2)

    4. Result in Ci_2

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:100:1-102:20:
relation ExternMethod_inst: Ci_0, methodPrototypeIR

1. Case analysis on methodPrototypeIR

  1. Case (% matches pattern `%%;`)

    1. (Let (_annotationList (_typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR )) ;) be methodPrototypeIR)

    2. (Let rid be $rid_IR(nameIR, parameterListIR))

    3. (Let methodDyn be (extern_method< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ) ?()))

    4. (Let Ci_1 be $add_routine_overload_inst((block), Ci_0, rid, (methodDyn as routineDyn)))

    5. Result in Ci_1

  2. Case (% matches pattern `%ABSTRACT%;`)

    1. (Let (_annotationList abstract (_typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR )) ;) be methodPrototypeIR)

    2. (Let rid be $rid_IR(nameIR, parameterListIR))

    3. (Let methodDyn be (extern_methodabstract< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR )))

    4. (Let Ci_1 be $add_routine_overload_inst((block), Ci_0, rid, (methodDyn as routineDyn)))

    5. Result in Ci_1

1. Else Phantom#1503

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:104:1-106:20:
relation ExternMethods_inst: Ci', methodPrototypeIR*

1. Case analysis on methodPrototypeIR*

  1. Case (% matches pattern [])

    1. Result in Ci'

  2. Case (% matches pattern _ :: _)

    1. (Let methodPrototypeIR_h :: methodPrototypeIR_t* be methodPrototypeIR*)

    2. (ExternMethod_inst: Ci' |- methodPrototypeIR_h ==> Ci_1)

    3. (ExternMethods_inst: Ci_1 |- methodPrototypeIR_t* ==> Ci_2)

    4. Result in Ci_2

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:112:1-114:23:
relation ParserStmt_inst: Ci_0', sto_0, parserStatementIR

1. Case analysis on parserStatementIR

  1. Case (% has type constantDeclarationIR)

    1. (Let constantDeclarationIR be (parserStatementIR as constantDeclarationIR))

    2. (Decl_inst: (block) Ci_0' sto_0 |- (constantDeclarationIR as declarationIR) ==> Ci_1 sto_1 declarationIR?)

    3. If ((declarationIR? has type constantDeclarationIR?)), then

      1. (Let constantDeclarationIR_inst? be (declarationIR? as constantDeclarationIR?))

      2. Result in Ci_1, sto_1, (constantDeclarationIR_inst? as parserStatementIR?)

    3. Else Phantom#1504

  2. Case (% has type variableDeclarationIR)

    1. (Let variableDeclarationIR be (parserStatementIR as variableDeclarationIR))

    2. (BlockElementStmt_inst: (block) Ci_0' sto_0 |- (variableDeclarationIR as blockElementStatementIR) ==> Ci_1 sto_1 blockElementStatementIR?)

    3. If ((blockElementStatementIR? has type variableDeclarationIR?)), then

      1. (Let variableDeclarationIR_inst? be (blockElementStatementIR? as variableDeclarationIR?))

      2. Result in Ci_1, sto_1, (variableDeclarationIR_inst? as parserStatementIR?)

    3. Else Phantom#1505

  3. Case (% has type emptyStatementIR)

    1. (Let emptyStatementIR be (parserStatementIR as emptyStatementIR))

    2. (Stmt_inst: (block) Ci_0' sto_0 |- (emptyStatementIR as statementIR) ==> Ci_1 sto_1 statementIR)

    3. If ((statementIR has type emptyStatementIR)), then

      1. (Let emptyStatementIR_inst be (statementIR as emptyStatementIR))

      2. Result in Ci_1, sto_1, ?((emptyStatementIR_inst as parserStatementIR))

    3. Else Phantom#1506

  4. Case (% has type assignmentStatementIR)

    1. (Let assignmentStatementIR be (parserStatementIR as assignmentStatementIR))

    2. (Stmt_inst: (block) Ci_0' sto_0 |- (assignmentStatementIR as statementIR) ==> Ci_1 sto_1 statementIR)

    3. If ((statementIR has type assignmentStatementIR)), then

      1. (Let assignmentStatementIR_inst be (statementIR as assignmentStatementIR))

      2. Result in Ci_1, sto_1, ?((assignmentStatementIR_inst as parserStatementIR))

    3. Else Phantom#1507

  5. Case (% has type callStatementIR)

    1. (Let callStatementIR be (parserStatementIR as callStatementIR))

    2. (Stmt_inst: (block) Ci_0' sto_0 |- (callStatementIR as statementIR) ==> Ci_1 sto_1 statementIR)

    3. If ((statementIR has type callStatementIR)), then

      1. (Let callStatementIR_inst be (statementIR as callStatementIR))

      2. Result in Ci_1, sto_1, ?((callStatementIR_inst as parserStatementIR))

    3. Else Phantom#1508

  6. Case (% has type directApplicationStatementIR)

    1. (Let (prefixedNameIR .apply( argumentListIR );) be (parserStatementIR as directApplicationStatementIR))

    2. (Let (cid, consDyn, id*)? be $find_constructor_overloaded_inst(Ci_0', prefixedNameIR, []))

    3. If (((cid, consDyn, id*)? matches pattern (_))), then

      1. (Let ?((_cid, consDyn, _id*)) be (cid, consDyn, id*)?)

      2. (Constructor_inst: (block) Ci_0' sto_0 |- consDyn < [] >( [] # [] )==> sto_1 objDyn)

      3. (Let tid be $flatten_prefixedNameIR(prefixedNameIR))

      4. (Let tid_fresh be $fresh_tid)

      5. (Let nameIR be $concat_text([tid, "_", tid_fresh]))

      6. (Let oid be Ci_0'.path ++ [nameIR])

      7. (Let sto_2 be $add_sto(sto_1, oid, objDyn))

      8. (Let typeIR be ((tid tid) as typeIR))

      9. (Let constantDeclarationIR be (() const typeIR nameIR (= ((! oid) as value)) ;))

      10. (Let routineTargetIR be ((((` tid) as expressionIR) # (( typeIR (ctk) ))) . "apply"))

      11. (Let callStatementIR be (routineTargetIR < [] >( argumentListIR );))

      12. (Let parserBlockStatementIR be (() { [(constantDeclarationIR as parserStatementIR), (callStatementIR as parserStatementIR)] }))

      13. Result in Ci_0', sto_2, ?((parserBlockStatementIR as parserStatementIR))

    3. Else Phantom#1509

  7. Case (% has type parserBlockStatementIR)

    1. (Let (annotationList { parserStatementListIR }) be (parserStatementIR as parserBlockStatementIR))

    2. (ParserStmts_inst: Ci_0' sto_0 |- parserStatementListIR ==> Ci_1 sto_1 parserStatementListIR_inst)

    3. (Let parserBlockStatementIR_inst be (annotationList { parserStatementListIR_inst }))

    4. Result in Ci_1, sto_1, ?((parserBlockStatementIR_inst as parserStatementIR))

  8. Case (% has type conditionalStatementIR)

    1. (Let conditionalStatementIR be (parserStatementIR as conditionalStatementIR))

    2. (Stmt_inst: (block) Ci_0' sto_0 |- (conditionalStatementIR as statementIR) ==> Ci_1 sto_1 statementIR)

    3. If ((statementIR has type conditionalStatementIR)), then

      1. (Let conditionalStatementIR_inst be (statementIR as conditionalStatementIR))

      2. Result in Ci_1, sto_1, ?((conditionalStatementIR_inst as parserStatementIR))

    3. Else Phantom#1510

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:116:1-118:23:
relation ParserStmts_inst: Ci', sto', parserStatementIR*

1. Case analysis on parserStatementIR*

  1. Case (% matches pattern [])

    1. Result in Ci', sto', []

  2. Case (% matches pattern _ :: _)

    1. (Let parserStatementIR_h :: parserStatementIR_t* be parserStatementIR*)

    2. (ParserStmt_inst: Ci' sto' |- parserStatementIR_h ==> Ci_1 sto_1 parserStatementIR'?)

    3. Case analysis on parserStatementIR'?

      1. Case (% matches pattern ())

        1. (ParserStmts_inst: Ci_1 sto_1 |- parserStatementIR_t* ==> Ci_2 sto_2 parserStatementIR_t'*)

        2. Result in Ci_2, sto_2, parserStatementIR_t'*

      2. Case (% matches pattern (_))

        1. (Let ?(parserStatementIR_h') be parserStatementIR'?)

        2. (ParserStmts_inst: Ci_1 sto_1 |- parserStatementIR_t* ==> Ci_2 sto_2 parserStatementIR_t'*)

        3. Result in Ci_2, sto_2, parserStatementIR_h' :: parserStatementIR_t'*

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:120:1-122:23:
relation ParserState_inst: Ci_0, sto_0, (annotationList state nameIR { parserStatementListIR transitionStatementIR })

1. (ParserStmts_inst: Ci_0 sto_0 |- parserStatementListIR ==> Ci_1 sto_1 parserStatementListIR_inst)

2. (Let stateDyn be (annotationList { parserStatementListIR_inst }))

3. (Let Ci_2 be $add_state_inst((block), Ci_1, nameIR, stateDyn))

4. Result in Ci_2, sto_1

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:124:1-126:23:
relation ParserStates_inst: Ci', sto', parserStateIR*

1. Case analysis on parserStateIR*

  1. Case (% matches pattern [])

    1. Result in Ci', sto'

  2. Case (% matches pattern _ :: _)

    1. (Let parserStateIR_h :: parserStateIR_t* be parserStateIR*)

    2. (ParserState_inst: Ci' sto' |- parserStateIR_h ==> Ci_1 sto_1)

    3. (ParserStates_inst: Ci_1 sto_1 |- parserStateIR_t* ==> Ci_2 sto_2)

    4. Result in Ci_2, sto_2

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:128:1-130:23:
relation ParserLocalDecl_inst: Ci_0', sto_0', parserLocalDeclarationIR

1. Case analysis on parserLocalDeclarationIR

  1. Case (% has type constantDeclarationIR)

    1. (Let constantDeclarationIR be (parserLocalDeclarationIR as constantDeclarationIR))

    2. (Decl_inst: (block) Ci_0' sto_0' |- (constantDeclarationIR as declarationIR) ==> Ci_1 sto_1 declarationIR?)

    3. If ((declarationIR? has type constantDeclarationIR?)), then

      1. (Let constantDeclarationIR_inst? be (declarationIR? as constantDeclarationIR?))

      2. Result in Ci_1, sto_1, (constantDeclarationIR_inst? as parserLocalDeclarationIR?)

    3. Else Phantom#1511

  2. Case (% has type instantiationIR)

    1. (Let instantiationIR be (parserLocalDeclarationIR as instantiationIR))

    2. (Decl_inst: (block) Ci_0' sto_0' |- (instantiationIR as declarationIR) ==> Ci_1 sto_1 declarationIR?)

    3. If ((declarationIR? has type instantiationIR?)), then

      1. (Let instantiationIR_inst? be (declarationIR? as instantiationIR?))

      2. Result in Ci_1, sto_1, (instantiationIR_inst? as parserLocalDeclarationIR?)

    3. Else Phantom#1512

  3. Case (% has type variableDeclarationIR)

    1. (Let variableDeclarationIR be (parserLocalDeclarationIR as variableDeclarationIR))

    2. Result in Ci_0', sto_0', ?((variableDeclarationIR as parserLocalDeclarationIR))

  4. Case (% has type valueSetDeclarationIR)

    1. (Let valueSetDeclarationIR be (parserLocalDeclarationIR as valueSetDeclarationIR))

    2. Result in Ci_0', sto_0', ?((valueSetDeclarationIR as parserLocalDeclarationIR))

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:132:1-134:23:
relation ParserLocalDecls_inst: Ci', sto', parserLocalDeclarationIR*

1. Case analysis on parserLocalDeclarationIR*

  1. Case (% matches pattern [])

    1. Result in Ci', sto', []

  2. Case (% matches pattern _ :: _)

    1. (Let parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t* be parserLocalDeclarationIR*)

    2. (ParserLocalDecl_inst: Ci' sto' |- parserLocalDeclarationIR_h ==> Ci_1 sto_1 parserLocalDeclarationIR'?)

    3. Case analysis on parserLocalDeclarationIR'?

      1. Case (% matches pattern ())

        1. (ParserLocalDecls_inst: Ci_1 sto_1 |- parserLocalDeclarationIR_t* ==> Ci_2 sto_2 parserLocalDeclarationIR_t'*)

        2. Result in Ci_2, sto_2, parserLocalDeclarationIR_t'*

      2. Case (% matches pattern (_))

        1. (Let ?(parserLocalDeclarationIR_h') be parserLocalDeclarationIR'?)

        2. (ParserLocalDecls_inst: Ci_1 sto_1 |- parserLocalDeclarationIR_t* ==> Ci_2 sto_2 parserLocalDeclarationIR_t'*)

        3. Result in Ci_2, sto_2, parserLocalDeclarationIR_h' :: parserLocalDeclarationIR_t'*

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:140:1-142:23:
relation TableProperty_inst: Ci, sto, tablePropertyIR

1. Case analysis on tablePropertyIR

  1. Case (% matches pattern `KEY={%}`)

    1. (Let (key={ tableKeyListIR }) be tablePropertyIR)

    2. Result in Ci, sto, (key={ tableKeyListIR })

  2. Case (% matches pattern `ACTIONS={%}`)

    1. (Let (actions={ tableActionListIR }) be tablePropertyIR)

    2. Result in Ci, sto, (actions={ tableActionListIR })

  3. Case (% matches pattern `%%ENTRIES={%}`)

    1. (Let (annotationList constOptIR entries={ tableEntryListIR }) be tablePropertyIR)

    2. Result in Ci, sto, (annotationList constOptIR entries={ tableEntryListIR })

  4. Case (% matches pattern `%%DEFAULT_ACTION=%;`)

    1. (Let (annotationList constOptIR default_action= tableActionReferenceIR ;) be tablePropertyIR)

    2. Result in Ci, sto, (annotationList constOptIR default_action= tableActionReferenceIR ;)

  5. Case (% matches pattern `%%CUSTOM%%;`)

    1. (Let (annotationList constOptIR custom nameIR (= typedExpressionIR) ;) be tablePropertyIR)

    2. (Let Ci_inner be $enter_path(Ci, nameIR))

    3. (Expr_inst: (local) Ci_inner sto |- typedExpressionIR ==> sto_1 value)

    4. Result in Ci, sto_1, (annotationList constOptIR custom_const nameIR (= value) ;)

  6. Case (% matches pattern `%%CUSTOM_CONST%%;`)

    1. (Let (annotationList constOptIR custom_const nameIR constantInitializerIR ;) be tablePropertyIR)

    2. Result in Ci, sto, (annotationList constOptIR custom_const nameIR constantInitializerIR ;)

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:144:1-146:23:
relation TableProperties_inst: Ci', sto', tablePropertyIR*

1. Case analysis on tablePropertyIR*

  1. Case (% matches pattern [])

    1. Result in Ci', sto', []

  2. Case (% matches pattern _ :: _)

    1. (Let tablePropertyIR_h :: tablePropertyIR_t* be tablePropertyIR*)

    2. (TableProperty_inst: Ci' sto' |- tablePropertyIR_h ==> Ci_1 sto_1 tablePropertyIR_h')

    3. (TableProperties_inst: Ci_1 sto_1 |- tablePropertyIR_t* ==> Ci_2 sto_2 tablePropertyIR_t'*)

    4. Result in Ci_2, sto_2, tablePropertyIR_h' :: tablePropertyIR_t'*

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:148:1-150:23:
relation ControlLocalDecl_inst: Ci_0', sto_0', controlLocalDeclarationIR

1. Case analysis on controlLocalDeclarationIR

  1. Case (% has type constantDeclarationIR)

    1. (Let constantDeclarationIR be (controlLocalDeclarationIR as constantDeclarationIR))

    2. (Decl_inst: (block) Ci_0' sto_0' |- (constantDeclarationIR as declarationIR) ==> Ci_1 sto_1 declarationIR?)

    3. If ((declarationIR? has type constantDeclarationIR?)), then

      1. (Let constantDeclarationIR_inst? be (declarationIR? as constantDeclarationIR?))

      2. Result in Ci_1, sto_1, (constantDeclarationIR_inst? as controlLocalDeclarationIR?)

    3. Else Phantom#1513

  2. Case (% has type instantiationIR)

    1. (Let instantiationIR be (controlLocalDeclarationIR as instantiationIR))

    2. (Decl_inst: (block) Ci_0' sto_0' |- (instantiationIR as declarationIR) ==> Ci_1 sto_1 declarationIR?)

    3. If ((declarationIR? has type constantDeclarationIR?)), then

      1. (Let constantDeclarationIR? be (declarationIR? as constantDeclarationIR?))

      2. Result in Ci_1, sto_1, (constantDeclarationIR? as controlLocalDeclarationIR?)

    3. Else Phantom#1514

  3. Case (% has type variableDeclarationIR)

    1. (Let variableDeclarationIR be (controlLocalDeclarationIR as variableDeclarationIR))

    2. Result in Ci_0', sto_0', ?((variableDeclarationIR as controlLocalDeclarationIR))

  4. Case (% has type actionDeclarationIR)

    1. (Let actionDeclarationIR be (controlLocalDeclarationIR as actionDeclarationIR))

    2. (Decl_inst: (block) Ci_0' sto_0' |- (actionDeclarationIR as declarationIR) ==> Ci_1 sto_1 declarationIR?)

    3. If ((declarationIR? has type actionDeclarationIR?)), then

      1. (Let actionDeclarationIR_inst? be (declarationIR? as actionDeclarationIR?))

      2. Result in Ci_1, sto_1, (actionDeclarationIR_inst? as controlLocalDeclarationIR?)

    3. Else Phantom#1515

  5. Case (% has type tableDeclarationIR)

    1. (Let (_annotationList table typeIR nameIR { tablePropertyListIR }) be (controlLocalDeclarationIR as tableDeclarationIR))

    2. (Let Ci_inner be $enter_path(Ci_0', nameIR))

    3. (Constructor_inst: (block) Ci_0' sto_0' |- (table nameIR { tablePropertyListIR }) < [] >( [] # [] )==> sto_1 objDyn)

    4. (Let oid be Ci_0'.path ++ [nameIR])

    5. (Let sto_2 be $add_sto(sto_1, oid, objDyn))

    6. (Let Ci_1 be $add_value_inst((block), Ci_0', nameIR, ((! oid) as value)))

    7. (Let constantDeclarationIR be (() const typeIR nameIR (= ((! oid) as value)) ;))

    8. Result in Ci_1, sto_1, ?((constantDeclarationIR as controlLocalDeclarationIR))

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:152:1-154:23:
relation ControlLocalDecls_inst: Ci', sto', controlLocalDeclarationIR*

1. Case analysis on controlLocalDeclarationIR*

  1. Case (% matches pattern [])

    1. Result in Ci', sto', []

  2. Case (% matches pattern _ :: _)

    1. (Let controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t* be controlLocalDeclarationIR*)

    2. (ControlLocalDecl_inst: Ci' sto' |- controlLocalDeclarationIR_h ==> Ci_1 sto_1 controlLocalDeclarationIR'?)

    3. Case analysis on controlLocalDeclarationIR'?

      1. Case (% matches pattern ())

        1. (ControlLocalDecls_inst: Ci_1 sto_1 |- controlLocalDeclarationIR_t* ==> Ci_2 sto_2 controlLocalDeclarationIR_t'*)

        2. Result in Ci_2, sto_2, controlLocalDeclarationIR_t'*

      2. Case (% matches pattern (_))

        1. (Let ?(controlLocalDeclarationIR_h') be controlLocalDeclarationIR'?)

        2. (ControlLocalDecls_inst: Ci_1 sto_1 |- controlLocalDeclarationIR_t* ==> Ci_2 sto_2 controlLocalDeclarationIR_t'*)

        3. Result in Ci_2, sto_2, controlLocalDeclarationIR_h' :: controlLocalDeclarationIR_t'*

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:160:1-162:26:
relation Decls_inst: p, Ci', sto', declarationIR*

1. Case analysis on declarationIR*

  1. Case (% matches pattern [])

    1. Result in Ci', sto', []

  2. Case (% matches pattern _ :: _)

    1. (Let declarationIR_h :: declarationIR_t* be declarationIR*)

    2. (Decl_inst: p Ci' sto' |- declarationIR_h ==> Ci_1 sto_1 declarationIR'?)

    3. Case analysis on declarationIR'?

      1. Case (% matches pattern ())

        1. (Decls_inst: p Ci_1 sto_1 |- declarationIR_t* ==> Ci_2 sto_2 declarationIR_t'*)

        2. Result in Ci_2, sto_2, declarationIR_t'*

      2. Case (% matches pattern (_))

        1. (Let ?(declarationIR_h') be declarationIR'?)

        2. (Decls_inst: p Ci_1 sto_1 |- declarationIR_t* ==> Ci_2 sto_2 declarationIR_t'*)

        3. Result in Ci_2, sto_2, declarationIR_h' :: declarationIR_t'*

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:164:1-166:26:
relation Decl_inst: p', Ci_0, sto', declarationIR

1. Case analysis on declarationIR

  1. Case (% has type constantDeclarationIR)

    1. (Let (annotationList const typeIR nameIR (= value) ;) be (declarationIR as constantDeclarationIR))

    2. (Let Ci_1 be $add_value_inst(p', Ci_0, nameIR, value))

    3. (Let constantDeclarationIR be (annotationList const typeIR nameIR (= value) ;))

    4. Result in Ci_1, sto', $wrap_decl(p', (constantDeclarationIR as declarationIR))

  2. Case (% has type instantiationIR)

    1. (Let (_annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;) be (declarationIR as instantiationIR))

    2. (Let (cid, consDyn, id*)? be $find_constructor_overloaded_inst(Ci_0, prefixedNameIR, argumentListIR))

    3. If (((cid, consDyn, id*)? matches pattern (_))), then

      1. (Let ?((_cid, consDyn, id_default*)) be (cid, consDyn, id*)?)

      2. (Let Ci_inner be $enter_path(Ci_0, nameIR))

      3. (Constructor_inst: p' Ci_inner sto' |- consDyn < typeArgumentListIR >( argumentListIR # id_default* )==> sto_1 objDyn)

      4. (Let objDyn' be objDyn)

      5. If ((objDyn' matches pattern `EXTERN{%%%%}`)), then

        1. (Let (extern{ tid theta venv renv }) be objDyn')

        2. (Let Ci_decl be $empty_context_inst[path = Ci_0.path][global = Ci_0.global])

        3. (Let objectDeclarationListIR be $get_init_decls(objectInitializerOptIR))

        4. (Decls_inst: (block) Ci_decl sto_1 |- (objectDeclarationListIR as declarationIR*) ==> Ci_decl_post sto_2 _declarationIR*)

        5. (Let venv_merged be $merge_venvs(venv, Ci_decl_post.block.venv))

        6. (Let renv_merged be $merge_renv_with_extern(renv, Ci_decl_post.block.renv))

        7. (Let objDyn_1 be (extern{ tid theta venv_merged renv_merged }))

        8. (Let oid be Ci_0.path ++ [nameIR])

        9. (Let sto_3 be $add_sto(sto_2, oid, objDyn_1))

        10. (Let Ci_1 be $add_value_inst(p', Ci_0, nameIR, ((! oid) as value)))

        11. (Let constantDeclarationIR be (() const typeIR nameIR (= ((! oid) as value)) ;))

        12. Result in Ci_1, sto_2, $wrap_decl(p', (constantDeclarationIR as declarationIR))

      5. Else Phantom#1516

      6. If (~$is_extern_object(objDyn)), then

        1. (Let oid be Ci_0.path ++ [nameIR])

        2. (Let sto_2 be $add_sto(sto_1, oid, objDyn))

        3. (Let Ci_1 be $add_value_inst(p', Ci_0, nameIR, ((! oid) as value)))

        4. (Let constantDeclarationIR be (() const typeIR nameIR (= ((! oid) as value)) ;))

        5. Result in Ci_1, sto_1, $wrap_decl(p', (constantDeclarationIR as declarationIR))

      6. Else Phantom#1517

    3. Else Phantom#1518

  3. Case (% has type functionDeclarationIR)

    1. (Let (_annotationList (typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR )) blockStatementIR) be (declarationIR as functionDeclarationIR))

    2. (Let rid be $rid_IR(nameIR, parameterListIR))

    3. (Let funcDyn be (function< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ) blockStatementIR))

    4. (Let Ci_1 be $add_routine_overload_inst(p', Ci_0, rid, (funcDyn as routineDyn)))

    5. Result in Ci_1, sto', ?()

  4. Case (% has type actionDeclarationIR)

    1. (Let (_annotationList action nameIR ( parameterListIR ) blockStatementIR) be (declarationIR as actionDeclarationIR))

    2. (Let rid be $rid_IR(nameIR, parameterListIR))

    3. (Let funcDyn be (action( parameterListIR ){ blockStatementIR }))

    4. (Let Ci_1 be $add_routine_non_overload_inst(p', Ci_0, rid, (funcDyn as routineDyn)))

    5. Result in Ci_1, sto', ?()

  5. Case (% has type externFunctionDeclarationIR)

    1. (Let (_annotationList extern (typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR )) ;) be (declarationIR as externFunctionDeclarationIR))

    2. (Let rid be $rid_IR(nameIR, parameterListIR))

    3. (Let funcDyn be (extern_function< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ){ ?() }))

    4. (Let Ci_1 be $add_routine_overload_inst(p', Ci_0, rid, (funcDyn as routineDyn)))

    5. Result in Ci_1, sto', ?()

  6. Case (% has type externObjectDeclarationIR)

    1. (Let (annotationList extern nameIR < typeParameterListIR , typeParameterListIR_inferred >{ methodPrototypeIR* }) be (declarationIR as externObjectDeclarationIR))

    2. (Let (methodPrototypeIR'*, methodPrototypeIR_method*) be $split_constructors_IR(methodPrototypeIR*))

    3. If ((methodPrototypeIR'* matches pattern [])), then

      1. (Bind_methods: $empty_rdenv |- methodPrototypeIR_method* ==> rdenv)

      2. (Let externObjectTypeIR be (extern nameIR rdenv))

      3. (Let polyTypeDefIR be ((externObjectTypeIR as typeIR) < typeParameterListIR , [] >))

      4. (Let Ci_1 be $add_typedef_inst(p', Ci_0, nameIR, (polyTypeDefIR as typeDefIR)))

      5. (Let cid be $cid_IR(nameIR, []))

      6. (Let consDyn be (extern nameIR < typeParameterListIR >( [] ){ methodPrototypeIR_method* }))

      7. (Let Ci_2 be $add_constructor_inst(p', Ci_1, cid, consDyn))

      8. Result in Ci_2, sto', ?()

    3. Else Phantom#1519

    4. (Bind_methods: $empty_rdenv |- methodPrototypeIR_method* ==> rdenv)

    5. (Let externObjectTypeIR be (extern nameIR rdenv))

    6. (Let polyTypeDefIR be ((externObjectTypeIR as typeIR) < typeParameterListIR , [] >))

    7. (Let Ci_1 be $add_typedef_inst(p', Ci_0, nameIR, (polyTypeDefIR as typeDefIR)))

    8. (Bind_constructors: p' Ci_1 typeParameterListIR methodPrototypeIR_method* |- methodPrototypeIR'* ==> Ci_2)

    9. Result in Ci_2, sto', ?()

  7. Case (% has type parserDeclarationIR)

    1. (Let (_annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }) be (declarationIR as parserDeclarationIR))

    2. (Let cid be $cid_IR(nameIR, constructorParameterListIR))

    3. (Let consDyn be (parser< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }))

    4. (Let Ci_1 be $add_constructor_inst(p', Ci_0, cid, consDyn))

    5. Result in Ci_1, sto', ?()

  8. Case (% has type controlDeclarationIR)

    1. (Let (_annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }) be (declarationIR as controlDeclarationIR))

    2. (Let cid be $cid_IR(nameIR, constructorParameterListIR))

    3. (Let consDyn be (control< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }))

    4. (Let Ci_1 be $add_constructor_inst(p', Ci_0, cid, consDyn))

    5. Result in Ci_1, sto', ?()

  9. Case (% has type packageTypeDeclarationIR)

    1. (Let (_annotationList package nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR* );) be (declarationIR as packageTypeDeclarationIR))

    2. (Let (_annotationList' _direction typeIR _nameIR _constantInitializerOptIR) be parameterIR)*

    3. (Let typeIR_package be ((package< typeIR* >) as typeIR))

    4. (Let typeDefIR_package be ((typeIR_package < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

    5. (Let Ci_1 be $add_typedef_inst(p', Ci_0, nameIR, typeDefIR_package))

    6. (Let cid be $cid_IR(nameIR, parameterIR*))

    7. (Let consDyn_package be (package< typeParameterListIR ++ typeParameterListIR_inferred >( parameterIR* )))

    8. (Let Ci_2 be $add_constructor_inst((global), Ci_1, cid, consDyn_package))

    9. Result in Ci_2, sto', ?()

1. Else Phantom#1520

2. If ((p' matches pattern `GLOBAL`)), then

  1. Case analysis on declarationIR

    1. Case (% has type errorDeclarationIR)

      1. (Let (error{ nameIR* }) be (declarationIR as errorDeclarationIR))

      2. (Let nameIR_field be $concat_text(["error.", nameIR]))*

      3. (Let Ci_1 be $add_values_inst((global), Ci_0, nameIR_field*, ((error. nameIR) as value)*))

      4. Result in Ci_1, sto', ?()

    2. Case (% has type matchKindDeclarationIR)

      1. (Let (match_kind{ nameIR* }) be (declarationIR as matchKindDeclarationIR))

      2. (Let Ci_1 be $add_values_inst((global), Ci_0, nameIR*, ((match_kind. nameIR) as value)*))

      3. Result in Ci_1, sto', ?()

    3. Case (% has type enumTypeDeclarationIR)

      1. (Let enumTypeDeclarationIR be (declarationIR as enumTypeDeclarationIR))

      2. Case analysis on enumTypeDeclarationIR

        1. Case (% matches pattern `%ENUM%{%}`)

          1. (Let (_annotationList enum nameIR { nameIR_mem* }) be enumTypeDeclarationIR)

          2. (Let nameIR_path be $concat_text([nameIR, ".", nameIR_mem]))*

          3. (Let Ci_1 be $add_values_inst((global), Ci_0, nameIR_path*, ((nameIR . nameIR_mem) as value)*))

          4. (Let Ci_2 be $add_typedef_inst((global), Ci_1, nameIR, ((enum nameIR { nameIR_mem* }) as typeDefIR)))

          5. Result in Ci_2, sto', ?()

        2. Case (% matches pattern `%ENUM%%{%}`)

          1. (Let (_annotationList enum typeIR nameIR { (nameIR_mem = typedExpressionIR)* }) be enumTypeDeclarationIR)

          2. (Exprs_inst: (global) Ci_0 sto' |- typedExpressionIR* ==> sto_1 value_mem*)

          3. (Let nameIR_path be $concat_text([nameIR, ".", nameIR_mem]))*

          4. (Let Ci_1 be $add_values_inst((global), Ci_0, nameIR_path*, ((nameIR . nameIR_mem # value_mem) as value)*))

          5. (Let Ci_2 be $add_typedef_inst((global), Ci_1, nameIR, ((enum nameIR # typeIR { (nameIR_mem = value_mem ;)* }) as typeDefIR)))

          6. Result in Ci_2, sto_1, ?()

    4. Case (% has type structTypeDeclarationIR)

      1. (Let (_annotationList struct nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR* }) be (declarationIR as structTypeDeclarationIR))

      2. (Let (_annotationList' typeIR nameIR_field ;) be typeFieldIR)*

      3. (Let typeDefIR be ((((struct nameIR { (typeIR nameIR_field ;)* }) as typeIR) < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

      4. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, typeDefIR))

      5. Result in Ci_1, sto', ?()

    5. Case (% has type headerTypeDeclarationIR)

      1. (Let (_annotationList header nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR* }) be (declarationIR as headerTypeDeclarationIR))

      2. (Let (_annotationList' typeIR nameIR_field ;) be typeFieldIR)*

      3. (Let typeDefIR be ((((header nameIR { (typeIR nameIR_field ;)* }) as typeIR) < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

      4. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, typeDefIR))

      5. Result in Ci_1, sto', ?()

    6. Case (% has type headerUnionTypeDeclarationIR)

      1. (Let (_annotationList header_union nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR* }) be (declarationIR as headerUnionTypeDeclarationIR))

      2. (Let (_annotationList' typeIR nameIR_field ;) be typeFieldIR)*

      3. (Let typeDefIR be ((((header_union nameIR { (typeIR nameIR_field ;)* }) as typeIR) < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

      4. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, typeDefIR))

      5. Result in Ci_1, sto', ?()

    7. Case (% has type typedefDeclarationIR)

      1. (Let typedefDeclarationIR be (declarationIR as typedefDeclarationIR))

      2. Case analysis on typedefDeclarationIR

        1. Case (% matches pattern `%TYPEDEF%%;`)

          1. (Let (_annotationList typedef typedefTypeIR nameIR ;) be typedefDeclarationIR)

          2. Case analysis on typedefTypeIR

            1. Case (% has type typeIR)

              1. (Let typeIR be (typedefTypeIR as typeIR))

              2. (Let typeIR_typedef be ((typedef nameIR typeIR) as typeIR))

              3. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, (typeIR_typedef as typeDefIR)))

              4. Result in Ci_1, sto', ?()

            2. Case (% has type derivedTypeDeclarationIR)

              1. (Let derivedTypeDeclarationIR be (typedefTypeIR as derivedTypeDeclarationIR))

              2. (Decl_inst: (global) Ci_0 $empty_sto |- (derivedTypeDeclarationIR as declarationIR) ==> Ci_local _sto _declarationIR?)

              3. (Let ({ tid* }) be $diff_set<tid>($dom_map<tid, typeDefIR>(Ci_local.global.tdenv), $dom_map<tid, typeDefIR>(Ci_0.global.tdenv)))

              4. If ((tid* matches pattern [ _/1 ])), then

                1. (Let [tid_newtype] be tid*)

                2. (Let typeDefIR'? be $find_typedef_inst((global), Ci_local, (. tid_newtype)))

                3. If ((typeDefIR'? matches pattern (_))), then

                  1. (Let ?(typeDefIR) be typeDefIR'?)

                  2. (Let typeDefIR'' be typeDefIR)

                  3. Case analysis on typeDefIR''

                    1. Case (% has type monoTypeDefIR)

                      1. (Let monoTypeDefIR be (typeDefIR'' as monoTypeDefIR))

                      2. (Let typeIR_typedef be ((typedef nameIR monoTypeDefIR) as typeIR))

                      3. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, (typeIR_typedef as typeDefIR)))

                      4. Result in Ci_1, sto', ?()

                    2. Case (% has type polyTypeDefIR)

                      1. (Let polyTypeDefIR be (typeDefIR'' as polyTypeDefIR))

                      2. (Let typeIR_typedef be ((typedef nameIR ((polyTypeDefIR < [] >) as typeIR)) as typeIR))

                      3. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, (typeIR_typedef as typeDefIR)))

                      4. Result in Ci_1, sto', ?()

                3. Else Phantom#1521

              4. Else Phantom#1522

        2. Case (% matches pattern `%TYPE%%;`)

          1. (Let (_annotationList type typeIR nameIR ;) be typedefDeclarationIR)

          2. (Let typeIR_newtype be ((type nameIR typeIR) as typeIR))

          3. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, (typeIR_newtype as typeDefIR)))

          4. Result in Ci_1, sto', ?()

    8. Case (% has type parserTypeDeclarationIR)

      1. (Let (_annotationList parser nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR* );) be (declarationIR as parserTypeDeclarationIR))

      2. (Let parameterTypeIR be $parameterIR(parameterIR))*

      3. (Let typeIR_parser be ((parser( parameterTypeIR* )) as typeIR))

      4. (Let typeDefIR_parser be ((typeIR_parser < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

      5. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, typeDefIR_parser))

      6. Result in Ci_1, sto', ?()

    9. Case (% has type controlTypeDeclarationIR)

      1. (Let (_annotationList control nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR* );) be (declarationIR as controlTypeDeclarationIR))

      2. (Let parameterTypeIR be $parameterIR(parameterIR))*

      3. (Let typeIR_control be ((control( parameterTypeIR* )) as typeIR))

      4. (Let typeDefIR_control be ((typeIR_control < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

      5. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, typeDefIR_control))

      6. Result in Ci_1, sto', ?()

  1. Else Phantom#1523

2. Else Phantom#1524

;; ../../../../examples/p4-concrete/6.03-instantiation-relation.spectec:168:1-170:17:
relation Program_inst: (declarationIR* ;)

1. (Let Ci_0 be $empty_context_inst)

2. (Let sto_0 be $empty_sto)

3. (Decls_inst: (global) Ci_0 sto_0 |- declarationIR* ==> Ci_1 sto_1 declarationIR'*)

4. If ((declarationIR'* matches pattern [])), then

  1. Result in Ci_1.global.cenv, Ci_1.global.tdenv, Ci_1.global.renv, Ci_1.global.venv, sto_1

4. Else Phantom#1525

;; ../../../../examples/p4-concrete/6.04-instantiation-constructor.spectec:6:1-6:84:
def $partition_default_parameters(parameterIR*, id_default*)

1. Case analysis on parameterIR*

  1. Case (% matches pattern [])

    1. Return ([], [])

  2. Case (% matches pattern _ :: _)

    1. (Let parameterIR_h :: parameterIR_t* be parameterIR*)

    2. (Let (_annotationList _direction _typeIR id_h _constantInitializerOptIR) be parameterIR_h)

    3. (Let (parameterIR_nondefault*, parameterIR_default*) be $partition_default_parameters(parameterIR_t*, id_default*))

    4. Case analysis on id_h is in id_default*

      1. Case true

        1. Return (parameterIR_nondefault*, parameterIR_h :: parameterIR_default*)

      2. Case false

        1. Return (parameterIR_h :: parameterIR_nondefault*, parameterIR_default*)

;; ../../../../examples/p4-concrete/6.04-instantiation-constructor.spectec:30:1-30:146:
def $align_cparams_with_args(constructorParameterIR*, argumentIR*, id_default*)

1. (Let (constructorParameterIR_nondefault*, constructorParameterIR_default*) be $partition_default_parameters(constructorParameterIR*, id_default*))

2. (Let (_annotationList _direction _typeIR id _constantInitializerOptIR) be constructorParameterIR_nondefault)*

3. (Let (constructorParameterIR_aligned*, argumentIR_aligned*) be $align_cparams_with_args'(({ (id : constructorParameterIR_nondefault)* }), constructorParameterIR_nondefault*, argumentIR*))

4. (Let (_annotationList' _direction' _typeIR' _nameIR constantInitializerOptIR) be constructorParameterIR_default)*

5. If ((constantInitializerOptIR matches pattern (_)))*, then

  1. (Let ?((= value_default)) be constantInitializerOptIR)*

  2. Return (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*)

5. Else Phantom#1526

;; ../../../../examples/p4-concrete/6.04-instantiation-constructor.spectec:31:1-31:142:
def $align_cparams_with_args'(({ (id_map : constructorParameterIR_map)* }), constructorParameterIR*, argumentIR*)

1. Case analysis on constructorParameterIR*

  1. Case (% matches pattern [])

    1. If ((argumentIR* matches pattern [])), then

      1. Return ([], [])

    1. Else Phantom#1527

  2. Case (% matches pattern _ :: _)

    1. (Let constructorParameterIR_h :: constructorParameterIR_t* be constructorParameterIR*)

    2. If ((argumentIR* matches pattern _ :: _)), then

      1. (Let argumentIR_h :: argumentIR_t* be argumentIR*)

      2. (Let argumentIR' be argumentIR_h)

      3. If ((argumentIR' has type typedExpressionIR)), then

        1. (Let typedExpressionIR be (argumentIR' as typedExpressionIR))

        2. (Let (constructorParameterIR_aligned*, argumentIR_aligned*) be $align_cparams_with_args'(({ (id_map : constructorParameterIR_map)* }), constructorParameterIR_t*, argumentIR_t*))

        3. Return (constructorParameterIR_h :: constructorParameterIR_aligned*, argumentIR_h :: argumentIR_aligned*)

      3. Else Phantom#1528

      4. If ((argumentIR_h matches pattern `_`)), then

        1. (Let (constructorParameterIR_aligned*, argumentIR_aligned*) be $align_cparams_with_args'(({ (id_map : constructorParameterIR_map)* }), constructorParameterIR_t*, argumentIR_t*))

        2. Return (constructorParameterIR_h :: constructorParameterIR_aligned*, argumentIR_h :: argumentIR_aligned*)

      4. Else Phantom#1529

      5. If ((argumentIR' matches pattern `%=%`)), then

        1. (Let (nameIR = _typedExpressionIR) be argumentIR')

        2. (Let constructorParameterIR'? be $find_map<id, constructorParameterIR>(({ (id_map : constructorParameterIR_map)* }), nameIR))

        3. If ((constructorParameterIR'? matches pattern (_))), then

          1. (Let ?(constructorParameterIR_matching) be constructorParameterIR'?)

          2. (Let (constructorParameterIR_aligned*, argumentIR_aligned*) be $align_cparams_with_args'(({ (id_map : constructorParameterIR_map)* }), constructorParameterIR_t*, argumentIR_t*))

          3. Return (constructorParameterIR_matching :: constructorParameterIR_aligned*, argumentIR_h :: argumentIR_aligned*)

        3. Else Phantom#1530

      5. Else Phantom#1531

    2. Else Phantom#1532

;; ../../../../examples/p4-concrete/6.04-instantiation-constructor.spectec:197:1-197:59:
def $init_table(tablePropertyListIR)

1. Return tablePropertyListIR

;; ../../../../examples/p4-concrete/6.08-instantiation-declaration.spectec:11:1-11:55:
def $wrap_decl(cursor', declarationIR)

1. If ((cursor' matches pattern `GLOBAL`)), then

  1. Return ?()

1. Else Phantom#1533

2. Return ?(declarationIR)

;; ../../../../examples/p4-concrete/6.08-instantiation-declaration.spectec:28:1-28:70:
def $get_init_decls(objectInitializerOptIR')

1. (Let objectInitializerIR? be objectInitializerOptIR')

2. If ((objectInitializerIR? matches pattern ())), then

  1. Return []

2. Else Phantom#1534

3. If ((objectInitializerOptIR' matches pattern (_))), then

  1. (Let ?((={ objectDeclarationListIR })) be objectInitializerOptIR')

  2. Return objectDeclarationListIR

3. Else Phantom#1535

;; ../../../../examples/p4-concrete/6.08-instantiation-declaration.spectec:34:1-34:36:
def $merge_venvs(venv, ({ (id : value)* }))

1. Return $adds_map<id, value>(venv, id*, value*)

;; ../../../../examples/p4-concrete/6.08-instantiation-declaration.spectec:40:1-40:47:
def $merge_renv_with_extern(renv, set<pair<rid, routineDyn>>')

1. If ((set<pair<rid, routineDyn>>' = ({ [] }))), then

  1. Return renv

1. Else Phantom#1536

2. (Let ({ pair<rid, routineDyn>* }) be set<pair<rid, routineDyn>>')

3. If ((pair<rid, routineDyn>* matches pattern _ :: _)), then

  1. (Let (rid_h : routineDyn_h) :: (rid_t : routineDyn_t)* be pair<rid, routineDyn>*)

  2. (Let routineDyn be routineDyn_h)

  3. If ((routineDyn has type funcDyn)), then

    1. (Let funcDyn be (routineDyn as funcDyn))

    2. If ((funcDyn matches pattern `FUNCTION<%>(%)%`)), then

      1. (Let (function< typeParameterListIR >( parameterListIR ) blockStatementIR) be funcDyn)

      2. (Let routineDyn_h_post be ((extern_method< typeParameterListIR >( parameterListIR ) ?(blockStatementIR)) as routineDyn))

      3. (Let renv_post be $update_map<rid, routineDyn>(renv, rid_h, routineDyn_h_post))

      4. Return $merge_renv_with_extern(renv_post, ({ (rid_t : routineDyn_t)* }))

    2. Else Phantom#1537

  3. Else Phantom#1538

3. Else Phantom#1539

;; ../../../../examples/p4-concrete/6.08-instantiation-declaration.spectec:81:1-81:37:
def $is_extern_object(objDyn')

1. If ((objDyn' matches pattern `EXTERN{%%%%}`)), then

  1. (Let (extern{ _tid _theta _venv _renv }) be objDyn')

  2. Return true

1. Else Phantom#1540

2. Return false

;; ../../../../examples/p4-concrete/6.08-instantiation-declaration.spectec:108:1-108:43:
def $rid_IR(nameIR, parameterIR*)

1. Return (nameIR ( $pid_IR(parameterIR)* ))

;; ../../../../examples/p4-concrete/6.08-instantiation-declaration.spectec:109:1-109:31:
def $pid_IR((_annotationList _direction _typeIR nameIR constantInitializerOptIR'))

1. (Let constantInitializerIR? be constantInitializerOptIR')

2. If ((constantInitializerIR? matches pattern ())), then

  1. Return (nameIR # false)

2. Else Phantom#1541

3. If ((constantInitializerOptIR' matches pattern (_))), then

  1. (Let ?(constantInitializerIR) be constantInitializerOptIR')

  2. Return (nameIR # true)

3. Else Phantom#1542

;; ../../../../examples/p4-concrete/6.08-instantiation-declaration.spectec:116:1-116:54:
def $cid_IR(nameIR, constructorParameterListIR)

1. Return $rid_IR(nameIR, constructorParameterListIR)

;; ../../../../examples/p4-concrete/6.08-instantiation-declaration.spectec:182:1-182:90:
def $split_constructors_IR(methodPrototypeIR*)

1. Case analysis on methodPrototypeIR*

  1. Case (% matches pattern [])

    1. Return ([], [])

  2. Case (% matches pattern _ :: _)

    1. (Let methodPrototypeIR_h :: methodPrototypeIR_t* be methodPrototypeIR*)

    2. (Let methodPrototypeIR' be methodPrototypeIR_h)

    3. Case analysis on methodPrototypeIR'

      1. Case (% matches pattern `%%<,%>(%);`)

        1. (Let (_annotationList _nameIR <, _typeParameterListIR >( _parameterListIR );) be methodPrototypeIR')

        2. (Let (methodPrototypeIR_t_constructor*, methodPrototypeIR_t_method*) be $split_constructors_IR(methodPrototypeIR_t*))

        3. Return (methodPrototypeIR_h :: methodPrototypeIR_t_constructor*, methodPrototypeIR_t_method*)

      2. Case (% matches pattern `%%;`)

        1. (Let (_annotationList _functionPrototypeIR ;) be methodPrototypeIR')

        2. (Let (methodPrototypeIR_t_constructor*, methodPrototypeIR_t_method*) be $split_constructors_IR(methodPrototypeIR_t*))

        3. Return (methodPrototypeIR_t_constructor*, methodPrototypeIR_h :: methodPrototypeIR_t_method*)

      3. Case (% matches pattern `%ABSTRACT%;`)

        1. (Let (_annotationList abstract _functionPrototypeIR ;) be methodPrototypeIR')

        2. (Let (methodPrototypeIR_t_constructor*, methodPrototypeIR_t_method*) be $split_constructors_IR(methodPrototypeIR_t*))

        3. Return (methodPrototypeIR_t_constructor*, methodPrototypeIR_h :: methodPrototypeIR_t_method*)

    3. Else Phantom#1543
