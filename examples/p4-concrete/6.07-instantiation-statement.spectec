;;
;; Statement instantiation
;;
;; syntax statementIR
;;

;;; emptyStatementIR

rule Stmt_inst/emptyStatementIR:
  p Ci sto |- emptyStatementIR ==> Ci sto emptyStatementIR

;;; assignmentStatementIR

rule Stmt_inst/assignmentStatementIR:
  p Ci sto |- assignmentStatementIR ==> Ci sto assignmentStatementIR

;;; callStatementIR
;;; syntax callStatementIR =
;;;   routineLvalueIR `< typeArgumentListIR > `( argumentListIR ) `;

rule Stmt_inst/callStatementIR:
  p Ci sto |- callStatementIR ==> Ci sto callStatementIR

;;; directApplicationStatementIR
;;; syntax directApplicationStatementIR =
;;;   prefixedNameIR `. APPLY `( argumentListIR ) `;

rule Stmt_inst/directApplicationStatementIR:
  p Ci sto_0 |- prefixedNameIR `. APPLY `( argumentListIR ) `;
            ==> Ci sto_2 blockStatementIR
  ---- ;; find and instantiate constructor
  -- if $find_constructor_overloaded_inst(Ci, prefixedNameIR, eps) = (_, consDyn, _)
  -- Constructor_inst: p Ci sto_0 |- consDyn `< eps > `( eps `# eps ) ==> sto_1 objDyn
  ---- ;; assign new tid with random string appended
  -- if $fresh_tid() = tid_fresh
  -- if $flatten_prefixedNameIR(prefixedNameIR) = tid
  -- if TID tid = typeIR
  -- if $concat_text([ tid, "_", tid_fresh]) = nameIR
  ---- ;; add object to store
  -- if Ci.PATH ++ nameIR = oid
  -- if $add_sto(sto_1, oid, objDyn) = sto_2
  ---- ;; replace with constant declaration and call statement
  -- if `EMPTY CONST typeIR nameIR (`= (`! oid)) `; = constantDeclarationIR
  -- if ((`` tid) `# `( typeIR CTK )) `. "apply" = routineTargetIR
  -- if routineTargetIR `< eps > `( argumentListIR ) `; = callStatementIR
  -- if `EMPTY `{ [ constantDeclarationIR, callStatementIR ] } = blockStatementIR

;;; returnStatementIR

rule Stmt_inst/returnStatementIR:
  p Ci sto |- returnStatementIR ==> Ci sto returnStatementIR

;;; exitStatementIR

rule Stmt_inst/exitStatementIR:
  p Ci sto |- exitStatementIR ==> Ci sto exitStatementIR

;;; blockStatementIR
;;; syntax blockStatementIR = annotationList `{ blockElementStatementListIR }

rule Stmt_inst/blockStatementIR:
  p Ci sto |- annotationList `{ blockElementStatementListIR }
          ==> Ci_1 sto_1 (annotationList `{ blockElementStatementListIR' })
  -- Block_inst: p Ci sto |- annotationList `{ blockElementStatementListIR } ==> Ci_1 sto_1 (_ `{ blockElementStatementListIR' })

;;; conditionalStatementIR
;;; syntax conditionalStatementIR =

;;;; IF `( typedExpressionIR ) statementIR

rule Stmt_inst/conditionalStatementIR-non-else:
  p Ci sto |- IF `( typedExpressionIR ) statementIR
          ==> Ci_1 sto_1 (IF `( typedExpressionIR ) statementIR')
  -- Stmt_inst: p Ci sto |- statementIR ==> Ci_1 sto_1 statementIR'

;;;; IF `( typedExpressionIR ) statementIR ELSE statementIR

rule Stmt_inst/conditionalStatementIR-else:
  p Ci sto |- IF `( typedExpressionIR ) statementIR_then ELSE statementIR_else
          ==> Ci_2 sto_2 (IF `( typedExpressionIR ) statementIR_then' ELSE statementIR_else')
  ---- ;; instantiate then branch
  -- Stmt_inst: p Ci sto |- statementIR_then ==> Ci_1 sto_1 statementIR_then'
  ---- ;; instantiate else branch
  -- Stmt_inst: p Ci_1 sto_1 |- statementIR_else ==> Ci_2 sto_2 statementIR_else'

;;; forStatementIR : TODO

;;; breakStatementIR

rule Stmt_inst/breakStatementIR:
  p Ci sto |- breakStatementIR ==> Ci sto breakStatementIR

;;; continueStatementIR

rule Stmt_inst/continueStatementIR:
  p Ci sto |- continueStatementIR ==> Ci sto continueStatementIR

;;; switchStatementIR
;;; syntax switchStatementIR = SWITCH `( typedExpressionIR ) `{ switchCaseListIR }

rule Stmt_inst/switchStatementIR:
  p Ci sto |- SWITCH `( typedExpressionIR ) `{ switchCaseListIR } 
          ==> Ci_1 sto_1 (SWITCH `( typedExpressionIR ) `{ switchCaseListIR' })
  ---- ;; instantiate switch cases
  -- SwitchCases_inst: p Ci sto |- switchCaseListIR ==> Ci_1 sto_1 switchCaseListIR'

;;
;; Switch case instantiation
;;
;; syntax switchCaseIR
;;

;;; switchLabelIR `: blockStatementIR

rule SwitchCase_inst/match:
  p Ci sto |- switchLabelIR `: blockStatementIR ==> Ci_1 sto_1 (switchLabelIR `: blockStatementIR')
  -- Stmt_inst: p Ci sto |- blockStatementIR ==> Ci_1 sto_1 blockStatementIR'

;;; switchLabelIR `:

rule SwitchCase_inst/fallthrough:
  p Ci sto |- switchLabelIR `: ==> Ci sto (switchLabelIR `:)

rule SwitchCases_inst/nil:
  p Ci sto |- eps ==> Ci sto eps

rule SwitchCases_inst/cons:
  p Ci_0 sto_0 |- switchCaseIR_h :: switchCaseIR_t*
              ==> Ci_2 sto_2 (switchCaseIR_h' :: switchCaseIR_t'*)
  -- SwitchCase_inst: p Ci_0 sto_0 |- switchCaseIR_h ==> Ci_1 sto_1 switchCaseIR_h'
  -- SwitchCases_inst: p Ci_1 sto_1 |- switchCaseIR_t* ==> Ci_2 sto_2 switchCaseIR_t'*

;;
;; syntax blockElementStatementIR
;;

;;; constantDeclarationIR

rule BlockElementStmt_inst/constantDeclarationIR:
  p Ci sto |- constantDeclarationIR ==> Ci_1 sto_1 constantDeclarationIR'
  -- Decl_inst: p Ci sto |- constantDeclarationIR ==> Ci_1 sto_1 constantDeclarationIR'

;;; variableDeclarationIR

rule BlockElementStmt_inst/variableDeclarationIR:
  GLOBAL Ci sto |- variableDeclarationIR ==> Ci sto eps

rule BlockElementStmt_inst/variableDeclarationIR:
  p Ci sto |- variableDeclarationIR ==> Ci sto variableDeclarationIR

;;; statementIR

rule BlockElementStmt_inst/statementIR:
  p Ci sto |- statementIR ==> Ci_1 sto_1 statementIR_inst
  -- Stmt_inst: LOCAL Ci sto |- statementIR ==> Ci_1 sto_1 statementIR_inst

rule BlockElementStmts_inst/nil:
  p Ci sto |- eps ==> Ci sto eps

rule BlockElementStmts_inst/cons:
  p Ci_0 sto_0 |- blockElementStatementIR_h :: blockElementStatementIR_t*
              ==> Ci_2 sto_2 (blockElementStatementIR_h' :: blockElementStatementIR_t'*)
  -- BlockElementStmt_inst: p Ci_0 sto_0 |- blockElementStatementIR_h ==> Ci_1 sto_1 blockElementStatementIR_h'
  -- BlockElementStmts_inst: p Ci_1 sto_1 |- blockElementStatementIR_t* ==> Ci_2 sto_2 blockElementStatementIR_t'*

;;
;; syntax blockStatmentIR
;;

;;; syntax blockStatmentIR =
;;;   annotationList `{ blockElementStatementListIR }

rule Block_inst:
  p Ci_0 sto_0 |- annotationList `{ blockElementStatementListIR }
              ==> Ci_2 sto_1 (annotationList `{ blockElementStatementListIR_inst })
  -- if $enter_inst(Ci_0) = Ci_1
  -- BlockElementStmts_inst: p Ci_1 sto_0 |- blockElementStatementListIR ==> Ci_2 sto_1 blockElementStatementListIR_inst
  -- if $exit_inst(Ci_2) = Ci_3
