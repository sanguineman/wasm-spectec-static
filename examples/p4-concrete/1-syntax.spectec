;;
;; Misc
;;

syntax trailingCommaOpt =
  | `EMPTY
  | `,

;;
;; Numbers
;;

syntax number =
  | D int        hint(print %)
  | nat W int    hint(print %#W#%)
  | nat S int    hint(print %#S#%)

;;
;; Strings
;;

syntax stringLiteral = `" text `"    hint(print `"#%#`")

;;
;; Names
;;

;;; The grammar is actually ambiguous,
;;; so the lexer and the parser must collaborate for parsing the language.
;;; In particular, the lexer must be able to distinguish two kinds of identifiers:
;;;
;;; * Type names previously introduced (TYPE_IDENTIFIER tokens)
;;; * Regular identifiers (IDENTIFIER token)

syntax identifier = `ID text
syntax typeIdentifier = `TID text

;;
;;;; Non-type names
;;

syntax nonTypeName =
  | identifier
  | APPLY | KEY | ACTIONS | STATE
  | ENTRIES | TYPE | PRIORITY

syntax prefixedNonTypeName =
  | nonTypeName
  | `ID `. nonTypeName

;;
;;;; Type names
;;

syntax typeName = typeIdentifier

syntax prefixedTypeName =
  | typeName 
  | `TID `. typeName

;;
;;;; Table custom property names
;;

syntax tableCustomName =
  | identifier
  | typeIdentifier
  | APPLY | STATE | TYPE | PRIORITY

;;
;;;; Names
;;

syntax name =
  | nonTypeName
  | typeName
  | LIST

syntax nameList =
  | name
  | nameList `, name

dec $flatten_nameList(nameList) : name*
def $flatten_nameList(name) = name
def $flatten_nameList(nameList `, name) =
  $flatten_nameList(nameList) ++ [ name ]

syntax member = name

;;
;; Directions
;;

syntax direction = `EMPTY | IN | OUT | INOUT

;;
;; Types
;;

;;
;;;; Base types
;;

syntax expression

syntax baseType =
  | BOOL
  | ERROR
  | MATCH_KIND
  | STRING
  | INT
  | INT `< int >
  | INT `< `( expression ) >
  | BIT
  | BIT `< int >
  | BIT `< `( expression ) >
  | VARBIT `< int >
  | VARBIT `< `( expression ) >

;;
;;;; Named types
;;

syntax typeArgumentList

syntax specializedType = prefixedTypeName `< typeArgumentList >

syntax namedType =
  | prefixedTypeName
  | specializedType

;;
;;;; Header stack types
;;

syntax headerStackType = namedType `[ expression ]

;;
;;;; List types
;;

syntax typeArgument

syntax listType = LIST `< typeArgument >

;;
;;;; Tuple types
;;

syntax tupleType = TUPLE `< typeArgumentList >

;;
;;;; Types
;;

syntax type =
  | baseType
  | namedType
  | headerStackType
  | listType
  | tupleType

syntax typeOrVoid =
  | type
  | VOID
  | identifier

;;
;; Type parameters
;;

syntax typeParameter = name

syntax typeParameterList =
  | typeParameter
  | typeParameterList `, typeParameter

dec $flatten_typeParameterList(typeParameterList) : typeParameter*
def $flatten_typeParameterList(typeParameter) = typeParameter
def $flatten_typeParameterList(typeParameterList `, typeParameter) =
  $flatten_typeParameterList(typeParameterList) ++ [ typeParameter ]

syntax typeParameterListOpt =
  | `EMPTY
  | `< typeParameterList >

dec $flatten_typeParameterListOpt(typeParameterListOpt) : typeParameter*
def $flatten_typeParameterListOpt(`EMPTY) = eps
def $flatten_typeParameterListOpt(`< typeParameterList >)
  = $flatten_typeParameterList(typeParameterList)

;;
;; Parameters
;;

syntax annotationList, initializerOpt

syntax parameter =
  annotationList direction type name initializerOpt

syntax nonEmptyParameterList =
  | parameter
  | nonEmptyParameterList `, parameter

syntax parameterList =
  | `EMPTY
  | nonEmptyParameterList

dec $flatten_parameterList(parameterList) : parameter*
def $flatten_parameterList(`EMPTY) = eps
def $flatten_parameterList(parameter) = parameter
def $flatten_parameterList(nonEmptyParameterList `, parameter)
  = $flatten_parameterList(nonEmptyParameterList) ++ [ parameter ]

;;
;; Constructor parameters
;;

syntax constructorParameter = parameter

syntax constructorParameterList = parameterList

syntax constructorParameterListOpt =
  | `EMPTY
  | `( parameterList )

dec $flatten_constructorParameterListOpt(constructorParameterListOpt)
  : constructorParameter*

def $flatten_constructorParameterListOpt(`EMPTY) = eps
def $flatten_constructorParameterListOpt(`( parameterList ))
  = $flatten_parameterList(parameterList)

;;
;; Expression key-value pairs
;;

syntax namedExpression = name `= expression

syntax namedExpressionList =
  | namedExpression
  | namedExpressionList `, namedExpression

dec $flatten_namedExpressionList(namedExpressionList) : namedExpression*
def $flatten_namedExpressionList(namedExpression) = namedExpression
def $flatten_namedExpressionList(namedExpressionList `, namedExpression) =
  $flatten_namedExpressionList(namedExpressionList) ++ [ namedExpression ]

;;
;; Expressions
;;

;;
;;;; Literal expressions
;;

syntax literalExpression =
  | TRUE | FALSE
  | number
  | stringLiteral

;;
;;;; Reference expressions
;;

syntax referenceExpression =
  | prefixedNonTypeName
  | THIS

;;
;;;; Default expressions
;;

syntax defaultExpression = `...

;;
;;;; Unary, binary, and ternary expressions
;;

syntax expressionNonBrace

syntax unop = `! | `~ | `- | `+

syntax unaryExpression = unop expression

syntax binop =
  | `* | `/ | `% | `+ | `- | `|+| | `|-| | `<< | `>>
  | `<= | `>= | ``< | ``> | `!= | `==
  | `& | `^ | `| | `++ | `&& | `||

syntax binaryExpression = expression binop expression

syntax binaryExpressionNonBrace =
  expressionNonBrace binop expression

syntax ternaryExpression =
  expression `? expression `: expression

syntax ternaryExpressionNonBrace =
  expressionNonBrace `? expression `: expression

;;
;;;; Cast expressions
;;

syntax castExpression = `( type ) expression

;;
;;;; Data (aggregate) expressions
;;

syntax dataElementExpression

syntax dataExpression =
  | `{#}
  | `{ dataElementExpression trailingCommaOpt }

;;
;;;; Member and index access expressions
;;

syntax memberAccessBase, memberAccessBaseNonBrace

syntax errorAccessExpression =
  ERROR `. member

syntax memberAccessExpression =
  memberAccessBase `. member

syntax indexAccessExpression =
  | expression `[ expression ]
  | expression `[ expression `: expression ]

syntax accessExpression =
  | errorAccessExpression
  | memberAccessExpression
  | indexAccessExpression

syntax memberAccessExpressionNonBrace =
  memberAccessBaseNonBrace `. member

syntax indexAccessExpressionNonBrace =
  | expressionNonBrace `[ expression ]
  | expressionNonBrace `[ expression `: expression ]

syntax accessExpressionNonBrace =
  | errorAccessExpression
  | memberAccessExpressionNonBrace
  | indexAccessExpressionNonBrace

;;
;;;; Call expressions
;;

syntax callTarget
syntax routineTarget
syntax realTypeArgumentList
syntax argumentList
syntax callTargetNonBrace
syntax routineTargetNonBrace

syntax callExpression =
  | callTarget `( argumentList )
  | routineTarget `< realTypeArgumentList > `( argumentList )

syntax callExpressionNonBrace =
  | callTargetNonBrace `( argumentList )
  | routineTargetNonBrace `< realTypeArgumentList > `( argumentList )

;;
;;;; Parenthesized expressions
;;

syntax parenthesizedExpression = `( expression )

;;
;;;; Expressions
;;

syntax expression =
  | literalExpression
  | referenceExpression
  | defaultExpression
  | unaryExpression
  | binaryExpression
  | ternaryExpression
  | castExpression
  | dataExpression
  | accessExpression
  | callExpression
  | parenthesizedExpression

;;; (TODO) Why allow (EMPTY `, expression)?
syntax expressionList =
  | `EMPTY
  | expression
  | expressionList `, expression

dec $flatten_expressionList(expressionList) : expression*
def $flatten_expressionList(`EMPTY) = eps
def $flatten_expressionList(expression) = expression
def $flatten_expressionList(expressionList `, expression) =
  $flatten_expressionList(expressionList) ++ [ expression ]

syntax memberAccessBase =
  | prefixedTypeName
  | expression

syntax sequenceElementExpression = expressionList

syntax recordElementExpression =
  | name `= expression
  | name `= expression `, `...
  | name `= expression `, namedExpressionList
  | name `= expression `, namedExpressionList `, `...

syntax dataElementExpression =
  | sequenceElementExpression
  | recordElementExpression

syntax routineTarget = expression
syntax constructorTarget = namedType

syntax callTarget =
  | routineTarget
  | constructorTarget

;;
;;;; Non-brace expressions
;;

syntax expressionNonBrace =
  | literalExpression
  | referenceExpression
  | unaryExpression
  | binaryExpressionNonBrace
  | ternaryExpressionNonBrace
  | castExpression
  | accessExpressionNonBrace
  | callExpressionNonBrace
  | parenthesizedExpression

syntax memberAccessBaseNonBrace =
  | prefixedTypeName
  | expressionNonBrace

syntax routineTargetNonBrace = expressionNonBrace

syntax callTargetNonBrace =
  | routineTargetNonBrace
  | constructorTarget

dec $expressionNonBrace(expressionNonBrace) : expression
def $expressionNonBrace(literalExpression) = literalExpression
def $expressionNonBrace(referenceExpression) = referenceExpression
def $expressionNonBrace(unaryExpression) = unaryExpression
def $expressionNonBrace(
    expressionNonBrace_l binop expression_r
  )
  = expression_l binop expression_r
  -- if expression_l = $expressionNonBrace(expressionNonBrace_l)
def $expressionNonBrace(
    expressionNonBrace_cond `? expression_true `: expression_false
  )
  = expression_cond `? expression_true `: expression_false
  -- if expression_cond = $expressionNonBrace(expressionNonBrace_cond)
def $expressionNonBrace(castExpression) = castExpression
def $expressionNonBrace(errorAccessExpression) = errorAccessExpression
def $expressionNonBrace(prefixedTypeName `. member)
  = prefixedTypeName `. member
def $expressionNonBrace(expressionNonBrace_base `. member)
  = expression_base `. member
  -- if expression_base = $expressionNonBrace(expressionNonBrace_base)
def $expressionNonBrace(
    expressionNonBrace_base `[ expression_index ]
  )
  = expression_base `[ expression_index ]
  -- if expression_base = $expressionNonBrace(expressionNonBrace_base)
def $expressionNonBrace(
    expressionNonBrace_base `[ expression_hi `: expression_lo ]
  )
  = expression_base `[ expression_hi `: expression_lo ]
  -- if expression_base = $expressionNonBrace(expressionNonBrace_base)
def $expressionNonBrace(
    expressionNonBrace `( argumentList )
  )
  = expression `( argumentList )
  -- if expression = $expressionNonBrace(expressionNonBrace)
def $expressionNonBrace(
    constructorTarget `( argumentList )
  )
  = constructorTarget `( argumentList )
def $expressionNonBrace(
    expressionNonBrace `< realTypeArgumentList > `( argumentList )
  )
  = expression `< realTypeArgumentList > `( argumentList )
  -- if expression = $expressionNonBrace(expressionNonBrace)
def $expressionNonBrace(parenthesizedExpression) = parenthesizedExpression

;;
;; Keyset expressions
;;

syntax simpleKeysetExpression =
  | expression
  | expression `&&& expression
  | expression `.. expression
  | DEFAULT
  | `_

syntax simpleKeysetExpressionList = 
  | simpleKeysetExpression
  | simpleKeysetExpressionList `, simpleKeysetExpression

dec $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList)
  : simpleKeysetExpression*
def $flatten_simpleKeysetExpressionList(simpleKeysetExpression)
  = simpleKeysetExpression
def $flatten_simpleKeysetExpressionList(
    simpleKeysetExpressionList `, simpleKeysetExpression
  )
  = $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList)
    ++ [ simpleKeysetExpression ]

syntax tupleKeysetExpression =
  | `( expression `&&& expression )
  | `( expression `.. expression )
  | `( DEFAULT )
  | `( `_ )
  | `( simpleKeysetExpression `, simpleKeysetExpressionList )

syntax keysetExpression =
  | simpleKeysetExpression
  | tupleKeysetExpression

;;
;; Type arguments
;;

syntax realTypeArgument =
  | type
  | VOID
  | `_

syntax realTypeArgumentList =
  | realTypeArgument
  | realTypeArgumentList `, realTypeArgument

dec $flatten_realTypeArgumentList(realTypeArgumentList) : realTypeArgument*
def $flatten_realTypeArgumentList(realTypeArgument) = realTypeArgument
def $flatten_realTypeArgumentList(realTypeArgumentList `, realTypeArgument) =
  $flatten_realTypeArgumentList(realTypeArgumentList) ++ [ realTypeArgument ]

syntax typeArgument =
  | realTypeArgument
  | nonTypeName

;;; (TODO) Why allow (EMPTY `, argument)?
syntax typeArgumentList =
  | `EMPTY
  | typeArgument
  | typeArgumentList `, typeArgument

dec $flatten_typeArgumentList(typeArgumentList) : typeArgument*
def $flatten_typeArgumentList(`EMPTY) = eps
def $flatten_typeArgumentList(typeArgument) = typeArgument
def $flatten_typeArgumentList(typeArgumentList `, typeArgument) =
  $flatten_typeArgumentList(typeArgumentList) ++ [ typeArgument ]

;;
;; Arguments
;;

syntax argument =
  | expression
  | name `= expression
  | name `= `_
  | `_

syntax argumentListNonEmpty =
  | argument
  | argumentListNonEmpty `, argument

syntax argumentList =
  | `EMPTY
  | argumentListNonEmpty

dec $flatten_argumentList(argumentList) : argument*
def $flatten_argumentList(`EMPTY) = eps
def $flatten_argumentList(argument) = argument
def $flatten_argumentList(argumentListNonEmpty `, argument) =
  $flatten_argumentList(argumentListNonEmpty) ++ [ argument ]

;;
;; L-values
;;

syntax lvalue =
  | referenceExpression
  | lvalue `. member
  | lvalue `[ expression ]
  | lvalue `[ expression `: expression ]
  | `( lvalue )

;;
;; Statements
;;

;;
;;;; Empty statements
;;

syntax emptyStatement = `;

;;
;;;; Assignment statements
;;

syntax assignop =
  | `=
  | `+= | `-= | `|+|= | `|-|= | `*= | `/= | `%=
  | `<<= | `>>= | `&= | `^= | `|=

syntax assignmentStatement = lvalue assignop expression `;

;;
;;;; Call statements
;;

syntax callStatement =
  | lvalue `( argumentList ) `;
  | lvalue `< typeArgumentList > `( argumentList ) `;

;;
;;;; Direct application statements
;;

syntax directApplicationStatement = namedType `. APPLY `( argumentList ) `;

;;
;;;; Return statements
;;

syntax returnStatement =
  | RETURN `;
  | RETURN expression `;

;;
;;;; Exit statements
;;

syntax exitStatement = EXIT `;

;;
;;;; Block statements
;;

syntax blockElementStatementList

syntax blockStatement = annotationList `{ blockElementStatementList }

;;
;;;; Conditional statements
;;

syntax statement

syntax conditionalStatement =
  | IF `( expression ) statement
  | IF `( expression ) statement ELSE statement

;;
;;;; For statements
;;

syntax annotationListNonEmpty

syntax forInitStatement =
  | annotationList type name initializerOpt
  | lvalue `( argumentList )
  | lvalue `< typeArgumentList > `( argumentList )
  | lvalue assignop expression

syntax forInitStatementListNonEmpty =
  | forInitStatement
  | forInitStatementListNonEmpty `, forInitStatement

syntax forInitStatementList =
  | `EMPTY
  | forInitStatementListNonEmpty

syntax forUpdateStatement = forInitStatement

syntax forUpdateStatementListNonEmpty =
  | forUpdateStatement
  | forUpdateStatementListNonEmpty `, forUpdateStatement

syntax forUpdateStatementList =
  | `EMPTY
  | forUpdateStatementListNonEmpty

syntax forCollectionExpression =
  | expression
  | expression `.. expression

syntax forStatement =
  | annotationList FOR
      `( forInitStatementList `; expression `; forUpdateStatementList ) statement
  | annotationList FOR
      `( type name IN forCollectionExpression ) statement
  | annotationList FOR
      `( annotationListNonEmpty type name IN forCollectionExpression ) statement

;;
;;;; Switch statements
;;

syntax switchLabel =
  | DEFAULT
  | expressionNonBrace

syntax switchCase =
  | switchLabel `: blockStatement
  | switchLabel `: 

syntax switchCaseList =
  | `EMPTY
  | switchCaseList switchCase

dec $flatten_switchCaseList(switchCaseList) : switchCase*
def $flatten_switchCaseList(`EMPTY) = eps
def $flatten_switchCaseList(switchCaseList switchCase)
  = $flatten_switchCaseList(switchCaseList) ++ [ switchCase ]

syntax switchStatement = SWITCH `( expression ) `{ switchCaseList }

;;
;;;; Break and continue statements
;;

syntax breakStatement = BREAK `;

syntax continueStatement = CONTINUE `;

;;
;;;; Statements
;;

syntax statement =
  | emptyStatement
  | assignmentStatement
  | callStatement
  | directApplicationStatement
  | returnStatement
  | exitStatement
  | blockStatement
  | conditionalStatement
  | forStatement
  | breakStatement
  | continueStatement
  | switchStatement

;;
;; Declarations
;;

;;
;;;; Constant and variable declarations
;;

syntax initializer = `= expression

syntax constantDeclaration =
  annotationList CONST type name initializer `;

syntax initializerOpt =
  | `EMPTY
  | initializer

syntax variableDeclaration =
  annotationList type name initializerOpt `;

syntax blockElementStatement =
  | constantDeclaration
  | variableDeclaration
  | statement

syntax blockElementStatementList =
  | `EMPTY
  | blockElementStatementList blockElementStatement

dec $flatten_blockElementStatementList(blockElementStatementList)
  : blockElementStatement*
def $flatten_blockElementStatementList(`EMPTY) = eps
def $flatten_blockElementStatementList(
    blockElementStatementList blockElementStatement
  )
  = $flatten_blockElementStatementList(blockElementStatementList) ++
    [ blockElementStatement ]

;;
;;;; Function declarations
;;

syntax functionPrototype =
  typeOrVoid name typeParameterListOpt `( parameterList )

syntax functionDeclaration =
  annotationList functionPrototype blockStatement

;;
;;;; Action declarations
;;

syntax actionDeclaration =
  annotationList ACTION name `( parameterList ) blockStatement

;;
;;;; Instantiations
;;

syntax objectDeclarationList

syntax objectInitializer = `= `{ objectDeclarationList }

;; (TODO) can we refine type as namedType?
syntax instantiation =
  | annotationList type `( argumentList ) name `;
  | annotationList type `( argumentList ) name objectInitializer `;

syntax objectDeclaration =
  | functionDeclaration
  | instantiation

syntax objectDeclarationList =
  | `EMPTY
  | objectDeclarationList objectDeclaration

dec $flatten_objectDeclarationList(objectDeclarationList) : objectDeclaration*
def $flatten_objectDeclarationList(`EMPTY) = eps
def $flatten_objectDeclarationList(
    objectDeclarationList objectDeclaration
  )
  = $flatten_objectDeclarationList(objectDeclarationList)
    ++ [ objectDeclaration ]

;;
;;;; Error declarations
;;

syntax errorDeclaration = ERROR `{ nameList }

;;
;;;; Match kind declarations
;;

syntax matchKindDeclaration = MATCH_KIND `{ nameList trailingCommaOpt }

;;
;;;; Derived type declarations
;;

;;
;;;;;; Enum type declarations
;;

syntax enumTypeDeclaration =
  | annotationList ENUM name `{ nameList trailingCommaOpt }
  | annotationList ENUM type name `{ namedExpressionList trailingCommaOpt }

;;
;;;;;; Struct, header, and union type declarations
;;

syntax typeField = annotationList type name `;

syntax typeFieldList =
  | `EMPTY
  | typeFieldList typeField

dec $flatten_typeFieldList(typeFieldList) : typeField*
def $flatten_typeFieldList(`EMPTY) = eps
def $flatten_typeFieldList(typeFieldList typeField)
  = $flatten_typeFieldList(typeFieldList) ++ [ typeField ]

syntax structTypeDeclaration =
  annotationList STRUCT name typeParameterListOpt `{ typeFieldList }

syntax headerTypeDeclaration =
  annotationList HEADER name typeParameterListOpt `{ typeFieldList }

syntax headerUnionTypeDeclaration =
  annotationList HEADER_UNION name typeParameterListOpt `{ typeFieldList }

syntax derivedTypeDeclaration =
  | enumTypeDeclaration
  | structTypeDeclaration
  | headerTypeDeclaration
  | headerUnionTypeDeclaration

;;
;;;; Typedef and newtype declarations
;;

syntax typedefType =
  | type
  | derivedTypeDeclaration

syntax typedefDeclaration =
  | annotationList TYPEDEF typedefType name `;
  | annotationList TYPE type name `;

;;
;;;; Extern declarations
;;

syntax externFunctionDeclaration =
  annotationList EXTERN functionPrototype `;

syntax methodPrototype =
  | annotationList typeIdentifier `( parameterList ) `;
  | annotationList functionPrototype `;
  | annotationList ABSTRACT functionPrototype `;

syntax methodPrototypeList =
  | `EMPTY
  | methodPrototypeList methodPrototype

dec $flatten_methodPrototypeList(methodPrototypeList) : methodPrototype*
def $flatten_methodPrototypeList(`EMPTY) = eps
def $flatten_methodPrototypeList(
    methodPrototypeList methodPrototype
  )
  = $flatten_methodPrototypeList(methodPrototypeList) ++ [ methodPrototype ]

syntax externObjectDeclaration =
  annotationList EXTERN nonTypeName typeParameterListOpt `{ methodPrototypeList }

syntax externDeclaration =
  | externFunctionDeclaration
  | externObjectDeclaration

;;
;;;; Parser statements and declarations
;;

;;
;;;;;; Select expressions
;;

syntax selectCase = keysetExpression `: name `;

syntax selectCaseList =
  | `EMPTY
  | selectCaseList selectCase

dec $flatten_selectCaseList(selectCaseList) : selectCase*
def $flatten_selectCaseList(`EMPTY) = eps
def $flatten_selectCaseList(selectCaseList selectCase)
  = $flatten_selectCaseList(selectCaseList) ++ [ selectCase ]

syntax selectExpression = SELECT `( expressionList ) `{ selectCaseList }

;;
;;;;;; Transition statements
;;

syntax stateExpression =
  | name `;
  | selectExpression

syntax transitionStatement =
  | `EMPTY
  | TRANSITION stateExpression

;;
;;;;;; Value set declarations
;;

syntax valueSetType =
  | baseType
  | tupleType
  | prefixedTypeName

syntax valueSetDeclaration =
  annotationList VALUE_SET `< valueSetType > `( expression ) name `;

;;
;;;;;; Parser type declarations
;;

syntax parserTypeDeclaration =
  annotationList PARSER name typeParameterListOpt `( parameterList ) `;

;;
;;;;;; Parser declarations
;;

syntax parserStatementList

syntax parserBlockStatement = annotationList `{ parserStatementList }

syntax parserStatement =
  | constantDeclaration
  | variableDeclaration
  | emptyStatement
  | assignmentStatement
  | callStatement
  | directApplicationStatement
  | parserBlockStatement
  | conditionalStatement

syntax parserStatementList =
  | `EMPTY
  | parserStatementList parserStatement

dec $flatten_parserStatementList(parserStatementList) : parserStatement*
def $flatten_parserStatementList(`EMPTY) = eps
def $flatten_parserStatementList(parserStatementList parserStatement)
  = $flatten_parserStatementList(parserStatementList) ++ [ parserStatement ]

syntax parserState =
  annotationList STATE name `{ parserStatementList transitionStatement }

syntax parserStateList =
  | parserState
  | parserStateList parserState

dec $flatten_parserStateList(parserStateList) : parserState*
def $flatten_parserStateList(parserState) = parserState
def $flatten_parserStateList(parserStateList parserState)
  = $flatten_parserStateList(parserStateList) ++ [ parserState ]

syntax parserLocalDeclaration =
  | constantDeclaration
  | instantiation
  | variableDeclaration
  | valueSetDeclaration

syntax parserLocalDeclarationList =
  | `EMPTY
  | parserLocalDeclarationList parserLocalDeclaration

dec $flatten_parserLocalDeclarationList(parserLocalDeclarationList)
  : parserLocalDeclaration*
def $flatten_parserLocalDeclarationList(`EMPTY) = eps
def $flatten_parserLocalDeclarationList(
    parserLocalDeclarationList parserLocalDeclaration
  )
  = $flatten_parserLocalDeclarationList(parserLocalDeclarationList)
    ++ [ parserLocalDeclaration ]

syntax parserDeclaration =
  annotationList PARSER name typeParameterListOpt
    `( parameterList ) constructorParameterListOpt
    `{ parserLocalDeclarationList parserStateList }

;;
;;;; Control statements and declarations
;;

;;
;;;;;; Table declarations
;;

syntax const = CONST

syntax constOpt =
  | `EMPTY
  | const

dec $flatten_constOpt(constOpt) : const?
def $flatten_constOpt(`EMPTY) = eps
def $flatten_constOpt(const) = const

;;
;;;;;;;; Table key property 
;;

syntax tableKey = expression `: name annotationList `;

syntax tableKeyList =
  | `EMPTY
  | tableKeyList tableKey

dec $flatten_tableKeyList(tableKeyList) : tableKey*
def $flatten_tableKeyList(`EMPTY) = eps
def $flatten_tableKeyList(tableKeyList tableKey)
  = $flatten_tableKeyList(tableKeyList) ++ [ tableKey ]

;;
;;;;;;;; Table actions property
;;

syntax tableActionReference =
  | prefixedNonTypeName
  | prefixedNonTypeName `( argumentList )

syntax tableAction = annotationList tableActionReference `;

syntax tableActionList =
  | `EMPTY
  | tableActionList tableAction

dec $flatten_tableActionList(tableActionList) : tableAction*
def $flatten_tableActionList(`EMPTY) = eps
def $flatten_tableActionList(tableActionList tableAction) =
  $flatten_tableActionList(tableActionList) ++ [ tableAction ]

;;
;;;;;;;; Table entry property
;;

syntax tableEntryPriority =
  | PRIORITY `= number `: 
  | PRIORITY `= `( expression ) `:

syntax tableEntry =
  | constOpt tableEntryPriority keysetExpression `: tableActionReference annotationList `; 
  | constOpt keysetExpression `: tableActionReference annotationList `; 

syntax tableEntryList =
  | `EMPTY
  | tableEntryList tableEntry

dec $flatten_tableEntryList(tableEntryList) : tableEntry*
def $flatten_tableEntryList(`EMPTY) = eps
def $flatten_tableEntryList(tableEntryList tableEntry)
  = $flatten_tableEntryList(tableEntryList) ++ [ tableEntry ]

;;
;;;;;;;; Table properties
;;

syntax tableProperty =
  | KEY `= `{ tableKeyList }
  | ACTIONS `= `{ tableActionList }
  | annotationList constOpt ENTRIES `= `{ tableEntryList }
  | annotationList constOpt tableCustomName initializer `;

syntax tablePropertyList =
  | `EMPTY
  | tablePropertyList tableProperty

dec $flatten_tablePropertyList(tablePropertyList) : tableProperty*
def $flatten_tablePropertyList(`EMPTY) = eps
def $flatten_tablePropertyList(tablePropertyList tableProperty) =
  $flatten_tablePropertyList(tablePropertyList) ++ [ tableProperty ]

syntax tableDeclaration =
  annotationList TABLE name `{ tablePropertyList }

;;
;;;;;; Control type declarations
;;

syntax controlTypeDeclaration =
  annotationList CONTROL name typeParameterListOpt `( parameterList ) `;

;;
;;;;;; Control declarations
;;

syntax controlBody = blockStatement

syntax controlLocalDeclaration =
  | constantDeclaration
  | instantiation
  | variableDeclaration
  | actionDeclaration
  | tableDeclaration

syntax controlLocalDeclarationList =
  | `EMPTY
  | controlLocalDeclarationList controlLocalDeclaration

dec $flatten_controlLocalDeclarationList(controlLocalDeclarationList)
  : controlLocalDeclaration*

def $flatten_controlLocalDeclarationList(`EMPTY) = eps
def $flatten_controlLocalDeclarationList(
    controlLocalDeclarationList controlLocalDeclaration
  )
  = $flatten_controlLocalDeclarationList(controlLocalDeclarationList) ++
    [ controlLocalDeclaration ]

syntax controlDeclaration =
  annotationList CONTROL name typeParameterListOpt
    `( parameterList ) constructorParameterListOpt
    `{ controlLocalDeclarationList APPLY controlBody }

;;
;;;; Package type declarations
;;

syntax packageTypeDeclaration =
  annotationList PACKAGE name typeParameterListOpt `( parameterList ) `;

;;
;;;; Type declarations
;;

syntax typeDeclaration =
  | derivedTypeDeclaration
  | typedefDeclaration
  | parserTypeDeclaration
  | controlTypeDeclaration
  | packageTypeDeclaration

;;
;;;; Declaration
;;

syntax declaration =
  | constantDeclaration
  | instantiation
  | functionDeclaration
  | actionDeclaration
  | errorDeclaration
  | matchKindDeclaration
  | externDeclaration
  | parserDeclaration
  | controlDeclaration 
  | typeDeclaration

;;
;; Annotations
;;

syntax annotationToken =
  | UNEXPECTED_TOKEN | ABSTRACT | ACTION | ACTIONS | APPLY
  | BOOL | BIT | BREAK | CONST | CONTINUE
  | CONTROL | DEFAULT | ELSE | ENTRIES | ENUM
  | ERROR | EXIT | EXTERN | FALSE | FOR
  | HEADER | HEADER_UNION | IF | IN | INOUT
  | INT | KEY | MATCH_KIND | TYPE | OUT
  | PARSER | PACKAGE | PRAGMA | RETURN | SELECT
  | STATE | STRING | STRUCT | SWITCH | TABLE
  | THIS | TRANSITION | TRUE | TUPLE | TYPEDEF
  | VARBIT | VALUE_SET | LIST | VOID | `_
  | identifier | typeIdentifier | stringLiteral | number
  | `&&& | `.. | `<< | `&& | `|| 
  | `== | `!= | `>= | `<=  | `++
  | `+ | `|+| | `- | `|-| | `*
  | `/ | `% | `| | `& | `^
  | `~ | ``[ | ``] | ``{ | ``}
  | ``< | ``> | `! | `: | `,
  | `? | `. | `= | `; | `@

syntax annotationBody =
  | `EMPTY
  | annotationBody `( annotationBody )
  | annotationBody annotationToken

syntax structuredAnnotationBody =
  dataElementExpression trailingCommaOpt

syntax annotation =
  | `@ name
  | `@ name `( annotationBody )
  | `@ name `[ structuredAnnotationBody ]

syntax annotationListNonEmpty =
  | annotation
  | annotationListNonEmpty annotation

syntax annotationList =
  | `EMPTY
  | annotationListNonEmpty

;;
;; P4 program
;;

syntax p4program =
  | `EMPTY
  | p4program declaration
  | p4program `;

dec $flatten_p4program(p4program) : declaration*
def $flatten_p4program(`EMPTY) = eps
def $flatten_p4program(p4program declaration)
  = $flatten_p4program(p4program) ++ [ declaration ]
def $flatten_p4program(p4program `;)
  = $flatten_p4program(p4program)
