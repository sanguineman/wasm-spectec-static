;;
;; Relations for type alpha-equivalence
;;

relation Type_alpha:
  typeIR ~~ typeIR
  hint(input %0 %1)

relation ParameterType_alpha:
  parameterTypeIR ~~ parameterTypeIR
  hint(input %0 %1)

relation RoutineType_alpha:
  routineTypeIR ~~ routineTypeIR
  hint(input %0 %1)

relation RoutineTypeDef_alpha:
  routineTypeDefIR ~~ routineTypeDefIR
  hint(input %0 %1)

;;
;;;; Alpha-equivalence of types
;;

;;; Base types

rule Type_alpha/basetype:
  baseTypeIR ~~ baseTypeIR

;;; Named types

rule Type_alpha/nametype:
  (TID tid) ~~  (TID tid)

rule Type_alpha/spectype-nominal:
  (polyTypeDefIR_a `< typeIR_a* >) ~~ (polyTypeDefIR_b `< typeIR_b* >)
  -- if typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a, typeIR_a*)
  -- if typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b, typeIR_b*)
  -- Type_alpha: typeIR_a_spec ~~ typeIR_b_spec
  ---- ;; for nominal types, the type arguments must also match
  -- if $is_nominal_typeIR(typeIR_a_spec)
        /\ $is_nominal_typeIR(typeIR_b_spec)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/spectype-structural:
  (polyTypeDefIR_a `< typeIR_a* >) ~~ (polyTypeDefIR_b `< typeIR_b* >)
  -- if typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a, typeIR_a*)
  -- if typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b, typeIR_b*)
  -- Type_alpha: typeIR_a_spec ~~ typeIR_b_spec
  ---- ;; for structural types, the type arguments do not need to match
  -- if ~$is_nominal_typeIR(typeIR_a_spec)
        /\ ~$is_nominal_typeIR(typeIR_b_spec)

;;; Typedef types

rule Type_alpha/typedeftype-left:
  (TYPEDEF _ typeIR_a) ~~ typeIR_b
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Type_alpha/typedeftype-right:
  typeIR_a ~~ (TYPEDEF _ typeIR_b)
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Type_alpha/newtype:
  (TYPE tid typeIR_a) ~~ (TYPE tid typeIR_b)
  -- Type_alpha: typeIR_a ~~ typeIR_b

;;; Data types

rule Type_alpha/listtype:
  (LIST `< typeIR_a >) ~~ (LIST `< typeIR_b >)
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Type_alpha/tupletype:
  (TUPLE `< typeIR_a* >) ~~ (TUPLE `< typeIR_b* >)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/stacktype:
  (typeIR_a `[ n_s ]) ~~ (typeIR_b `[ n_s ])
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Type_alpha/structtype:
  (STRUCT tid `{ (typeIR_f_a id_f `;)* })
  ~~ (STRUCT tid `{ (typeIR_f_b id_f `;)* })
  -- (Type_alpha: typeIR_f_a ~~ typeIR_f_b)*

rule Type_alpha/headertype:
  (HEADER tid `{ (typeIR_f_a id_f `;)* })
  ~~ (HEADER tid `{ (typeIR_f_b id_f `;)* })
  -- (Type_alpha: typeIR_f_a ~~ typeIR_f_b)*

rule Type_alpha/headeruniontype:
  (HEADER_UNION tid `{ (typeIR_f_a id_f `;)* })
  ~~ (HEADER_UNION tid `{ (typeIR_f_b id_f `;)* })
  -- (Type_alpha: typeIR_f_a ~~ typeIR_f_b)*

rule Type_alpha/enumtype:
  (ENUM tid `{ id_f* }) ~~ (ENUM tid `{ id_f* })

rule Type_alpha/serenumtype:
  (ENUM tid `# typeIR_a `{ (id_f `= value_f `;)* })
  ~~ (ENUM tid `# typeIR_b `{ (id_f `= value_f `;)* })
  -- Type_alpha: typeIR_a ~~ typeIR_b

;;; Object types

rule Type_alpha/externtype:
  (EXTERN tid (`{ (rid_a `: routineTypeDefIR_a)* }))
  ~~ (EXTERN tid (`{ (rid_b `: routineTypeDefIR_b)* }))
  -- if $eq_set<rid>(`{ rid_a* }, `{ rid_b* })
  -- if (routineTypeDefIR_a'
        = $find_map<rid, routineTypeDefIR>(
            `{ (rid_a `: routineTypeDefIR_a)* },
            rid_a))*
  -- if (routineTypeDefIR_b'
        = $find_map<rid, routineTypeDefIR>(
            `{ (rid_b `: routineTypeDefIR_b)* },
            rid_a))*
  -- (RoutineTypeDef_alpha: routineTypeDefIR_a' ~~ routineTypeDefIR_b')*

rule Type_alpha/parsertype:
  (PARSER `( parameterTypeIR_a* )) ~~ (PARSER `( parameterTypeIR_b* ))
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*

rule Type_alpha/controltype:
  (CONTROL `( parameterTypeIR_a* )) ~~ (CONTROL `( parameterTypeIR_b* ))
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*

rule Type_alpha/packagetype:
  (PACKAGE `< typeIR_a* >) ~~ (PACKAGE `< typeIR_b* >)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/tabletype:
  (TABLE tid `# typeIR_a) ~~ (TABLE tid `# typeIR_b)
  -- Type_alpha: typeIR_a ~~ typeIR_b

;;; Synthesized types

rule Type_alpha/defaulttype:
  DEFAULT ~~ DEFAULT

rule Type_alpha/sequencetype:
  (SEQ `< typeIR_a* >) ~~ (SEQ `< typeIR_b* >)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/sequencedefaulttype:
  (SEQ `< typeIR_a* `, `... >) ~~ (SEQ `< typeIR_b* `, `... >)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/recordtype:
  (RECORD `{ (typeIR_a id `;)* }) ~~ (RECORD `{ (typeIR_b id `;)* })
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/recorddefaulttype:
  (RECORD `{ (typeIR_a id `;)* `, `... })
  ~~ (RECORD `{ (typeIR_b id `;)* `, `... })
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/invalidtype:
  HEADER_INVALID ~~ HEADER_INVALID

rule Type_alpha/settype:
  (SET `< typeIR_a >) ~~ (SET `< typeIR_b >)
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Type_alpha/tableenumtype:
  (TABLE_ENUM tid `{ id_f* }) ~~ (TABLE_ENUM tid `{ id_f* })

rule Type_alpha/tablestructtype:
  (TABLE_STRUCT tid `{ (typeIR_f_a id_f `;)* })
  ~~ (TABLE_STRUCT tid `{ (typeIR_f_b id_f `;)* })
  -- (Type_alpha: typeIR_f_a ~~ typeIR_f_b)*

;;
;;;; Alpha-equivalence of parameter types
;;

rule ParameterType_alpha:
  (_ typeIR_a _ _) ~~ (_ typeIR_b _ _)
  -- Type_alpha: typeIR_a ~~ typeIR_b

;;
;;;; Alpha-equivalence of routine types
;;

rule RoutineType_alpha/builtinfunction:
  (BUILTIN_FUNCTION `( parameterTypeIR_a* ) `-> typeIR_ret_a)
  ~~ (BUILTIN_FUNCTION `( parameterTypeIR_b* ) `-> typeIR_ret_b)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule RoutineType_alpha/function:
  (FUNCTION `( parameterTypeIR_a* ) `-> typeIR_ret_a)
  ~~ (FUNCTION `( parameterTypeIR_b* ) `-> typeIR_ret_b)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule RoutineType_alpha/action:
  (ACTION `( parameterTypeIR_a* )) ~~ (ACTION `( parameterTypeIR_b* ))
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*

rule RoutineType_alpha/externfunction:
  (EXTERN_FUNCTION `( parameterTypeIR_a* ) `-> typeIR_ret_a)
  ~~ (EXTERN_FUNCTION `( parameterTypeIR_b* ) `-> typeIR_ret_b)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule RoutineType_alpha/builtinmethod:
  (BUILTIN_METHOD `( parameterTypeIR_a* ) `-> typeIR_ret_a)
  ~~ (BUILTIN_METHOD `( parameterTypeIR_b* ) `-> typeIR_ret_b)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule RoutineType_alpha/externmethod:
  (EXTERN_METHOD `( parameterTypeIR_a* ) `-> typeIR_ret_a)
  ~~ (EXTERN_METHOD `( parameterTypeIR_b* ) `-> typeIR_ret_b)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule RoutineType_alpha/externmethod-abstract:
  (EXTERN_METHOD ABSTRACT `( parameterTypeIR_a* ) `-> typeIR_ret_a)
  ~~ (EXTERN_METHOD ABSTRACT `( parameterTypeIR_b* ) `-> typeIR_ret_b)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule RoutineType_alpha/parserapply:
  (PARSER_APPLY `( parameterTypeIR_a* ))
  ~~ (PARSER_APPLY `( parameterTypeIR_b* ))
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*

rule RoutineType_alpha/controlapply:
  (CONTROL_APPLY `( parameterTypeIR_a* ))
  ~~ (CONTROL_APPLY `( parameterTypeIR_b* ))
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*

rule RoutineType_alpha/tableapply:
  (TABLE_APPLY `-> typeIR_ret_a)
  ~~ (TABLE_APPLY `-> typeIR_ret_b)
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

;;
;;;; Alpha-equivalence of routine definitions
;;

rule RoutineTypeDef_alpha/mono:
  routineTypeIR_a ~~ routineTypeIR_b
  -- RoutineType_alpha: routineTypeIR_a ~~ routineTypeIR_b

rule RoutineTypeDef_alpha/poly:
  (routineTypeIR_a `< tid_a* `, tid_hidden_a* >)
  ~~ (routineTypeIR_b `< tid_b* `, tid_hidden_b* >)
  ---- ;; check that the type arguments match
  -- if |tid_a*| = |tid_b*|
  -- if |tid_hidden_a*| = |tid_hidden_b*|
  ---- ;; create fresh type identifiers
  -- if tid_fresh* = $fresh_tids($(|tid_a*| + |tid_hidden_a*|))
  ---- ;; substitute the left hand side with fresh type identifiers
  -- if tid_a'* = tid_a* ++ tid_hidden_a*
  -- if theta_a = `{ (tid_a' `: (TID tid_fresh))* }
  -- if routineTypeIR_a_subst
      = $subst_routineType(theta_a, routineTypeIR_a)
  ---- ;; substitute the right hand side with fresh type identifiers
  -- if tid_b'* = tid_b* ++ tid_hidden_b*
  -- if theta_b = `{ (tid_b' `: (TID tid_fresh))* }
  -- if routineTypeIR_b_subst
      = $subst_routineType(theta_b, routineTypeIR_b)
  ---- ;; check that the substituted routine types are alpha-equivalent
  -- RoutineType_alpha: routineTypeIR_a_subst ~~ routineTypeIR_b_subst
