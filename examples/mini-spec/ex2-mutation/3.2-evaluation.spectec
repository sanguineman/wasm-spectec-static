relation Eval:
  env; sto |- expr ==> value; sto
  hint(input %0 %1 %2)

var n : nat

rule Eval/numE:
  env; sto |- NumE i ==> NumV i; sto

rule Eval/binE-add:
  env; sto |- BinE ADD e_l e_r ==> NumV $(i_l + i_r); sto_2
  -- Eval: env; sto |- e_l ==> NumV i_l; sto_1
  -- Eval: env; sto_1 |- e_r ==> NumV i_r; sto_2

rule Eval/binE-mul:
  env; sto |- BinE MUL e_l e_r ==> NumV $(i_l * i_r); sto_2
  -- Eval: env; sto |- e_l ==> NumV i_l; sto_1
  -- Eval: env; sto_1 |- e_r ==> NumV i_r; sto_2

rule Eval/letE:
  env; sto |- LetE id e_p e_b ==> value_b; sto_2
  -- Eval: env; sto |- e_p ==> value_p; sto_1
  -- Eval: ((id -> value_p) :: env); sto_1 |- e_b ==> value_b; sto_2

rule Eval/varE:
  env; sto |- VarE id ==> value; sto
  -- if $lookup_env(env, id) = value

rule Eval/funcE:
  env; sto |- FuncE id _ e ==> CloV id e env; sto

rule Eval/applyE:
  env; sto |- ApplyE e_f e_a ==> value_r; sto_3
  -- Eval: env; sto |- e_f ==> CloV id e_b env_clo; sto_1
  -- Eval: env; sto_1 |- e_a ==> value_a; sto_2
  -- Eval: ((id -> value_a) :: env_clo); sto_2 |- e_b ==> value_r; sto_3

rule Eval/refE:
  env; sto |- RefE e ==> LocV n; sto_1 ++ [ value ]
  -- Eval: env; sto |- e ==> value; sto_1
  -- if |sto_1| = n

rule Eval/derefE:
  env; sto |- DerefE e ==> value; sto_1
  -- Eval: env; sto |- e ==> LocV n; sto_1
  -- if sto_1[n] = value

rule Eval/updateE:
  env; sto |- UpdateE e_l e_r ==> value_r; sto_3
  -- Eval: env; sto |- e_l ==> LocV n; sto_1
  -- Eval: env; sto_1 |- e_r ==> value_r; sto_2
  -- if sto_2[[n] = value_r] = sto_3
